################################################################################
# TREEDYN
# Copyright ©  2000-2007 Chevenet F. chevenet@ird.fr
# Action Bioinformatique Inter-EPST CNRS, INSERM,
# INRA, INRIA, Ministere de la Recherche
#
# Chevenet F., Brun C., Banuls A.L., Jacq B. and R. Christen
# TreeDyn: towards dynamic graphics and annotations for analyses of trees
# BMC Bioinformatics 2006, 7:439
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
################################################################################

# 197, 198
# Vista ok

# OK TreePAT canvas size
# OK D3 node export leaf labels to clipboard
# OK negative branch length values set to 0

# OK matrice 1/0 revision: outline - fill + update color(1 ou 0 toolbox ou M3)
# OK matrice rgb
# matrice rgb suppression possible de toute la heatmap (avec les numero col)
# matrice rgb clic droit serie add/delete outline

# REVISION SHRINK 
# OK shrink symbol
# OK shrink3 triangle 
# OK shrink4 polygon cumulatif
# Shrink 4 sur node avec sous-shrink : tout le monde passe en shrink4
# Memorisation type de shrink , eg changement de conformation
# BUG B(SHIfon,$id) (cf conformation)
# M3, update color update stipple
# Figuration::RestaurationShrinkAll
# Abstraction::ShrinkUn TransitionVG
# M3 si shrink de type shrink symbol ajouter une command "update symbol"
# copy/paste mauvais ordre d'empilement
# shrink shrink3 shrink4 en operation

# newick mid-point rooting
# newick outgroup @x,y
# newick radial

# annotation Revision newick annotation panel
# annotation New symbol 1 symbole par valeur et projection

# illustration points cardinaux redimenssions
# OK illustration stipple

# OK toolbox switch move / last used tool
# OK Image curssor + Image current tool
# VALIDATION icontool // D3, D1~tool etc (eg cardinal zoom, illustration carre-cercle)
# interface preference panel
# OK interface FitToContents (annotation)

# OK selection de feuille shift D1 selection forcee
# OK selection de feuille altD1 deselection forcee
# OK selection de feuille retirer le stipple
# selection de feuille gestion multiple M3/colonne M3tree/export par serie
# OK selection de feuille Help string

# ANALYSE MAILS


################################################################################
# HELP
################################################################################
namespace eval Help {
    
    ##set S(toolhelp,rotation) 		Conformation Rotation (M1, Shift-M1)
    ##set S(toolhelp,collapse) 	 	Abstraction Collapse (M1, Shift-M1)
    proc HelpSetting {} {
        global S
        set S(toolhelp,treepatfromt) "Highligthing Tree from Matrix \n clic (left mouse button) \n a leaf"
        #TreeALI package
        set S(toolhelp,trealg-) "Tree & Alignement Reset \n clic (left mouse button) a sub-tree"
        set S(toolhelp,trealg+) "Tree & Alignement Highligthing \n clic (left mouse button) a position"
        #TreeXY package
        set S(toolhelp,xytot) "Matrix to Tree Highligthing"
        set S(toolhelp,ttoxy) "Tree to Matrix Highligthing"
        # Amelie package
        set S(toolhelp,arccour) 		"Arc curve"
        set S(toolhelp,arcx) 	"Arc move"
        set S(toolhelp,faiadd) 	"Beam add"
        set S(toolhelp,selcol) 	"Selection color"
        set S(toolhelp,fairem) 	"Beam remove"
        set S(toolhelp,faix) 	"Beam move"
        set S(toolhelp,arccol) 	"Arc color "
        set S(toolhelp,faicol) 	"Beam color "
        set S(toolhelp,arcdel) 	"Arc delete "
        set S(toolhelp,faidel) 	"Beam delete "
        set S(toolhelp,seldel) 	"Selection delete "
        set S(toolhelp,selx) 	"Selection move "
        ### NAVIGATION
        set S(toolhelp,move) 		"MOVE (Navigation) \n clic (left mouse button) \nnear a tree and drag it. \n use the Shift key for moving all items"
        set S(toolhelp,movel) 	"MOVE (Navigation) \n clic (left mouse button) \n on a canvas item and drag it. \n This tool do not takes into account global structures"
        set S(toolhelp,copypaste) 	"COPY&PASTE (Navigation) \n clic (left mouse button) a sub-tree \nand drag its copy. \n Use the Shift key for a new item in a new document"
        set S(toolhelp,copypastenavi) 		"COPY&PASTE to Navigator (Navigation) \n clic (left mouse button) \non a sub-tree. \n The copy is displayed in a resizeable window"
        set S(toolhelp,copypastecollection) 	"COPY&PASTE to collection (Navigation) \n  clic (left mouse button) on a sub-tree. \n Select a collection to complete \n(or create a new collection)"
        set S(toolhelp,zoom1) 			 "ZOOM In/Out (Navigation) \n clic (left mouse button) and drag near a tree \n only the tree width is updated"
        set S(toolhelp,zoom2) 			 "ZOOM In/Out (Navigation) \n clic (left mouse button) and drag near a tree \n only the tree height is updated "
        set S(toolhelp,zoom3) 			 "ZOOM In/Out (Navigation) \n clic (left mouse button) and drag near a tree \n the ratio width/height is free"
        set S(toolhelp,zoom4) 			 "ZOOM In/Out (Navigation) \n clic (left mouse button) and drag near a tree \n the ratio width/height is locked"
        set S(toolhelp,zoompc) 			"ZOOM In/Out (Navigation)\n clic (left mouse button)\n a tree and use the dots to resize the tree"
        set S(toolhelp,zoomxb) 			"ZOOM In/Out (Navigation)\n clic (left mouse button)\n near a tree to zoom-in \n Shift-clic to zoom-out (X only )"
        set S(toolhelp,zoomyb) 		 "ZOOM In/Out (Navigation)\n clic (left mouse button)\n near a tree to zoom-in \n Shift-clic to zoom-out (Y only)"
        set S(toolhelp,zoomxyb) 	 "ZOOM In/Out (Navigation)\n clic (left mouse button)\n near a tree to zoom-in \n Shift-clic to zoom-out (X & Y)"
        set S(toolhelp,zoomuser) 	"ZOOM factor (Navigation)\n set the zoom factors \n and clic (left mouse button) near a tree"
        set S(toolhelp,reset)     "RESET graphic variables (Figuration) \n clic (left mouse button) a document/a tree/a subtree  \n and select graphical variable(s) to reset"
        set S(toolhelp,delete)    "DELETE (Navigation) \n clic (left mouse button) the canvas \n or near tree and select items to delete"
        ### FIGURATION
        set S(toolhelp,fgcolor) 		  "COLOR Foreground Subtree (Figuration) \n clic (left mouse button) a subtree. \n Argument: color (parameters panel) \n Shift-clic reset to default color"
        set S(toolhelp,bgcolorst1)  "COLOR Background Subtree (Figuration) \n clic (left mouse button) a subtree. \n Arguments: color, stipple, shape (parameters panel) \n Shift-clic delete the background"
        set S(toolhelp,fgcolorleaf) "COLOR Foreground Leave(s) (Figuration) \n clic (left mouse button) a subtree. \n Arguments: color (parameters panel) \n Shift-clic reset to default color"
        set S(toolhelp,bgcolor) 		  "COLOR Background Leave(s) (Figuration) \n clic (left mouse button) a subtree. \n Arguments: color (parameters panel) \n Shift-clic delete the background"
        set S(toolhelp,width+-) 		  "LINE WIDTH +- (Figuration) \n clic (left mouse button) a subtree to increase width \nShift-clic to decrease width"
        set S(toolhelp,dash) 			    "LINE DASH (Figuration) \n clic (left mouse button) a subtree \n to dash line \nShift-clic to normal line"
        set S(toolhelp,textset) 		  "TEXT leave(s) font (Figuration)\n clic (left mouse button) a subtree.\n Argument: font (parameters panel)"
        set S(toolhelp,textsize+-) 	"TEXT leave(s) font Size (Figuration)\n clic (left mouse button) \n a subtree to increase the leaves font size.\n Shift-clic decrease the leaves font size"
        set S(toolhelp,textitalic) 	"TEXT leave(s) font Slant On/Off (Figuration)\n clic (left mouse button) a subtree.\n clic again to undo"
        set S(toolhelp,textunder) 		"TEXT leave(s) font Underline On/Off (Figuration)\n clic (left mouse button) a subtree.\n clic again to undo"
        set S(toolhelp,textbold) 		 "TEXT leave(s) font Bold On/Off (Figuration)\n clic (left mouse button) a subtree.\n clic again to undo"
        set S(toolhelp,textover) 		 "TEXT leave(s) font Overstrike On/Off (Figuration)\n clic (left mouse button) a subtree.\n clic again to undo"
        ### ANNOTATION
        set S(toolhelp,annotree) 	 	       "ANNOTATE Tree (Annotation) \n clic (left mouse button) near a tree"
        set S(toolhelp,textleafc) 		       "ANNOTATE Leaves, text (Annotation) \n clic (left mouse button) a subtree.\n Argument: text (parameters panel)"
        set S(toolhelp,leafillustrationC) 	"ANNOTATE Leaves, symbol (Annotation) \n clic (left mouse button) a subtree.\n Argument: symbol (parameters panel)"
        set S(toolhelp,textnode) 		        "ANNOTATE Subtree, text(Annotation) \n clic (left mouse button) a subtree.\n Argument: text (parameters panel)"
        set S(toolhelp,symbolnode) 		      "ANNOTATE Subtree, symbol (Annotation)  \n clic (left mouse button) a subtree.\n Argument: symbol (parameters panel)"
        set S(toolhelp,nodeillustration) 	 "ANNOTATE Subtree (Annotation)\n clic (left mouse button) a subtree.\n Argument: symbol (parameters panel)"
        set S(toolhelp,absleaf) 		       "Display/Hide leaves labels \n clic (left mouse button) a subtree for hiding leaves \n shift-clic to display leaves"
        set S(toolhelp,movematrix) "Management of Annotations Matrix\nMove Matrix"
        set S(toolhelp,movecol) 		 "Management of Annotations Matrix\nMove Column Labels"
        set S(toolhelp,annfgcol) 		"Management of Annotations Matrix\nColumn Foreground Color"
        set S(toolhelp,annfgrow) 		"Management of Annotations Matrix\nRow Foreground Color"
        set S(toolhelp,annfocol) 		"Management of Annotations Matrix\nColumn Font"
        set S(toolhelp,annforow) 		"Management of Annotations Matrix\nRow Font"
        set S(toolhelp,annanchw) 		"Management of Annotations Matrix\nAnchor W"
        set S(toolhelp,annanche) 		"Management of Annotations Matrix\nAnchor E"
        set S(toolhelp,valbefore)   "ANNOTATE from newick string (Annotation)\n clic (left mouse button) a subtree\n for posting annotations stored before the :"
        set S(toolhelp,valafter)    "ANNOTATE from newick string (Annotation)\n clic (left mouse button) a subtree\n for posting annotations stored before the :"
        ### IDENTIFICATION
        set S(toolhelp,d3menus) 	 	    "LABELISATION (Identification) \n clic (left mouse button) a subtree"
        set S(toolhelp,localisation) 		"LOCALISATION (Identification)\n clic (left mouse button) near a tree"
        ### CONFORMATION
        set S(toolhelp,swap) 			    "SWAP (Conformation)\n clic (left mouse button) a subtree "
        set S(toolhelp,outgroup) 	  "OUTGROUP (Conformation)\n clic (left mouse button) a subtree"
        set S(toolhelp,ladder) 		 	 "LADDERIZE (Conformation)\n clic (left mouse button) a subtree \nto ladderize from top to bottom\n Shift-clic to ladderize from bottom to top"
        set S(toolhelp,confcircext) "CIRCULAR tree configuration (Conformation)\n clic (left mouse button) a tree \n for an external circular phylogram"
        set S(toolhelp,confcircext2) "CIRCULAR tree configuration (Conformation)\n clic (left mouse button) a tree \n for an external circular cladogram"
        set S(toolhelp,confcircint) "CIRCULAR tree configuration (Conformation)\n clic (left mouse button) a tree \n for an intern circular cladogram"
        set S(toolhelp,confrect)    "RECTANGULAR tree configuration (Conformation)\n clic (left mouse button) a tree \n for a rectangular phylogram \n Shift-clic for a rectangular cladogram"
        # ABSTRACTION
        set S(toolhelp,shrink) 		   "SHRINK ON/OFF (Conformation)\n clic (left mouse button) a subtree"
        set S(toolhelp,shrink3) 		   "SHRINK ON/OFF (Conformation)\n clic (left mouse button) a subtree"
        set S(toolhelp,shrink4) 		   "SHRINK ON/OFF (Conformation)\n clic (left mouse button) a subtree"
        set S(toolhelp,subtree) 	 	   "DECOMPOSITION, extract subtree (Abstraction)\n clic (left mouse button) a subtree and drag it"
        set S(toolhelp,stcollapse) 	  "COLLAPSE (Abstraction)\n clic (left mouse button) a subtree"
        set S(toolhelp,stpolytotale) 	"POLYTOMY ALL (Abstraction)\n clic (left mouse button) a subtree"
        set S(toolhelp,stpolypartial) "POLYTOMY ONLY NEXT LEVEL (Abstraction)\n clic (left mouse button) a subtree"
        set S(toolhelp,stdelete) 		   "DELETE SUBTREE (Abstraction)\n clic (left mouse button) a subtree"
        set S(toolhelp,stcopypaste) 		"COPY&INSERTION \n(COPY a node and PASTE it as a new node or as polytomy) (Abstraction)\n clic (left mouse button) a subtree"
        ### REFLECTION
        set S(toolhelp,transition1) 	 	"TRANSITION (Reflection)\n clic (left mouse button) a subtree"
        set S(toolhelp,transition2) 	 	"TRANSITION (Reflection)\n clic (left mouse button) a subtree"
        set S(toolhelp,transition3) 		 "TRANSITION (Reflection)\n clic (left mouse button) a subtree"
        set S(toolhelp,connect) 	 	    "GRAPHICS CONNECTORS (Reflection)\n clic (left mouse button) a subtree"
        set S(toolhelp,congruence) 	 	 "CONGRUENCE (Reflection)\n clic (left mouse button) a subtree"
        ### ILLUSTRATION
        set S(toolhelp,textinsert) 		 "CANVAS TEXT INSERTION (Illustration)"
        set S(toolhelp,symbolinsert) 	"CANVAS SYMBOL INSERTION(Illustration)"
        set S(toolhelp,drawrectangle) "DRAW A RECTANGLE (Illustration) Rectangle"
        set S(toolhelp,drawoval) 		   "DRAW AN OVAL (Illustration)"
        set S(toolhelp,drawline) 	   	"DRAW A LINE (Illustration)"
        set S(toolhelp,catchfont) 		  "FONT CATCH (Illustration)"
        set S(toolhelp,catchcolor) 		 "COLOR CATCH (Illustration)"
        set S(toolhelp,bracketdraw) 		"BRACKET with annotation (Illustration)\n Arguments: text, font, color, stipple \n(parameters panel)"
        set S(toolhelp,leafsel) "Leaf selection \n clic (switch +/-) or Shift-clic (+) or Ctrl-clic (-) \n near a tree, a checkboxe, a leaf label, a node"
        set S(toolhelp,annothttp) "Annotation <-> URLs"
                
    }
}
################################################################################


################################################################################
# Toolbox
################################################################################

namespace eval Toolbox {
    
    #S(ltoolboxusername) liste des i noms des toolbox
    #set S(toolbox) $S(toolboxType,i)
    # S(toolbox) est une aliste outil color
    proc ToolBoxEdit {} {
        global S
        if {[winfo exists .usertoolbox]} {destroy .usertoolbox}
        set p [toplevel .usertoolbox]
        wm title .usertoolbox "Toolbox Editor"
        # help
        label $p.msg  -background azure1 -justify left -anchor w -text " + Select the toolbox you want to edit using the top menu. check the \"New\" option for building a new toolbox.\n\
                + Clic (left mouse button) on icons to add or remove tools.\n\
                + A selected tool is highlighted by a colored bounding box, by default the color is blue. Check on the \"color\" button for others colors\n\
                + As the tool selection is done, clic the \"Make\" or \"Update\" buttons for making the toolbox.\n\
                + Note that the last selected tool always appears at the end of the toolbox on the main TreeDyn panel.\n\
                + The tools order can be modified using the midle mouse button: first clic on the tool to move, then clic again on a target position\n\
                + A tool color can be updated without modifying the tool position within the toolbox by using the right mouse button"
        
        #affichage rappel de la toolbox en edition
        #label $p.lab -textvariable S(toolboxMenu)
        # liste Toolbox + New
        frame $p.f
        label $p.f.lt -text "Toolbox: "
        menubutton $p.f.mt -textvariable S(toolboxMenu)  -menu $p.f.mt.m -indicatoron 1
        set m  [menu  $p.f.mt.m -tearoff 0]
        $m configure -postcommand "Toolbox::ToolBoxUpdateMenu $m"
        pack $p.f.lt $p.f.mt -side left -expand 1 -fill x
        checkbutton $p.chco -text "Color" -variable S(toolboxColor) -command "Interface::PopUpPanel  ColorFontPanel"
        # liste des outils
        set p2 [frame $p.can]
        canvas $p2.c -width 200 -height 200  \
                -xscrollcommand "$p2.xsbar set" -yscrollcommand "$p2.ysbar set"\
                -highlightthickness 0 -background LightGoldenrodYellow
        scrollbar $p2.xsbar -orient horizontal -command "$p2.c xview"
        scrollbar $p2.ysbar -orient vertical -command "$p2.c yview"
        grid $p2.c -row 0 -column 0 -sticky news
        grid $p2.xsbar -row 1 -column 0 -sticky ew
        grid $p2.ysbar -row 0 -column 1 -sticky ns
        grid rowconfigure $p2 0  -weight 1
        grid columnconfigure $p2 0 -weight 1
        set tools {}
        foreach {tool color} [lrange $S(toolbox,all) 2 end] {
            lappend tools $tool
        }
        set x 10 ; set y 10
        foreach ti $tools {
            $p2.c create image $x $y -image TIM$ti -tags "i $ti"
            regsub -all "\n" $S(toolhelp,$ti) "" tex
            $p2.c create text [expr $x + 30] $y -text $tex -anchor w
            incr y 20
        }
        $p2.c  configure -scrollregion [$p2.c bbox all]
        $p2.c bind i <Button-1> "Toolbox::ToolBoxAddRemoveTool %W"
        $p2.c bind i <Button-3> "Toolbox::ToolUpdateColor %W"
        
        # control
        frame $p.control
        button $p.control.selectall -text "Select all" -command "Toolbox::ToolBoxSelectAll"
        button $p.control.unselectall -text "UnSelect all" -command "Toolbox::ToolBoxUnSelectAll"
        set S(ToolboxCol) azure1
        pack $p.control.selectall $p.control.unselectall -side left -expand 1 -fill x
        
        # frame control "New"
        frame $p.subNew
        iwidgets::entryfield $p.subNew.name -width 25 -textvariable S(toolboxusername) -labeltext "Name:" -validate alphabetic
        button $p.subNew.make -text "Make" -command Toolbox::ToolBoxMake
        pack   $p.subNew.name $p.subNew.make -side top -expand true -fill x
        # frame subElse
        frame $p.subElse
        button $p.subElse.up -text "Update" -command Toolbox::ToolBoxMake
        button $p.subElse.del -text "Delete" -command Toolbox::ToolBoxDelete
        pack  $p.subElse.up $p.subElse.del -side top -expand true -fill x
        # PACK
        pack $p.msg -expand 1 -fill x
        pack $p.f -expand 1 -fill x
        pack $p.chco -expand 1 -fill x
        pack $p.control -expand 1 -fill x
        
        if {$S(toolboxType) == "basic" || $S(toolboxType) == "all"} {
            set S(toolboxMenu) New
            pack $p.subNew -side top -expand 1 -fill x
        } else {
            set S(toolboxMenu) $S(toolboxType)
            pack $p.subElse -side top -expand 1 -fill x
        }
        pack $p.can -expand 1 -fill both
        Toolbox::ToolBoxSwitch $S(toolboxMenu)
    }
    #
    proc ToolUpdateColor {c} {
        global S
        set i [lindex [$c gettags current] 1]
        set x [$c find withtag [list b && $i]]
        if {$x == ""} {
            return
        } else  {
            $c itemconfigure $x -fill $S(col)
        }
    }
    #
    proc ToolBoxUpdateMenu {m} {
        global S
        $m  delete 0 end
        $m add radiobutton -label "New" -command "Toolbox::ToolBoxSwitch New" \
                -variable S(toolboxMenu) -value New
        $m add separator
        foreach i $S(ltoolboxusername) {
            $m add radiobutton -label $i -command "Toolbox::ToolBoxSwitch $i" \
                    -variable S(toolboxMenu) -value $i
        }
    }
    #
    proc ToolBoxDelete {} {
        global S
        .usertoolbox.can.c delete b
        if {$S(toolboxMenu) != "New"} {
            unset S(toolbox,$S(toolboxMenu))
            set loriginal $S(ltoolboxusername)
            set S(ltoolboxusername) [Tools::SousL  $S(ltoolboxusername) $S(toolboxMenu)]
            # mise a jour menu toolbox editor
            ToolBoxUpdateMenu .usertoolbox.f.mt.m
            # mise a jour main interface (menu) et palette si en cours d'edition
            foreach i $loriginal {
                set name [format "%s%s" .toolbox.w $i]
                .treedyn.m delete $name
            }
            foreach i $S(ltoolboxusername) {
                set name [format "%s%s" .toolbox.w $i]
                .treedyn.m add radiobutton $name -label $i -variable S(toolboxType) \
                        -value $i -command "Toolbox::ToolbarOrganiseCAP"
            }
            if {$S(ltoolboxusername) == ""} {
                set S(toolboxType) basic
                set S(toolboxMenu) New
                ToolbarOrganiseCAP
                Toolbox::ToolBoxSwitch $S(toolboxMenu)
            } else {
                set S(toolboxType) [lindex $S(ltoolboxusername) end]
                set S(toolboxMenu) $S(toolboxType)
                ToolbarOrganiseCAP
                Toolbox::ToolBoxSwitch $S(toolboxMenu)
            }
        }
    }
    #
    proc ToolBoxSelectAll {} {
        global S
        .usertoolbox.can.c delete b
        if  {$S(toolboxColor)} {set color $S(col)} {set color azure1}
        foreach {tool col} [lrange $S(toolbox,all) 2 end] {
            set co [.usertoolbox.can.c bbox $tool]
            set id [.usertoolbox.can.c create rectangle $co -tag "b $tool" -fill $color]
            .usertoolbox.can.c lower $id
        }
    }
    #
    proc ToolBoxSwitch {to} {
        global S
        ToolBoxUnSelectAll
        pack forget .usertoolbox.subNew .usertoolbox.subElse
        if {$to != "New"} {
            foreach {tool color} [lrange $S(toolbox,$to) 2 end] {
                set co [.usertoolbox.can.c bbox $tool]
                set id [.usertoolbox.can.c create rectangle $co -tag "b $tool" -fill $color]
                .usertoolbox.can.c lower $id
            }
            pack .usertoolbox.subElse -expand 1 -fill x
        } else {
            ToolBoxUnSelectAll
            set S(toolboxusername) ""
            pack .usertoolbox.subNew -expand 1 -fill x
        }
    }
    proc ToolBoxUnSelectAll {} {
        .usertoolbox.can.c delete b
    }
    proc ToolBoxAddRemoveTool {c} {
        global S
        set i [lindex [$c gettags current] 1]
        set x [$c find withtag [list b && $i]]
        if  {$S(toolboxColor)} {set color $S(col)} {set color azure1}
        if {$x == ""} {
            set co [$c bbox current]
            set id [$c create rectangle $co -tag "b $i" -fill $color]
            $c lower $id
        } else  {
            $c delete $x
        }
    }
    proc ToolBoxMake {} {
        global S
        set lit [lsort -increasing [.usertoolbox.can.c find withtag b]]
        set tools {}
        set toolscolor {}
        foreach it $lit {
            lappend tools [lindex [.usertoolbox.can.c gettags $it] end]
            lappend toolscolor [lindex [.usertoolbox.can.c gettags $it] end] \
                    [lindex [.usertoolbox.can.c itemconfigure $it -fill] end]
        }
        set wmax [winfo width .treedyn]
        set nbtools [llength $tools]
        set cmax [expr round($wmax / 25)  ]
        set rmax [expr round(($nbtools / $cmax) + 0.5)]
        if {$S(toolboxusername) ==  ""} {set S(toolboxusername) [Tools::GenId]}
        set S(toolbox,$S(toolboxusername)) "$rmax $cmax $toolscolor"
        set S(toolbox) $S(toolbox,$S(toolboxusername))
        set S(toolboxType) $S(toolboxusername)
        set S(toolboxMenu) $S(toolboxType)
        Toolbox::ToolBoxSwitch $S(toolboxMenu)
        ToolbarOrganise
        # mise a jour menu
        if {[lsearch $S(ltoolboxusername) $S(toolboxusername)] == -1} {
            lappend S(ltoolboxusername) $S(toolboxusername)
            set name [format "%s%s" .toolbox.w $S(toolboxusername)]
            .treedyn.m add radiobutton $name -label $S(toolboxusername) -variable S(toolboxType) \
                    -value $S(toolboxusername) -command "Toolbox::ToolbarOrganiseCAP"
        }
    }
    proc ToolbarRefresh {} {
        global S
        destroy .treedyn.t
        frame .treedyn.t
        set wmax [winfo width .treedyn]
        set nbtools [llength $S(toolbox)]
        set cmax [expr round($wmax / 25)  ]
        set rmax [expr round(($nbtools / $cmax) + 0.5)]
        set S(toolbox) "$rmax $cmax [lrange $S(toolbox) 2 end]"
        set S(toolbox,$S(toolboxType)) "$rmax $cmax [lrange $S(toolbox) 2 end]"
        set tools {}
        set colors {}
        foreach {tool color} [lrange $S(toolbox) 2 end] {
            lappend tools $tool
            lappend colors $color
        }
        set ti 0
        for {set r 0} {$r <= $rmax} {incr r} {
            for {set c 0} {$c <= $cmax} {incr c} {
                set tool [lindex $tools $ti]
                set color [lindex $colors $ti]
                if {$tool != "" && $color != ""} {
                    if {[catch {set command $S(toolcommand,$tool)} yes]} {set command ""}
                    
                    radiobutton .treedyn.t.$tool -value $tool -image TIM$tool \
                            -overrelief raised -offrelief flat -selectcolor LightGoldenrodYellow \
                            -variable S(tool)  -indicatoron off -highlightthickness 0\
                            -background  $color -command $command
                    grid .treedyn.t.$tool -row $r -column $c -ipadx 0 -ipady 0 -padx 0 -pady 0
                    incr ti
                }
            }
        }
        grid .treedyn.t  -row 1 -column 0
        update
        wm geometry .treedyn [winfo reqwidth .treedyn]x[winfo reqheight .treedyn]
        update idletasks
        if {$S(tool,help)} {Toolbox::ToolsHelp}
    }
    proc ToolbarRefreshCol {cmax} {
        global S
        destroy .treedyn.t
        frame .treedyn.t
        set wmax [winfo width .treedyn]
        set nbtools [llength $S(toolbox)]
        set rmax [expr round(($nbtools / $cmax) + 0.5)]
        set S(toolbox) "$rmax $cmax [lrange $S(toolbox) 2 end]"
        set S(toolbox,$S(toolboxType)) "$rmax $cmax [lrange $S(toolbox) 2 end]"
        set tools {}
        set colors {}
        foreach {tool color} [lrange $S(toolbox) 2 end] {
            lappend tools $tool
            lappend colors $color
        }
        set ti 0
        for {set r 0} {$r <= $rmax} {incr r} {
            for {set c 0} {$c <= $cmax} {incr c} {
                set tool [lindex $tools $ti]
                set color [lindex $colors $ti]
                if {$tool != "" && $color != ""} {
                    if {[catch {set command $S(toolcommand,$tool)} yes]} {set command ""}
                    radiobutton .treedyn.t.$tool -value $tool -image TIM$tool  \
                            -overrelief raised -offrelief flat -selectcolor LightGoldenrodYellow \
                            -variable S(tool)  -indicatoron off -highlightthickness 0\
                            -background  $color -command $command
                    grid .treedyn.t.$tool -row $r -column $c -ipadx 0 -ipady 0 -padx 0 -pady 0
                    incr ti
                }
            }
        }
        grid .treedyn.t  -row 1 -column 0
        update
        wm geometry .treedyn [winfo reqwidth .treedyn]x[winfo reqheight .treedyn]
        update idletasks
        if {$S(tool,help)} {Toolbox::ToolsHelp}
    }
    proc ToolbarOrganiseCAP {} {
        global S
        set S(toolbox) $S(toolbox,$S(toolboxType))
        ToolbarOrganise
    }
    proc ToolbarOrganise {} {
        global S
        destroy .treedyn.t
        frame .treedyn.t
        set rmax [lindex $S(toolbox) 0]
        set cmax [lindex $S(toolbox) 1]
        set tools {}
        set colors {}
        foreach {tool color} [lrange $S(toolbox) 2 end] {
            lappend tools $tool
            lappend colors $color
        }
        set ti 0
        for {set r 0} {$r <= $rmax} {incr r} {
            for {set c 0} {$c <= $cmax} {incr c} {
                set tool [lindex $tools $ti]
                set color [lindex $colors $ti]
                if {$tool != "" && $color != ""} {
                    if {[catch {set command $S(toolcommand,$tool)} yes]} {set command ""}
                    radiobutton .treedyn.t.$tool -value $tool -image TIM$tool  \
                            -overrelief raised -offrelief flat -selectcolor LightGoldenrodYellow \
                            -variable S(tool)  -indicatoron off -highlightthickness 0\
                            -background  $color -command $command
                    grid .treedyn.t.$tool -row $r -column $c -ipadx 0 -ipady 0 -padx 0 -pady 0
                    bind .treedyn.t.$tool <Button-2> "Toolbox::ToolSwitch $tool"
                    incr ti
                }
            }
        }
        grid .treedyn.t  -row 1 -column 0
        update
        wm geometry .treedyn [winfo reqwidth .treedyn]x[winfo reqheight .treedyn]
        update idletasks
        Toolbox::ToolsHelp
    }
    proc ToolSwitch {to} {
        global S
        if {$S(toolswitch) == $to} {
            return
        }  elseif {$S(toolswitch) == ""} {
            set S(toolswitch) $to
        } else {
            # MOVE
            # on suprime les from
            set indFrom  [lsearch $S(toolbox) $S(toolswitch)] ;# index
            set ToFrom [lindex $S(toolbox) $indFrom] ;# tool
            set CoFrom [lindex $S(toolbox) [expr $indFrom +1]] ;# color
            set l [join [lreplace $S(toolbox) $indFrom [expr $indFrom +1] ""]] ;# suppresion
            # insertion, on inserre le from avant le target
            set indTo [lsearch $S(toolbox) $to] ;# index
            set S(toolbox) [linsert $l $indTo $ToFrom $CoFrom]
            set S(toolswitch) ""
            set S(toolbox,$S(toolboxType)) $S(toolbox)
            Toolbox::ToolbarOrganiseCAP
        }
    }
    # mise a jour menu
    proc ListUserToolboxes {} {
        global S
        foreach to $S(ltoolboxusername)  {
            set name [format "%s%s" .toolbox.w $to]
            if {[winfo exists $name] != 1} {
                .treedyn.m add radiobutton $name -label $to -variable S(toolboxType) \
                        -value $to -command "Toolbox::ToolbarOrganiseCAPUSER"
            }
        }
    }
    proc updateToolColor {tool} {
        global S
        set properties {}
        foreach {key value} $S(toolbox) {
            if {$key == $tool} {
                lappend properties $key $S(col)
            } else  {lappend properties $key $value}
        }
        set S(toolbox) $properties
        set S(toolbox,$S(toolboxType)) $properties
        if  {$S(toolboxColor)} {set color $S(col)} {set color azure1}
        if {[winfo exists .treedyn.t.$tool] == 1} {
            .treedyn.t.$tool configure -background $color
        }
    }
    proc updateFamilyToolColor {tool} {
        global S
        set family [string tolower [lindex $S(tool,$tool) [expr 1 + [lsearch  $S(tool,$tool) famille ]]]]
        foreach tool $S(toolbox,$family) {
            updateToolColor $tool
        }
    }
    proc updateAllToolColor {tool} {
        global S
        foreach tool $S(toolbox,all) {
            updateToolColor $tool
        }
    }
    # ATTENTION RETRAIT : rotation azure1 shrink4 azure1 collapse azure1 textnodebl2 textnodeblp2
    # fgcolor navajowhite3   bgcolorst1 navajowhite3   fgcolorleaf darkolivegreen1   bgcolor darkolivegreen1
    # swap LavenderBlush2  outgroup LavenderBlush2
    proc QueryTools  {} {
        global S tcl_platform
        switch $tcl_platform(platform) {
            "unix" {
                if  {$tcl_platform(os) == "Darwin"} {
                    set color systemButtonFace
                } else  {
                    set color #efebe7
                }
            }
            "windows" {
                set color systemButtonFace
            }
        }
        set S(toolbox,all) [list 7 10 \
                move $color movel $color reset $color  delete $color  copypaste $color  copypastenavi $color  copypastecollection $color \
                zoompc $color  zoomxb $color  zoomyb $color  zoomxyb $color \
                zoom1 $color  zoom2 $color  zoom3 $color  zoom4 $color  zoomuser $color \
                fgcolor $color   bgcolorst1 $color   fgcolorleaf $color   bgcolor $color   width+- $color  dash $color \
                textset $color  textsize+- $color  textitalic $color  textunder $color  textbold $color \
                textover $color  annotree $color  textleafc $color  leafillustrationC $color  textnode $color  symbolnode $color \
                nodeillustration $color  valbefore $color  valafter $color  absleaf $color  movematrix $color \
                movecol $color  annfgcol $color  annfgrow $color  annfocol $color  annforow $color  annanchw $color  annanche $color \
                confrect $color  confcircext $color  confcircext2 $color  confcircint $color \
                swap $color  outgroup $color  ladder $color  shrink $color shrink3 $color shrink4 $color subtree $color  stcollapse $color  stpolytotale $color  stpolypartial $color \
                stdelete $color  stcopypaste $color  transition1 $color  transition2 $color  transition3 $color  connect $color \
                congruence $color  textinsert $color  symbolinsert $color  drawrectangle $color  drawoval $color \
                drawline $color  catchfont $color  catchcolor $color  bracketdraw $color  d3menus $color  localisation $color leafsel $color annothttp $color]       
        set S(toolbox,basic) {2 9 move grey95 reset grey95 delete grey95 zoom3 grey95 bgcolorst1 grey95 fgcolor grey95
            fgcolorleaf grey95 bgcolor grey95 textleafc grey95 leafillustrationC grey95
            textnode grey95 symbolnode grey95 swap grey95 outgroup grey95
            confrect grey95 confcircext grey95 confcircext2 grey95 confcircint grey95 valbefore grey95 valafter grey95}
        set S(toolcommand,zoomuser)          "Navigation::ZoomFactorPanel"
        set S(toolcommand,fgcolor)           "Interface::PopUp Color"
        set S(toolcommand,bgcolorst1)        "Interface::PopUp Stipple"
        set S(toolcommand,fgcolorleaf)       "Interface::PopUp Color"
        set S(toolcommand,shrink)           "Interface::PopUp Symbol"
        set S(toolcommand,shrink3)           "Interface::PopUp Color"
        set S(toolcommand,shrink4)           "Interface::PopUp Color"
        set S(toolcommand,bgcolor)           "Interface::PopUp Color"
        set S(toolcommand,textset)           "Interface::PopUp Font"
        set S(toolcommand,annotree)          "Interface::PopUp Font "
        set S(toolcommand,textleafc)         "Interface::PopUp Text"
        set S(toolcommand,leafillustrationC) "Interface::PopUp Symbol"
        set S(toolcommand,textnode)          "Interface::PopUp Text"
        set S(toolcommand,symbolnode)        "Interface::PopUp Symbol"
        set S(toolcommand,nodeillustration)  "Interface::PopUp Symbol"
        set S(toolcommand,textnodebl2)       "Interface::PopUp Font"
        set S(toolcommand,textnodeblp2)      "Interface::PopUp Font"
        set S(toolcommand,d3menus)           "Interface::PopUp Font"
        set S(toolcommand,localisation)      "Operation::OperationMenu"
        set S(toolcommand,transition1)       "Operation::OperationMenu"
        set S(toolcommand,transition2)       "Operation::OperationMenu"
        set S(toolcommand,transition3)       "Operation::OperationMenu"
        set S(toolcommand,transition3)       "Operation::AnnotHTTPpanel"
        set S(toolcommand,textinsert)        "Interface::PopUp Font"
        set S(toolcommand,symbolinsert)      "Interface::PopUp Symbol"
        set S(toolcommand,bracketdraw)       "Interface::PopUp Text"
        set S(toolcommand,annothttp)       "Operation::AnnotHTTPpanel"
        
    }
    proc BalloonhelpMake {} {
        global S
        toplevel .balloonhelp
        wm overrideredirect .balloonhelp 1
        set x [expr [winfo rootx .treedyn] -3]
        set y [expr 5 + [winfo rooty .treedyn] + [winfo height .treedyn]]
        set ccc [format "%s%s%s%s" 250x80+ $x + $y]
        wm geometry .balloonhelp $ccc
        label .balloonhelp.info -anchor center -background LightGoldenrodYellow -font $S(InterfPref,FontBalloonHelp)
        canvas .balloonhelp.move -border 0 -bd 0 -width 10 -height 7 -background grey -relief flat
        .balloonhelp.move create rectangle 0 0 250 8 -fill ivory2 -outline grey  -stipple gray50
        bind .balloonhelp.move  <B1-Motion> "Toolbox::HelpMoveMotion %W %x %y"
        grid .balloonhelp.move -row 0 -column 0 -sticky ew
        grid .balloonhelp.info -row 1 -column 0 -sticky news
        grid rowconfigure .balloonhelp 1  -weight 1
        grid columnconfigure .balloonhelp 0 -weight 1
        HelpOnOff
    }

    proc HelpMoveMotion {w x y} {
        wm geometry .balloonhelp "+[winfo pointerx .balloonhelp]+[winfo pointery .balloonhelp]"
    }
    proc ToolsHelp {} {
        global S
        foreach {tool color} [lrange $S(toolbox) 2 end] {
            bind .treedyn.t.$tool <Any-Enter> "Toolbox::balloonhelp_show $tool"
            bind .treedyn.t.$tool <Any-Leave> "Toolbox::balloonhelpCurrent"
        }
    }
    proc balloonhelp_show {tool} {
        global S
        if {[winfo exists .balloonhelp]} {
            .balloonhelp.info configure -text $S(toolhelp,$tool)
        }
    }
    proc balloonhelpCurrent {} {
        global S
        if {[winfo exists .balloonhelp]} {
            .balloonhelp.info configure -text $S(toolhelp,$S(tool))
        }
    }
    proc HelpOnOff {} {
        global S
        switch  $S(tool,help) {
            0 {wm withdraw .balloonhelp}
            1 {wm deiconify .balloonhelp}
        }
    }
}

################################################################################
# UPDATE
################################################################################
namespace eval Update {
    #
    proc TreeDynUpdate {} {
        global S
        if {[winfo exists .httpnews] == 1} {destroy .httpnews}
        # TOPLEVEL
        set top [toplevel .httpnews]
        wm title .httpnews "TreeDyn Update"
        #wm overrideredirect $top 1
        set x [expr ([winfo screenwidth $top] - 300) /2]
        set y [expr ([winfo screenheight $top] - 100) /2]
        wm geometry $top "400x270+$x+$y"
        # BUTTONS
        set wb [frame $top.c]
        button $wb.b1 -text "Check for Update(s)" -command "Update::httpUpdateCheck"
        button $wb.b3 -text "Exit" -command "destroy .httpnews"
        pack $wb.b1 $wb.b3 -side left -expand true -fill x
        # message dynamique transactions
        set S(httpText) ""
        label $top.l  -textvariable S(httpText)  -foreground black
        #
        set S(treedynPackCheck) ?
        set S(treedynPatchCheck) ?
        set S(treedynManualCheck) ?
        set wmsg [frame $top.msg]
        #  mesage
        label $wmsg.l01  -text ""
        label $wmsg.l02  -text "Your version:" -foreground blue
        label $wmsg.l03  -text "Current Version:"  -foreground red
        #  Pack un nom
        label $wmsg.l11  -text TreeDynPack:
        label $wmsg.l12  -textvariable S(treedynpack) -foreground blue
        label $wmsg.l13  -textvariable S(treedynPackCheck) -foreground red
        # Patch un numero
        label $wmsg.l21  -text TreeDynPatch:
        label $wmsg.l22  -textvariable S(patchnumber)  -foreground blue
        label $wmsg.l23  -textvariable S(treedynPatchCheck) -foreground red
        button $wmsg.b2  -text Update   -command Update::httpUpdatePatch -state disabled
        # Grid
        grid $wmsg.l01 -row 0 -column 0
        grid $wmsg.l02 -row 0 -column 1
        grid $wmsg.l03 -row 0 -column 2
        #
        grid $wmsg.l21 -row 2 -column 0
        grid $wmsg.l22 -row 2 -column 1
        grid $wmsg.l23 -row 2 -column 2
        #
        grid $wmsg.b2 -row 2 -column 3
        # PACK
        pack $wb $wmsg $top.l -expand yes -fill x -anchor n -side top
    }
    #
    proc httpUpdateCheck {} {
        global S
        set query "http://www.treedyn.org/treedynupdatecheck"
        set S(httpText) "...checking..."
        http::geturl $query -timeout 5000 -command  Update::httpUpdateCheckProcess
    }
    #
    proc httpUpdateCheckProcess {token} {
        global S
        upvar #0 $token state
        if {$state(status) != "timeout"} {
            set new [http::data $token]
            set S(treedynPackCheck) [lindex $new 0]
            set S(treedynPatchCheck) [lindex $new 1]
            set S(treedynManualCheck) [lindex $new 2]
            if {$S(treedynPatchCheck) > $S(patchnumber)} {.httpnews.msg.b2 configure -state normal}
            set S(httpText) "done"
        } else  {
            set S(httpText) "www.treedyn.org not responding\n Retry later"
        }
    }
    ### Update Patch
    proc httpUpdatePatch {} {
        global S
        set query "http://www.treedyn.org/data"
        set S(httpText) "Downloading TreeDyn Patch number $S(treedynPatchCheck)"
        destroy .httpnews.p
        iwidgets::feedback .httpnews.p  -steps 100  -labelpos w \
                -barheight 5 -barcolor AntiqueWhite3 -troughcolor  LightGoldenrodYellow
        pack .httpnews.p -expand true -fill x
        .httpnews.p reset
        update idletasks
        after 1000
        http::geturl $query -blocksize 16384 -timeout 30000 \
                -command Update::httpUpdatePatching \
                -progress Update::httpUpdatePatchProgress
    }
    proc httpUpdatePatchProgress {token total current} {
        global S
        .httpnews.p step
    }
    proc httpUpdatePatching {token} {
        global S tcl_platform
        upvar #0 $token state
        if {$state(status) != "timeout"} {
            set S(httpText) "Patching"
            after 1000
            update idletasks
            if  {$tcl_platform(os) == "Darwin"} {
                set fid [open  $S(osxtreedynupdate)  w]
            } else  {
                set fid [open  ./data  w]
            }
            
            puts $fid [http::data $token]
            close $fid
            set S(httpText) "TreeDyn updated, please restart TreeDyn"
            destroy .httpnews.p
            set S(patchnumber) $S(treedynPatchCheck)
            .httpnews.msg.b2 configure -state disable
            
        } else  {
            set S(httpText) "www.treedyn.org not responding\n Retry later"
        }
    }
    
}
################################################################################



################################################################################
# INTERFACE
################################################################################
namespace eval Interface {
    
    
    ########
    proc TreeDynCop {} {
        global S
        if {[winfo exists .copyr] == 1} {destroy .copyr}
        set top [toplevel .copyr -relief raised -borderwidth 2]
        wm title .copyr "TreeDyn Copyright"
        set te [frame $top.te -relief raised -borderwidth 2]
        text $te.text -relief sunken -bd 2 -yscrollcommand "$te.scroll set" -setgrid 1 \
                -height 30 -undo 1 -autosep 1
        scrollbar $te.scroll -command "$te.text yview"
        pack $te.scroll -side right -fill y
        pack $te.text -expand yes -fill both
        pack $te
        set te .copyr.te.text
        $te insert end " TREEDYN\n"
        $te insert end " Copyright (C)  2000-2007 Chevenet F. francois.chevenet@ird.fr\n"
        $te insert end "\n"
        $te insert end " This program is free software; you can redistribute it and/or\n"
        $te insert end " modify it under the terms of the GNU General Public License\n"
        $te insert end " as published by the Free Software Foundation; either version 2\n"
        $te insert end " of the License, or (at your option) any later version.\n"
        $te insert end "\n"
        $te insert end " This program is distributed in the hope that it will be useful,\n"
        $te insert end " but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
        $te insert end " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
        $te insert end " GNU General Public License for more details.\n"
        $te insert end "\n"
        $te insert end " You should have received a copy of the GNU General Public License\n"
        $te insert end " along with this program; if not, write to the Free Software\n"
        $te insert end " Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n"
    }
    proc TreeDynMessage {m} {
        tk_messageBox -message $m -type ok
    }
    ### Undo
    proc Undo {} {
        global S
        if {$S(und) != "?"} {eval $S(und)}
        set S(und) ""
    }
    proc TreeDynInitialisation {} {
        global  tcl_platform S T db IMGshn IMGil1 B asedCon find
        set S(version) "TreeDyn (198.3)"
        set S(treedynpack) Marianne
        set S(patchnumber) 198
        set S(manual) 1.0
        set S(TreeDynUpdate) {Marianne 198 1.0}
        set S(loc) 1
        set S(history) ""
        set S(AutoReset) 0
        set S(illustration-tabulation) 0
        set S(TabulationAnnot) 5
        ### FONT
        switch $tcl_platform(platform) {
            "unix" {
                set S(-family) Arial
                set S(-weight) normal
                set S(-size)  10
                set S(-slant)  roman
                set S(-underline)  0
                set S(-overstrike) 0
                set S(gfo) [list -family $S(-family) \
                        -weight $S(-weight) \
                        -size $S(-size) \
                        -slant $S(-slant) \
                        -underline $S(-underline) \
                        -overstrike $S(-overstrike)]
                        set S(fontbase) {Arial 8 normal}
            }
            "windows" {
                set S(-family) Arial
                set S(-weight) normal
                set S(-size)  8
                set S(-slant)  roman
                set S(-underline)  0
                set S(-overstrike) 0
                set S(gfo) [list -family $S(-family) \
                        -weight $S(-weight) \
                        -size $S(-size) \
                        -slant $S(-slant) \
                        -underline $S(-underline) \
                        -overstrike $S(-overstrike)]
                set S(fontbase) {Arial 8 normal}
            }
        }
        # Database
        set S(lastid) 0
        set S(nbobj) 0
        set S(database) ""
        set S(ldatabase) {}
        set asedCon [interp create treedyn]
        $asedCon alias db "Database::db"
        set S(topmessage) $S(version)
        set S(ghi) grey ;# couleur de hightlight
        set S(ilt) 0 ;# liste des identificateurs tree
        set S(ilw) 0 ;# liste des identificateurs windows
        set S(col) red
        set S(display_eu) normal
        set S(nodefilter) 0
        set S(tool) move
        set S(cp) "" ; # variable contenant les arguemnts pour les copy/paste
        set S(und) "?" ; # variable undo
        set S(Xfactor) 1.0
        set S(Yfactor) 1.0
        set S(collection) "" ;# liste des ID de collection (processus de copy / paste)
        set S(browserCP_width) 150
        set S(browserCP_height) 150
        ### variable package supertree
        set S(supertreeConsDisplayNewWindow) 1
        set S(supertreeConsDisplaySameWindow) 1
        set S(supertreeConsFile) 0
        ##### variable de reset graphique
        set S(OpResetLFgC) 0
        set S(OpResetLBgC) 0
        set S(OpResetLF) 0
        set S(OpResetNFgC) 0
        set S(OpResetNBgC) 0
        set S(OpResetNLW) 0
        set S(OpResetNLD) 0
        set S(OpResetNUS) 0
        set S(OpResetNUC) 0
        set S(OpResetAL) 0
        set S(OpResetAN) 0
        set S(OpResetAC) 0
        set S(AutoReset) 0 ;# variable de reset automatic du panel "Interface::Find"
        ##### variable/ valeur par defaut pour exportation HTML
        set S(url-prefix) "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=Nucleotide&cmd=search&val="
        set S(stipple) z.xbm
        # variable clavier virtuel (illustration)
        set S(ill-family) Wingdings
        set S(ill-size) 6
        set S(ill-weight) normal
        set S(ill-overstrike) 0
        set S(ill-underline) 0
        set S(ill-slant) roman
        #symbol par defaut
        set S(symboltype) 03
        set S(symboldx) 3
        set S(symboldy) 3
        # operation  l'identification
        set S(operation) leaffgcolor
        set S(operationName) "Leaf Foreground Color"
        set S(operationlabelisation) menu
        set S(operationdatabase) localisation
        set S(AnnotateNote) <text>
        set S(illustration-tabulation) 0
        set S(TabulationAnnot) 5 
        # allumage (voir database::select et scripting)
        set S(loc) 1
        set S(history) {}
        set find(case) 1
        set S(newW) 350 ;# Width et Height par defaut
        set S(newH) 350 ;# Width et Height par defaut
        set S(defaultshape) 1 ;# la forme par defaut des backgrounds
        set S(DisplayVOV) 1 ;# variable pour qLannC et qLannC360 pour differencie affichage variableValeur
        # variable MULTI IMPORT
        set S(MultiImportTDY) 0
        set S(MultiImportSFN) "0 File(s)"
        set S(MultiImportAFN) "0 File(s)"
        set S(MultiImportTRE) "0 Tree(s)"
        set S(MultiImportDII) {} ;# conservation des directories deja visitees
        set S(MultiImportTAR) new
        set S(MultiImportNBC) 3
        # fonte d'illustration par defaut
        set S(ill-fon) +
        set S(ill-car) +
        #variable SIMPLE IMPORT
        set S(SimpleImportTDY) 0
        set S(SimpleImportAFN) "0 File(s)"
        set S(SimpleImportTRE) "0 Tree(s)"
        set S(SimpleImportDII) {} ;# conservation des directories deja visitees
        # parametre par defaut Legend (identification query variable)
        set S(LegendLabels) 0
        set S(LegendVariable) 0
        set S(LegendOperator) 0
        set S(LegendOperation) 0
        set S(LegendBox) 1
        set S(LegendCadre) 0
        # variable BigImport
        set S(BIseuil) 5
        set S(ImportAUTOTAR) 1 ;# autotarget
        set S(alterTool) move
        set S(toolswitch) ""
        set S(ltoolboxusername) {}
        # le groupe de variables sujet a preferences, valeurs par defaut
        Interface::InterPrefsDefault
        source [file join $S(SCRIPTdir) preferences/.treedynprefs]
        if {[catch {set S(toolboxType) $S(toolboxType)} err]} {set S(toolboxType) basic}  
        Help::HelpSetting
        Toolbox::QueryTools
        # activation des preferences
         option add *Canvas.background $S(InterfPref,Canvas.background)
         option add *textBackground $S(InterfPref,textBackground)
         option add *Text.background $S(InterfPref,textBackground)
         option add *Listbox.background $S(InterfPref,Listbox.background)
         option add *Listbox.selectForeground $S(InterfPref,Listbox.selectForeground)
         option add *Listbox.selectBackground $S(InterfPref,Listbox.selectBackground)
         option add *Listbox.selectBorderWidth $S(InterfPref,Listbox.selectBorderWidth)
    }
    ### TreeDyn
    proc TreeDynPanel {} {
        global  tcl_platform S T db IMGshn IMGil1 B asedCon find
        destroy .treedyn
        #InterPrefsDefault
        set t [toplevel .treedyn -relief raised -borderwidth 2]
        #wm resizable .treedyn 0 0
        wm protocol .treedyn WM_DELETE_WINDOW {Interface::TreeDynExit}
        wm minsize .treedyn 180 55
        wm title .treedyn "$S(version)"
        iwidgets::menubar $t.m -helpvariable S(topmessage) -borderwidth 1  \
                -activeborderwidth 0  -menubuttons {
                    menubutton file  -text "File" -width 4 -menu {
                        command open -label "Open tree(s)..."  -helpstr "Open File(s)"   \
                                -command {ImportExport::MIimport}
                separator sep5
                command loadlabel -label "Load annotations..."  -helpstr "Load labels file"   -command "Database::LoadAnnotations"
                separator sep55
                command open2 -label "Load script..."  -helpstr "Open TreeDyn Script"   \
                        -command {Interface::PopUpPanel ScriptingPanel ; Scripting::OpenScriptCAP}
                separator sep2
                command newcanvas -label "New"  -helpstr "New Canvas"   -command "ImportExport::NewCanvas"
                separator sep4
                cascade savewinds -label "Save..." -command "Interface::ListWindowSave"
                cascade saveaswinds -label "Save As..." -command "Interface::ListWindowSave"
                separator sep7
                cascade export -label "Export..." -command "Interface::ListWindowSave"
                separator sep6
                cascade printwinds -label "Print..." -command "Interface::ListWindowSave"
                separator sep3
                command exit -label "Exit"    -helpstr "Exit application"  -command {Interface::TreeDynExit}
            }
            menubutton toolbox -text "Toolbox" -width 8 -menu {
                checkbutton help -label "Balloon help" -variable S(tool,help) \
                        -onvalue 1 -offvalue 0 -command Toolbox::HelpOnOff
                command refresh  -label "Row(s) x Column(s) Update" -command Toolbox::ToolbarRefresh
                separator t2
                radiobutton all  -label "All tools" -variable S(toolboxType) -value all -command "Toolbox::ToolbarOrganiseCAP"
                radiobutton default  -label "Basic tools" -variable S(toolboxType) -value basic -command "Toolbox::ToolbarOrganiseCAP"
                separator t1
                command usertool  -label "Toolbox editor..." -command "Toolbox::ToolBoxEdit"
            }
            menubutton view -text "View" -width 6 -menu {
                options -tearoff false
                command ColorFontPanel  -label "Paramaters panel (Color/Font/Stipple/Symbol/Text)" -command "Interface::PopUpPanel ColorFontPanel"
                command treeview  -label "Tree panel" -helpstr "" -command "Operation::TreeViewerPanel"
                separator sep10
                command AnnotationPanel  -label "Annotation panel" -command "Interface::PopUpPanel AnnotationPanel"
                command AnnotationPanelBL  -label "Newick Annotation panel" -command "Annotation::ANPanelBL"
                command FindPanel  -label "Find panel" -command "Interface::PopUpPanel FindPanel"
                command IdentificationPanel  -label "Identification panel" -command "Interface::PopUpPanel IdentificationPanel"
                command LibraryPanel  -label "Library panel" -command "Interface::PopUpPanel LibraryPanel"
                command ScriptingPanel  -label "Scripting panel" -command "Interface::PopUpPanel ScriptingPanel"
                command W3Panel  -label "HTML export panel" -command "Interface::PopUpPanel HTMLexportPanel"
                separator sep11
                command supertree  -label "TreeSPU" -command "SuperTree::SuperTreePanel"
                command amelie    -label "TreeIG" -command "Amelie::InteractionGraph"
                command treebase    -label "TreeBASEinterf" -command "TreeBase::TreeBasepanel"
                command treemat    -label "TreePAT" -command "TreeMat::TreeMatpanel"
                command treexy    -label "TreeXY" -command "TreeXY::treexyPanel"
                separator sep12
                command PreferencesPanel  -label "Preferences panel" -command "Interface::PreferencesPanel"
            }
            menubutton help -text "Help" -image IMGhelp -menu {
                options -tearoff false
                command update -label "TreeDyn Update"  -helpstr ""  -command Update::TreeDynUpdate
                separator sep19
                command helponline -label "www.treedyn.org" -command Interface::TreeDynOrg
                separator sep22
                command helptopicsonline  -label "User's Manual..." -command Interface::ManualOnline
                separator sep18
                command copyr -label "TreeDyn Copyright"   -command Interface::TreeDynCop
                separator sep21
                command about -label "About..."   -command Interface::AboutPanel
            }
        }
        Toolbox::ToolbarOrganiseCAP
        foreach i $S(ltoolboxusername) {
            set name [format "%s%s" .toolbox.w $i]
            .treedyn.m add radiobutton $name -label $i -variable S(toolboxType) \
                    -value $i -command "Toolbox::ToolbarOrganiseCAP"
        }
        .treedyn.m invoke .file.savewinds
        bind .treedyn.m <Any-Enter> ".treedyn.m invoke .file.savewinds"
        bind .treedyn <Any-Enter> "Toolbox::HelpOnOff"
        grid $t.m  -row 0 -column 0  -sticky ew
        grid rowconfigure .treedyn 1  -weight 1
        grid columnconfigure .treedyn 0 -weight 1
        update
        wm iconbitmap .treedyn gray50
        wm geometry .treedyn [winfo reqwidth .treedyn]x[winfo reqheight .treedyn]$S(Preference_mainXY)
        update idletasks
    }
    proc unmapall {} {
        destroy .balloonhelp
        destroy .about
        foreach w [winfo children .] {wm iconify $w}
    }
    proc mapall {} {
        foreach w [winfo children .] {wm deiconify $w}
        Toolbox::BalloonhelpMake
    }
    #
    proc MenuTreeTarget {} {
        global S
        set m .treedyn.m
        $m delete .edit.target
        $m delete .edit.sep12
        $m delete .edit.undo
        $m add cascade .edit.target -label "Target..." -command {Interface::MenuTreeTarget}
        $m add separator .edit.sep12
        $m add command .edit.undo -label "Undo"  -helpstr "Undo"  -command {Interface::Undo}
        # menu target select/unselect all general
        $m add command .edit.target.selall   -label "Select All" -command "Selection::TreeTargetSelectAll"
        $m add command .edit.target.unselall -label "UnSelect All" -command "Selection::TreeTargetUnSelectAll"
        $m add separator .edit.target.sep01
        # menu target un menu par fenetre, avec select/unselect all par fenetre
        # un menu par fenetre, avec select/unselect all par fenetre
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set ms [format "%s%s%s" .edit.target .w [Tools::GenId]]
                $m add cascade $ms -label [wm title .t$wi]
                $m add command $ms.selallw -label "Select All" -command "Selection::TreeTargetSelectAllperW $wi"
                $m add command $ms.unselallw -label "Unselect All" -command "Selection::TreeTargetUnSelectAllperW $wi"
                $m add separator $ms.sep
                set win [format "%s%s%s" .t $wi .c]
                foreach ti $S($win,t) {
                    if {$S($ti,tit) != ""} {
                        set name [format "%s%s%s" $ms .ti [Tools::GenId]]
                        $m add checkbutton $name -label [string toupper $S($ti,tit)] -variable S($ti,tar) -command "Selection::ShwoTree $ti"
                    }
                }
            }
        }
    }
    ###
    proc ListWindowSave {} {
        global S tcl_platform
        .treedyn.m delete .file.savewinds
        .treedyn.m delete .file.saveaswinds
        .treedyn.m delete .file.export
        .treedyn.m delete .file.printwinds
        .treedyn.m delete .file.exit
        .treedyn.m delete .file.sep7
        .treedyn.m delete .file.sep6
        .treedyn.m delete .file.sep3
        .treedyn.m add cascade .file.savewinds -label "Save..." -command "Interface::ListWindowSave"
        .treedyn.m add cascade .file.saveaswinds -label "Save As..." -command "Interface::ListWindowSave"
        .treedyn.m add separator .file.sep7
        .treedyn.m add cascade .file.export -label "Export..."  -command "Interface::ListWindowPrint"
        .treedyn.m add separator .file.sep6
        .treedyn.m add cascade .file.printwinds -label "Print..."   -command "Interface::ListWindowPrint"
        .treedyn.m add separator .file.sep3
        .treedyn.m add command .file.exit -label "Exit"  -command "Interface::TreeDynExit"
        # menu save
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set name [format "%s%s%s" .file.savewinds. w [Tools::GenId]]
                set target [format "%s%s%s" .t $wi .c]
                .treedyn.m add command $name -label [wm title .t$wi] -command "ImportExport::draw_save $target save"
            }
        }
        # menu save as
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set name [format "%s%s%s" .file.saveaswinds. w [Tools::GenId]]
                set target [format "%s%s%s" .t $wi .c]
                .treedyn.m add command $name -label [wm title .t$wi] -command "ImportExport::draw_save $target saveas"
            }
        }
        # menu export
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set name [format "%s%s%s" .file.export. w [Tools::GenId]]
                set target [format "%s%s%s" .t $wi .c]
                .treedyn.m add command $name -label [wm title .t$wi] -command "ImportExport::ExportFile $target"
            }
        }
        # menu print
        switch $tcl_platform(platform) {
            "unix" {
                #rien
            }
            "windows" {
                foreach wi $S(ilw)  {
                    if {$wi != 0 && [winfo exists .t$wi] == 1} {
                        set name [format "%s%s%s" .file.printwinds. w [Tools::GenId]]
                        set target [format "%s%s%s" .t $wi .c]
                        .treedyn.m add command $name -label [wm title .t$wi] -command "Package::Printer::print_widget $target all ?"
                    }
                }
            }
        }
    }
    ###
    proc preMagnify {} {
        global S
        if {[winfo exists .mag] == 0 } {
            set S(mag) [image create photo -width 192 -height 192]
            toplevel .mag
            wm title .mag Magnifier
            grid [label .mag.l -image $S(mag)]
            wm geom .mag +400+0
        }
    }
    proc Magnify { w x y } {
        global S
        
        set wid [winfo width $w]
        set ht [winfo height $w]
        if { $x < 12 } {
            set x 12
        }
        if { $x > $wid - 13 } {
            set x [expr { $wid - 13 }]
        }
        if { $y < 12 } {
            set y 12
        }
        if { $y > $ht - 13 } {
            set y [expr { $ht - 13 }]
        }
        set from [image create photo -format window -data $w]
        $S(mag) copy $from \
                -from [expr { $x - 12 }] [expr { $y - 12 }] \
                [expr { $x + 12 }] [expr { $y + 12 }] \
                -to 0 0 191 191 \
                -zoom 8
        rename $from {}
    }
    proc PopUpPanel {kw} {
        switch -exact $kw {
            
            AbstractionPanel {
                if {[winfo exists .abs] == 1} {
                    wm deiconify .ut
                } else  {
                    Abstraction::AbstractionPanel
                }
            }
            AnnotationPanel {
                if {[winfo exists .ann] == 1} {
                    wm deiconify .ann
                } else  {
                    Annotation::ANPanel
                }
            }
            ColorFontPanel {
                if {[winfo exists .cf] == 1} {
                    wm deiconify .cf
                } else  {
                    Operation::ColorFontPanel
                }
            }
            FindPanel {
                if {[winfo exists .find] == 1} {
                    wm deiconify .find
                } else  {
                    Interface::Find
                }
            }
            IdentificationPanel {
                if {[winfo exists .identification] == 1} {
                    wm deiconify .identification
                } else  {
                    Database::dbBrowser
                }
            }
            LibraryPanel {
                if {[winfo exists .int] == 1} {
                    wm deiconify .int
                } else  {
                    Integration::IntegrationPanel
                }
            }
            PreferencesPanel {
                if {[winfo exists .pref] == 1} {
                    wm deiconify .pref
                } else  {
                    Interface::PreferencesPanel
                }
            }
            SubdivisionPanel {
                if {[winfo exists .sb] == 1} {
                    wm deiconify .sb
                } else  {
                    Abstraction::SubdivisionPanel
                }
            }
            HTMLexportPanel {
                if {[winfo exists .htmlexport] == 1} {
                    wm deiconify .htmlexport
                } else  {
                    ImportExport::HTMLexportPanel
                }
            }
            ScriptingPanel {
                if {[winfo exists .tds] == 1} {
                    wm deiconify .tds
                } else  {
                    Scripting::ScriptingPanel
                }
            }
        }
    }
    # active si besoin le panel des parametres treedyn
    # et pop le tabs correspondant
    proc PopUp {what} {
        if {[winfo exists .cf] == 1} {
            wm deiconify .cf
        } else  {
            Operation::ColorFontPanel
        }
        .cf.n view $what
        
    }
    proc PopUpPanel2 {kw} {
        switch -exact $kw {
            StipplePanel {
                if {[winfo exists .stipp] == 1} {
                    wm deiconify .stipp
                } else  {
                    Interface::StipplePanel
                }
            }
            AbstractionPanel {
                if {[winfo exists .abs] == 1} {
                    wm deiconify .abs
                } else  {
                    Abstraction::AbstractionPanel
                }
            }
            AnnotationPanel {
                if {[winfo exists .ann] == 1} {
                    wm deiconify .ann
                } else  {
                    Annotation::ANPanel
                }
            }
            ColorFontPanel {
                if {[winfo exists .cf] == 1} {
                    wm deiconify .cf
                } else  {
                    Operation::ColorFontPanel
                }
            }
            FindPanel {
                if {[winfo exists .find] == 1} {
                    wm deiconify .find
                } else  {
                    Interface::Find
                }
            }
            IdentificationPanel {
                if {[winfo exists .identification] == 1} {
                    wm deiconify .identification
                } else  {
                    Database::dbBrowser
                }
            }
            LibraryPanel {
                if {[winfo exists .int] == 1} {
                    wm deiconify .int
                } else  {
                    Integration::IntegrationPanel
                }
            }
            PreferencesPanel {
                if {[winfo exists .pref] == 1} {
                    wm deiconify .pref
                } else  {
                    Interface::PreferencesPanel
                }
            }
            SubdivisionPanel {
                if {[winfo exists .sb] == 1} {
                    wm deiconify .sb
                } else  {
                    Abstraction::SubdivisionPanel
                }
            }
            HTMLexportPanel {
                if {[winfo exists .htmlexport] == 1} {
                    wm deiconify .htmlexport
                } else  {
                    ImportExport::HTMLexportPanel
                }
            }
            ScriptingPanel {
                if {[winfo exists .tds] == 1} {
                    wm deiconify .tds
                } else  {
                    Scripting::ScriptingPanel
                }
            }
        }
    }
    proc StipplePanel {{w ?}} {
        global S
        # TOOLBAR
        eval {iwidgets::toolbar} $w.t
        $w.t add radiobutton  z -overrelief sunken\
                -variable S(stipple) -value z.xbm \
                -image STIz
        $w.t add radiobutton  a -overrelief sunken\
                -variable S(stipple) -value a.xbm \
                -image STIa
        $w.t add radiobutton  b -overrelief sunken\
                -variable S(stipple) -value b.xbm \
                -image STIb
        $w.t add radiobutton  c -overrelief sunken\
                -variable S(stipple) -value c.xbm \
                -image STIc
        $w.t add radiobutton  e -overrelief sunken\
                -variable S(stipple) -value e.xbm \
                -image STIe
        $w.t add radiobutton  f -overrelief sunken\
                -variable S(stipple) -value f.xbm \
                -image STIf
        $w.t add radiobutton  l -overrelief sunken\
                -variable S(stipple) -value l.xbm \
                -image STIl
        $w.t add radiobutton  m -overrelief sunken\
                -variable S(stipple) -value m.xbm \
                -image STIm
        $w.t add radiobutton  g -overrelief sunken\
                -variable S(stipple) -value g.xbm \
                -image STIg
        $w.t add radiobutton  h -overrelief sunken\
                -variable S(stipple) -value h.xbm \
                -image STIh
        $w.t add radiobutton i -overrelief sunken\
                -variable S(stipple) -value i.xbm \
                -image STIi
        $w.t add radiobutton  j -overrelief sunken\
                -variable S(stipple) -value j.xbm \
                -image STIj
        $w.t add radiobutton k -overrelief sunken\
                -variable S(stipple) -value k.xbm \
                -image STIk
        # PACK
        pack $w.t
    }
    ############################ PREFERENCES
    proc DisplayEu {} {
        global S
        if {$S(Preference_display_eu) == 1} {
            set S(display_eu) normal
        } { set S(display_eu) hidden}
    }
    #
    proc FgColor {} {
        global S
        set S(Preference_fgc) $S(col)
        .treedyn.m  menuconfigure .edit.prefs.defaultcolor  -background $S(Preference_fgc)
    }
    ###  
    proc PreferencesPanel {} {
        global S
        set p .pref
        toplevel $p
        wm title $p "TreeDyn Preferences"
        # tabenotebook
        iwidgets::tabnotebook $p.n  -width 400 -height 300 -equaltabs 1 
        set p1 [$p.n add -label "Font" -tabpos nw  ]
        set p2 [$p.n add -label "Color" -tabpos nw  ]
        pack $p.n -fill both -expand yes 
        $p.n view "Font"
        $p.n configure  -tabpos n
        # TAB FONT
        iwidgets::optionmenu  $p1.balloonhelp -labeltext "Balloonhelp: " -labelpos w \
                -command "Interface::FontBalloonhelpPrefs $p1.balloonhelp "
        foreach i {"Arial 7 normal" "Arial 8 normal" "Arial 10 normal" } {$p1.balloonhelp insert end $i}
        .pref.n.canvas.notebook.cs.page1.cs.balloonhelp select $S(InterfPref,FontBalloonHelp)
        iwidgets::optionmenu  $p1.leaffont -labeltext "Leaf label:  " -labelpos w \
                -command "Interface::FontLeafLabelPrefs $p1.leaffont"
                foreach i {"Arial 7 normal" "Arial 8 normal" "Arial 10 normal" \
                        "Arial 7 italic" "Arial 8 italic" "Arial 10 italic"} {$p1.leaffont insert end $i}
        .pref.n.canvas.notebook.cs.page1.cs.leaffont select $S(fontbase)
        pack $p1.balloonhelp $p1.leaffont -side top -expand 1 -fill x
        
        # buttons
        frame $p.b
        button $p.b.save -text "Save" -command Interface::PrefsSave
        button $p.b.default -text "Default" -command "Interface::InterPrefsDefault ; Interface::InterfPrefUpdate"
        button $p.b.quit -text "Quit" -command "destroy .pref"
        pack $p.b.save $p.b.default $p.b.quit -side left
        pack $p.b -side top
    }
    #
    proc FontBalloonhelpPrefs {w} {
        global S
        # w == .pref.n.canvas.notebook.cs.page1.cs.balloonhelp
        .balloonhelp.info configure -font [$w get]
        set S(InterfPref,FontBalloonHelp) [$w get]
    }
    proc FontLeafLabelPrefs {w} {
        global S
        # w == .pref.n.canvas.notebook.cs.page1.cs.leaffont
        #.balloonhelp.info configure -font [$w get]
        set S(fontbase) [$w get]
    }
    #
    proc UpdateColor {} {
        global S
        set S(InterfPref,background) [tk_chooseColor]
        .pref.backcolor configure -background $S(InterfPref,background)
    }
    #
    proc InterfPrefUpdate {} {
        # activation des prefs
        global S tcl_platform
        # ballon help font
        .balloonhelp.info configure -font "Arial 8 normal"
        .pref.n.canvas.notebook.cs.page1.cs.balloonhelp select $S(InterfPref,FontBalloonHelp)
        # leaf label font
        .pref.n.canvas.notebook.cs.page1.cs.leaffont select $S(fontbase)
        update
    }
    # variable update + interface update
    proc InterPrefsDefault   {} {
        global S tcl_platform
        set S(tool,help) 1
        set S(SCRIPTdir) [file join [file dirname [info script]] +/]
        set S(userDIR) [pwd]
        set S(ImportDIR) [pwd]
        set S(Preference_mainXY) +50+50
        set S(ltoolboxusername) {}
        set S(toolboxType)  all
        set S(InterfPref,FontBalloonHelp) "Arial 8 normal"
        set S(fontbase) "Arial 8 normal"
        set S(InterfPref,Canvas.background) white
        set S(InterfPref,Menu.background) grey
        set S(InterfPref,activeForeground) black
        set S(InterfPref,activeBackground) LightGoldenrodYellow
        set S(InterfPref,Tabnotebook.backdrop) grey
        set S(InterfPref,activeBorderWidth) 2
        set S(InterfPref,textBackground) LightGoldenrodYellow
        set S(InterfPref,Listbox.background) LightGoldenrodYellow
        set S(InterfPref,Listbox.selectForeground) LightGoldenrodYellow
        set S(InterfPref,Listbox.selectBorderWidth) 0
        set S(InterfPref,Listbox.selectBackground) blue
        set S(InterfPref,background) grey
        set S(Preference_display_eu) 1
        set S(Preference_fgc) black
    }
        proc PrefsSave {} {
        global S
        set fid [open [file join $S(SCRIPTdir) preferences/.treedynprefs] w]
        puts $fid "# Treedyn Preferences"
        foreach l $S(ltoolboxusername) {
            puts $fid "set S(toolbox,$l) [list $S(toolbox,$l)]"
        }
        puts $fid "set S(InterfPref,FontBalloonHelp) [list $S(InterfPref,FontBalloonHelp)]"
        puts $fid "set S(fontbase) [list $S(fontbase)]"
        puts $fid "set S(ltoolboxusername) [list $S(ltoolboxusername)]"
        puts $fid "set S(toolboxType)  $S(toolboxType)"
        puts $fid "set S(tool,help) $S(tool,help)"
        puts $fid "set S(Preference_mainXY) [format "%s%s%s%s" + [winfo x .treedyn] + [winfo y .treedyn]]"
        puts $fid "set S(ImportDIR) [list $S(ImportDIR)]"
        puts $fid "set S(userDIR) [list $S(userDIR)]" 
        puts $fid "set S(Preference_display_eu) $S(Preference_display_eu)"
        puts $fid "set S(Preference_fgc) $S(Preference_fgc)"      
        puts $fid "set S(InterfPref,Canvas.background) $S(InterfPref,Canvas.background)"
        puts $fid "set S(InterfPref,Menu.background) $S(InterfPref,Menu.background)"
        puts $fid "set S(InterfPref,activeForeground)  $S(InterfPref,activeForeground)"
        puts $fid "set S(InterfPref,activeBackground) $S(InterfPref,activeBackground)"
        puts $fid "set S(InterfPref,Tabnotebook.backdrop) $S(InterfPref,Tabnotebook.backdrop)"
        puts $fid "set S(InterfPref,activeBorderWidth) $S(InterfPref,activeBorderWidth)"
        puts $fid "set S(InterfPref,textBackground) $S(InterfPref,textBackground)"
        puts $fid "set S(InterfPref,Listbox.background) $S(InterfPref,Listbox.background)"
        puts $fid "set S(InterfPref,Listbox.selectForeground) $S(InterfPref,Listbox.selectForeground)"
        puts $fid "set S(InterfPref,Listbox.selectBorderWidth) $S(InterfPref,Listbox.selectBorderWidth)"
        puts $fid "set S(InterfPref,Listbox.selectBackground) $S(InterfPref,Listbox.selectBackground)"
        puts $fid "set S(InterfPref,background) $S(InterfPref,background)"
        close $fid
    }
    #
    proc Pref1 {c} {
        global S
        set i [lindex [$c gettags current] 1]
        set x [$c find withtag [list b && $i]]
        if {$x == ""} {
            set co [$c bbox current]
            set id [$c create rectangle $co -tag "b $i" -fill LightGoldenrodYellow]
            $c lower $id
            lappend S(ltools) $i
        } else  {
            $c delete $x
            set index [lsearch -exact $S(ltools) $i]
            set S(ltools) [concat [lrange $S(ltools) 0 [expr $index - 1]] \
                    [lrange $S(ltools) [expr $index + 1] end]]
        }
    }
    # exit application
    proc TreeDynExit {} {
        set choix [tk_messageBox -type okcancel -default ok  -message "Exit TreeDyn ?" -icon question]
        if {$choix == "ok"} {
            catch {Interface::PrefsSave}
            exit
        }
    }
    
    ###
    proc Lbs2 {w titre wi he var} {
        global S
        #label $w.lab -bd 1 -text $titre -width $wi -background grey75
        scrollbar $w.yscroll -bd 1 -command "$w.l yview"
        scrollbar $w.xscroll -bd 1 -orient horizontal -command "$w.l xview "
        listbox  $w.l  -xscroll "$w.xscroll set" -yscroll "$w.yscroll set"  \
                -selectmode browse -width $wi -height $he -exportselection 0
        #grid $w.lab -row 0 -column 0
        grid $w.l -row 1 -column 0 -sticky news
        grid $w.yscroll -row 1 -column 1 -sticky ns
        grid $w.xscroll -row 2 -column 0 -sticky ew
        grid rowconfigure $w 1 -weight 1
        grid columnconfigure $w 0 -weight 1
        return $w
    }
    ### About Panel
    proc AboutPanel {} {
        if {[winfo exists .about] == 1} {destroy .about}
        toplevel .about -relief raised  -borderwidth 2 -background white
        wm resizable .about 0 0
        wm overrideredirect .about 1
        after idle {
            label .about.logo -borderwidth 2  -relief groove \
                    -background white -image IMGlogo
            bind .about.logo <ButtonPress-1> "destroy .about"
            update idletasks
            
            set x [expr ([winfo screenwidth .about] - [winfo reqwidth .about.logo]) /2]
            set y [expr ([winfo screenheight .about] - [winfo reqheight .about.logo]) /2]
            wm geometry .about "+$x+$y"
            pack .about.logo
        }
        update
    }
    proc ManualOnline {} {
        global tcl_platform
        switch $tcl_platform(platform) {
            "unix" {
                catch {
                    #"eval exec mozilla -remote [format "%s%s" [pwd]  /+/manual/index.html &
                    exec mozilla  http://www.treedyn.org/manual.html &
                } err
            }
            "windows" {
                catch {
                    eval exec "{C:/program files/internet explorer/iexplore.exe}" http://www.treedyn.org/manual.html &
                } err
            }
        }
    }
    
    proc TreeDynOrg {} {
        global tcl_platform
        switch $tcl_platform(platform) {
            "unix" {
                catch {
                    #"eval exec mozilla -remote [format "%s%s" [pwd]  /+/manual/index.html &
                    exec mozilla  http://www.treedyn.org &
                } err
            }
            "windows" {
                catch {
                    eval exec "{C:/program files/internet explorer/iexplore.exe}" http://www.treedyn.org &
                } err
            }
        }
    }
    ### Event
    proc AnyEnterCanvas {w} {
        global S
        bindtags $w [list $S(tool) $w Canvas . all ]
        raise .treedyn
    }
    #
    proc ToolIcon {w x y} {
        global S
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        # important de delete avant reconstuire a cause du T$t
        $w delete mousetool
        #set id [$w find closest $x $y]
        #set tags [$w gettags $id]
        #set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        #$w create image [expr $x +25] [expr $y +25] -image [format "%s%s" TIM $S(tool)] -tags "mousetool T$t"
        $w create image [expr $x +25] [expr $y +25] -image [format "%s%s" TIM $S(tool)] -tags "mousetool"
    }
    ### Event
    proc AnyLeaveCanvas {w} {
        $w delete mousetool
        bindtags $w {}
    }
    ### MENUS CONTEXTUELS
    proc D3Switch {w x y} {
        if {[winfo exists $w.d3menu ] == 1} {destroy $w.d3menu}
        set m [menu $w.d3menu -tearoff 0]
        set i [$w find withtag current]
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        if {$i != {}}  {
            set tags [$w gettags $i]
            if {[lsearch -glob $tags *C] != -1} {
                # NODE N
                Interface::D3Node  $w $m $i $x $y
            } elseif  {[lsearch -exact $tags Morpho] != -1} {
                # shape (morphometrie)
                Interface::D3Shape $w $m $i
            } elseif  {[lsearch -exact $tags Plot] != -1} {
                # shape (morphometrie)
                Interface::D3Plot $w $m $i
            } elseif  {[lsearch -exact $tags querynode] != -1} {
                # QUERY NODE
                Interface::D3QueryNode $w $m $i
            } elseif  {[lsearch -exact $tags bullab] != -1} {
                # LABEL NODE
                Interface::D3LabelNode $w $m $i
            } elseif  {[lsearch -exact $tags DBL] != -1} {
                # DBL
                Interface::D3DBL $w $m $i
            } elseif  {[lsearch -exact $tags DBV] != -1} {
                # DBV
                Interface::D3DBV $w $m $i
            }   elseif  {[lsearch -exact $tags Connect] != -1} {
                # CONNECTOR
                Interface::D3Connector $w $m $i $x $y
            }   elseif  {[lsearch -exact $tags ConnectIcon] != -1} {
                # CONNECTOR ICON
                Interface::D3ConnectorIcon $w $m $i $x $y
            }  elseif  {[lsearch -exact $tags bgtree] != -1} {
                # rectangle tree background
                Interface::D3BgTree $w $m $i
            }  elseif  {[lsearch -exact $tags SHRINK] != -1} {
                # SHRINK NODE
                Interface::D3ShrinkNode $w $m $i
            } elseif  {[lsearch -exact $tags Legend] != -1} {
                # LEGEND
                Interface::D3Legend $w $m $i
            } elseif  {[lsearch -exact $tags L] != -1} {
                # LEAF
                Interface::D3Leaf $w $m $i
            } elseif  {[lsearch -exact $tags bracket] != -1} {
                # ILLUSTRATION : crochet
                Interface::D3IllustrationBracket $w $m $i
            } elseif  {[lsearch -exact $tags nbracket] != -1} {
                # ILLUSTRATION : crochet associe a un node
                Interface::D3IllustrationNBracket $w $m $i
            } elseif  {[lsearch -exact $tags DRAW] != -1} {
                # ILLUSTRATION : OVAL RECTANGLE LINE ILLUSTRATION(symbol sur canvas)
                Interface::D3Illustration $w $m $i
            } elseif  {[lsearch -exact $tags ni] != -1} {
                # ILLUSTRATION : node illustration
                Interface::D3NodeIllustration $w $m $i
            }  elseif  {[lsearch -exact $tags SuperTreeM] != -1} {
                # SUPERTREE MATRICE ANNOTATION
                Interface::D3SuperTreeMatrice $w $m $i
            }  elseif  {[lsearch -exact $tags bitmap] != -1} {
                # BITMAP
                Interface::D3Bitmap $w $m $i
            }  elseif  {[lsearch -exact $tags  TXT] != -1} {
                # Free Text
                Interface::D3FreeText $w $m $i
            }   elseif  {[lsearch -exact $tags  SCA] != -1} {
                # scale
                Interface::D3Scale $w $m $i
            }   elseif  {[lsearch -exact $tags AnnotMatrix] != -1} {
                # AnnotMatrix
                Interface::D3AnnotMatrix $w $x $y $m $i
            }   elseif  {[lsearch -exact $tags Arc] != -1} {
                # Arc
                Interface::D3Arc $w $x $y $m $i
            } else {
                # ?
                $m add command -label "?" -command ""
            }
            
            
            #  $w find overlapping [expr $x -30] [expr $y - 30] [expr $x+30] [expr $y+30] ] == "" 
        
            
            
        } elseif {[$w gettags [$w find overlapping [expr $x -30] [expr $y - 30] [expr $x+30] [expr $y+30] ]] == "mousetool" } {
            # CANVAS mousetool
            Interface::D3Canvas $w $m $x $y
        } else {
            # TREE
            set id [$w find closest $x $y]
            set tags [$w gettags $id]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$t != ""} {
                Interface::D3Tree $w $m $t $x $y $tags
            }
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    #
    proc D3SuperTreeMatrice {w m i} {
        set tags [$w gettags $i]
        set i  [lindex $tags [lsearch -glob $tags ST*]]
        
        $m add command -label [string toupper "Presence/Absence SuperTree:"]
        $m add separator
        $m add command -label "Delete" -command "$w delete $i"
    }
    ### D3 Canvas
    proc D3Canvas {w m x y} {
        global S
        set f Interface::D3ActionCanvas
        if {[winfo class [winfo parent $w]] == "Toplevel" } {
            $m add command -label "Document: [wm title [winfo parent $w]]"  -command ""
        } {$m add command -label "TreeDyn"  -command ""}
        set nb [llength $S($w,t)]
        set ms0 [format "%s%s" $m .trees]
        menu $ms0 -tearoff 0
        $m add cascade -label [string toupper "$nb Tree(s)..."]  -menu $ms0
        foreach tree $S($w,t) {
            set msx [format "%s%s%s" $m . [Tools::GenId]]
            menu $msx -tearoff 0
            $ms0 add cascade -label $S($tree,tit) -menu $msx
            Interface::D3Tree $w $msx  $tree $x $y {}
        }
        $m add separator
        ####
        $m add command -label "Add Tree(s)..." -command "$f $w inserttree"
        if {$S(cp) != ""} {
            $m add command -label "Paste" -command "$f $w paste"
        } else  {
            $m add command -label "Paste" -command "$f $w paste"\
                    -state disabled
        }
        $m add command -label "Import GIF file..." -command "$f $w insertback"
        $m add separator
        $m add command -label "Select Trees (exclusif)" -command "Selection::TreeTargetUnSelectAll ; Selection::TreeTargetSelectAllperW2 $w"
        $m add command -label "Add Trees to selection (inclusif)" -command "Selection::TreeTargetSelectAllperW2 $w"
        $m add command -label "Unselect Trees" -command "Selection::TreeTargetUnSelectAllperW2 $w"
        $m add separator
        $m add command -label "Row(s) x Column(s) Trees Organisation..." -command "Navigation::ReorganizeAll $w"
        $m add command -label "Resize Trees..." -command "Navigation::ResizeAll $w"
        $m add command -label "Fit To Contents" -command "$f $w fitocontent"
        $m add separator
        $m add command -label "Update Canvas Background Color" -command "$f $w canvasbgcolor"
        $m add command -label "Update Tree(s) Foreground Color" -command "$f $w treefgcolor"
        $m add command -label "Update Leaves  Font" -command "$f $w treefont"
        $m add separator
        $m add command -label "Display/Hide Leaves" -command "$f $w displayleaves"
        $m add command -label "Add Tree(s) Names" -command "$f $w treenames"
        
        # $m add separator
        # set ms6 [format "%s%s" $m .remove]
        # menu $ms6 -tearoff 0
        # $m add cascade -label "Remove" -menu $ms6
        
        $m add separator
        set ms7 [format "%s%s" $m .conformation]
        menu $ms7 -tearoff 0
        $m add cascade -label "Conformation" -menu $ms7
        $ms7 add command -label "With Branch Length:"
        $ms7 add command -label "Rectangular"  -command "$f $w PhyNJ"
        $ms7 add command -label "Circular"  -command "$f $w PhyCir1"
        $ms7 add separator
        $ms7 add command -label "Without Branch Length:"
        $ms7 add command -label "Rectangular"   -command "$f $w ClaRec"
        $ms7 add command -label "Circular (External)"  -command "$f $w ClaCir1"
        #$ms7 add command -label "Circular (External)"  -command "$f $w ClaCir2"
        $ms7 add command -label "Circular (Internal)"  -command "$f $w ClaCir3"
        $m add separator
        set ms5 [format "%s%s" $m .reset]
        menu $ms5 -tearoff 0
        $m add cascade -label "Reset/Remove" -menu $ms5
        $ms5 add command -label "Subtree(s) Background Color" -command "$f $w GraVarInitBgSubTree"
        $ms5 add command -label "Subtree(s) Foreground Color" -command "$f $w GraVarInitFgTree"
        $ms5 add command -label "Subtree(s) Line Width" -command "$f $w GraVarInitLineWidth"
        $ms5 add command -label "Subtree(s) Line Dash" -command "$f $w GraVarInitLineDash"
        $ms5 add command -label "Leaves Background Color" -command "$f $w GraVarInitBgLeaf"
        $ms5 add command -label "Leaves Foreground Color" -command "$f $w GraVarInitFgLeaf"
        $ms5 add command -label "Leaves Font" -command "$f $w GraVarInitFont"
        $ms5 add command -label "All" -command "$f $w NodeGraVarInit"
        $ms5 add separator
        $ms5 add command -label "Remove Annotations" -command "$f $w removeallannotation"
        $ms5 add command -label "Remove Illustrations"  -command ""
        $m add separator
        $m add command -label "Export as Newick strings" -command "$f $w savenewickfile"
        $m add command -label "Export as Leaves lists" -command "$f $w saveleavefile"
        
        return $m
    }
    proc D3DBV {w m i } {
        global S
        $m add command -label "X: annotation"
        $m add separator
        $m add command -label "Update Color" -command "$w itemconfigure $i -fill $S(col)"
        $m add command -label "Update Font" -command "$w itemconfigure $i -font [list $S(gfo)]"
        $m add separator
        $m add command -label Delete -command "$w delete $i"
        $m add command -label "Delete all" -command "$w delete DBL"
    }
    proc D3DBL {w m i} {
        global S
        $m add command -label ":X annotation"
        $m add separator
        $m add command -label "Update Color" -command "$w itemconfigure $i -fill $S(col)"
        $m add command -label "Update Font" -command "$w itemconfigure $i -font [list $S(gfo)]"
        $m add separator
        $m add command -label Delete -command "$w delete $i"
        $m add command -label "Delete all" -command "$w delete DBL"
    }
    ### D3 Tree
    proc D3Tree {w m t x y tags} {
        global S B
        if {$S($t,tit) != ""} {
            $m add command -label "Tree: $S($t,tit)" -command "Selection::ShwoTree $t"
        } else  {
            $m add command -label Tree -command "Selection::ShwoTree $t"
        }
        set f Interface::D3ActionTree
        $m add separator
        $m add command -label "Copy" -command "$f $w $t copy"
        $m add command -label "Duplicate" -command "ImportExport::CopyTree2 $w $t $t $x $y"
        $m add command -label "Copy & Paste as New Window" -command "ImportExport::CopyTree $t $t"
        $m add command -label "Resize..." -command "Navigation::ResizeOne $w $t"
        $m add command -label "Fit To Window" -command "$f $w $t fittowindow"
        $m add separator
        $m add command -label "Global Navigator" -command "$f  $w $t globa"
        $m add command -label "Local Navigator" -command "$f  $w $t loca"
        $m add separator
        $m add command -label "Target Tree (exclusif)" -command "Selection::TreeTargetUnSelectAll ; set S($t,tar) 1"
        $m add command -label "Add Tree to Selection" -command "set S($t,tar) 1"
        $m add command -label "UnTarget Tree" -command "set S($t,tar) 0"
        $m add separator
        $m add command -label "Foreground Color by Leaves level" -command "$f $w $t color2"
        $m add command -label "Foreground Color by Leaves Number" -command "$f $w $t colornLL"
        $m add command -label "Foreground Color by Depth levels" -command "$f $w $t colorn"
        $m add separator
        set ms5 [format "%s%s" $m .reset]
        menu $ms5 -tearoff 0
        $m add cascade -label "Reset/Remove" -menu $ms5
        $ms5 add command -label "Reset Subtree(s) Background Color" -command "Figuration::GraVarInitBgSubTree $w $t"
        $ms5 add command -label "Reset Subtree(s) Foreground Color" -command "Figuration::GraVarInitFgTree $w $t"
        $ms5 add command -label "Reset Subtree(s) Line Width" -command "Figuration::GraVarInitLineWidth $w $t"
        $ms5 add command -label "Reset Subtree(s) Line Dash" -command "Figuration::GraVarInitLineDash $w $t"
        $ms5 add command -label "Reset Leaves Background Color" -command "Figuration::GraVarInitBgLeaf $w $t"
        $ms5 add command -label "Reset Leaves Foreground Color" -command "Figuration::GraVarInitFgLeaf $w $t"
        $ms5 add command -label "Reset Leaves Font" -command "Figuration::GraVarInitFont $w $t"
        $ms5 add command -label "Reset all" -command "$f $w $t reset"
        $ms5 add separator
        $ms5 add command -label "Remove Annotations" -command "$f $w $t removeallannotation"
        $ms5 add command -label "Remove Illustrations"  -command "S($t,LabelMatrixBase) 0 ; $w delete AM$t"
        $m add separator
        $m add command -label "Name Tree" -command "$f $w $t renametree"
        $m add command -label "Display Leaves On/Off" -command "$f $w $t displayeunames"
        $m add command -label "Display Newick Annotations" -command "Annotation::ANPanelBL"
        set ms8 [format "%s%s" $m .textnew]
        menu $ms8 -tearoff 0
        $m add cascade -label "Scale, date..." -menu $ms8
        $ms8 add command -label "Scale" -command "Annotation::AnnotateBuiltIn $w $t $x $y Scale"
        $ms8 add command -label "Scale %" -command "Annotation::AnnotateBuiltIn $w $t $x $y Scale100"
        $ms8 add command -label "Date" -command "Annotation::AnnotateBuiltIn $w $t $x $y Date"
        $ms8 add command -label "File" -command "Annotation::AnnotateBuiltIn $w $t $x $y File"
        $m add separator
        set ms7 [format "%s%s" $m .conformation]
        menu $ms7 -tearoff 0
        $m add cascade -label "Conformation" -menu $ms7
        $ms7 add command -label "With Branch Length:"
        $ms7 add command -label "Rectangular"  -command "set S($t,type) PhyNJ ; $f $w  $t PhyNJ"
        $ms7 add command -label "Circular"  -command "set S($t,type) PhyCir1 ; $f  $w  $t PhyCir1"
        $ms7 add command -label "Radial"  -command "set S($t,type) PhyRad ; $f  $w  $t PhyRad"
        $ms7 add separator
        $ms7 add command -label "Without Branch Length:"
        $ms7 add command -label "Rectangular"   -command "set S($t,type) ClaRec ; $f  $w  $t ClaRec"
        $ms7 add command -label "Circular (External)"  -command "set S($t,type) ClaCir1  ;  $f  $w  $t ClaCir1"
        #$ms7 add command -label "Circular (External)"  -command "set S($t,type) ClaCir2 ; $f $w $t  ClaCir2"
        $ms7 add command -label "Circular (Internal)"  -command "set S($t,type) ClaCir3 ;  $f $w $t ClaCir3"
        $ms7 add separator
        if  { [string match *Cir* $S($t,type)] != 1}  {
            $ms7 add command -label "Mirror" -command "$f $w  $t mirror"
        } else  {
            $ms7 add command -label "Mirror" -command "$f $w  $t mirror" -state disabled
        }
        $ms7 add separator
        $ms7 add command -label "Leaves Anchor W"  -command "$f $w $t anchorw"
        $ms7 add command -label "Leaves Anchor E"  -command "$f $w $t anchore"
        if {$S($t,type) == "ClaCir1" || $S($t,type) == "ClaCir2"} {
            $ms7 add command -label "Display Leaves Radial" -command "$f $w $t displayeuRadial"
        }
        $m add separator
        $m add command -label "Export as Newick string" -command "$f $w $t savenewickfile"
        $m add command -label "Export as Leaves list" -command "$f $w $t saveleavefile"
        $m add separator
        $m add command -label "Delete tree" -command "$f $w $t cut"
        
        return $m
    }
    ### NODE d'un Tree
    proc D3Node {w m i x y} {
        global S T
        set tags [$w gettags $i]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set f Interface::D3ActionNode
        $m add command -label "Node"
        $m add separator
        $m add command -label "Branch Length : $T($t,dbl,$n)" -command ""
        $m add separator
        Labelisation::MenuUEfromNode $w $m $t $n
        $m add separator
        $m add command -label "Copy" -command "ImportExport::CoPy $w node $t $n"
        $m add command -label "Duplicate" -command "ImportExport::CopyTree2 $w $t $n $x $y"
        $m add command -label "Copy & Paste as New Window" -command "ImportExport::CopyTree $t $n"
        $m add separator
        $m add command -label "Display Leaves On/Off" -command "$f $w $t $n displayeunames"
        $m add command -label "Display x: On/Off" -command "$f $w $t $n displaydbl"
        $m add command -label "Display :x On/Off" -command "$f $w $t $n displaydbv"
        $m add separator
        $m add command -label "Swap"  -command "$f $w $t $n swap"
        $m add command -label "Outgroup"  -command "$f $w $t $n outgroup"
        $m add command -label "Shrink"  -command ""
        $m add command -label "Collapse"  -command ""
        $m add separator
        $m add command -label "Export as Newick string" -command "$f $w $t $n savenewickfile"
        $m add command -label "Export as Leaves list" -command "$f $w $t $n saveleavefile"
        $m add command -label "Export Leaves list to Clipboard" -command "$f $w $t $n exportll2clipboard"
        $m add separator
        set ms3 [format "%s%s" $m .reset]
        menu $ms3 -tearoff 0
        $m add cascade -label "Reset/Remove" -menu $ms3
        $ms3 add command -label "Reset Node Background Color" -command "Figuration::NodeColorBgSubTreeRemove $t $n"
        $ms3 add command -label "Reset Node Foreground Color" -command "Figuration::GraVarInitFgTree $w $t [format "%s%s" $n *]"
        $ms3 add command -label "Reset Node Line Width" -command "Figuration::GraVarInitLineWidth $w $t [format "%s%s" $n *]"
        $ms3 add command -label "Reset Node Line Dash" -command "Figuration::GraVarInitLineDash $w $t [format "%s%s" $n *]"
        $ms3 add command -label "Reset Leaves Background Color" -command "Figuration::NodeColorBgLeafRemove $t $n"
        $ms3 add command -label "Reset Leaves Foreground Color" -command "Figuration::GraVarInitFgLeaf $w $t [format "%s%s" $n *]"
        $ms3 add command -label "Reset Leaves Font" -command "Figuration::GraVarInitFont $w $t [format "%s%s" $n *]"
        $ms3 add command -label "Reset all" -command "Figuration::GraVarInitAll $w $t $n"
        $ms3 add separator
        $ms3 add command -label "Remove Annotations"  -command ""
        $ms3 add command -label "Remove Illustrations"  -command ""
        #$m add separator
        #$m add command -label "Catch Color" -command ""
        # INFOS
        # NAVIGATION
        #set ms7 [format "%s%s" $m .navigation]
        #menu $ms7 -tearoff 0
        #$m add cascade -label "Navigation" -menu $ms7 -image PANnavigation  -compound left
        # FIGURATION
        #set ms3 [format "%s%s" $m .figuration]
        #menu $ms3 -tearoff 0 -background  LightSteelBlue1
        #$m add cascade -label "Figuration" -menu $ms3 -image PANfiguration  -compound left
        #$ms3 add command -label "Node Update Background Color" -command "Figuration::NodeColorBgSubTreeRemove $t $n"
        #$ms3 add command -label "Node Update Foreground Color" -command "Figuration::GraVarInitFgTree $w $t [format "%s%s" $n *]"
        #$ms3 add command -label "Node Line Width +" -command "Figuration::GraVarInitLineWidth $w $t [format "%s%s" $n *]"
        #$ms3 add command -label "Node Line Width -" -command "Figuration::GraVarInitLineWidth $w $t [format "%s%s" $n *]"
        #$ms3 add command -label "Node Line Dash On/Off" -command "Figuration::GraVarInitLineDash $w $t [format "%s%s" $n *]"
        #$ms3 add command -label "Leaves Update Background Color" -command "Figuration::NodeColorBgLeafRemove $t $n"
        #$ms3 add command -label "Leaves Update Foreground Color" -command "Figuration::GraVarInitFgLeaf $w $t [format "%s%s" $n *]"
        #$ms3 add command -label "Leaves Update Font" -command "Figuration::GraVarInitFont $w $t [format "%s%s" $n *]"
        #$ms3 add separator
        #set ms6 [format "%s%s" $m .annotation]
        #menu $ms6 -tearoff 0 -background  LightSteelBlue1
        #$ms6 add separator
        #$m add cascade -label "Annotation" -menu $ms6 -image PANannotation  -compound left
        #$ms6 add command -label "Add Node Annotation"  -command ""
        #$ms6 add command -label "Add Leaves Annotation"   -command ""
        # CONFORMATION
        #set ms4 [format "%s%s" $m .conformation]
        #menu $ms4 -tearoff 0 -background  LightSteelBlue1
        #$m add cascade -label "Conformation" -menu $ms4 -image PANconformation  -compound left
        #$ms4 add command -label "Swap"  -command "$f $w $t $n swap"
        #$ms4 add command -label "Outgroup"  -command "$f $w $t $n outgroup"
        #$ms4 add command -label "Ladder Up"  -command ""
        #$ms4 add command -label "Ladder Down"  -command ""
        # ABSTRACTION
        #$m add separator
        #set ms5 [format "%s%s" $m .abstraction]
        #menu $ms5 -tearoff 0 -background  LightSteelBlue1
        #$m add cascade -label "Abstraction" -menu $ms5 -image PANabstraction  -compound left
        #$ms5 add command -label "Shrink"  -command ""
        #$ms5 add command -label "Collapse"  -command ""
        #$ms5 add command -label "Decompose" -command ""
        # IMPORT/EXPORT
        #set ms9 [format "%s%s" $m .insertion]
        #menu $ms9 -tearoff 0 -background  LightSteelBlue1
        #$m add cascade -label "Import/Export" -menu $ms9
    }
    ### LEAF
    proc D3Leaf {w m i} {
        $m configure
        $m add command -label "Leaf:"
        $m add separator
        $m add command -label "Update Font" -command "Interface::D3ActionLeaf $w $i upfont"
        $m add command -label "Update Foreground Color" -command "Interface::D3ActionLeaf $w $i upfgcolor"
        $m add command -label "Update Background Color" -command "Interface::D3ActionLeaf $w $i upbgcolor"
        $m add command -label "Reset Foreground Color" -command "Interface::D3ActionLeaf $w $i refgcolor"
        $m add command -label "Reset Background Color" -command "Interface::D3ActionLeaf $w $i rebgcolor"
    }
    #
    proc D3ActionLeaf {w i action} {
        global S T
        switch -exact $action {
            upfont  {
                set tags [$w gettags $i]
                set name [string trimleft \
                        [lindex $tags [lsearch -glob $tags EUL*]] EUL]
                set t [string range \
                        [lindex $tags [lsearch -glob $tags T*]] 1 end]
                Figuration::FontSetGlobal $t $T($t,ltc,$name) $S(gfo)
            }
            upfgcolor  {
                set tags [$w gettags $i]
                set name [string trimleft \
                        [lindex $tags [lsearch -glob $tags EUL*]] EUL]
                set t [string range \
                        [lindex $tags [lsearch -glob $tags T*]] 1 end]
                Figuration::NodeColorFgLeaf $t $T($t,ltc,$name) $S(col)
            }
            upbgcolor {
                set tags [$w gettags $i]
                set name [string trimleft \
                        [lindex $tags [lsearch -glob $tags EUL*]] EUL]
                set t [string range \
                        [lindex $tags [lsearch -glob $tags T*]] 1 end]
                Figuration::NodeColorBgLeaf $t $T($t,ltc,$name)
            }
            refgcolor {
                set tags [$w gettags $i]
                set name [string trimleft \
                        [lindex $tags [lsearch -glob $tags EUL*]] EUL]
                set t [string range \
                        [lindex $tags [lsearch -glob $tags T*]] 1 end]
                Figuration::GraVarInitFgLeaf $w $t $T($t,ltc,$name)
            }
            rebgcolor {
                set tags [$w gettags $i]
                set name [string trimleft \
                        [lindex $tags [lsearch -glob $tags EUL*]] EUL]
                set t [string range \
                        [lindex $tags [lsearch -glob $tags T*]] 1 end]
                Figuration::NodeColorBgLeafRemove $t $T($t,ltc,$name)
            }
        }
    }
    ### QUERYNODE
    proc D3QueryNode {w m i} {
        global T B S
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags QYN*]] ¶] end]
        # titre complet avec fichier de label
        $m add command -label $B(QYNqry,$id) -command ""
        # Tree Target
        $m add command -label "Target: $S($B(QYNtre,$id),tit)" -command ""
        $m add separator
        # cascade EU issue de la requete
        set nb1 [llength $B(QYNres,$id)]
        set nb2 [llength $T($B(QYNtre,$id),ue_lab)]
        set p100 [expr round( double($nb1) / double($nb2) * 100.0)]
        set ms [format "%s%s" $m .result]
        menu $ms -tearoff 0
        $m add cascade -label "[format "%s%s%s" ~ $p100 %] Matching EUs ($nb1/$nb2)..." -menu $ms
        set L {}
        foreach e $B(QYNres,$id) {
            lappend L [string toupper [string range $e 0 0]]
        }
        set L [Tools::DelRep $L]
        foreach e $L {
            set ms2 [format "%s%s%s" $ms .m [string tolower $e]]
            $ms add cascade -label $e -menu $ms2
            menu $ms2 -tearoff 0
            foreach r $B(QYNres,$id)  {
                if {[string toupper [string range $r 0 0]] == $e} {
                    $ms2 add command -label $r -command "Identification::LocalisationEU $w $B(QYNtre,$id) $r"
                }
            }
        }
        $m add separator
        $m add command -label "Query" -command "Annotation::QueryNodeLocalisation $id"
        $m add separator
        $m add command -label "Update Font" -command "Annotation::QueryNodeUpdateFont $w $id"
        $m add command -label "Update Color" -command "Annotation::QueryNodeUpdateColor $w $id"
        $m add separator
        $m add command -label Delete -command "Annotation::QueryNodeDelete $w $id"
    }
    #
    proc D3Legend {w m i} {
        set tags [$w gettags $i]
        set id [lindex $tags [lsearch -glob $tags LE*]]
        $m add command -label [string toupper "Legend Annotation:"]
        $m add separator
        $m add command -label "Update Font" -command "Interface::D3ActionLegend $w $id updatefont"
        $m add separator
        $m add command -label "Delete" -command "Interface::D3ActionLegend $w $id delete"
    }
    
    #
    proc D3BgTree {w m i} {
        $m add command -label [string toupper "Item Background Tree :"]
        $m add separator
        $m add command -label "Update Color" -command "Interface::D3ActionBgTree $w $i updatecolor"
        $m add command -label "Update Stipple" -command "Interface::D3ActionBgTree $w $i updatestipple"
        $m add separator
        $m add command -label "Shape switch to type I" -command "Interface::D3ActionBgTree $w $i shapeswitch1"
        $m add command -label "Shape switch to type II" -command "Interface::D3ActionBgTree $w $i shapeswitch2"
        $m add command -label "Shape switch to type III" -command "Interface::D3ActionBgTree $w $i shapeswitch3"
        $m add command -label "Shape switch to type IV" -command "Interface::D3ActionBgTree $w $i shapeswitch4"
        $m add command -label "Shape switch to type V" -command "Interface::D3ActionBgTree $w $i shapeswitch5"
        $m add separator
        $m add command -label Background -command "$w lower $i"
        $m add command -label Foreground -command "$w raise $i"
        $m add separator
        $m add command -label "Delete" -command "Interface::D3ActionBgTree $w $i delete"
    }
    #
    proc D3Shape {w m i} {
        global S
        $m add command -label [string toupper "Shape:"]
        $m add separator
        $m add command -label "Update Color" -command "$w itemconfigure $i -fill $S(col)"
        $m add command -label "Update Stipple" -command "$w itemconfigure $i -stipple @[file join + stipple $S(stipple)]"
        $m add separator
        $m add command -label "Delete" -command "Annotation::BLLDelete $w $i"
    }
    #
    proc D3Plot {w m i} {
        global S
        $m add command -label [string toupper "Scatterplot:"]
        $m add separator
        $m add command -label "Update Color" -command "$w itemconfigure $i -fill $S(col)"
        $m add separator
        $m add command -label "Delete" -command "Annotation::BLLDelete $w $i"
    }
    #
    proc D3BgLeaf {w m i} {
        $m add command -label [string toupper "Item Background Leaf"]
        $m add separator
        $m add command -label "Update Color" -command "Interface::D3ActionBgLeaf $w $i updatecolor"
        $m add separator
        $m add command -label "Delete" -command "Interface::D3ActionBgLeaf $w $i delete"
    }
    #
    proc D3ActionBgLeaf {w i command} {
        switch $command {
            updatecolor {}
            delete {}
        }
    }
    ### CONNECTOR
    proc D3Connector {w m i x y} {
        global B
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags Connect¶*]] ¶] end]
        if {$B(CONnot,$id) != {}} {
            $m add command -label [string toupper "Node Network # $B(CONnot,$id)"]
        } else  {
            $m add command -label [string toupper "Node Network"]
        }
        $m add separator
        $m add command -label "Node Foreground Color" -command "Interface::D3ConnectorAction $w $id nodefgcolor"
        $m add command -label "Node Background Color" -command "Interface::D3ConnectorAction $w $id nodebgcolor"
        $m add command -label "Node Width Line +" -command "Interface::D3ConnectorAction $w $id widthline+"
        $m add command -label "Node Width Line -" -command "Interface::D3ConnectorAction $w $id widthline-"
        $m add command -label "Node Dash Line On" -command "Interface::D3ConnectorAction $w $id nodedashOn"
        $m add command -label "Node Dash Line Off" -command "Interface::D3ConnectorAction $w $id nodedashOff"
        $m add separator
        $m add command -label "Leaves Foreground Color" -command "Interface::D3ConnectorAction $w $id leaffgcolor"
        $m add command -label "Leaves Background Color" -command "Interface::D3ConnectorAction $w $id leafbgcolor"
        $m add command -label "Leaves Font" -command "Interface::D3ConnectorAction $w $id leaffontglob"
        $m add separator
        $m add command -label "Network Update Color" -command "Interface::D3ConnectorAction $w $id updatecolor"
        $m add command -label "Network Line Width +" -command "Interface::D3ConnectorAction $w $id linewidth+"
        $m add command -label "Network Line Width -" -command "Interface::D3ConnectorAction $w $id linewidth-"
        $m add command -label "Network Line Dash On/Off" -command "Interface::D3ConnectorAction $w $id linedash"
        $m add command -label "Network Annotate" -command "Interface::D3ConnectorAction $w $id annotate"
        $m add command -label "Network Restart Description" -command "Reflection::ReStartNodeNetwork $w $id"
        $m add command -label "Network Iconify" -command "Reflection::ConnectorIconify $w $id $x $y"
        set ms [format "%s%s" $m .merge]
        menu $ms -tearoff 0
        $m add cascade -label "Network Merging" -menu $ms
        $ms configure -postcommand "Interface::UpdateMergingNetwork $w $ms $id"
        $m add separator
        $m add command -label "Delete Network" -command "Interface::D3ConnectorAction $w $id delete"
    }
    ### CONNECTOR
    proc D3ConnectorIcon {w m i x y} {
        global B
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags ConIconTag¶*]] ¶] end]
        if {$B(CONnot,$id) != {}} {
            $m add command -label [string toupper "Node Network # $B(CONnot,$id)"]
        } else  {
            $m add command -label [string toupper "Node Network"]
        }
        $m add separator
        $m add command -label "Node Foreground Color" -command "Interface::D3ConnectorAction $w $id nodefgcolor"
        $m add command -label "Node Background Color" -command "Interface::D3ConnectorAction $w $id nodebgcolor"
        $m add command -label "Node Width Line +" -command "Interface::D3ConnectorAction $w $id widthline+"
        $m add command -label "Node Width Line -" -command "Interface::D3ConnectorAction $w $id widthline-"
        $m add command -label "Node Dash Line On" -command "Interface::D3ConnectorAction $w $id nodedashOn"
        $m add command -label "Node Dash Line Off" -command "Interface::D3ConnectorAction $w $id nodedashOff"
        $m add separator
        $m add command -label "Leaves Foreground Color" -command "Interface::D3ConnectorAction $w $id leaffgcolor"
        $m add command -label "Leaves Background Color" -command "Interface::D3ConnectorAction $w $id leafbgcolor"
        $m add command -label "Leaves Font" -command "Interface::D3ConnectorAction $w $id leaffontglob"
        $m add separator
        $m add command -label "Network Update Color" -command "Interface::D3ConnectorAction $w $id updatecolor"
        $m add command -label "Network Update Font" -command "Interface::D3ConnectorAction $w $id updatefont"
        $m add command -label "Network Line Width +" -command "Interface::D3ConnectorAction $w $id linewidth+"
        $m add command -label "Network Line Width -" -command "Interface::D3ConnectorAction $w $id linewidth-"
        $m add command -label "Network Line Dash On/Off" -command "Interface::D3ConnectorAction $w $id linedash"
        $m add command -label "Network Annotate" -command "Interface::D3ConnectorAction $w $id annotate"
        $m add command -label "Network Restart Description" -command "Reflection::ReStartNodeNetwork $w $id"
        $m add command -label "Network Display On/Off" -command "Reflection::ConnectorIconifyONOFF $w $id"
        $m add command -label "Network DeIconify" -command "Reflection::ConnectorIconRemove $w $id"
        $m add separator
        set ms [format "%s%s" $m .merge]
        menu $ms -tearoff 0
        $m add cascade -label "Network Merging" -menu $ms
        $ms configure -postcommand "Interface::UpdateMergingNetwork $w $ms $id"
        $m add separator
        $m add command -label "Delete Network" -command "Interface::D3ConnectorAction $w $id delete"
    }
    # update menu merging node network
    proc UpdateMergingNetwork {w m idsource} {
        global S B
        set connectA [$w find withtag Connect]
        set connectB [$w find withtag [list ConnectIcon && line]]
        set lid {}
        foreach i $connectA {
            set tags [$w gettags $i]
            set idi [lindex [split [lindex $tags [lsearch -glob $tags Connect¶*]] ¶] end]
            if {[lsearch $lid $idi] == -1} {lappend lid $i $idi}
        }
        foreach i $connectB {
            set tags [$w gettags $i]
            set idi [lindex [split [lindex $tags [lsearch -glob $tags ConIconTag¶*]] ¶] end]
            if {[lsearch $lid $idi] == -1} {lappend lid $i $idi}
        }
        # ajout command menu
        set lAll {}
        foreach {i idi} $lid {
            if {$idi != $idsource} {
                # identification du node network par la couleur, voir plus tard avec note
                set c [lindex [$w itemconfigure $i -fill] end]
                lappend lAll $idi
                $m add command -label $B(CONnot,$idi) -foreground $c -command "Reflection::ConnectorMerge $w $idsource [list $idi]"
            }
        }
        if {[llength $lid] >= 3} {
            $m add command -label "All"  -command "Reflection::ConnectorMerge $w $idsource [list $lAll]"
        }
    }
    ### CONNECTOR ACTION
    proc D3ConnectorAction  {w id command} {
        global B S
        switch -exact $command  {
            nodefgcolor {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    Figuration::NodeColorFgTree $t $n $S(col)
                }
            }
            nodebgcolor {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    Figuration::NodeColorBgSubTree $t $n
                }
            }
            widthline+ {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    Figuration::NodeLineWidth $t $n +
                }
            }
            widthline- {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    Figuration::NodeLineWidth $t $n -
                }
            }
            nodedashOn {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    Figuration::NodeLineDash $t $n 1
                }
            }
            nodedashOff {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    Figuration::NodeLineDash $t $n 0
                }
            }
            leaffgcolor {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    Figuration::NodeColorFgLeaf $t $n $S(col)
                }
            }
            leafbgcolor {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    puts "tags $tags"
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    puts "t $t"
                    Figuration::NodeColorBgLeaf $t $n
                }
            }
            leaffontglob {
                foreach n $B(CONnod,$id) {
                    set tags [$w gettags $n]
                    set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
                    Figuration::FontSetGlobal $t $n $S(gfo)
                }
            }
            updatecolor {
                set j [format "%s%s%s"  Connect ¶ $id ]
                $w itemconfigure $j -fill $S(col)
                
                set ConIconTag [format "%s%s%s" ConIconTag ¶ $id]
                $w itemconfigure $ConIconTag -fill $S(col)
            }
            updatefont {
                set ConIconTag [format "%s%s%s" ConIconTag ¶ $id]
                set id [$w find withtag [list $ConIconTag && text]]
                $w itemconfigure $id -font $S(gfo)
                
            }
            linewidth+ {
                set j [format "%s%s%s"  Connect ¶ $id ]
                set width_line [lindex [$w itemconfigure $j -width] end]
                set new_wl [expr  abs($width_line + 1)]
                $w itemconfigure $j -width $new_wl
                # mise a jour icone
                set ConIconTag [format "%s%s%s" ConIconTag ¶ $id]
                set id [$w find withtag [list $ConIconTag && line]]
                $w itemconfigure $id -width $new_wl
                
            }
            linewidth- {
                set j [format "%s%s%s"  Connect ¶ $id ]
                set width_line [lindex [$w itemconfigure $j -width] end]
                set new_wl [expr  abs($width_line - 1)]
                $w itemconfigure $j -width $new_wl
                # mise a jour icone
                set ConIconTag [format "%s%s%s" ConIconTag ¶ $id]
                set id [$w find withtag [list $ConIconTag && line]]
                $w itemconfigure $id -width $new_wl
            }
            linedash {
                set j [format "%s%s%s"  Connect ¶ $id ]
                set dash_line [lindex [$w itemconfigure $j -dash] end]
                if  {$dash_line == {}} {
                    set dash_line {2 2}
                } else  {
                    set dash_line {}
                }
                $w itemconfigure $j -dash $dash_line
                # mise a jour icone
                set ConIconTag [format "%s%s%s" ConIconTag ¶ $id]
                set id [$w find withtag [list $ConIconTag && line]]
                $w itemconfigure $id -dash $dash_line
            }
            annotate {
                Reflection::ConnectNote $w $id
            }
            configuration {
            }
            delete {
                Reflection::ConnectorDelete $w $id
            }
        }
    }
    ###
    proc D3AnnotMatrix  {w x y m i} {
        global S
        set tags [$w gettags $i]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        # serie
        set serie [lindex $tags [lsearch -glob $tags COL*]]
        #
        set maq  [lindex $tags [lsearch -glob $tags MA*]]
        set q [lindex [split $maq ¶] end]
        #
        set ILL  [lindex $tags [lsearch -glob $tags ILL*]]
        $m add command -label "Annotation $q" -command ""
        if {$ILL != ""} {
            # on est sur une illustration
            $m add command -label "Update Symbol (annotation)" -command "$w itemconfigure $i -font [list $S(ill-fon)]"
            $m add command -label "Update Symbols family (serie)" -command "Annotation::ANannillcol $w $x $y"
            $m add command -label "Update Symbols (serie)" -command "Annotation::ANannillcar $w $x $y"
            $m add command -label "Update Color (annotation)" -command "$w itemconfigure $i -fill $S(col)"
            $m add command -label "Update Color (list)" -command "Annotation::ANannfgcol $w $x $y"
        } else  {
            $m add separator
            # on est pas sur une illustration: ajout update font/color/etc
            $m add command -label "Update Font (annotation)" -command "$w itemconfigure $i -font [list $S(gfo)]"
            $m add command -label "Update Font (serie)" -command "Annotation::ANannfocol $w $x $y"
            $m add command -label "Update Color (annotation)" -command "$w itemconfigure $i -fill $S(col)"
            $m add command -label "Update Color (serie)" -command "Annotation::ANannfgcol $w $x $y"
            $m add command -label "Row & Col" -command "Annotation::ANannRowCol $w $x $y"
        }
        $m add separator
        $m add command -label "Delete this annotation" -command "$w delete $i"
        $m add command -label "Delete serie" -command "$w delete $serie"
        $m add command -label "Delete all" -command "set S($t,LabelMatrixBase) 0 ; $w delete AM$t"
    }
    #
    proc D3Arc  {w x y m i} {
        global S
        set tags [$w gettags $i]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set beam [lindex $tags [lsearch -glob $tags COL*]]
        set arcu [split [lindex $tags [lsearch -glob $tags ARCU*]] ¶]
        set lfrom [lindex $arcu end-1]
        set lto [lindex $arcu end]
        $m add command -label "Arc $lfrom -> $lto" -command ""
        $m add separator
        $m add command -label "Update Color" -command "$w itemconfigure $i -fill $S(col)"
        $m add command -label "Update Color (beam)" -command "$w itemconfigure $beam -fill $S(col)"
        $m add separator
        $m add command -label "Delete" -command "$w delete $i"
        $m add command -label "Delete (beam)" -command "$w delete $beam"
        $m add command -label "Delete all" -command "$w delete Arc$t"
    }
    #
    proc D3ActionBgTree {w i command} {
        global S
        switch $command {
            updatecolor {Figuration::NodeColorBgSubTreeUpateColor $w $i $S(col)}
            updatestipple {Figuration::NodeColorBgSubTreeUpdateStipple $w $i}
            shapeswitch1 {Figuration::NodeColorBgSubTreeSwitch $w $i 1}
            shapeswitch2 {Figuration::NodeColorBgSubTreeSwitch $w $i 2}
            shapeswitch3 {Figuration::NodeColorBgSubTreeSwitch $w $i 3}
            shapeswitch4 {Figuration::NodeColorBgSubTreeSwitch $w $i 4}
            shapeswitch5 {Figuration::NodeColorBgSubTreeSwitch $w $i 5}
            delete {Figuration::NodeColorBgSubTreeDelete $w $i}
        }
    }
    #
    proc D3ActionLegend {w i command} {
        global S
        switch $command {
            delete {$w delete $i}
            updatefont {
                set li [$w find withtag [list $i && txt]]
                foreach i $li {
                    $w itemconfigure $i -font $S(gfo)
                }
            }
        }
    }
    ### SHRINKNODE
    proc D3ShrinkNode {w m i} {
        global T B S
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags SHN*]] ¶] end]
        set t $B(SHItre,$id)
        $m add command -label [string toupper "Shrink Node :"]
        $m add separator

        # cascade EU issue du node
        set leafs [Tools::NodeNoToLe $t $B(SHInod,$id)]
        set nb1 [llength $leafs]
        set nb2 [llength $T($t,ue_lab)]
        set p100 [expr round( double($nb1) / double($nb2) * 100.0)]
        set ms [format "%s%s" $m .result]
        menu $ms -tearoff 0
        $m add cascade -label "[format "%s%s%s" ~ $p100 %] Matching EUs ($nb1/$nb2)..." -menu $ms
        set L {}
        foreach e $leafs {
            lappend L [string toupper [string range $T($t,ctl,$e) 0 0]]
        }
        set L [Tools::DelRep $L]
        foreach e $L {
            set ms2 [format "%s%s%s" $ms .m [string tolower $e]]
            $ms add cascade -label $e -menu $ms2
            menu $ms2 -tearoff 0
            foreach r $leafs  {
                if {[string toupper [string range $T($t,ctl,$r) 0 0]] == $e} {
                    $ms2 add command -label $T($t,ctl,$r) -command ""
                }
            }
        }
        $m add separator
        $m add command -label "UnShrink" -command "Abstraction::ShrinkUn $w $t $id"
        $m add separator
        # appel aux fonctions de gestion des variables graphiques
        $m add command -label "Update Color" -command "Abstraction::ShrinkNodeUpdateColor $w $i"
        $m add command -label "Update Stipple" -command "Abstraction::ShrinkNodeUpdateStipple $w $i" 
    }
    ### BLL
    proc D3LabelNode {w m i} {
        global T B S
        # titre complet avec fichier de label
        $m add command -label Labels -command ""
        $m add separator
        # appel aux fonctions de gestion des variables graphiques
        $m add command -label "Update Font" -command "Annotation::BLLUpdateFont $w $i"
        $m add command -label "Update Color" -command "Annotation::BLLUpdateColor $w $i"
        $m add separator
        # delete
        $m add command -label Delete -command "Annotation::BLLDelete $w $i"
    }
    # BITMAP
    proc D3Bitmap {w m i} {
        $m add command -label Bitmap -command ""
        $m add separator
        $m add command -label Delete -command "$w delete $i"
    }
    # OVAL RECTANGLE LINE (objet de dessin)
    proc D3Illustration {w m i} {
        global S
        $m add command -label Illustration -command ""
        $m add separator
        $m add command -label "Update Color" -command "$w itemconfigure $i -fill $S(col) -outline $S(col)"
        $m add command -label "Update Stipple" -command "$w itemconfigure $i -stipple @[file join + stipple $S(stipple)]"
        $m add separator
        $m add command -label Lower -command "$w lower $i"
        $m add command -label Raise -command "$w raise $i"
        $m add separator
        $m add command -label Delete -command "$w delete $i"
    }
    # Illustration Crochet (objet de dessin)
    proc D3IllustrationBracket {w m i} {
        global S
        set tags [$w gettags $i]
        set id [lindex $tags [lsearch -glob $tags BKT*]]
        $m add command -label Illustration -command ""
        $m add separator
        $m add command -label "Update Color" -command "$w itemconfigure $id -fill $S(col)"
        $m add separator
        $m add command -label "Add Label" -command "Illustration::BracketAddLabel $w $i"
        $m add separator
        $m add command -label Delete -command "$w delete $id"
    }
    # Illustration Crochet (objet de dessin) associe a un subtree
    proc D3IllustrationNBracket {w m i} {
        global S
        set tags [$w gettags $i]
        set id [lindex $tags [lsearch -glob $tags NBKT*]]
        $m add command -label Illustration -command ""
        $m add separator
        $m add command -label "Update Text..." -command "Illustration::BracketNproperties $w $id text"
        $m add command -label "Update Color..." -command "Illustration::BracketNproperties $w $id color"
        $m add command -label "Update Stipple..." -command "Illustration::BracketNproperties $w $id stipple"
        $m add command -label "Update Font..." -command "Illustration::BracketNproperties $w $id font"
        $m add separator
        $m add command -label Delete -command "$w delete $id"
    }
    # NODE ILLUSTRATION
    proc D3NodeIllustration {w m i} {
        global S
        $m add command -label "Node Illustration" -command ""
        $m add separator
        $m add command -label Delete -command "$w delete $i"
    }
    # FREE TEXT
    proc D3FreeText {w m i} {
        global find S
        # titre complet avec fichier de label
        $m add command -label Note -command ""
        $m add separator
        # appel aux fonctions de gestion des variables graphiques
        $m add command -label "Update Font" -command "$w itemconfigure $i -font [list $S(gfo)]"
        $m add command -label "Update Color" -command "$w itemconfigure $i -fill $S(col)"
        $m add separator
        $m add command -label "Find..."  -command "Interface::Find ; set find(stringsearch) [$w itemcget $i -text]"
        $m add separator
        # delete
        $m add command -label Delete -command "$w delete $i"
    }
    # FREE TEXT
    proc D3Scale {w m i} {
        global S
        set tags [$w gettags $i]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        # titre complet avec fichier de label
        $m add command -label Scale -command ""
        $m add separator
        # appel aux fonctions de gestion des variables graphiques
        $m add command -label "Update Font" -command "Interface::ScaleUpdateFont $w $t"
        $m add command -label "Update Color" -command "Interface::ScaleUpdateColor $w $t"
        $m add separator
        # delete
        $m add command -label Delete -command "Interface::ScaleDelete $w $t"
    }
    proc ScaleDelete  {w t} {
        set items [$w find withtag [list SCA && T$t]]
        foreach it $items {
            $w delete $it
        }
    }
    proc ScaleUpdateColor  {w t} {
        global S
        set items [$w find withtag [list SCA && T$t]]
        foreach it $items {
            $w itemconfigure $it -fill $S(col)
        }
    }
    proc ScaleUpdateFont  {w t} {
        global S
        set items [$w find withtag [list SCA && T$t]]
        foreach it $items {
            #test si c du text
            if {[$w type $it] == "text"} {
                $w itemconfigure $it -font [list $S(gfo)]
            }
        }
    }
    ### D3 Action CANVAS
    proc D3ActionCanvas  {w command} {
        global S T B
        switch $command {
            save - saveas  {ImportExport::draw_save $w $command
            }
            savenewickfile {
                set typelist {
                    {"Text File" {".nwk"} }
                    {"All Files" {*}}
                }
                set file [tk_getSaveFile -initialdir $S(userDIR)  -defaultextension ".nwk" \
                        -filetypes $typelist -title "Save Tree(s) as Newick strings list..."]
                if {$file != ""} {set S(userDIR) [file dirname $file]}
                if {$file != ""} {
                    set fid [open $file w]
                    foreach ti $S($w,t) {
                        puts $fid $T($ti,nwk,$ti)
                        if {[string range $T($ti,nwk,$ti) end end] != ";"} {puts $fid ";"}
                    }
                    close $fid
                }
            }
            saveleavefile {
                set typelist {
                    {"Text File" {".txt"} }
                    {"All Files" {*}}
                }
                set file [tk_getSaveFile -initialdir $S(userDIR)  -defaultextension ".txt" \
                        -filetypes $typelist -title "Save Leaves as a text file..."]
                if {$file != ""} {set S(userDIR) [file dirname $file]}
                if {$file != ""} {
                    set fid [open $file w]
                    set ll {}
                    foreach ti $S($w,t) {
                        foreach l $T($ti,ue_lab) {
                            if {[lsearch -exact $ll $l] == -1} {lappend ll $l}
                        }
                    }
                    foreach l [lsort -dictionary $ll] {
                        puts $fid $l
                    }
                    close $fid
                }
            }
            export {ImportExport::ExportFile $w}
            copy {ImportExport::CoPy $w canvas nil nil}
            paste {ImportExport::Paste $w}
            print {Package::Printer::print_widget $w all ?}
            inserttree {
                set S(MultiImportTAR) $w
                ImportExport::MIimport
                set S(MultiImportTAR) new
            }
            fgshareN {
                set ll {}
                foreach ti $S($w,t) {
                    lappend ll $T($ti,ue_lab)
                }
                set intersection [Tools::operatorANDll $ll]
                foreach ti $S($w,t) {
                    set peres  [Operation::FindFatherNode $ti $intersection]
                    foreach e $peres {Figuration::NodeColorFgTree $ti $e $S(col)}
                }
            }
            fgunshareN {
                set ll {}
                foreach ti $S($w,t) {
                    lappend ll $T($ti,ue_lab)
                }
                set intersection [Tools::operatorANDll $ll]
                foreach ti $S($w,t) {
                    # on recupere pour chaque arbre la liste des feuilles qui ne sont pas ds intersection
                    set llspec [Tools::SousL  $T($ti,ue_lab) $intersection]
                    set peres  [Operation::FindFatherNode $ti $llspec]
                    foreach e $peres {Figuration::NodeColorFgTree $ti $e $S(col)}
                }
            }
            fgshareL {
                set ll {}
                foreach ti $S($w,t) {
                    lappend ll $T($ti,ue_lab)
                }
                set intersection [Tools::operatorANDll $ll]
                foreach ti $S($w,t) {
                    Figuration::EUColorFgLeaf $ti $intersection $S(col)
                }
            }
            fgunshareL {
                set ll {}
                foreach ti $S($w,t) {
                    lappend ll $T($ti,ue_lab)
                }
                set intersection [Tools::operatorANDll $ll]
                foreach ti $S($w,t) {
                    set llspec [Tools::SousL  $T($ti,ue_lab) $intersection]
                    Figuration::EUColorFgLeaf $ti $llspec $S(col)
                }
            }
            removeallannotation {
                foreach ti $S($w,t) {
                    foreach a $B($ti,bll) {
                        Annotation::BLLDelete2 $w $a
                    }
                }
            }
            unshrink {
                foreach ti $S($w,t) {
                    Abstraction::ShrinkUnAll $w $ti
                }
            }
            canvasbgcolor {
                $w configure -bg $S(col)
            }
            export_leaves {
                set typelist {
                    {"Text File" {".txt"} }
                    {"All Files" {*}}
                }
                set file [tk_getSaveFile -initialdir $S(userDIR)  -defaultextension ".txt" \
                        -filetypes $typelist -title "Save Leaves as a text file..."]
                if {$file != ""} {set S(userDIR) [file dirname $file]}
                if {$file != ""} {
                    set fid [open $file w]
                    set ll {}
                    foreach ti $S($w,t) {
                        foreach l $T($ti,ue_lab) {
                            if {[lsearch -exact $ll $l] == -1} {lappend ll $l}
                        }
                    }
                    foreach l $ll {
                        puts $fid $l
                    }
                    close $fid
                }
            }
            export_ps {
                set c $w
                set parent $w
                set typelist {
                    {"Postscript Files" {".ps"} }
                    {"All Files" {*}}
                }
                set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".ps" \
                        -filetypes $typelist -parent $parent -title "Save Canvas as Postscript file..."]
                if {$file != "" } {set S(userDIR) [file dirname $file]}
                # init si canvas vide
                set x0 0
                set y0 0
                set x1 [winfo width $c]
                set y1 [winfo height $c]
                # affectation des variables
                foreach {x0 y0 x1 y1} [$c bbox all] {}
                set w [expr $x1 - $x0]
                set h [expr $y1 - $y0]
                $c postscript  -file  $file -colormode color \
                        -x $x0 -y $y0 -width $w -height $h \
                        -pagex 0 -pagey 0 -pagewidth 20.c -pageheight 30.c \
                        -pageanchor nw
            }
            export_svg {
                set c $w
                set parent $w
                set typelist {
                    {"SVG Files" {".svg"} }
                    {"All Files" {*}}
                }
                set file [tk_getSaveFile  -initialdir $S(userDIR) -defaultextension ".svg" \
                        -filetypes $typelist -parent $parent -title "Save Canvas as SVG file..."]
                if {$file != "" } {set S(userDIR) [file dirname $file]}
                if {$file != "" }{::can2svg::canvas2file $c $file }
            }
            export_wmf  {
                set window $w
                set parent $w
                set typelist {
                    {"Windows Meta Files" {".wmf"}}
                    {"All Files" {*}}
                }
                set ff [tk_getSaveFile  -initialdir $S(userDIR)  -defaultextension ".wmf" \
                        -filetypes $typelist -parent $parent -title "Save Canvas as WMF file..."]
                if {$ff != "" } {set S(userDIR) [file dirname $ff]}
                if {$ff!=""} then {
                    raise [winfo toplevel $window]
                    update
                    set emfdc [wmf open]
                    set size [gdi copybits $emfdc -window $window -calc]
                    eval gdi copybits $emfdc -window $window -source [ list $size ] -scale 1.01
                    set emf [wmf close $emfdc]
                    wmf copy $emf -file $ff
                    wmf delete $emf
                }
            }
            export_gif {
                set typelist {
                    {"Bitmap Files" {".bmp"}}
                    {"All Files" {*}}
                }
                set ff [tk_getSaveFile -initialdir $S(userDIR)  -defaultextension .bmp \
                        -filetypes $typelist  -title "Save Canvas as BMP file..."]
                if {$ff != "" } {set S(userDIR) [file dirname $ff]}
                if {$ff!=""} then {
                    raise [winfo toplevel $w]
                    update
                    set img [image create photo -format window -data $w]
                    $img write $ff -format bmp
                }
                
            }
            copytoclipboard  {
                set emfdc [wmf open]
                raise [winfo toplevel $w]
                update
                gdi copybits $emfdc -window $w client
                set emf [wmf close $emfdc]
                wmf copy $emf -type enhanced
                wmf delete $emf
            }
            GraVarInitBgSubTree {foreach ti $S($w,t) {Figuration::GraVarInitBgSubTree $w $ti}}
            GraVarInitFgTree {foreach ti $S($w,t) {Figuration::GraVarInitFgTree $w $ti}}
            GraVarInitLineWidth {foreach ti $S($w,t) {Figuration::GraVarInitLineWidth $w $ti}}
            GraVarInitLineDash {foreach ti $S($w,t) {Figuration::GraVarInitLineDash $w $ti}}
            GraVarInitBgLeaf {foreach ti $S($w,t) {Figuration::GraVarInitBgLeaf $w $ti}}
            GraVarInitFgLeaf {foreach ti $S($w,t) {Figuration::GraVarInitFgLeaf $w $ti}}
            GraVarInitFont {foreach ti $S($w,t) {Figuration::GraVarInitFont $w $ti}}
            NodeGraVarInit {foreach ti $S($w,t) {Figuration::NodeGraVarInit $ti}}
            displayleaves {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    if {$S($ti,display_eu) == "normal"} {
                        set S($ti,display_eu) hidden
                        $w itemconfigure [list T$ti && L] -state hidden
                        $w itemconfigure [list T$ti && bgleaf] -state hidden
                    } {
                        set S($ti,display_eu) normal
                        set litems [$w find withtag [list T$ti && L || T$ti && bgleaf]]
                        foreach item $litems {
                            set tags [$w gettags $item]
                            if  {[lsearch -glob $tags SHI*] == "-1"} {
                                $w itemconfigure $item -state normal
                            }
                        }
                    }
                    .progress.i step
                }
                destroy .progress
            }
            treenames {
                foreach ti $S($w,t) {
                    set co [$w bbox [list Z && T$ti]]
                    Annotation::AnnotateBuiltIn $w $ti [lindex $co 0] [lindex $co 1] File
                }
            }
            treefgcolor {
                # mise a jour de la couleur de preference
                set S(Preference_fgc) $S(col)
                $w itemconfigure Z -fill $S(col)
            }
            treefont {
                # mise a jour fontbase
                set S(fontbase) $S(gfo)
                $w itemconfigure L -font $S(gfo)
            }
            PhyNJ {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w PhyNJ
                    .progress.i step
                }
                destroy .progress
            }
            PhyRad {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w PhyRad
                    .progress.i step
                }
                destroy .progress
            }
            PhyCir1 {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w PhyCir1
                    .progress.i step
                }
                destroy .progress
            }
            PhyCir2 {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w PhyCir2
                    .progress.i step
                }
                destroy .progress
            }
            ClaRad {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w ClaRad
                    .progress.i step
                }
                destroy .progress
            }
            ClaRec {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w ClaRec
                    .progress.i step
                }
                destroy .progress
            }
            ClaSla {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w ClaSla
                    .progress.i step
                }
                destroy .progress
            }
            ClaCir1 {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w ClaCir1
                    .progress.i step
                }
                destroy .progress
            }
            ClaCir2 {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w ClaCir2
                    .progress.i step
                }
                destroy .progress
            }
            ClaCir3  {
                ProgressBar [llength $S($w,t)]
                foreach ti $S($w,t) {
                    Conformation::ArrToCanSwitch $ti $w ClaCir3
                    .progress.i step
                }
                destroy .progress
            }
            insertback {
                set typelist {
                    {"GIF Files" {".gif"} }
                    {"All Files" {*}}
                }
                set file [tk_getOpenFile -initialdir $S(userDIR)  \
                        -filetypes $typelist -defaultextension "gif" -title "Load GIF File"]
                if {$file != ""} {set S(userDIR) [file dirname $file]}
                set img [image create photo -file $file]
                set item [$w create image 0 0 -image $img -anchor nw -tags "bitmap map"]
                $w lower $item
                update
            }
            fitocontent {Navigation::FitToContents $w}
            fullscreen {Navigation::FitToFullScreen $w}
            
            bgcolor {}
            
            delete {ImportExport::DeleteCanvas $w}
        }
    }
    proc ConCat args {
        regsub -all {[ 	\.]+} $args . args
        return $args
    }
    proc ProgressBar {nb} {
        destroy .progress
        toplevel .progress
        wm withdraw .progress
        wm resizable .progress 0 0
        wm overrideredirect .progress 1
        set max $nb
        label .progress.l  -text "TreeDyn Conformation"
        iwidgets::feedback .progress.i -labelvariable S(ImportExportNI) -steps $max
        .progress.i reset
        set x [expr ([winfo screenwidth .progress] - [winfo reqwidth .progress]) /2]
        set y [expr ([winfo screenheight .progress] - [winfo reqheight .progress]) /2]
        wm geometry .progress "+$x+$y"
        pack .progress.l .progress.i -side top -fill both -expand yes
        wm deiconify .progress
    }
    ### Action Tree
    proc D3ActionTree  {w t command} {
        global T S B
        switch $command {
            savenewickfile {ImportExport::SaveNewick $w $t $t}
            save - saveas  {ImportExport::draw_save $w $command $t}
            copy {ImportExport::CoPy $w tree $t $t}
            duplicate {}
            removeallannotation {
                foreach a $B($t,bll) {
                    Annotation::BLLDelete2 $w $a
                }
            }
            anchorw {$w itemconfigure [list T$t && L] -anchor w}
            anchore {$w itemconfigure [list T$t && L] -anchor e}
            copypastenewwindow  {}
            copytoclipboard  {}
            saveleavefile {
                set typelist {
                    {"Text File" {".txt"} }
                    {"All Files" {*}}
                }
                set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".txt" \
                        -filetypes $typelist -title "Save Leaves as a text file..."]
                if {$file != "" } {set S(userDIR) [file dirname $file]}
                if {$file != ""} {
                    set fid [open $file w]
                    foreach l $T($t,ue_lab) {
                        puts $fid $l
                    }
                    close $fid
                }
            }
            renametree {
                eval destroy .rt
                set w [toplevel .rt]
                wm title $w "Rename Tree"
                global renametree
                set renametree $S($t,tit)
                entry .rt.ns -relief groove -width 10 -textvariable renametree
                button .rt.ok -text ok -command "Interface::UpdateNameTree $t"
                button .rt.ca -text cancel -command "destroy .rt"
                pack .rt.ns -fill x -expand yes
                pack .rt.ok .rt.ca -side left
            }
            displayeuRadial {
                Conformation::displayeuRadial $w $t
            }
            reset {Figuration::NodeGraVarInit $t}
            print {Package::Printer::print_widget $w T$t ?}
            fittowindow  {Navigation::FitToWindow $w $t}
            cut {ImportExport::DeleteTree $w $t}
            displaydbl {Annotation::DisplayDBL $w $t}
            displaydbv {Annotation::DisplayDBV $w $t}
            displaydbvseuil {Annotation::DisplayDBVseuil $w $t}
            displaydblseuil {Annotation::DisplayDBLseuil $w $t}
            displaydblpercent {Annotation::DisplayDBLpercent $w $t}
            displaydbvpercent {Annotation::DisplayDBVpercent $w $t}
            fgcolor  {}
            remove  {
                # T array
                foreach {key value} [array get T $t,*] {
                    unset T($key)
                }
                # S array
                regsub -all $t $S(ilt) "" S(ilt)
                if {$S(ict) == $t} {set S(ict) [lindex $S(ilt) 0]}
                set w $T($t)
                regsub -all $w $S(com) "" S(com)
            }
            color2 {
                foreach n [Tools::SousL $T($t,all_cod) $T($t,ue_cod)] {
                    set tag [format "%s%s" $n C]
                    set lid [$w find withtag $tag ]
                    foreach id $lid {
                        Figuration::NodeColorFgItem $w $id blue
                    }
                }
                foreach n  $T($t,ue_cod) {
                    Figuration::NodeColorFgItem $w $n red
                }
            }
            colorn {
                set incrhue [expr 6.28 / $T($t,tot)]
                set hue $incrhue
                
                set color [Operation::ColorPanel_hsb2rgb $hue 1 1]
                set lid [$w find withtag [list [format "%s%s" $t C] || [format "%s%s" $t gC] || [format "%s%s" $t dC] ]]
                foreach id $lid {
                    Figuration::NodeColorFgItem $w $id $color
                }
                for  {set i 1} {$i <= [expr $T($t,tot) -1]} {incr i}  {
                    set hue [expr $hue + $incrhue]
                    set color [Operation::ColorPanel_hsb2rgb $hue 1 1]
                    foreach n $T($t,cbg,$i) {
                        set tag1 [format "%s%s%s" $n g C]
                        set tag2 [format "%s%s%s" $n d C]
                        set lid [$w find withtag [list $tag1 || $tag2]]
                        foreach id $lid {
                            Figuration::NodeColorFgItem $w $id $color
                        }
                    }
                }
            }
            colornLL {
                set ldep [Tools::SousL $T($t,all_cod) $T($t,ue_cod)]
                foreach n $ldep {
                    set nb [llength [Tools::NodeNoToLe $t $n]]
                    set N($n) $nb
                }
                set lclass {}
                foreach {k v} [array get N] {
                    if  {[lsearch  $lclass $v] == "-1"} {
                        lappend lclass $v
                    }
                }
                set nbclass [expr [llength $lclass] + 2]
                set incrhue [expr 6.28 / $nbclass]
                set hue $incrhue
                foreach e [lsort -increasing $lclass] {
                    set NC($e) [Operation::ColorPanel_hsb2rgb $hue 1 1]
                    set hue [expr $hue + $incrhue]
                }
                foreach n $ldep {
                    set tag [format "%s%s" $n C]
                    set color $NC($N($n))
                    set lid [$w find withtag [list $n || $tag]]
                    foreach id $lid {
                        Figuration::NodeColorFgItem $w $id $color
                    }
                }
            }
            widthlineboots {
                set lkv [array get T $t,dbv,*]
                puts $lkv
            }
            ClaCir1 {Conformation::ArrToCanSwitch $t $w ClaCir1}
            ClaCir2 {Conformation::ArrToCanSwitch $t $w ClaCir2}
            ClaCir3 {Conformation::ArrToCanSwitch $t $w ClaCir3}
            PhyNJ   {Conformation::ArrToCanSwitch $t $w PhyNJ}
            PhyRad  {Conformation::ArrToCanSwitch $t $w PhyRad}
            PhyCir1 {Conformation::ArrToCanSwitch $t $w PhyCir1}
            PhyCir2 {Conformation::ArrToCanSwitch $t $w PhyCir2}
            ClaRec  {Conformation::ArrToCanSwitch $t $w ClaRec}
            ClaSla  {Conformation::ArrToCanSwitch $t $w ClaSla}
            ClaRad  {Conformation::ArrToCanSwitch $t $w ClaRad}
            Lleaves1  {Conformation::PhyCirc1DisplayLeaves $w $t Lleaves1}
            Lleaves2  {Conformation::PhyCirc1DisplayLeaves $w $t Lleaves2}
            displayeunames {
                if {$S($t,display_eu) == "normal"} {
                    set S($t,display_eu) hidden
                    $w itemconfigure [list T$t && L] -state hidden
                    $w itemconfigure [list T$t && bgleaf] -state hidden
                } {
                    set S($t,display_eu) normal
                    set litems [$w find withtag [list T$t && L || T$t && bgleaf]]
                    foreach item $litems {
                        set tags [$w gettags $item]
                        if  {[lsearch -glob $tags SHI*] == "-1"} {
                            $w itemconfigure $item -state normal
                        }
                    }
                }
            }
            globa {Navigation::makeBrowerGlobal $w $t}
            loca {Navigation::makeBrowerLocal $w $t}
            mirror {Orientation::Anchor $w $t ; Navigation::FitToContents $w}
            mirrorV {Orientation::AnchorVertical $w $t ; Navigation::FitToContents $w}
        }
    }
    proc D3ActionNode {w t n command} {
        global T S
        switch $command {
            savenewickfile {ImportExport::SaveNewick $w $t $n}
            swap {Conformation::Swap $w $t $n}
            outgroup {Conformation::Outgroup $w newitem $t $n}
            exportll2clipboard {
                clipboard clear
                set p [format "%s%s" $n *]
                set listneu {}
                foreach e $T($t,ue_cod) {
                    if {[string match $p $e] == 1} {
                        clipboard append "$T($t,ctl,$e) \n"
                    }
                }
            }
        }
    }
    proc UpdateNameTree {t} {
        global renametree S
        set S($t,tit) $renametree
    }
    # Panel de definition de classes
    # usage sur classes de valeurs de bootstrap, et line width differentielle
    proc PanelDeffClass {} {
        global S M
        toplevel .dc -relief raised -borderwidth 2
        wm title .dc "Class Definition"
        # panel controls
        set fc [frame .dc.co]
        button .dc.co.add -text "Add a Class"
        menubutton .dc.co.rm -text "Remove a Class" -menu .dc.co.rm.m
        set z  [menu  .dc.co.rm.m -tearoff 0]
        $z configure -postcommand "UpdateClassToRemove $z"
        button .dc.co.up -text "Update Display"
        # panel graphic
        set fd [frame .dc.fd]
        set canvasw 400.0
        set canvash 400.0
        set marge 20
        set c [canvas .dc.fd.ca -background LightGoldenrodYellow -borderwidth 1 -width $canvasw -height $canvash]
        # une barre verticale par colonne
        # set deltax [expr $canvasw / ($S(NBC) + 2)]
        set deltax 20
        set j 1
        set x [expr $j * $deltax]
        $c create line $x 0 $x [expr ($canvash - $marge)]
        set factory [expr ($canvash - $marge) / $S(MAX) ]
        set j 1
        set pattern [format "%s%s" *, $j]
        # liste des valeurs de bootstrap
        set lkv [array get M $pattern]
        set x [expr $j * $deltax]
        foreach {k v} $lkv {
            set y [expr $factory * $v ]
            $c create line [expr $x -2] $y [expr $x +2] $y
        }
        # un trait hori par classe
        set ampclass [expr ($S(MAX) - $S(MIN)) / $S(NBC) ]
        for  {set j 1} {$j <= [expr $S(NBC) -1]} {incr j} {
            set y [expr ($j * $ampclass) * $factory]
            $c create line 0 $y 400 $y -fill blue -width 2 -tags "CL class¶$j"
        }
        $c bind CL <Button-1> {MoveStart %W %x %y}
        $c bind CL <B1-Motion> {Move %W %x %y}
        $c bind CL <ButtonRelease-1> {SetClass %W}
        $c move all 0 [expr $marge /2]
        # packing
        pack .dc.co.add .dc.co.rm .dc.co.up -side left
        pack .dc.fd.ca
        pack .dc.co .dc.fd -side top
    }
    #
    proc MoveStart {w x y} {
        #set S(mox) $x
        global S
        set S(moy) $y
    }
    #
    proc Move {w x y} {
        global S
        #set id [$w find withtag current]
        if {$y < 398 && $y > 2} {
            $w move current 0 [expr $y - $S(moy)]
            set S(moy) $y
        }
        #set S(mox) $x
    }
    #
    proc SetClass {w} {
        set class [$w find withtag CL]
        foreach c $class {
            set tags [$w gettags $c]
            set classj [lindex $tags 1]
            set classID [lindex [split $classj ¶] end]
            set Y [$w coords $c ]
            puts "$classID at $Y"
        }
    }
    ###
    proc Find {} {
        global S find
        set find(stringsearch) *
        set find(filter) *
        set w [toplevel .find]
        wm title .find "Find"
        # selection par user avec pattern
        iwidgets::entryfield .find.etext -width 25 -textvariable find(stringsearch)   \
                -labeltext "Find:" -command Interface::FindGo
        # operation
        set mo [Operation::MenuOperation2 .find]
        # Reset
        menubutton .find.reset  -text "Reset" -menu .find.reset.m  -direction below
        set mc [menu  .find.reset.m -tearoff 0 ]
        $mc add check -label "Automatic Reset" -variable S(AutoReset)
        $mc add separator
        $mc add command -label  "Reset" -command {Operation::ResetGraphicVariables}
        $mc add separator
        $mc add command -label  "Graphical Variables to Reset:" -command ""
        $mc add check -label  "Leaf Foreground Color" -variable S(OpResetLFgC)
        $mc add check -label  "Leaf Background Color" -variable S(OpResetLBgC)
        $mc add check -label  "Leaf Font" -variable S(OpResetLF)
        $mc add check -label  "Node Foreground Color" -variable S(OpResetNFgC)
        $mc add check -label  "Node Background Color" -variable S(OpResetNBgC)
        $mc add check -label  "Node Line (Width)" -variable S(OpResetNLW)
        $mc add check -label  "Node Line (Dash)" -variable S(OpResetNLD)
        $mc add command -label  "Select All" -command "Operation::ResetAllFig+"
        $mc add command -label  "UnSelect All" -command "Operation::ResetAllFig-"
        # switch cible trees : tous les tree ou ceux en target, par defaut tous
        # + mise a jour de liste des feuilles available
        menubutton .find.target -text "Tree(s) Target" -menu .find.target.m  -direction below
        set z  [menu  .find.target.m -tearoff 0]
        $z configure -postcommand "Database::TreeTarget $z ; Interface::FindAddAvailableLeaves"
        set find(tree) ""
        # on/off case sensitive
        checkbutton .find.case -text "Case sensitive " -variable find(case)
        # selection par selection feuilles dans une listbox
        iwidgets::Labeledframe .find.leaves -labelpos nw -labeltext "Leaves"
        set p [.find.leaves childsite]
        # update leaves
        button $p.up -text "Update"  -command "Interface::FindAddAvailableLeaves"
        # leaves filter
        iwidgets::entryfield $p.filter -width 15 -textvariable find(filter)   \
                -labeltext "Filter:" -command Interface::FindAddAvailableLeaves
        # leaves list Total (pour tree target)
        set wd [frame $p.lfa]
        scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
        scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
        listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                -width 15 -height 8
        grid $wd.l -row 0 -column 0 -sticky news
        grid $wd.yscroll -row 0 -column 1 -sticky ns
        grid $wd.xscroll -row 1 -column 0 -sticky ew
        grid rowconfigure $wd 0 -weight 1
        grid columnconfigure $wd 0 -weight 1
        bind $p.lfa.l <Double-Button-1> "Interface::FindUp .find.leaves.childsite.lfa.l %x %y"
        # History
        iwidgets::Labeledframe .find.history -labelpos nw -labeltext "History"
        set p2 [.find.history childsite]
        Lbs $p2 "" 15 5 find(stringsearch)
        bind $p2.l <ButtonRelease> "Interface::FindUp .find.history.childsite.l %x %y"
        # clear the history list
        button $p2.delhistory -text "Clear History"  -command ".find.history.childsite.l delete 0 end"
        # alternagraphics
        button $p2.alterna -text "Alternagraphics"  -command "Interface::AlternaGraphics"
        grid $p2.delhistory -row 2 -column 0  -sticky ew
        grid $p2.alterna -row 3 -column 0  -sticky ew
        # PACK
        pack $p.up $p.filter -expand yes -fill x
        pack $wd -expand yes -fill both
        pack $p.lfa -expand yes -fill both
        pack $mo -expand yes -fill x
        pack .find.reset -expand yes -fill x
        pack .find.target -expand yes -fill x
        pack .find.case -expand yes -fill x
        pack .find.leaves -expand yes -fill both
        pack .find.etext -expand yes -fill x
        pack .find.history -expand yes -fill both
        # insertion liste des feuilles les feuilles des arbres en target
        Interface::FindAddAvailableLeaves
    }
    #
    proc AlternaGraphics {} {
        # interface panel
        set id [Tools::GenId]
        toplevel .alter$id
        #wm overrideredirect .alter$id 1
        wm title .alter$id "AlternaGraphics"
        wm geometry .alter$id "+[winfo pointerx .alter$id]+[winfo pointery .alter$id]"
        # canvas d'affichage de la liste de TOUS les patterns
        set w [frame .alter$id.canvas]
        scrollbar $w.xsbar -orient horizontal -command "$w.c xview"
        scrollbar $w.ysbar -orient vertical -command "$w.c yview"
        canvas $w.c -width 100 -height 100  \
                -xscrollcommand "$w.xsbar set" -yscrollcommand "$w.ysbar set"\
                -highlightthickness 0
        grid $w.c -row 0 -column 0 -sticky news
        grid $w.xsbar -row 1 -column 0 -sticky ew
        grid $w.ysbar -row 0 -column 1 -sticky ns
        grid rowconfigure $w 0  -weight 1
        grid columnconfigure $w 0 -weight 1
        set x 40
        set y 20
        #liste des patterns issus de Find/History
        set lv [.find.history.childsite.l get 0 end]
        foreach value $lv {
            $w.c create text [expr $x + 30] [expr $y + 15] -fill green \
                    -text $value -anchor w  -tags "t $value"
            incr y 15
        }
        $w.c bind t <Button-1> "Interface::AlternaGraphicsSelUnSelOne $w.c"
        $w.c configure -scrollregion [$w.c  bbox all]
        # message d'aide
        message .alter$id.msg -width 300 -text " + Clic on text values. Green: the value will be checked,\
                Red: the value will not be checked. Also use the <Select All> or <Unselect All> buttons."
        # menu operation
        iwidgets::optionmenu  .alter$id.operation -labeltext "Operation: " -labelpos w \
                -command "Interface::AlternaGraphicsOperation .alter$id.operation"
        foreach i {"Leaf Foreground Color" "Leaf Background Color" "Node Foreground Color" } {
            .alter$id.operation insert end $i
        }
        # button select all et unselect all
        set ww [frame .alter$id.select]
        button $ww.selall -text "Select All" -command "Interface::AlternaGraphicsSelectAll .alter$id.canvas.c"
        button $ww.unsall -text "Unselect All" -command "Interface::AlternaGraphicsUnSelectAll .alter$id.canvas.c"
        pack  $ww.selall $ww.unsall -side left -expand yes -fill both
        # message d'information de la requete courante
        message .alter$id.msgval -width 300 -text "" -textvariable find(stringsearch)
        global alter find
        Operation::ResetAllFig+
        Operation::ResetGraphicVariables
        set find(modeswitch) manual ;# ou auto
        set find(modeautoloop) 5 ;# number of loop to do in iterative mode
        set find(modeautotime) 200 ;# temps en millisecondes entre deux query
        set find(stop) 0 ;# temps en millisecondes entre deux query
        set find(stringsearch) ""
        ### MODE MANUAL/AUTO
        iwidgets::Labeledframe .alter$id.manual -labelpos nw -labeltext "Manual Mode"
        set p1 [.alter$id.manual childsite]
        iwidgets::Labeledframe .alter$id.auto -labelpos nw -labeltext "Automatic Mode"
        set p2 [.alter$id.auto childsite]
        # mode manual
        radiobutton $p1.mode -text "Manual mode"  -variable find(modeswitch) -value manual -command "Interface::AlternaGraphicsManualToAuto $p1 $p2"
        button $p1.prev -text "Previous"  -command "Interface::AlternaGraphicsManualPrev .alter$id.canvas.c"
        button $p1.next -text "Next" -command "Interface::AlternaGraphicsManualNext .alter$id.canvas.c"
        pack $p1.mode $p1.prev $p1.next  -side top -expand yes -fill x
        # mode automatic
        radiobutton $p2.mode -text "Automatic mode"  -variable find(modeswitch) \
                -value auto -command "Interface::AlternaGraphicsAutoToManual $p1 $p2"
        iwidgets::entryfield $p2.loop  -labeltext "Loop number" -width 5 -textvariable find(modeautoloop) -labelpos w
        iwidgets::entryfield $p2.time  -labeltext "Time laps (ms)" -width 5 -textvariable find(modeautotime) -labelpos w
        button $p2.query -text Query -command "Interface::AlternaGraphicsAutoQuery $w.c"
        button $p2.stop -text Stop -command "set find(stop) 1"
        pack $p2.mode $p2.loop $p2.time  $p2.query $p2.stop -side top -expand yes -fill x
        pack  .alter$id.msg .alter$id.select  $w \
                .alter$id.operation .alter$id.msgval .alter$id.manual .alter$id.auto \
                -expand yes -fill x
        # par defaut on est en mode manual donc inhibition des controls auto
        Interface::AlternaGraphicsManualToAuto $p1 $p2
    }
    #
    proc AlternaGraphicsManualPrev {c} {
        global find
        # recuperation des valeurs en selection
        set li [$c find withtag t]
        set lvalues {}
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green"} {
                lappend lvalues $valeur
            }
        }
        set find(ManualQueryList) $lvalues
        # on va tourner sur la liste
        if {$find(stringsearch) != ""} {
            set ou [lsearch -exact $find(ManualQueryList) $find(stringsearch)]
            if {$ou != -1} {
                set newval [lindex $find(ManualQueryList) [incr ou -1]]
                if {$newval != ""} {
                    set find(stringsearch) $newval
                } else  {
                    set find(stringsearch) [lindex $find(ManualQueryList) end]
                }
                Operation::ResetAllFig+
                Operation::ResetGraphicVariables
                Interface::AlternaGraphicsQuery
                update idletasks
            }
        }
    }
    #
    proc AlternaGraphicsManualNext {c} {
        global find
        # recuperation des valeurs en selection
        set li [$c find withtag t]
        set lvalues {}
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green"} {
                lappend lvalues $valeur
            }
        }
        set find(ManualQueryList) $lvalues
        # on va tourner sur la liste
        if {$find(stringsearch) != ""} {
            set ou [lsearch -exact $find(ManualQueryList) $find(stringsearch)]
            if {$ou != -1} {
                set newval [lindex $find(ManualQueryList) [incr ou]]
                if {$newval != ""} {
                    set find(stringsearch) $newval
                } else  {
                    set find(stringsearch) [lindex $find(ManualQueryList) 0]
                }
                Operation::ResetAllFig+
                Operation::ResetGraphicVariables
                Interface::AlternaGraphicsQuery
                update idletasks
            }
        }
    }
    #
    proc AlternaGraphicsAutoQuery {c} {
        global find
        # recuperation des valeurs en selection
        set li [$c find withtag t]
        set lvalues {}
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green"} {
                lappend lvalues $valeur
            }
        }
        for  {set i 1} {$i <= $find(modeautoloop)} {incr i} {
            if {$find(stop) == 1} {set find(stop) 0 ; break}
            
            foreach val $lvalues {
                set find(stringsearch) $val
                Operation::ResetAllFig+
                Operation::ResetGraphicVariables
                after $find(modeautotime)
                Interface::AlternaGraphicsQuery
                update idletasks
                update
            }
        }
    }
    
    #
    proc AlternaGraphicsQuery {} {
        global find T
        # Aliste $w $t des cibles
        if {$find(tree) == "all"} {
            set ltree [Selection::TreeAll]
        } {
            set ltree [Selection::TreeTar]
        }
        if {$ltree != {}} {
            # filtrage feuilles et Operation
            foreach {w t} $ltree  {
                set pattern $find(stringsearch)
                set leu {}
                foreach i $T($t,ue_lab) {
                    if {[string match $pattern $i]} {lappend leu $i }
                }
                Operation::Operation $w $t $leu
            }
        }
    }
    #
    proc AlternaGraphicsManualToAuto {p1 p2} {
        $p1.prev configure -state normal
        $p1.next configure -state normal
        $p2.loop configure -state disabled
        $p2.time configure -state disabled
        $p2.query configure -state disabled
        $p2.stop configure -state disabled
    }
    #
    proc AlternaGraphicsAutoToManual {p1 p2} {
        $p1.prev configure -state disabled
        $p1.next configure -state disabled
        $p2.loop configure -state normal
        $p2.time configure -state normal
        $p2.query configure -state normal
        $p2.stop configure -state normal
    }
    #
    proc AlternaGraphicsSelUnSelOne {w} {
        set c [$w itemcget current -fill]
        if {$c == "green"} {set color red} {set color green}
        $w itemconfigure current -fill $color
    }
    #
    proc AlternaGraphicsOperation {w} {
        global S
        set operation [$w get]
        switch -glob $operation {
            "Leaf Foreground Color" {set S(operation) leaffgcolor }
            "Node Foreground Color" {set S(operation) nodefgcolor }
            "Leaf Background Color" {set S(operation) leafbgcolor }
            "Node Background Color" {set S(operation) nodebgcolor }
            "Leaf Illustration (columns)" {set S(operation) LillC ; Interface::PopUp Symbol}
            "Leaf Annotation (columns)" {set S(operation) LannC ; Interface::PopUp Text}
            "Query: Leaf Annotate (columns)" {set S(DisplayVOV) 0 ;  set S(operation) qLannC}
            "Query: Node Annotate" {set S(operation) insertvarval}
        }
    }
    #
    proc AlternaGraphicsSelectAll {w} {
        $w itemconfigure t -fill green
    }
    #
    proc AlternaGraphicsUnSelectAll {w} {
        $w itemconfigure t -fill red
    }
    #
    proc FindUp {w x y} {
        global find
        set find(stringsearch) [$w get @$x,$y]
        Interface::FindGo
    }
    # mise a jour liste des feuilles en fonction des arbres en target
    proc FindAddAvailableLeaves {} {
        global S find T
        .find.leaves.childsite.lfa.l delete 0 end
        # liste de tree target
        if {$find(tree) == "all"} {
            set ltree [Selection::TreeAll]
        } {
            set ltree [Selection::TreeTar]
        }
        set ltreetarget {}
        foreach {w t} $ltree  {
            lappend ltreetarget $t
        }
        if {$ltree != {}} {
            # construction de la liste des feuilles de tous les arbres en selection
            # liste sans repetitions, classe par ordre alpha et respectant le filtre
            set leu {}
            if {$find(filter) != "*"} {
                foreach t $ltreetarget  {
                    foreach i $T($t,ue_lab) {
                        if {[string match $find(filter) $i]} {lappend leu $i }
                    }
                }
            } else  {
                foreach t $ltreetarget  {
                    set leu [concat $leu $T($t,ue_lab)]
                }
            }
            if {[llength $ltreetarget] != 1} {set leu [Tools::DelRep $leu]}
            set leu [lsort -dictionary $leu]
            # remplissage listbox
            eval {.find.leaves.childsite.lfa.l insert end} $leu
        }
    }
    ###
    proc FindGo {} {
        global S T find
        # mise a jour listbox
        set l [.find.history.childsite.l get 0 end]
        lappend l $find(stringsearch)
        set find(history) [Tools::DelRep $l]
        .find.history.childsite.l delete 0 end
        foreach e [lsort -dictionary $find(history)] {
            .find.history.childsite.l insert 0 $e
        }
        # Aliste $w $t des cibles
        if {$find(tree) == "all"} {
            set ltree [Selection::TreeAll]
        } {
            set ltree [Selection::TreeTar]
        }
        if {$ltree != {}} {
            # case sensitive
            if {$find(case) == 0} {
                foreach {w t} $ltree  {
                    set leu {}
                    foreach i $T($t,ue_lab) {
                        if {[string match -nocase $find(stringsearch) $i]} {lappend leu $i }
                    }
                    Operation::Operation $w $t $leu
                }
            } else  {
                foreach {w t} $ltree  {
                    set leu {}
                    foreach i $T($t,ue_lab) {
                        if {[string match $find(stringsearch) $i]} {lappend leu $i }
                    }
                    Operation::Operation $w $t $leu
                }
            }
        }
    }
    ###
    proc Lbs {w titre wi he var} {
        global S
        label $w.lab -text $titre -width $wi
        scrollbar $w.yscroll -bd 1 -command "$w.l yview"
        scrollbar $w.xscroll -bd 1 -orient horizontal -command "$w.l xview "
        listbox  $w.l  -xscroll "$w.xscroll set" -yscroll "$w.yscroll set"  \
                -selectmode browse -width $wi -height $he -exportselection 0
        grid $w.lab -row 0 -column 0
        grid $w.l -row 1 -column 0 -sticky news
        grid $w.yscroll -row 1 -column 1 -sticky ns
        grid $w.xscroll -row 2 -column 0 -sticky ew
        grid rowconfigure $w 1 -weight 1
        grid columnconfigure $w 0 -weight 1
        return $w
    }
}
################################################################################

################################################################################
# REFLECTION
################################################################################
namespace eval Reflection {
    
    ### Transition I / Transition Empirique Simple
    proc Transition-I {w} {
        global S T
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            foreach key [array names S *,tar]  {
                if {$S($key) == 1} {
                    set ti [string range $key 0 [expr [string first , $key] - 1]]
                    if {$ti != 0} {
                        set wi $S($ti,w)
                        #liste des codes
                        set SouCodLea [Tools::NodeNoToLe $t $n]
                        #liste de noms
                        set SouRefLea [Tools::NodeLeCoToRe $t $SouCodLea]
                        Operation::Operation $wi $ti $SouRefLea
                    }
                }
            }
        }
    }
    
    #
    proc ConnectionAction {w t n key} {
        global S T
        #liste des codes
        set SouCodLea [Tools::NodeNoToLe $t $n]
        #liste de noms
        set SouRefLea [Tools::NodeLeCoToRe $t $SouCodLea]
        if {$key != "nodenetwork"} {
            foreach ti $S($w,t) {
                switch $key {
                    nodefgcolor {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::NodeColorFgTree $ti $ni $S(col)
                        }
                    }
                    leaffgcolor {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::NodeColorFgLeaf $ti $ni $S(col)
                        }
                    }
                    shrink {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Abstraction::Shrink $w $ti $ni
                        }
                    }
                    unshrink {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Abstraction::ShrinkUn $w $ti $ni
                        }
                    }
                    nodebgcolor {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::NodeColorBgSubTree $ti $ni
                        }
                    }
                    leafbgcolor {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::NodeColorBgLeaf $ti $ni
                        }
                    }
                    leaffontglob {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::FontSetGlobal $ti $ni $S(gfo)
                        }
                    }
                    widthline+ {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::NodeLineWidth $ti $ni +
                        }
                    }
                    widthline- {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::NodeLineWidth $ti $ni -
                        }
                    }
                    nodedashOn {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::NodeLineDash $ti $ni 1
                        }
                    }
                    nodedashOff {
                        set peres [FindFatherNode $ti $SouRefLea]
                        foreach ni $peres {
                            Figuration::NodeLineDash $ti $ni 0
                        }
                    }
                    leafhide {
                    }
                    leafdisplay {
                    }
                    collapse {
                    }
                    uncollapse {
                    }
                    anotationmatrix {
                        Annotation::LabelMatrix  $w $ti $SouRefLea User
                    }
                }
            }
        } else  {
            set lkv {}
            lappend lkv $t $n
            foreach ti $S($w,t) {
                set peres [FindFatherNode $ti $SouRefLea]
                foreach ni $peres {
                    lappend lkv $ti $ni
                }
            }
            Reflection::NodeNetworkBuild $w $lkv ""
        }
    }
    ###
    proc Transition-III {w} {
        global S T
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if {$S(database) == ""} {
                if {[winfo exists $w.d2connect ] == 1} {destroy $w.d2connect}
                set m [menu $w.d2connect -tearoff 0  ]
                $m add command -label "Load Transition File" -command "Database::LoadTransitionFile"
            } else {
                
                if {[winfo exists $w.d2connect ] == 1} {destroy $w.d2connect}
                set m [menu $w.d2connect -tearoff 0  ]
                $m add command -label "Load Transition File" -command "Database::LoadTransitionFile"
                $m add separator
                set listevariables [Database::dbQueryVarAll $S(database)]
                foreach v $listevariables {
                    $m add command -label $v -command "Reflection::Transition-IIIAction $w $t $n $S(database) $v"
                }
            }
            
        } else  {
            if {[winfo exists $w.d2connect ] == 1} {destroy $w.d2connect}
            set m [menu $w.d2connect -tearoff 0  ]
            $m add command -label "Load Transition File" -command "Database::LoadTransitionFile"
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    
    # des feuilles vers des feuilles
    proc Transition-IIIAction {w t n database variable} {
        global S T
        # liste feuilles sources
        set SouRefLea [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        # liste records dont la valeur de la variable contient au moins une feuille de liste source
        set MatchingRecords {}
        foreach f $SouRefLea {
            # ceci ok si la variable a pour valeurs des feuilles
            set recordsOK [Database::dbQueryRecordsFromVarPatVal $database $variable $f]
            foreach r $recordsOK {
                if {[lsearch -exact $MatchingRecords $r] == -1} {lappend MatchingRecords $r}
            }
        }
        # traduction records vers leafs
        set leaves [Database::dbQueryEusFromRecords $database $MatchingRecords]
        # localisation multi-arbres
        # allumage
        foreach key [array names S *,tar]  {
            if {$S($key) == 1} {
                set ti [string range $key 0 [expr [string first , $key] - 1]]
                if {$ti != 0} {
                    set wi $S($ti,w)
                    # allumer les resultats
                    Operation::Operation $w $ti $leaves
                    # allumer la source et ses copies
                    Operation::Operation $w $ti $SouRefLea
                }
            }
        }
    }
    ### intersection de feuilles pour une valeur de variable
    proc Transition-II {w} {
        global S T
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if {$S(database) == ""} {
                if {[winfo exists $w.d2connect ] == 1} {destroy $w.d2connect}
                set m [menu $w.d2connect -tearoff 0  ]
                $m add command -label "Load Transition File" -command "Database::LoadTransitionFile"
            } else {
                if {[winfo exists $w.d2connect ] == 1} {destroy $w.d2connect}
                set m [menu $w.d2connect -tearoff 0  ]
                $m add command -label "Load Transition File" -command "Database::LoadTransitionFile"
                $m add separator
                set listevariables [Database::dbQueryVarAll $S(database)]
                foreach v $listevariables {
                    $m add command -label $v -command "Reflection::Transition-IIAction $w $t $n $S(database) $v"
                }
            }
        } else  {
            if {[winfo exists $w.d2connect ] == 1} {destroy $w.d2connect}
            set m [menu $w.d2connect -tearoff 0  ]
            $m add command -label "Load Transition File" -command "Database::LoadTransitionFile"
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    ###
    proc Transition-IIAction {w t n database variable} {
        global S T
        # liste feuilles sources
        set SouRefLea [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        
        # liste records correspondant aux feuilles sources
        set MatchingRecords {}
        foreach f $SouRefLea {
            set recordsOK [Database::dbQueryRecordsFromVarPatVal $database EU $f]
            foreach r $recordsOK {
                lappend MatchingRecords $r
            }
        }
        # liste valeurs pour $variable sur les matching records
        upvar #0 $database X
        set MatchingValues {}
        foreach r $MatchingRecords {
            set t $X($r)
            if {!([set pos [lsearch $t $variable]]%2)} {
                set val [lindex $t [incr pos]]
                if {[lsearch -exact $MatchingValues $val] == -1} {lappend MatchingValues $val}
            }
        }
        # Records matchant les MatchingValues sur la $database
        set MatchingRecordsFinal {}
        foreach v $MatchingValues {
            set recordsOK [Database::dbQueryRecordsFromVarPatVal $database $variable $v]
            foreach r $recordsOK {
                if {[lsearch -exact $MatchingRecordsFinal $r] == -1} {lappend MatchingRecordsFinal $r}
            }
        }
        # traduction records vers leafs
        set leaves [Database::dbQueryEusFromRecords $database $MatchingRecordsFinal]
        # localisation multi-arbres
        
        foreach key [array names S *,tar]  {
            if {$S($key) == 1} {
                set ti [string range $key 0 [expr [string first , $key] - 1]]
                if {$ti != 0} {
                    set wi $S($ti,w)
                    Operation::Operation $w $ti $leaves
                }
            }
        }
    }
    ### OPTIMISATION : si un node est ok : ne pas tester ses nodes fils
    proc FindFatherNode {t SouRefLea} {
        global S T
        set L {}
        if {[llength $SouRefLea] != 1} {
            foreach TarCodNod [lsort -dictionary $T($t,all_cod)] {
                # selection des codes leaf issus de node
                set TarCodLea [Tools::NodeNoToLe $t $TarCodNod]
                # passage codes leaf -> references leaf
                set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
                # test inclusion des references leaf de TARGET avec SOURCE
                if {$S(nodefilter) == 0} {
                    set r [Tools::ListInclu $TarRefLea $SouRefLea]
                    if {$r == 1} {lappend L $TarCodNod}
                } else  {
                    set r [Tools::ListIncluSauf $TarRefLea $SouRefLea $S(nodefilter)]
                    if {$r == 1} {lappend L $TarCodNod}
                }
            }
            # meme node pere possibles
            # differents nodes peres possibles
            # -> identification des nodes peres de plus haut niveau
            set l [Tools::NodeFaNoId {} $L]
            if {$L == {}} {return {}} {return $l}
        } {
            if {[lsearch -exact $T($t,ue_lab) $SouRefLea] != -1} {return $T($t,ltc,$SouRefLea)} else {return {}}
        }
    }
    ### allume fg leafs et nodes a partir d'un node select par user
    ### et compare les topologies, transmission aux tree de la meme fenetre
    ### selon resultats comparaison
    proc Congruence {w} {
        global S T
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            foreach ti $S($w,t) {
                congruenceTNs $t $n $ti
            }
        }
    }
    # cette proc applique la procedure congruenceTN a tous les nodes
    # issus de nsource issue de tsource
    proc congruenceTNs {tsource nsource ttarget} {
        global T S
        #
        set lresult {}
        # Figuration::NodeColorFgTree $tsource $nsource $S(col)
        set nodesfromsource [Tools::NodeNoCoFaToNoCoCh $tsource $nsource]
        # on ne prend pas en compte les codes des feuilles
        set latest [Tools::SousL $nodesfromsource $T($tsource,ue_cod)]
        foreach node $latest {
            lappend lresult [congruenceTN $tsource $node $ttarget]
        }
        #puts LRESULT$lresult
        if {[lsearch $lresult 0] == -1} {
            Figuration::NodeColorFgTree $ttarget [lindex $lresult 0] $S(col)
        }
    }
    # si il existe un et un seul node pere de ttarget commun
    # aux leafs names de tsource pour nsource, cette fonction
    # retourne ce node, sinon retourne 0
    proc congruenceTN {tsource nsource ttarget} {
        # liste des noms leafs de tsource pour nsource
        set SouCodLea [Tools::NodeNoToLe $tsource $nsource]
        set SouRefLea [Tools::NodeLeCoToRe $tsource $SouCodLea]
        # recherche d'un node pere a ces leafs sur ttarget
        set result [Tools::FatherSearch2 $ttarget $SouRefLea]
        #puts ===================
        #puts $SouRefLea
        #puts $result
        if {$result != "" && [llength $result] == 1} {
            return $result
        } else  {
            return 0
        }
    }
    # premiere procedure de construction de connecteur
    # M1 construction de l'attachement au premier node + plus le trait suit le cursseur
    # M1M1 Arret du processus
    proc Connection {w {id ""} } {
        global B S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if {$id == ""} {
                set id [Tools::GenId]
                # tree
                set B(CONtre,$id) {}
                # node
                set B(CONnod,$id) {}
                # note (also query from identification)
                set B(CONnot,$id) [list $id]
                #
                lappend S($w,con) $id
            }
            set nodeindex [lsearch -exact $B(CONnod,$id) $n]
            if {$nodeindex == -1} {
                # liste node connectes
                lappend B(CONnod,$id) $n
                if {[lsearch -exact $B(CONtre,$id) $t] == -1} {
                    lappend B(CONtre,$id) $t
                }
                bindtags $w [list connect $w Canvas . all]
                #bindtags $w [list $S(tool) $w Canvas . all]
                bind connect <Button-1> "Reflection::Connection %W $id"
                bind connect <Double-Button-1> "Reflection::UpdateLinkStop %W $t $id"
                bind connect <Motion> "Reflection::UpdateLink %W $t $id %x %y"
            } else  {
                # selectioner un node deja dans le reseau signifie qu'on le retire
                # on le retire
                set B(CONnod,$id)  [concat [lrange $B(CONnod,$id) 0 [expr $nodeindex - 1]] \
                        [lrange $B(CONnod,$id) [expr $nodeindex + 1] end]]
                
                bindtags $w [list connect $w Canvas . all]
                #bindtags $w [list $S(tool) $w Canvas . all]
                #
                bind connect <Button-1> "Reflection::Connection %W $id"
                bind connect <Double-Button-1> "Reflection::UpdateLinkStop %W $t $id"
                bind connect <Motion> "Reflection::UpdateLink %W $t $id %x %y"
                $w bind Connect <Any-Enter> "$w config -cursor hand2"
                $w bind Connect <Any-Leave> "$w config -cursor top_left_arrow"
            }
        }
    }
    # completer un reseau, cad ajouter des nodes
    # sachant l'id d'un node network, on reactive la descrition du reseau
    # avec en argument le dernier element de B($id,CONnod)
    proc ReStartNodeNetwork {w id} {
        global S B
        set lasttree [lindex $B(CONtre,$id) end]
        set S(tool) connect
        bindtags $w [list $S(tool) $w Canvas . all]
        bind connect <Button-1> "Reflection::Connection %W $id"
        bind connect <Double-Button-1> "Reflection::UpdateLinkStop %W $lasttree $id"
        bind connect <Motion> "Reflection::UpdateLink %W $lasttree $id %x %y"
    }
    # delete
    proc ConnectorDelete  {w id} {
        global B S
        # nettoyage canvas
        $w delete [format "%s%s%s" Connect ¶ $id]
        $w delete [format "%s%s%s" ConIconTag ¶ $id]
        # nettoyage array B
        unset B(CONtre,$id)
        unset B(CONnod,$id)
        unset B(CONnot,$id)
        # retrait
        set index [lsearch -exact $S($w,con) $id]
        set S($w,con) [concat [lrange $S($w,con) 0 [expr $index - 1]] \
                [lrange $S($w,con) [expr $index + 1] end]]
    }
    ### voir modifications pour network en etoile
    proc UpdateLink {w t id xmouse ymouse} {
        global B S
        set lcoords {}
        foreach n $B(CONnod,$id) {
            set co [$w coords $n]
            lappend lcoords [lindex $co 0] [lindex $co 1]
        }
        lappend lcoords [expr $xmouse - 5] [expr $ymouse - 5]
        # prise en compte figuration preexistante
        set j [format "%s%s%s"  Connect ¶ $id ]
        if {[$w find withtag $j] != ""} {
            set width_line [lindex [$w itemconfigure $j -width] end]
            set dash_line [lindex [$w itemconfigure $j -dash] end]
            set color_line [lindex [$w itemconfigure $j -fill] end]
        } else  {
            set width_line 1
            set dash_line {2 2}
            set color_line $S(col)
        }
        $w delete $j
        if {$lcoords != {} } {
            $w create line  $lcoords -width $width_line -fill $color_line -dash $dash_line \
                    -tags "Connect [format "%s%s%s"  Connect ¶ $id ]  "
        }
        $w lower Connect
    }
    #
    proc UpdateLinkStop {w t id} {
        global B
        set lcoords {}
        foreach n $B(CONnod,$id) {
            set co [$w coords $n]
            lappend lcoords [lindex $co 0] [lindex $co 1]
        }
        set j [format "%s%s%s"  Connect ¶ $id ]
        set width_line [lindex [$w itemconfigure $j -width] end]
        set dash_line [lindex [$w itemconfigure $j -dash] end]
        set color_line [lindex [$w itemconfigure $j -fill] end]
        $w delete $j
        if {[llength $lcoords] != 2 } {
            $w create line  $lcoords -fill $color_line -dash $dash_line -width $width_line \
                    -tags "Connect $j"
        }
        bind connect <Button-1> "Reflection::Connection %W"
        # mise a nil pour le reste
        bind connect <Motion> ""
        bind connect <Double-Button-1> ""
    }
    #
    proc UpdateAll {w} {
        global B S
        foreach id $S($w,con) {
            set lcoords {}
            foreach n $B(CONnod,$id) {
                set co [$w coords $n]
                lappend lcoords [lindex $co 0] [lindex $co 1]
            }
            set j [format "%s%s%s"  Connect ¶ $id ]
            set width_line [lindex [$w itemconfigure $j -width] end]
            set dash_line [lindex [$w itemconfigure $j -dash] end]
            set color_line [lindex [$w itemconfigure $j -fill] end]
            set state [lindex [$w itemconfigure $j -state] end]
            $w delete $j
            if {[llength $lcoords] != 2 } {
                $w create line  $lcoords -fill $color_line -dash $dash_line -width $width_line \
                        -tags "Connect $j" -state $state
            }
        }
        $w lower Connect
    }
    ###
    proc  AnyEnterC {w x y {id}} {
        
    }
    ###
    proc  AnyLeaveC {w} {
        global B
        $w delete AMi
    }
    ###
    proc  ConnectNote {w id} {
        global B
        if {[winfo exists .connectnote] == 1} {destroy .connectnote}
        toplevel .connectnote
        wm title .connectnote "TreeDyn Note"
        iwidgets::scrolledtext .connectnote.st -labeltext "Connector Annotation " -wrap none \
                -vscrollmode static -hscrollmode dynamic \
                -width 2i -height 1i
        pack .connectnote.st -expand yes -fill both
        button .connectnote.cancel -text Cancel -command {destroy .connectnote}
        button .connectnote.ok -text Ok -command "Reflection::ConnectNoteOk $w $id"
        pack  .connectnote.ok .connectnote.cancel -side left
        .connectnote.st insert 1.0 $B(CONnot,$id)
    }
    #
    proc ConnectNoteOk {w id} {
        global B
        set B(CONnot,$id) [.connectnote.st get 1.0 end]
        destroy .connectnote
        Reflection::ConnectorIconifyUpdate $w $id
    }
    # network ON/OFF
    proc ConnectorIconifyONOFF  {w id} {
        set connector [format "%s%s%s" Connect ¶ $id ]
        set etat [$w itemcget $connector -state]
        if {$etat == "normal"} {
            $w itemconfigure $connector -state hidden
        } else  {
            $w itemconfigure $connector -state normal
        }
    }
    #
    proc ConnectorIconify {w id x y } {
        global B S
        set connector [format "%s%s%s" Connect ¶ $id ]
        set ConIconTag [format "%s%s%s" ConIconTag ¶ $id]
        # destruction de l'ancien si existe, mais on conserve x y
        set idtext  [$w find withtag [list $ConIconTag && text]]
        set idline  [$w find withtag [list $ConIconTag && line]]
        if {$idline != ""}  {
            set coords [$w coords $idline]
            set x [lindex $coords 0]
            set y [lindex $coords 1]
            $w delete $idtext
            $w delete $idline
        }
        # $w delete $idtext
        # on masque le reseau
        $w itemconfigure $connector -state hidden
        # on cree l'icon
        #set color [lindex [$w itemconfigure $connector -fill] end]
        set width_line [lindex [$w itemconfigure $connector -width] end]
        set dash_line [lindex [$w itemconfigure $connector -dash] end]
        set color_line [lindex [$w itemconfigure $connector -fill] end]
        $w create line $x $y [expr $x + 20] $y  -width $width_line -dash $dash_line -fill $color_line \
                -tag "ConnectIcon $id $ConIconTag line"
        if {$B(CONnot,$id) != "" } {
            $w create text $x [expr $y + 3] -text "$B(CONnot,$id)"  -anchor nw \
                    -tag "ConnectIcon $id $ConIconTag text" -fill $color_line -font $S(gfo)
        }  else  {
            $w create text $x [expr $y + 3] -text ""  -anchor nw \
                    -tag "ConnectIcon $id $ConIconTag text" -fill $color_line -font $S(gfo)
        }
    }
    # mise a jour icone node network apres annotation network (display ON)
    proc ConnectorIconifyUpdate {w id} {
        global B
        set ConIconTag [format "%s%s%s" ConIconTag ¶ $id]
        set idtext  [$w find withtag [list $ConIconTag && text]]
        $w itemconfigure $idtext -text $B(CONnot,$id) -anchor nw
    }
    #
    proc ConnectorIconRemove {w id} {
        set ConIconTag [format "%s%s%s" ConIconTag ¶ $id]
        $w delete $ConIconTag
        ConnectorIconifyONOFF $w $id
    }
    proc ConnectorMerge  {w idsource lid} {
        global B
        # fusion de node network
        # lid est soit un id de node network soit une liste d'id node network (selection de all)
        # mise a jour array
        foreach  id $lid {
            #tre
            foreach tid $B(CONtre,$id) {
                if {[lsearch $B(CONtre,$idsource) $tid] == -1}  {
                    lappend B(CONtre,$idsource) $tid
                }
            }
            #nod
            foreach nid $B(CONnod,$id) {
                if {[lsearch $B(CONnod,$idsource) $nid] == -1}  {
                    lappend B(CONnod,$idsource) $nid
                }
            }
            # mise en ordre
            set B(CONnod,$idsource) [lsort -dictionary $B(CONnod,$idsource)]
            # not
            foreach notid $B(CONnot,$id) {
                # on ne garde les note que si elle sont differente de id et pas deja referencees
                if {$notid != $id} {
                    if {[lsearch $B(CONnot,$idsource) $notid] == -1}  {
                        lappend B(CONnot,$idsource) $notid
                    }
                }
            }
            #deletion graphique
            Reflection::ConnectorDelete $w $id
        }
        # mise a jour graphic de idsource
        UpdateAll $w
    }
    proc NodeNetworkBuild {w lkv note} {
        global B S
        set id [Tools::GenId]
        if {$note == ""} {set note $id}
        # liste tree
        set B(CONtre,$id) {}
        # liste node
        set B(CONnod,$id) {}
        # note
        set B(CONnot,$id) [list $note]
        # liste id network / window
        lappend S($w,con) $id
        foreach {tree node} $lkv {
            lappend B(CONtre,$id) $tree
            lappend B(CONnod,$id) $node
        }
        # graphic
        set lcoords {}
        foreach n $B(CONnod,$id) {
            set co [$w coords $n]
            lappend lcoords [lindex $co 0] [lindex $co 1]
        }
        set j [format "%s%s%s"  Connect ¶ $id ]
        set width_line 1
        set dash_line {2 2}
        set color_line $S(col)
        $w delete $j
        if {[llength $lcoords] != 2 } {
            $w create line  $lcoords -fill $color_line -dash $dash_line -width $width_line \
                    -tags "Connect $j"
        }
    }
    
}
################################################################################


################################################################################
# FIGURATION
################################################################################
namespace eval Figuration {
    ###
    proc FontSet {t w n variable value} {
        global T
        set f [lindex [$w itemconfigure [format "%s%s" $n EUL] -font] end]
        set fnew {}
        foreach {var val} $f {
            if {$var == $variable} {lappend fnew $var $value} {lappend fnew $var $val}
        }
        set T($t,gfo,$n) $fnew
        $w itemconfigure [format "%s%s" $n EUL] -font $fnew
    }
    ###
    proc LineSize {mode} {
        global T S
        RecLineSize $S(ict) $mode
        if {$S(com) != {}} {
            foreach t $S(com) {
                set current [string range $t 2 [expr [string first .c $t] -1]]
                if {$current != $S(ict)} {
                    RecLineSize $current $mode
                }
            }
        }
    }
    
    ###
    proc RecLineSize {t mode} {
        global T S
        set w [format "%s%s%s" .t $t .c]
        if {$mode == "+" || $mode == "-"} {
            if {$T($t,sel) == "*"} {
                foreach c $T($t,all_cod) {
                    set code [format "%s%s" $c L]
                    set width_line [lindex [$w itemconfigure $code -width] end]
                    set new_wl [expr  abs($width_line $mode 1)]
                    $w itemconfigure $code -width $new_wl
                    $w itemconfigure [format "%s%s" $code C] -width $new_wl
                    set T($t,gls,$code) $new_wl
                }
            }
            if {$T($t,sel) != "*"} {
                foreach c $T($t,sel) {
                    set code [format "%s%s" $c L]
                    set width_line [lindex [$w itemconfigure $code -width] end]
                    set new_wl [expr  abs($width_line $mode 1)]
                    $w itemconfigure $code -width $new_wl
                    set T($t,gls,$code) $new_wl
                }
            }
        } else {
            
            if {$T($t,sel) == "*"} {
                foreach c $T($t,all_cod) {
                    set code [format "%s%s" $c L]
                    set new_wl 1
                    $w itemconfigure $code -width $new_wl
                    $w itemconfigure [format "%s%s" $code C] -width $new_wl
                    set T($t,gls,$code) $new_wl
                }
            }
            if {$T($t,sel) != "*"} {
                foreach c $T($t,sel) {
                    set code [format "%s%s" $c L]
                    set new_wl 1
                    $w itemconfigure $code -width $new_wl
                    set T($t,gls,$code) $new_wl
                }
            }
        }
        if {$S(desel) == 1} {TBA::UnSelect $w}
    }
    ###
    proc PreLineStipple {mode} {
        global T S
        set t $S(ict)
        set w [format "%s%s%s" .t $t .c ]
        LineStipple $t $w $mode
        if {$S(com) != {}} {
            foreach w $S(com) {
                set t [string range $w 2 [expr [string first .c $w] -1]]
                if {$t != $S(ict)} {
                    LineStipple $t $w $mode
                }
            }
        }
    }
    ###
    proc LineStipple {t w mode} {
        global T S
        foreach c $T($t,sel) {
            set code [format "%s%s" $c L]
            set dash_line [lindex [$w itemconfigure $code -dash] end]
            if {$mode == "+" || $mode == "-"} {
                switch -exact $dash_line {
                    1 { if {$mode == "+"} {
                            set new_dl 2
                        } else {
                            set new_dl {}
                        }
                    }
                    15 { if {$mode == "+"} {
                            set new_dl {}
                        } else {
                            set new_dl 14
                        }
                    }
                    {} { if {$mode == "+"} {
                            set new_dl 1
                            
                        } else {
                            set new_dl 15
                        }
                    }
                    default {
                        set new_dl [expr abs($dash_line $mode 1)]
                    }
                }
            } else {set new_dl {}}
            set T($t,gld,$c) $new_dl
            $w itemconfigure $code -dash $new_dl
        }
        if {$S(desel) == 1} {TBA::UnSelect $w}
    }
    #
    proc RedrawT {w t} {
        Conformation::ArrToCanType $t $w
    }
    # restauration sur un arbre entier
    proc RestaureT {w t} {
        #restauration des variables graphiques
        # gfg lbg lfg bbg gfo gls gld
        NodeGraVarRest $t
        # 2 variables graphiques particulieres (items suplementaires)
        # les bg tree et leaf
        Figuration::RestaureBGSall $w $t
        Figuration::RestaureBGLall $w $t
        ### restauration des variables de dessin
        # DANS L'ORDRE  decomposition, bll , querynode, shrink
        RestaureOVAall $w $t
        RestaureBLLall $w $t
        RestaureQYNall  $w $t
        RestaureShrinkAll $w $t
    }
    #
    proc RestaureShrinkAll {w t} {
        global T S B 
        # il faut reconstruire la structure hierarchique des shrink
        # les plus anciens shrink d'abord, ajout incremental du tag
        # si le tag est deja present on tag pas
        foreach id [lsort -increasing $B($t,shi)] {
            set TAG [format "%s%s%s" SHI ¶ $id]
            # dessin
            set c0 [$w coords $B(SHInod,$id)]
            set x0 [lindex $c0 2]
            set y0 [lindex $c0 3]
            #
            switch $B(SHItyp,$id) {
                0 {}
                3 {}
                4 {
                set lxy [Figuration::NodeColorBgSubTreeContour $w $t $B(SHInod,$id)]
                #
                $w create polygon "$x0 $y0 $lxy $x0 $y0"  -stipple @[file join  + stipple $B(SHIsti,$id)]   \
                        -fill $B(SHIcol,$id) -outline $B(SHIcol,$id) -tags "SHRINK [format "%s%s%s" SHN ¶ $id] T$t" \
                        -smooth 1 -splinesteps 100
                
                $w lower [format "%s%s%s" SHN ¶ $id]
                 }
            }       
            # bll associees a n et ses derives
            set pattern [format "%s%s" $B(SHInod,$id) *]
            foreach idbll $B($t,bll) {
                if {[string match $pattern $B(BLLnod,$idbll)] == 1 } {
                    if {[$w itemcget $B(BLLidt,$idbll) -state] != "hidden"} {
                        $w addtag $TAG withtag $B(BLLidt,$idbll)
                        $w addtag $TAG withtag $B(BLLidl,$idbll)
                        $w itemconfigure $B(BLLidt,$idbll) -state hidden
                        $w itemconfigure $B(BLLidl,$idbll) -state hidden
                    }
                }
            }
            # leaves
            set leafs [Tools::NodeNoToLe $t $B(SHInod,$id)]
            foreach i $leafs {
                set tagi [list [format "%s%s" EUL  $T($t,ctl,$i)] && T$t]
                if {[$w itemcget $tagi -state] != "hidden"} {
                    $w addtag  $TAG withtag $tagi
                    $w itemconfigure $tagi -state hidden
                }
            }
            # background leaves
            set pattern [format "%s%s" $B(SHInod,$id) *]
            foreach idi $B($t,bgl)  {
                if  {[string match $pattern $B(BGLnod,$idi)] == 1} {
                    if {[$w itemcget [format "%s%s%s" BGL ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" BGL ¶ $idi]
                        $w itemconfigure [format "%s%s%s" BGL ¶ $idi] -state hidden
                    }
                }
            }
            # arretes terminales
            set Le [Tools::NodeNoToLe $t $B(SHInod,$id)]
            foreach e $Le {
                if {[$w itemcget $e -state] != "hidden"} {
                    $w addtag $TAG withtag $e
                    $w itemconfigure $e -state hidden
                }
            }
            # tree
            set lchild [Tools::NodeNoCoFaToNoCoCh $t $B(SHInod,$id)]
            foreach i $lchild {
                if {[$w itemcget $i -state] != "hidden"} {
                    $w addtag $TAG withtag [format "%s%s" $i C]
                    $w itemconfigure [format "%s%s" $i C] -state hidden
                }
            }
            # background tree
            set pattern [format "%s%s" $B(SHInod,$id) *]
            foreach idi $B($t,bgs)  {
                if  {[string match $pattern $B(BGSnod,$idi)] == 1} {
                    if {[$w itemcget [format "%s%s%s" BGS ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" BGS ¶ $idi]
                        $w itemconfigure [format "%s%s%s" BGS ¶ $idi] -state hidden
                    }
                }
            }
            # sous shrink
            set pattern [format "%s%s" $B(SHInod,$id) *]
            foreach idi $B($t,shi)  {
                if  {[string match $pattern $B(SHInod,$idi)] == 1 && $id != $idi} {
                    if {[$w itemcget [format "%s%s%s" SHN ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" SHN ¶ $idi]
                        $w itemconfigure [format "%s%s%s" SHN ¶ $idi] -state hidden
                        set B(SHIsta,$idi) hidden
                    }
                }
            }
        }
    }
    #
    proc RestaureBLLall {w t} {
        global B
        set l {}
        foreach id $B($t,bll) {
            $w create text $B(BLLxxx,$id) $B(BLLyyy,$id) \
                    -text $B(BLLtxt,$id) -font $B(BLLgfo,$id) -fill $B(BLLcol,$id) -anchor nw \
                    -tags "bullab T$B(BLLtre,$id) $B(BLLidt,$id)"
            set co_sou [$w coords $B(BLLnod,$id)]
            set x1 [lindex $co_sou 0]
            set y1 [lindex $co_sou 1]
            $w create line $x1 $y1 $B(BLLxxx,$id) $B(BLLyyy,$id) \
                    -width 1 -fill $B(BLLcol,$id) -tags "Link T$B(BLLtre,$id) $B(BLLidl,$id)"
        }
    }
    #
    proc RestaureQYNall {w t} {
        global B
        foreach id $B($t,qyn) {
            set idtext [format "%s%s%s" QYN ¶ $id]
            $w create text $B(QYNxxx,$id) $B(QYNyyy,$id) \
                    -text [lrange $B(QYNqry,$id) [expr [lsearch $B(QYNqry,$id) where] + 1] end] \
                    -font $B(QYNgfo,$id) -fill $B(QYNcol,$id) -anchor nw \
                    -tags "querynode T$t $B(QYNidt,$id)"
            $w raise Q$t
        }
    }
    #
    proc RestaureOVAall {w t} {
        global B
        set lnodlid {}
        foreach id $B($t,ova) {
            lappend lnodlid $B(OVAnod2,$id)
            set decomp($B(OVAnod2,$id)) $id
        }
        foreach n [lsort -increasing $lnodlid] {
            set id $decomp($n)
            set TAG [format "%s%s%s" TD ¶ $id]
            Decomposition::SubTreeDescendant $w $t $n $id $TAG
            $w move $TAG $B(OVAtrx,$id) $B(OVAtry,$id)
        }
        Decomposition::UpdateLink $w $t
        if [array exists decomp] {unset decomp}
    }
    #
    proc RestaureBGSall {w t} {
        global T S B
        set lnodes {}
        foreach idi $B($t,bgs) {
            $w delete [format "%s%s%s" BGS ¶ $idi]
            lappend lnodes $B(BGSnod,$idi)
            set transit($B(BGSnod,$idi)) $idi
        }
        foreach ni [lsort -increasing $lnodes] {
            # compatibilite sauvegarde precedent la creation variable du type des contours et stipple
            if {[catch {set v $B(BGStyp,$transit($ni))} err]} then {set B(BGStyp,$transit($ni)) 1}
            if {[catch {set v $B(BGSsti,$transit($ni))} err]} then {set B(BGSsti,$transit($ni)) z.xbm}
            set lxy [Figuration::NodeColorBgSubTreeContourSwitch $w $t $ni $B(BGStyp,$transit($ni))]
            set idi $transit($ni)
            set tag [format "%s%s%s" BGS ¶ $idi]
            if {$B(BGSsti,$idi) == "z.xbm"} {
                $w create polygon $lxy -outline $B(BGScol,$idi) -fill $B(BGScol,$idi) -tags "bgtree T$t $tag"
            } else  {
                $w create polygon $lxy -outline $B(BGScol,$idi) -fill $B(BGScol,$idi) -tags "bgtree T$t $tag" \
                        -stipple @[file join + stipple $B(BGSsti,$idi)]
            }
        }
        $w lower bgtree
        if {[array exists transit] == 1} {unset transit}
    }
    #
    proc RestaureBGLall {w t} {
        global T S B
        set lnodes {}
        foreach idi $B($t,bgl) {
            $w delete [format "%s%s%s" BGL ¶ $idi]
            lappend lnodes $B(BGLnod,$idi)
            set transit($B(BGLnod,$idi)) $idi
        }
        foreach ni $lnodes {
            set lab $T($t,ctl,$ni)
            set coords [$w bbox [list [format "%s%s" EUL  $lab ] && T$t]]
            if {$coords != ""} {
                set x1 [lindex $coords 0]
                set y1 [expr [lindex $coords 1] -1]
                set x2 [lindex $coords 2]
                set y2 [lindex $coords 3]
                set idi $transit($ni)
                set tag [format "%s%s%s" BGL ¶ $idi]
                # dessin
                $w create rectangle $x1 $y1 $x2 $y2 \
                        -fill  $B(BGLcol,$idi) -outline  $B(BGLcol,$idi) \
                        -tags "bgleaf T$t $tag"
            }
        }
        $w lower bgleaf
        if {[array exists transit] == 1} {unset transit}
    }
    #
    proc RedrawBGLall {w t} {
        global T  B
        foreach idi $B($t,bgl) {
            set lab $T($t,ctl,$B(BGLnod,$idi))
            set coords [$w bbox [list [format "%s%s" EUL  $lab ] && T$t]]
            if {$coords != ""} {
                $w coords [format "%s%s%s" BGL ¶ $idi] $coords
            }
        }
    }
    ### Procedure de restauration des variables graphiques sur tout l'arbre
    proc NodeGraVarRest {t} {
        global S T
        set w $S($t,w)
        ###
        # T($t,gfg,$n) restauration des foreground color tree
        # on classe les codes pour fg les subtree de la racine vers les feuilles
        set li [lsort -dictionary [array names T $t,gfg,*]]
        foreach key $li {
            set n [string range $key [expr [string last , $key] + 1] end]
            set Le [Tools::NodeNoCoFaToNoCoCh $t $n]
            foreach e $Le {
                foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                    Figuration::NodeColorFgItem $w $j $T($key)
                }
            }
        }
        ###
        # T($t,lfg,$n) restauration des foreground color leaf
        foreach key [array names T $t,lfg,*] {
            set n [string range $key [expr [string last , $key] + 1] end]
            set lab $T($t,ctl,$n)
            $w itemconfigure [list [format "%s%s" EUL  $lab ] && T$t] -fill $T($key)
        }
        ###
        # T($t,gld,$n) restauration des line dash
        set li [lsort -dictionary [array names T $t,gld,*]]
        foreach key  $li {
            set n [string range $key [expr [string last , $key] + 1] end]
            set Le [Tools::NodeNoCoFaToNoCoCh $t $n]
            foreach e $Le {
                foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                    $w itemconfigure $j -dash $T($key)
                }
            }
        }
        ###
        # set T($t,gls,$i)  restauration des line width
        set li [lsort -dictionary [array names T $t,gls,*]]
        foreach key $li {
            set n [string range $key [expr [string last , $key] + 1] end]
            set Le [Tools::NodeNoCoFaToNoCoCh $t $n]
            foreach e $Le {
                foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                    $w itemconfigure $j -width $T($key)
                }
            }
        }
        ###
        # set T($t,gfo,$i)  restauration des font
        foreach key [array names T $t,gfo,*] {
            set n [string range $key [expr [string last , $key] + 1] end]
            set lab $T($t,ctl,$n)
            set i [$w find withtag [list [format "%s%s" EUL  $lab ] && T$t]]
            $w itemconfigure $i -font $T($key)
        }
    }
    #Procedure de restauration des variables graphiques a partir de N
    #independance de l'existence de variable
    proc NodeGraVarRestLOCAL {t n} {
        global S T
        set w $S($t,w)
        set p [format "%s%s" $n *]
        ###
        # T($t,gfg,$n) restauration des foreground color tree
        # on classe les codes pour fg les subtree de la racine vers les feuilles
        set li [lsort -dictionary [array names T $t,gfg,$p]]
        foreach key $li {
            set n [string range $key [expr [string last , $key] + 1] end]
            set Le [Tools::NodeNoCoFaToNoCoCh $t $n]
            foreach e $Le {
                foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                    Figuration::NodeColorFgItem $w $j $T($key)
                }
            }
        }
        ###
        # T($t,lfg,$n) restauration des foreground color leaf
        foreach key [array names T $t,lfg,$p] {
            set n [string range $key [expr [string last , $key] + 1] end]
            set lab $T($t,ctl,$n)
            $w itemconfigure [list [format "%s%s" EUL  $lab ] && T$t] -fill $T($key)
        }
        ###
        # T($t,gld,$n) restauration des line dash
        set li [lsort -dictionary [array names T $t,gld,$p]]
        foreach key  $li {
            set n [string range $key [expr [string last , $key] + 1] end]
            set Le [Tools::NodeNoCoFaToNoCoCh $t $n]
            foreach e $Le {
                foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                    $w itemconfigure $j -dash $T($key)
                }
            }
        }
        ###
        # set T($t,gls,$i)  restauration des line width
        set li [lsort -dictionary [array names T $t,gls,$p]]
        foreach key $li {
            set n [string range $key [expr [string last , $key] + 1] end]
            set Le [Tools::NodeNoCoFaToNoCoCh $t $n]
            foreach e $Le {
                foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                    $w itemconfigure $j -width $T($key)
                }
            }
        }
        ###
        # set T($t,gfo,$i)  restauration des font
        foreach key [array names T $t,gfo,$p] {
            set n [string range $key [expr [string last , $key] + 1] end]
            set lab $T($t,ctl,$n)
            set i [$w find withtag [list [format "%s%s" EUL  $lab ] && T$t]]
            $w itemconfigure $i -font $T($key)
        }
    }
    # T($t,gfg,$n) init des foreground color tree
    # a l'appel n* = les desceandants aussi
    # par defaut l'arbre entier
    proc GraVarInitFgTree {w t {n *}} {
        global T S
        # liste key soit une si n soit peut etre liste si n*, fonction de l'appel
        set li [lsort -dictionary [array names T $t,gfg,$n]]
        foreach key $li {
            # destruction variable
            unset T($key)
            # coloration back to default
            # set node [string range $key [expr [string last , $key] + 1] end]
            set p [format "%s%s" $n *]
            foreach e $T($t,all_cod) {
                if {[string match $p $e] == 1} {
                    foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                        Figuration::NodeColorFgItem $w $j $S(Preference_fgc)
                    }
                }
            }
        }
        # si que n restauration locale sur d'eventuelle variable
        # si n* on a tout detruit donc pas besoin de restauration
        if {[string range $n end end] != "*"} {
            #restauration locale et specifique variable
            set p [format "%s%s" $n *]
            set li [lsort -dictionary [array names T $t,gfg,$p]]
            foreach key $li {
                set n [string range $key [expr [string last , $key] + 1] end]
                set Le [Tools::NodeNoCoFaToNoCoCh $t $n]
                foreach e $Le {
                    foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                        Figuration::NodeColorFgItem $w $j $T($key)
                    }
                }
            }
        }
    }
    #  init des background color tree
    proc GraVarInitBgSubTree {w t {n *}} {
        if {[string range $n end end] == "*"} {
            NodeColorBgSubTreeRemoveAll $t $n
        } else {
            NodeColorBgSubTreeRemove $t $n
        }
    }
    # T($t,lfg,$n) init des foreground color leaf
    proc GraVarInitFgLeaf {w t {n *}} {
        global T S
        if {$n != "*"} {set pattern [format "%s%s" $n *]} {set pattern *}
        foreach key [array names T $t,lfg,$pattern] {
            set n [string range $key [expr [string last , $key] + 1] end]
            set lab $T($t,ctl,$n)
            $w itemconfigure [list [format "%s%s" EUL  $lab ] && T$t] -fill $S(Preference_fgc)
            unset T($key)
        }
    }
    #  init des background color leaf
    proc GraVarInitBgLeaf {w t {n *}} {
        global T S B
        set listid {}
        
        if {$n != "*"} {set p [format "%s%s" $n *]} {set p *}
        foreach {k v} [array get B BGLnod,*] {
            if {[string match $p $v] == 1} {
                lappend listid [string trimleft $k "BGLnod," ]
            }
        }
        foreach id $listid {
            $w delete [format "%s%s%s" BGL ¶ $id]
            set w $S($t,w)
            set t $B(BGLtre,$id)
            foreach key [array names B *,$id] {
                unset B($key)
            }
            set index [lsearch -exact $B($t,bgl) $id]
            set B($t,bgl) [concat [lrange $B($t,bgl) 0 [expr $index - 1]] \
                    [lrange $B($t,bgl) [expr $index + 1] end]]
        }
    }
    
    # set T($t,gfo,$i)  init des font
    proc GraVarInitFont {w t {n *}} {
        global T S
        foreach key [array names T $t,gfo,$n] {
            set n [string range $key [expr [string last , $key] + 1] end]
            set lab $T($t,ctl,$n)
            $w itemconfigure [list [format "%s%s" EUL  $lab] && T$t] -font $S(fontbase)
            unset T($key)
        }
    }
    # T($t,gls,$c) la taille du trait
    proc GraVarInitLineWidth {w t {n *}} {
        global T
        set li [lsort -dictionary [array names T $t,gls,$n]]
        foreach key $li {
            set n [string range $key [expr [string last , $key] + 1] end]
            set p [format "%s%s" $n *]
            set listeitems {}
            foreach e $T($t,all_cod) {
                if {[string match $p $e] == 1} {
                    foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                        lappend listeitems $j
                    }
                }
            }
            foreach i $listeitems {
                $w itemconfigure $i -width 1
            }
            unset T($key)
        }
    }
    # T($t,gld,$c) le pointille du trait
    proc GraVarInitLineDash {w t {n *}} {
        global T
        set li [lsort -dictionary [array names T $t,gld,$n]]
        foreach key  $li {
            set n [string range $key [expr [string last , $key] + 1] end]
            set p [format "%s%s" $n *]
            set listeitems {}
            foreach e $T($t,all_cod) {
                if {[string match $p $e] == 1} {
                    foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                        lappend listeitems $j
                    }
                }
            }
            foreach i $listeitems {
                $w itemconfigure $i -dash {}
            }
            unset T($key)
        }
    }
    # reset general de tous les arbres de toutes les fenetres
    proc ResetGlob {} {
        global S
        set l {}
        foreach key [array names S *,w] {
            foreach t $S($S($key),t) {
                if {[lsearch -exact $l $t] == -1} {lappend l $t}
            }
        }
        foreach t $l  {
            Figuration::NodeGraVarInit $t
        }
    }
    # procedure de suppression de toutes les variables graphiques
    proc NodeGraVarInit  {t} {
        global S T
        set w $S($t,w)
        # init des foreground color tree
        GraVarInitFgTree $w $t
        #  init des background color tree
        GraVarInitBgSubTree $w $t
        #  init des background color leaf
        GraVarInitBgLeaf $w $t
        # T($t,lfg,$n) init des foreground color leaf
        GraVarInitFgLeaf $w $t
        # set T($t,gfo,$i)  init des font
        GraVarInitFont $w $t
        # T($t,gls,$c) la taille du trait
        GraVarInitLineWidth $w $t
        # T($t,gld,$c) le pointille du trait
        GraVarInitLineDash $w $t
    }
    proc GraVarInitAllN {w t n} {
        GraVarInitFgTree $w $t $n
        GraVarInitBgSubTree $w $t $n
        GraVarInitBgLeaf $w $t $n
        GraVarInitFgLeaf $w $t $n
        GraVarInitFont $w $t $n
        GraVarInitLineWidth $w $t $n
        GraVarInitLineDash $w $t $n
    }
    # fonction de copy des variables graphiques d'un arbre vers un autre
    ## c un peu magique mais ca marche, il y a corespondance
    ## exacte entre les codes tsource/ttarget, cela vient de la procedure NodeNoCoFaToNoCoCh
    proc TransitionVG {w tsource npere ttarget}   {
        global T S B
        set lnodesFrom [Tools::NodeNoCoFaToNoCoCh $tsource $npere]
        set lnodesTo [Tools::NodeNoCoFaToNoCoCh $ttarget $ttarget]
        foreach nf $lnodesFrom nt $lnodesTo {
            set transition($nf) $nt
        }
        set lnodesFrom2 [lsort -dictionary [Tools::NodeFathers $tsource $npere]]
        foreach nf $lnodesFrom2  {
            set transition2($nf) $ttarget
        }
        # GROUPE 1, on prend en compte les nodes ascendants
        # variables T
        set lvar {gfg lfg gld gls gfo}
        foreach nf $lnodesFrom2  {
            foreach var $lvar {
                if {[catch {set v $T($tsource,$var,$nf)} err]} then {
                    #rien
                } else {
                    set T($ttarget,$var,$transition2($nf)) $v
                }
            }
        }
        # BGL bg leaves
        foreach idbgl $B($tsource,bgl) {
            if {[lsearch -exact $lnodesFrom2 $B(BGLnod,$idbgl)] != -1} {
                Figuration::NodeColorBgLeaf2 $ttarget $transition2($B(BGLnod,$idbgl)) $B(BGLcol,$idbgl)
            }
        }
        # BGS bg subtree
        foreach idbgs $B($tsource,bgs) {
            if {[lsearch -exact $lnodesFrom2 $B(BGSnod,$idbgs)] != -1} {
                Figuration::NodeColorBgSubTree2 $ttarget $transition2($B(BGSnod,$idbgs)) $B(BGScol,$idbgs) $B(BGSsti,$idbgs)
            }
        }
        # GROUPE 2 on ne prend pas en compte les ascendants
        # variables graphiques
        set lvar {gfg lfg gld gls gfo}
        foreach nf $lnodesFrom  {
            foreach var $lvar {
                if {[catch {set v $T($tsource,$var,$nf)} err]} then {
                    #rien
                } else {
                    set T($ttarget,$var,$transition($nf)) $v
                }
            }
        }
        # BGL bg leaves
        foreach idbgl $B($tsource,bgl) {
            if {[lsearch -exact $lnodesFrom $B(BGLnod,$idbgl)] != -1} {
                Figuration::NodeColorBgLeaf2 $ttarget $transition($B(BGLnod,$idbgl)) $B(BGLcol,$idbgl)
            }
        }
        # BGS bg subtree
        foreach idbgs $B($tsource,bgs) {
            if {[lsearch -exact $lnodesFrom $B(BGSnod,$idbgs)] != -1} {
                Figuration::NodeColorBgSubTree2 $ttarget $transition($B(BGSnod,$idbgs)) $B(BGScol,$idbgs) $B(BGSsti,$idbgs)
            }
        }
        # variables B : shi bll ova
        # construction des items (mais array seuleument, pas graphique)
        # BLL
        # on prend les nodes des bll on regarde si ils sont dans la liste des nodes copies
        foreach bi $B($tsource,bll) {
            if {[lsearch -exact $lnodesFrom $B(BLLnod,$bi)] != -1} {
                set co [$w coords $transition($B(BLLnod,$bi))]
                set x [lindex $co 0]
                set y [lindex $co 1]
                set titx  [string first "\n"  $B(BLLtxt,$bi)]
                set titre [string range $B(BLLtxt,$bi) 0 [expr $titx - 1]]
                set text  [string range $B(BLLtxt,$bi) [expr $titx + 1] end]
                # BLLmake2 ne construit que les array
                Annotation::BLLmake2 $w $ttarget $x $y $titre $text $transition($B(BLLnod,$bi)) $B(BLLcol,$bi) $B(BLLgfo,$bi)
            }
        }
        ### OVA
        # on prend les nodes sous decomposition et on regarde si ils sont dans la liste des nodes copies
        foreach idc $B($tsource,ova) {
            if {[lsearch -exact $lnodesFrom $B(OVAnod2,$idc)] != -1} {
                Decomposition::SubTree2 $ttarget $B(OVAtrx,$idc) $B(OVAtry,$idc) $transition($B(OVAnod2,$idc))
            }
        }
        # SHI en dernier
        # il suffit de reconstruire les shrink en partant des plus bas
        # afin d'appliquer le state/tag de visiblite au fur et a mesure
        set lni {}
        # on prend les nodes qui sont shrink et on regarde si ils sont dans la liste des nodes copies
        foreach si $B($tsource,shi) {
            if {[lsearch -exact $lnodesFrom $B(SHInod,$si)] != -1} {lappend lni $B(SHInod,$si)}
        }
        # on ordonne ensuite les codes nodes, les plus profons d'abord, la fct shrink
        # reconstruit la strucutre imbriquee des shrink
        foreach ni [lsort -decreasing $lni] {
            # arguments w t n col stipple type symdx symdy symty
            foreach si $B($tsource,shi) {
                if {$B(SHInod,$si) == $ni} {
                    Abstraction::Shrink2 $w $ttarget $transition($ni) $B(SHIcol,$si)  \
                            $B(SHIsti,$si) $B(SHItyp,$si) $B(SHIsymdx,$si)  $B(SHIsymdy,$si)  $B(SHIsymty,$si)
                }
            }
            
        }
        unset transition
    } 
    ###set S(contour2mode) c ; set S(contour2mode) d ;
    proc NodeColorBgSubTreeToolbox {w command} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            switch -exact $command {
                add1 {NodeColorBgSubTree $t $n}
                remove {NodeColorBgSubTreeRemove $t $n}
                removeall {NodeColorBgSubTreeRemoveAll $t $n}
                menushape {SetDefaultShape $w}
            }
            Figuration::RestaureBGSall $w $t
        }
    }
    proc SetDefaultShape {w} {
        global S
        if {[winfo exists $w.defaultshape] == 1} {destroy $w.defaultshape}
        set m [menu $w.defaultshape -tearoff 0  ]
        $m add command -label "Set default Shape to I" -command "set S(defaultshape) 1"
        $m add command -label "Set default Shape to II" -command "set S(defaultshape) 2"
        $m add command -label "Set default Shape to III" -command "set S(defaultshape) 3"
        $m add command -label "Set default Shape to IV" -command "set S(defaultshape) 3"
        $m add command -label "Set default Shape to V" -command "set S(defaultshape) 5"
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    ### Background color of Subtree
    # on calcule le pourtour du sous-arbre
    # pour etre independant des orientations des arbres et des items
    # on compare les normes des vecteurs entre chaque extremites et
    # une des coordonnees du node pere
    proc NodeColorBgSubTree {t n} {
        global T S B
        set w $S($t,w)
        set id [format "%s%s"  $t [Tools::GenId]]
        # MEM
        set B(BGStre,$id) $t
        set B(BGSnod,$id) $n
        set B(BGScol,$id) $S(col)
        set B(BGSsti,$id) $S(stipple)
        set B(BGStyp,$id) $S(defaultshape)
        # Liste des BGS par tree
        lappend B($t,bgs) $id
        # RestaureBGSall est place ailleurs car trop long en identification
        #Figuration::RestaureBGSall $w $t
    }
    proc NodeColorBgSubTreeSwitch {w i type} {
        global S B
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BGS*]] ¶] end]
        set B(BGStyp,$id) $type
        Figuration::RestaureBGSall $w $B(BGStre,$id)
    }
    proc NodeColorBgSubTreeUpdateStipple {w i} {
        global S B
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BGS*]] ¶] end]
        set B(BGSsti,$id) $S(stipple)
        Figuration::RestaureBGSall $w $B(BGStre,$id)
    }
    #
    proc NodeColorBgSubTreeRemove {t n } {
        global T S B
        set w $S($t,w)
        set listid {}
        foreach {k v} [array get B BGSnod,*] {
            if {$n == $v} {
                lappend listid [string trimleft $k "BGSnod," ]
            }
        }
        foreach id $listid {
            $w delete [format "%s%s%s" BGS ¶ $id]
            set w $S($t,w)
            set t $B(BGStre,$id)
            foreach key [array names B *,$id] {
                unset B($key)
            }
            #retirer
            set index [lsearch -exact $B($t,bgs) $id]
            set B($t,bgs) [concat [lrange $B($t,bgs) 0 [expr $index - 1]] \
                    [lrange $B($t,bgs) [expr $index + 1] end]]
        }
    }
    #
    proc NodeColorBgSubTreeRemoveAll {t n } {
        global T S B
        set w $S($t,w)
        set p [format "%s%s" $n *]
        set listid {}
        foreach {k v} [array get B BGSnod,*] {
            if {[string match $p $v] == 1} {
                lappend listid [string trimleft $k "BGSnod," ]
            }
        }
        foreach id $listid {
            $w delete [format "%s%s%s" BGS ¶ $id]
            set w $S($t,w)
            set t $B(BGStre,$id)
            foreach key [array names B *,$id] {
                unset B($key)
            }
            #retirer
            set index [lsearch -exact $B($t,bgs) $id]
            set B($t,bgs) [concat [lrange $B($t,bgs) 0 [expr $index - 1]] \
                    [lrange $B($t,bgs) [expr $index + 1] end]]
        }
    }
    #
    proc NodeColorBgSubTree2 {t n c s} {
        global T S B
        set id [format "%s%s"  $t [Tools::GenId]]
        # MEM
        set B(BGStre,$id) $t
        set B(BGSnod,$id) $n
        set B(BGScol,$id) $c
        set B(BGSsti,$id) $s
        # Liste des BGS par tree
        lappend B($t,bgs) $id
    }
    #
    proc NodeColorBgSubTreeDelete {w i} {
        global B S
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BGS*]] ¶] end]
        $w delete [format "%s%s%s" BGS ¶ $id]
        set t $B(BGStre,$id)
        set w $S($t,w)
        foreach key [array names B *,$id] {
            unset B($key)
        }
        #retirer
        set index [lsearch -exact $B($t,bgs) $id]
        set B($t,bgs) [concat [lrange $B($t,bgs) 0 [expr $index - 1]] \
                [lrange $B($t,bgs) [expr $index + 1] end]]
    }
    #
    proc NodeColorBgSubTreeUpateColor {w i c} {
        global B S
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BGS*]] ¶] end]
        $w itemconfigure  [format "%s%s%s" BGS ¶ $id] -fill $c -outline $c
        set B(BGScol,$id) $c
    }
    proc NodeColorBgSubTreeContourSwitch {w t n mode} {
        switch $mode {
            1 {set lxy [NodeColorBgSubTreeContour $w $t $n]}
            2 {set lxy [NodeColorBgSubTreeContour2 $w $t $n 2]}
            3 {set lxy [NodeColorBgSubTreeContour2 $w $t $n 3]}
            4 {set lxy [NodeColorBgSubTreeContour2 $w $t $n 4]}
            5 {set lxy [NodeColorBgSubTreeContour2 $w $t $n 5]}
        }
        return $lxy
    }
    ###
    proc NodeColorBgSubTreeContourTriangle {w t n} {
        set co [$w coords $n]
        set xo [lindex $co 0]
        set yo [lindex $co 1]
        set xmax $xo
        set ymin $yo
        set ymax $yo
        set leafs [Tools::NodeNoToLe $t $n]
        puts $leafs
        foreach f $leafs {
            set tag [format "%s%s" $f C]
            set co [$w coords $tag]
            set xi [lindex $co 0]
            set yi [lindex $co 1]
            if {$xi >= $xmax} {set xmax $xi}
            if {$yi >= $ymax} {set ymax $yi}
            if {$yi <= $ymin} {set ymin $yi}
        }
        set lxy [list $xo $yo $xmax $ymin $xmax $ymax $xo $yo]
        return $lxy
    }
    ###
    proc NodeColorBgSubTreeContour {w t n} {
        #on trace le polygon du contour du sous-arbre
        # depart
        set lxy {}
        set leafs [Tools::NodeNoToLe $t $n]
        set nodes [Tools::SousL [Tools::NodeNoCoFaToNoCoCh $t $n] $n]
        set sbase [string length $n]
        if {[llength $leafs] != 1 } {
            # descandants gauche y compris feuilles
            set ldesgauche {}
            foreach ni [lsort -increasing $nodes] {
                set suffixe [string range $ni $sbase end]
                if {[string match *d* $suffixe] == 0} {
                    lappend ldesgauche $ni
                }
            }
            # ascendants droits y compris feuilles
            set lascdroit {}
            foreach ni [lsort -decreasing $nodes] {
                set suffixe [string range $ni $sbase end]
                if {[string match *g* $suffixe] == 0} {
                    lappend lascdroit $ni
                }
            }
            # feuilles intermediaires (sans les descandants feuilles g et d)
            set leafsinter [Tools::SousL $leafs [concat $ldesgauche  $lascdroit]]
            # coordonnees
            set lxy {}
            # la base
            set npap [Tools::NodeParentNode $t $n]
            if {$npap == $t || $npap == ""} {
                set npap [format "%s%s" $t C]
            }
            set conp [$w coords $npap]
            set xp [lindex $conp 0]
            set yp [lindex $conp 1]
            
            if {$n  == $t || $n == ""} {
                set n2 [format "%s%s" $t C]
            } else  {
                set n2 $n
            }
            # NB pb avec les copy paste
            set coni [$w coords $n2]
            set x1 [lindex $coni 0]
            set y1 [lindex $coni 1]
            set x2 [lindex $coni 2]
            set y2 [lindex $coni 3]
            set norm1 [expr sqrt((($xp - $x1) * ($xp - $x1)) + (($yp - $y1) * ($yp - $y1)))]
            set norm2 [expr sqrt((($xp - $x2) * ($xp - $x2)) + (($yp - $y2) * ($yp - $y2)))]
            if  {$norm1 <= $norm2} {
                lappend lxy [list $x2 $y2]
            } else  {
                lappend lxy [list $x1 $y1]
            }
            # descandants gauche
            foreach i  $ldesgauche {
                set npap [Tools::NodeParentNode $t $i]
                if {$npap == $t} {
                    set npap [format "%s%s" $t C]
                }
                set conp [$w coords $npap]
                set xp [lindex $conp 0]
                set yp [lindex $conp 1]
                set coni [$w coords $i]
                set x1 [lindex $coni 0]
                set y1 [lindex $coni 1]
                set x2 [lindex $coni 2]
                set y2 [lindex $coni 3]
                set norm1 [expr sqrt((($xp - $x1) * ($xp - $x1)) + (($yp - $y1) * ($yp - $y1)))]
                set norm2 [expr sqrt((($xp - $x2) * ($xp - $x2)) + (($yp - $y2) * ($yp - $y2)))]
                if  {$norm1 <= $norm2} {
                    lappend lxy [list $x1 $y1 $x2 $y2]
                } else  {
                    lappend lxy [list $x2 $y2 $x1 $y1]
                }
            }
            # feuilles
            foreach i  $leafsinter {
                set npap [Tools::NodeParentNode $t $i]
                if {$npap == $t} {
                    set npap [format "%s%s" $t C]
                }
                set conp [$w coords $npap]
                set xp [lindex $conp 0]
                set yp [lindex $conp 1]
                set coni [$w coords $i]
                set x1 [lindex $coni 0]
                set y1 [lindex $coni 1]
                set x2 [lindex $coni 2]
                set y2 [lindex $coni 3]
                set norm1 [expr sqrt((($xp - $x1) * ($xp - $x1)) + (($yp - $y1) * ($yp - $y1)))]
                set norm2 [expr sqrt((($xp - $x2) * ($xp - $x2)) + (($yp - $y2) * ($yp - $y2)))]
                if  {$norm1 <= $norm2} {
                    lappend lxy [list $x2 $y2]
                } else  {
                    lappend lxy [list $x1 $y1]
                }
            }
            # ascendants droits
            foreach i  $lascdroit {
                set npap [Tools::NodeParentNode $t $i]
                if {$npap == $t} {
                    set npap [format "%s%s" $t C]
                }
                set conp [$w coords $npap]
                set xp [lindex $conp 0]
                set yp [lindex $conp 1]
                set coni [$w coords $i]
                set x1 [lindex $coni 0]
                set y1 [lindex $coni 1]
                set x2 [lindex $coni 2]
                set y2 [lindex $coni 3]
                set norm1 [expr sqrt((($xp - $x1) * ($xp - $x1)) + (($yp - $y1) * ($yp - $y1)))]
                set norm2 [expr sqrt((($xp - $x2) * ($xp - $x2)) + (($yp - $y2) * ($yp - $y2)))]
                if  {$norm1 <= $norm2} {
                    lappend lxy [list $x2 $y2 $x1 $y1]
                } else  {
                    lappend lxy [list $x1 $y1 $x2 $y2]
                }
            }
            regsub -all "\{" $lxy "" lxy
            regsub -all "\}" $lxy "" lxy
        } else  {
            set lxy [$w coords $n]
        }
        return $lxy
    }
    #
    ### NodeColorBgSubTreeContour2 un background tree en rectangle
    proc NodeColorBgSubTreeContour2 {w t n mode} {
        global S T
        # x1 (partie commune)
        if {$n == $t || $n == ""} {
            set n [format "%s%s" $t C]
        }
        set cop [$w coords $n]
        set xp1 [lindex $cop 0]
        set xp2 [lindex $cop 2]
        if {$xp1 < $xp2} {
            set x1 $xp1
        } else  {
            set x1 $xp2
        }
        # x2 (xmax) y1 (ymin) y2 (ymax)
        set leafs [Tools::NodeNoToLe $t $n]
        set x2 0 ; set y1 100000 ; set y2 0
        # NB pas de switch sur 1 qui correpond au contour 1
        switch -exact $mode {
            2 {
                foreach i  $leafs {
                    # le texte des feuilles n'est pas pris en compte
                    set coi [$w coords $i]
                    set xi1 [lindex $coi 0]
                    set yi1 [lindex $coi 1]
                    set xi2 [lindex $coi 2]
                    set yi2 [lindex $coi 3]
                    # x2
                    if {$xi1 > $xi2} {
                        if {$xi1 > $x2} {set x2 $xi1}
                    } else  {
                        if {$xi2 > $x2} {set x2 $xi2}
                    }
                    # y1 et y2
                    if {$yi1 > $yi2} {
                        # y1: on regarde yi2
                        if {$yi2 < $y1} {set y1 $yi2}
                        # y2: on regarde yi1
                        if {$yi1 > $y2} {set y2 $yi1}
                    } else  {
                        # y1: on regarde yi1
                        if {$yi1 < $y1} {set y1 $yi1}
                        # y2: on regarde yi2
                        if {$yi2 > $y2} {set y2 $yi2}
                    }
                }
            }
            3 {
                # prise en compte des texte feuilles
                foreach i  $leafs {
                    set ii [$w find withtag [list [format "%s%s" EUL $T($t,ctl,$i)] && T$t]]
                    set coi [$w bbox $ii]
                    # le texte des feuilles n'est pas pris en compte
                    #set coi [$w coords $i]
                    set xi1 [lindex $coi 0]
                    set yi1 [lindex $coi 1]
                    set xi2 [lindex $coi 2]
                    set yi2 [lindex $coi 3]
                    # x2
                    if {$xi1 > $xi2} {
                        if {$xi1 > $x2} {set x2 $xi1}
                    } else  {
                        if {$xi2 > $x2} {set x2 $xi2}
                    }
                    # y1 et y2
                    if {$yi1 > $yi2} {
                        # y1: on regarde yi2
                        if {$yi2 < $y1} {set y1 $yi2}
                        # y2: on regarde yi1
                        if {$yi1 > $y2} {set y2 $yi1}
                    } else  {
                        # y1: on regarde yi1
                        if {$yi1 < $y1} {set y1 $yi1}
                        # y2: on regarde yi2
                        if {$yi2 > $y2} {set y2 $yi2}
                    }
                }
            }
            4 {
                # cas d'un xmax commun a tous les backgrounds, non prise en compte des annotations
                set coi [$w bbox [list T$t && L]]
                set x2 [lindex $coi 2]
                foreach i  $leafs {
                    set tagi [format "%s%s" EUL $T($t,ctl,$i)]
                    #set coi [$w coords $tagi]
                    set coi [$w bbox [list $tagi && T$t]]
                    set xi1 [lindex $coi 0]
                    set yi1 [lindex $coi 1]
                    set xi2 [lindex $coi 2]
                    set yi2 [lindex $coi 3]
                    # y1 et y2
                    if {$yi1 > $yi2} {
                        # y1: on regarde yi2
                        if {$yi2 < $y1} {set y1 $yi2}
                        # y2: on regarde yi1
                        if {$yi1 > $y2} {set y2 $yi1}
                    } else  {
                        # y1: on regarde yi1
                        if {$yi1 < $y1} {set y1 $yi1}
                        # y2: on regarde yi2
                        if {$yi2 > $y2} {set y2 $yi2}
                    }
                }
            }
            5 {
                # cas d'un xmax commun a tous les backgrounds, prise en compte des annotations
                set coi [$w bbox T$t]
                set x2 [lindex $coi 2]
                foreach i $leafs {
                    set tagi [format "%s%s" EUL $T($t,ctl,$i)]
                    #set coi [$w coords $tagi]
                    set coi [$w bbox [list $tagi && T$t]]
                    set xi1 [lindex $coi 0]
                    set yi1 [lindex $coi 1]
                    set xi2 [lindex $coi 2]
                    set yi2 [lindex $coi 3]
                    # y1 et y2
                    if {$yi1 > $yi2} {
                        # y1: on regarde yi2
                        if {$yi2 < $y1} {set y1 $yi2}
                        # y2: on regarde yi1
                        if {$yi1 > $y2} {set y2 $yi1}
                    } else  {
                        # y1: on regarde yi1
                        if {$yi1 < $y1} {set y1 $yi1}
                        # y2: on regarde yi2
                        if {$yi2 > $y2} {set y2 $yi2}
                    }
                }
            }
        }
        # redim x2 (du au bounding box du bbox)
        # original  return [list $x1 $y1  [expr $x2 -2] $y1 [expr $x2 -2] $y2 $x1 $y2]
        return [list $x1 [expr $y1 + 3] [expr $x2 -2] [expr $y1 + 3] [expr $x2 -2] [expr $y2 - 3] $x1 [expr $y2 - 3]]
    }
    ###
    proc NodeColorBgLeafToolbox {w command} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            switch -exact $command {
                add {NodeColorBgLeaf $t $n}
                remove  {NodeColorBgLeafRemove $t $n}
            }
        }
    }
    ### foreground color leaf via node pere
    proc NodeColorFgLeaf {t n c} {
        global T S
        set w $S($t,w)
        set leafs [Tools::NodeNoToLe $t $n]
        foreach code $leafs {
            $w itemconfigure [list [format "%s%s" EUL $T($t,ctl,$code)] && T$t] -fill $c
            set T($t,lfg,$code) $c
        }
    }
    ###
    proc NodeColorFgLeafToolbox {w} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            NodeColorFgLeaf $t $n $S(col)
        }
    }
    ###
    proc NodeColorFgLeafToolboxRemove {w} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            GraVarInitFgLeaf $w $t $n
        }
    }
    ###
    proc NodeLineDashToolbox {w o} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            NodeLineDash $t $n $o
        }
    }
    # NodeLineDash
    # variable binaire
    # donc on ne creer une variable graphique que pour l'etat dash
    # et une variable globale pour le noeud a l'origine du sous-arbre
    proc NodeLineDash {t n o} {
        global T S
        set w $S($t,w)
        set p [format "%s%s" $n *]
        set listeitems {}
        foreach e $T($t,all_cod) {
            if {[string match $p $e] == 1} {
                lappend listeitems $e
            }
        }
        # creation d'une variable pour chaque node
        if {$o == "1"} {
            foreach i $listeitems {
                $w itemconfigure $i -dash {2 2}
                $w itemconfigure [format "%s%s" $i C] -dash {2 2}
                set T($t,gld,$i) {2 2}
            }
        } else  {
            # il faut supprimer les variables des nodes issues de $code
            # set pattern [format "%s%s" $n *]
            # foreach key [array names T $t,gld,$pattern] {
            # unset T($key)
            # }
            foreach i $listeitems {
                $w itemconfigure $i -dash {}
                $w itemconfigure [format "%s%s" $i C] -dash {}
                set T($t,gld,$i) {}
            }
        }
    }
    ###
    proc NodeLineWidthToolbox {w o} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if {[string length $o] == "1"} {
                NodeLineWidth $t $n $o
            } {NodeLineWidthSet $t $n $o}
            
        }
    }
    # NodeLineWidth augmente (si o = +) ou diminue ( o = -)
    # la valeur des epaisseurs de traits issus de node
    # donc creation d'une variable graphique propre a chaque element
    # (possiblilite d'avoir des epaisseur differentes pour les arretes de n)
    proc NodeLineWidth {t n o} {
        global T S
        set w $S($t,w)
        set p [format "%s%s" $n *]
        set listeitems {}
        foreach e $T($t,all_cod) {
            if {[string match $p $e] == 1} {
                foreach j [$w find withtag [format "%s%s" $e C]] {
                    set width_line [lindex [$w itemconfigure $j -width] end]
                    set new_wl [expr  abs($width_line $o 1)]
                    $w itemconfigure $j -width $new_wl
                    set T($t,gls,$e) $new_wl
                }
            }
        }
    }
    # cette fonction met l'epaisseur de trait des arretes issues de n
    # a la valeur de l'epaisseur de trait de n augmente/diminue de 1 (toutes
    # les arretes auront la meme epaisseur)
    proc NodeLineWidthSet {t n o} {
        global T S
        if {$o == "++"} {set o +} else {set o -}
        set w $S($t,w)
        set p [format "%s%s" $n *]
        set listeitems {}
        foreach e $T($t,all_cod) {
            if {[string match $p $e] == 1} {
                lappend listeitems $e
            }
        }
        set width_line [lindex [$w itemconfigure $n -width] end]
        set new_wl [expr  abs($width_line $o 1)]
        foreach i $listeitems {
            $w itemconfigure $i -width $new_wl
            $w itemconfigure [format "%s%s" $i C] -width $new_wl
            #set T($t,gls,$i) $new_wl
        }
        # on detruit les variables sous-jacentes
        set pattern [format "%s%s" $n *]
        foreach key [array names T $t,gls,$pattern] {
            unset T($key)
        }
        # on stocke la variable pour le noeud pere
        set T($t,gls,$n) $new_wl
    }
    # le probleme de la presence de multiple arbres ds la meme w et
    # ayant des eu names en commun est resolu via le bbox &&
    proc NodeColorBgLeaf {t n } {
        global T S B
        set w $S($t,w)
        set p [format "%s%s" $n *]
        set listneu {}
        foreach e $T($t,ue_cod) {
            if {[string match $p $e] == 1} {
                lappend listneu $e
            }
        }
        foreach i $listneu {
            set id [format "%s%s"  $t [Tools::GenId]]
            # MEM
            set B(BGLtre,$id) $t
            set B(BGLnod,$id) $i
            set B(BGLcol,$id) $S(col)
            # Liste des BGL par tree
            lappend B($t,bgl) $id
        }
        Figuration::RestaureBGLall $w $t
    }
    #
    proc NodeColorBgLeafRemove {t n } {
        global T S B
        set w $S($t,w)
        set p [format "%s%s" $n *]
        set listid {}
        foreach {k v} [array get B BGLnod,*] {
            if {[string match $p $v] == 1} {
                #lappend listid [string range $k [expr [string first , $k] - 1]] end ]
                lappend listid [string trimleft $k "BGLnod," ]
            }
        }
        foreach id $listid {
            $w delete [format "%s%s%s" BGL ¶ $id]
            set w $S($t,w)
            set t $B(BGLtre,$id)
            foreach key [array names B *,$id] {
                unset B($key)
            }
            #retirer
            set index [lsearch -exact $B($t,bgl) $id]
            set B($t,bgl) [concat [lrange $B($t,bgl) 0 [expr $index - 1]] \
                    [lrange $B($t,bgl) [expr $index + 1] end]]
        }
        Figuration::RestaureBGLall $w $t
    }
    #
    proc NodeColorBgLeafDelete {w i} {
        global B S
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BGL*]] ¶] end]
        $w delete [format "%s%s%s" BGL ¶ $id]
        set t $B(BGLtre,$id)
        foreach key [array names B *,$id] {
            unset B($key)
        }
        #retirer
        set index [lsearch -exact $B($t,bgl) $id]
        set B($t,bgl) [concat [lrange $B($t,bgl) 0 [expr $index - 1]] \
                [lrange $B($t,bgl) [expr $index + 1] end]]
    }
    #
    proc NodeColorBgLeaf2 {t n c} {
        global T S B
        set p [format "%s%s" $n *]
        foreach e $T($t,ue_cod) {
            if {[string match $p $e] == 1} {
                set id [format "%s%s"  $t [Tools::GenId]]
                # MEM
                set B(BGLtre,$id) $t
                set B(BGLnod,$id) $e
                set B(BGLcol,$id) $c
                # Liste des BGL par tree
                lappend B($t,bgl) $id
            }
        }
    }
    ### idem NodeColorBgLeaf mais l'argument est une liste de leafs et non un code node pere
    proc EUColorBgLeaf {t eus c} {
        global T S B
        set w $S($t,w)
        foreach i $eus {
            set id [format "%s%s"  $t [Tools::GenId]]
            # MEM
            set B(BGLtre,$id) $t
            set B(BGLnod,$id) $T($t,ltc,$i)
            #set B(BGLcol,$id) $S(col)
            set B(BGLcol,$id) $c
            # Liste des BGL par tree
            lappend B($t,bgl) $id
        }
        Figuration::RestaureBGLall $w $t
    }
    ### couleur d'ecriture des text leaf, arg = liste eu
    proc EUColorFgLeaf {t eus c} {
        global T S
        set w $S($t,w)
        foreach i $eus {
            set tag [list [format "%s%s" EUL  $i ] && T$t]
            # creation des variables graphiques
            #set T($t,lfg,$T($t,ltc,$i)) $S(col)
            set T($t,lfg,$T($t,ltc,$i)) $c
            # dessin
            $w itemconfigure $tag -fill $c
        }
    }
    ###
    proc NodeColorFgTag {w tag color} {
        set listeitems [$w find withtag $tag]
        foreach i $listeitems  {
            switch [$w type $i] {
                line - text  {
                    $w itemconfigure $i -fill $color
                }
                rectangle - polygon - oval - arc {
                    $w itemconfigure $i -outline $color
                }
            }
        }
    }
    ###
    proc NodeColorFgItem {w item color} {
        switch [$w type $item] {
            line   {
                $w itemconfigure $item -fill $color
            }
            rectangle - polygon - oval - arc {
                $w itemconfigure $item -outline $color
            }
        }
    }
    ###
    proc NodeColorFgTreeToolbox {w} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            NodeColorFgTree $t $n $S(col)
        }
    }
    ###
    proc NodeColorFgTreeToolboxRemove {w} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            GraVarInitFgTree $w $t $n
        }
    }
    ### cette fonction modifie la valeur $T($ti,gfg,$node) (affecte $color)
    ### elle est utilisee par la localisation et NodeColorFgTreeToolbox
    proc NodeColorFgTree {t code color} {
        global T S
        set w $S($t,w)
        set p [format "%s%s" $code *]
        set listeitems {}
        foreach e $T($t,all_cod) {
            if {[string match $p $e] == 1} {
                foreach j [$w find withtag [format "%s%s" $e C]] {
                    NodeColorFgItem $w $j $color
                }
            }
        }
        # il faut supprimer les variables des nodes issues de $code
        set pattern [format "%s%s" $code *]
        foreach key [array names T $t,gfg,$pattern] {
            unset T($key)
        }
        # on cree la variable graphique pour le node pere seuleument
        set T($t,gfg,$code) $color
    }
    ### cette fonction modifie la valeur $T($ti,gfg,$node) (affecte $color)
    ### elle est utilisee par la localisation et NodeColorFgTreeToolbox
    proc NodeColorFgTreeNoMem {t code color} {
        global T S
        set w $S($t,w)
        set p [format "%s%s" $code *]
        set listeitems {}
        foreach e $T($t,all_cod) {
            if {[string match $p $e] == 1} {
                foreach j [$w find withtag [list [format "%s%s" $e C] && T$t]] {
                    lappend listeitems $j
                }
            }
        }
        foreach i $listeitems {
            NodeColorFgItem $w $i $color
        }
    }
    ###
    proc CatchColor {w} {
        global S
        set i [$w find withtag current]
        set color ""
        switch [$w type $i] {
            rectangle - polygon - oval - line - text {
                set color [lindex [$w itemconfigure $i -fill] end]
            }
            arc {
                set color [lindex [$w itemconfigure $i -outline] end]
            }
        }
        if {$color != ""} {
            set S(col) $color
            if {[winfo exists .colorpanel.sample] == 1} {.colorpanel.sample configure -background $S(col)}
            set winwin [format "%s%s%s" .colorpanel.dic. $S(col) .b]
            if {[winfo exists $winwin] == 1} {$winwin select}
        }
    }
    ###
    proc CatchFont {w} {
        global S
        set i [$w find withtag current]
        set font ""
        switch [$w type $i] {
            text {
                set font [lindex [$w itemconfigure $i -font] end]
            }
        }
        if {$font != ""} {
            set S(gfo) $font
            foreach {var val} $font {
                set S($var) $val
            }
            if {[winfo exists .fontpanel.msg] == 1} {.fontpanel.msg configure -font $S(gfo)}
        }
    }
    
    ###
    proc FontWeight {w} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set leafs [Tools::NodeNoToLe $t $n]
            foreach code $leafs {
                set i [$w find withtag [list [format "%s%s" EUL $T($t,ctl,$code)] && T$t]]
                set f [lindex [$w itemconfigure  $i -font] end]
                set fnew {}
                foreach {var val} $f {
                    if {$var == "-weight"} {
                        if {$val == "bold"} {set val normal} {set val bold}
                    }
                    lappend fnew $var $val
                }
                set T($t,gfo,$code) $fnew
                $w itemconfigure $i -font $fnew
            }
        }
    }
    ###
    proc FontSlant {w} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set leafs [Tools::NodeNoToLe $t $n]
            foreach code $leafs {
                set i [$w find withtag [list [format "%s%s" EUL $T($t,ctl,$code)] && T$t]]
                set f [lindex [$w itemconfigure $i  -font] end]
                set fnew {}
                foreach {var val} $f {
                    if {$var == "-slant"} {
                        if {$val == "roman"} {set val italic} {set val roman}
                    }
                    lappend fnew $var $val
                }
                set T($t,gfo,$code) $fnew
                $w itemconfigure $i  -font $fnew
            }
            
        }
    }
    ###
    proc FontOverstrike {w} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set leafs [Tools::NodeNoToLe $t $n]
            foreach code $leafs {
                set i [$w find withtag [list [format "%s%s" EUL $T($t,ctl,$code)] && T$t]]
                set f [lindex [$w itemconfigure $i -font] end]
                set fnew {}
                foreach {var val} $f {
                    if {$var == "-overstrike"} {
                        if {$val == "true"} {set val false} {set val true}
                    }
                    lappend fnew $var $val
                }
                set T($t,gfo,$code) $fnew
                $w itemconfigure $i -font $fnew
            }
        }
    }
    ###
    proc FontUnderline {w} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set leafs [Tools::NodeNoToLe $t $n]
            foreach code $leafs {
                set i [$w find withtag [list [format "%s%s" EUL $T($t,ctl,$code)] && T$t]]
                set f [lindex [$w itemconfigure $i -font] end]
                set fnew {}
                foreach {var val} $f {
                    if {$var == "-underline"} {
                        if {$val == "true"} {set val false} {set val true}
                    }
                    lappend fnew $var $val
                }
                set T($t,gfo,$code) $fnew
                $w itemconfigure $i -font $fnew
            }
        }
    }
    ### OK
    proc FontSize {w mode} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set leafs [Tools::NodeNoToLe $t $n]
            foreach code $leafs {
                set i [$w find withtag [list [format "%s%s" EUL $T($t,ctl,$code)] && T$t]]
                set f [lindex [$w itemconfigure $i -font] end]
                set fnew {}
                foreach {var val} $f {
                    if {$var == "-size"} {
                        if {$mode == "+"} {set val [incr val]} {set val [incr val -1]}
                    }
                    lappend fnew $var $val
                }
                set T($t,gfo,$code) $fnew
                $w itemconfigure $i -font $fnew
            }
        }
    }
    ### OK
    proc FontSetGlobalToolbox {w} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            FontSetGlobal $t $n $S(gfo)
            
        }
    }
    ### Font du panel Font, via un node pere
    proc FontSetGlobal {t n font} {
        global T S
        set w $S($t,w)
        set leafs [Tools::NodeNoToLe $t $n]
        foreach code $leafs {
            $w itemconfigure [list [format "%s%s" EUL $T($t,ctl,$code)] && T$t] -font $font
            set T($t,gfo,$code) $font
        }
    }
    ### Font du panel Font, via une liste d'eu
    proc FontSetGlobalEU {t eus font} {
        global T S
        set w $S($t,w)
        foreach eu $eus {
            $w itemconfigure [list [format "%s%s" EUL $eu] && T$t] -font $font
            set T($t,gfo,$T($t,ltc,$eu)) $font
        }
    }
    ###
    proc FontSet {t w n variable value} {
        global T
        set f [lindex [$w itemconfigure [format "%s%s" $n EUL] -font] end]
        set fnew {}
        foreach {var val} $f {
            if {$var == $variable} {lappend fnew $var $value} {lappend fnew $var $val}
        }
        set T($t,gfo,$n) $fnew
        $w itemconfigure [format "%s%s" $n EUL] -font $fnew
    }
    ###
    proc RecFoSw {t variable value} {
        global T S
        set w [format "%s%s%s" .t $t .c]
        foreach code $T($t,sel) {
            if {[lsearch -exact $T($t,ue_cod) $code] != -1} {
                FontSet $t $w $code $variable $value
            }
        }
        
    }
    
}
################################################################################


################################################################################
# INTEGRATION
################################################################################
namespace eval Integration {
    
    
    
    proc ToolSelect {w} {
        global S
        set operation [string range [$w get] 0 1]
        pack forget [winfo children .int.p]
        switch -glob $operation {
            1 {pack .int.p.p1}
            2 {pack .int.p.p2}
            3 {pack .int.p.p3}
            4 {pack .int.p.p4}
        }
    }
    
    ############################## Integration
    proc IntegrationPanel {} {
        global S
        toplevel .int
        wm title .int "Library"
        wm geometry .int "430x220"
        #
        iwidgets::optionmenu  .int.tools -labeltext "Tool: " -labelpos w \
                -command {.int.p view [.int.tools get]}
        foreach i { "1 Nexus To Newick"
            "2 Newick Concatenation"
            "3 Find & Replace leave names"
            "4 Leaves*Variables matrix annotations to a TreeDyn labels" } {
            .int.tools insert end $i
        }
        iwidgets::notebook .int.p
        grid .int.tools -row 0 -column 0 -sticky ew
        grid .int.p -row 1 -column 0 -sticky news
        grid rowconfigure .int 1 -weight 1
        grid columnconfigure .int 0 -weight 1
        #pack .int.tools -expand yes -fill x
        #pack .int.p -side top -expand yes -fill both
        ####################################### P1 concatenation de fichiers newick
        set p1 [.int.p add -label "2 Newick Concatenation"]
        # boutton d'activation du panel de selection des fichiers a concat
        message $p1.m -width 300 -text "Concatenation of Files (eg. concatenation\
                of multiple newick strings into one file)."
        button $p1.b1 -text "Files to concatenate" -command Integration::FileSelectionPanel
        # list des fichiers a concatener
        set wd [frame $p1.ld ]
        scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
        scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
        listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" -width 40 -height 5
        
        
        puts $wd.l
        
        
        grid $wd.l -row 0 -column 0 -sticky news
        grid $wd.yscroll -row 0 -column 1 -sticky ns
        grid $wd.xscroll -row 1 -column 0 -sticky ew
        grid rowconfigure $wd 0 -weight 1
        grid columnconfigure $wd 0 -weight 1
        set S(FSPtargetfile) [format "%s%s" $S(userDIR)  /?.nwk]
        iwidgets::entryfield $p1.tar -textvariable S(FSPtargetfile) -labeltext "Target File: "
        # nom fichier target
        button $p1.ok -text Ok -command Integration::FileConcatenation
        # pack
        grid $p1.m -row 0 -column 0 -sticky news
        grid $p1.b1 -row 1 -column 0 -sticky news
        grid $wd -row 2 -column 0 -sticky news
        grid $p1.tar -row 3 -column 0 -sticky news
        grid $p1.ok -row 4 -column 0 -sticky news
        grid rowconfigure $p1 2 -weight 1
        grid columnconfigure $p1 0 -weight 1
        
        ####################################### P2 traduction de chaine newick eg orf vers sp
        # from file
        
        set p2 [.int.p add -label "3 Find & Replace leave names"]
        set S(FSPtransFF) [format "%s%s" $S(userDIR)  /]
        message $p2.m -width 300 -text "Find & Replace leave names from a newick string to another.\
                A Labels file is needed (see the user's manual for more details)."
        button $p2.fromfile -text "From File" \
                -command "Integration::TranslationSelectFile {Translation: From File ?} FSPtransFF"
        iwidgets::entryfield $p2.efromfile  -textvariable S(FSPtransFF)
        # translation file
        set S(FSPtransTrF) [format "%s%s" $S(userDIR)  /]
        button $p2.transfile -text "Translation File" \
                -command "Integration::TranslationSelectFile {Translation File ?} FSPtransTrF"
        iwidgets::entryfield $p2.etransfile -textvariable S(FSPtransTrF)
        # to file
        set S(FSPtransTF) [format "%s%s" $S(userDIR)  /?.nwk]
        button $p2.tofile -text "To File" \
                -command "Integration::TranslationSelectFile {Translation: To File ?} FSPtransTF"
        iwidgets::entryfield $p2.etofile -textvariable S(FSPtransTF)
        button $p2.ok -text "Ok" -command Integration::NewickTranslation
        grid $p2.m -row 0 -column 0 -columnspan 2 -sticky news
        grid $p2.fromfile -row 1 -column 0  -sticky news
        grid $p2.efromfile -row 1 -column 1  -sticky news
        grid $p2.transfile -row 2 -column 0  -sticky news
        grid $p2.etransfile -row 2 -column 1  -sticky news
        grid $p2.tofile -row 3 -column 0  -sticky news
        grid $p2.etofile -row 3 -column 1  -sticky news
        grid $p2.ok -row 4 -column 0 -columnspan 2  -sticky news
        grid columnconfigure $p2 1 -weight 1
        
        ####################################### P3 traduction fichier de labels excel vers records treedyn
        set p3 [.int.p add -label "4 Leaves*Variables matrix annotations to a TreeDyn labels"]
        # from file
        set S(MakeLabelFileIN) [format "%s%s" $S(userDIR)  /]
        message $p3.m -width 300 -text "Translation of a Leaves*Variables data matrix \
                to a TreeDyn labels file format (list of records)."
        button $p3.fromfile -text "From File" \
                -command "Integration::TranslationSelectFile {Translation: From File ?} MakeLabelFileIN"
        iwidgets::entryfield $p3.efromfile -textvariable S(MakeLabelFileIN)
        # to file
        set S(MakeLabelFileOUT) [format "%s%s" $S(userDIR)  /?.tlf]
        button $p3.tofile -text "To File" \
                -command "Integration::TranslationSelectFile {Translation: To File ?} MakeLabelFileOUT"
        iwidgets::entryfield $p3.etofile  -textvariable S(MakeLabelFileOUT)
        button $p3.ok -text "Ok" -command Integration::MakeLabelFile
        grid $p3.m -row 0 -column 0 -columnspan 2 -sticky news
        grid $p3.fromfile -row 1 -column 0  -sticky news
        grid $p3.efromfile -row 1 -column 1  -sticky news
        grid $p3.tofile -row 3 -column 0  -sticky news
        grid $p3.etofile -row 3 -column 1  -sticky news
        grid $p3.ok -row 4 -column 0 -columnspan 2  -sticky news
        grid columnconfigure $p3 1 -weight 1
        
        ####################################### P4 NEXUS to NWK
        set p4 [.int.p add -label "1 Nexus To Newick"  ]
        set S(NexusFileIN) [format "%s%s" $S(userDIR)  /]
        message $p4.m -width 300 -text "Nexus to TreeDyn (Newick)."
        button $p4.fromfile -text "Nexus File" \
                -command "Integration::TranslationSelectFile {Translation: From File ?} NexusFileIN"
        iwidgets::entryfield $p4.efromfile -textvariable S(NexusFileIN)
        # to file
        set S(NexusFileOUT) [format "%s%s" $S(userDIR)  /?.nwk]
        button $p4.tofile -text "To File" \
                -command "Integration::TranslationSelectFile {Translation: To File ?} NexusFileOUT"
        
        iwidgets::entryfield $p4.etofile -textvariable S(NexusFileOUT)
        button $p4.ok -text "Ok" -command Integration::NexusToNewick
        grid $p4.m -row 0 -column 0 -columnspan 2 -sticky news
        grid $p4.fromfile -row 1 -column 0  -sticky news
        grid $p4.efromfile -row 1 -column 1  -sticky news
        grid $p4.tofile -row 3 -column 0  -sticky news
        grid $p4.etofile -row 3 -column 1  -sticky news
        grid $p4.ok -row 4 -column 0 -columnspan 2  -sticky news
        grid columnconfigure $p4 1 -weight 1
        
        
        .int.p view "1 Nexus To Newick"
        
    }
    
    ### renvoie une chaine newick a partir d'un fichier nexus
    proc NexusToNewick {} {
        global S
        set fSource $S(NexusFileIN)
        set fTarget $S(NexusFileOUT)
        if {$fSource != "" && $fTarget != ""} {
            if [catch {open $fSource r} fidS] {
                puts stderr "Error Opening File"
            } else {
                set s [read $fidS]
                regsub -all "\n" $s "" s
                regsub -all {\[} $s "" s
                # suppression des signes - sur les longueurs de branches
                #regsub -all {:-} $s ":" s
                regsub -all {\]} $s "" s
                
                
                #OK puts $s
                set fidT [open $fTarget w]
                # un petit regexp pour  recuperer dans blaa la liste des feuilles 1 BLSK, 2 SHSFH, 3 SGGSS
                regexp {Translate(.+?);} $s bla blaa
                #OK puts $blaa
                # un petit foreach pour ranger dans une liste $l les nom des feuilles {BLSK SHSFH SGGSS}
                foreach e $blaa {
                    if {[regexp {^[0-9]+$} $e ] ==0} {
                        regexp {[^,]+} $e e1
                        lappend l $e1
                    }
                }
                # un petit regexp de nouveau pour recuperer dans blaa1 l'arbre en format ((1:346.34,2:56.6):876.9,3:1.9)
                # original regexp {;[^(]+([^;]+);(E|e)nd;} $s bla1 blaa1
                regexp {;[^(]+([^;]+);(E|e)nd;} $s bla1 blaa1
                # initialisation de la variable qui va contenir le resultat final
                set Nick {}
                set i 0
                # un petit regsub pour spliter $blaa1 de la forme ((1,2),3) pour la forme ( ( 1 , 2 ) , 3 )
                # pour traiter blaa1 comme une liste avec un foreach
                # Tout d'abord l'arbre a t'il des longueur de feuilles ou faut-il en mettre?
                if [regexp : $blaa1] {
                    regsub -all {(\(|,|\)|:)} $blaa1 { & } blaa1
                    # un petit foreach pour remplacer dans l'expression $blaa1 les chiffres par le nom
                    # des feuilles stocke dans $l
                    foreach e $blaa1 {
                        if {[regexp {^[0-9]+$} $e] & [lindex $blaa1 [expr $i+1]] == ":"} {
                            set Nick $Nick[lindex $l [expr $e -1]]
                        } elseif [string equal $e ")"] {
                            set Nick $Nick)
                        } {
                            set Nick $Nick$e
                        }
                        incr i
                    }
                } {
                    regsub -all {(\(|,|\))} $blaa1 { & } blaa1
                    # un petit foreach pour remplacer dans l'expression $blaa1 les chiffres par le nom
                    # des feuilles stocke dans $l
                    foreach e $blaa1 {
                        if [regexp {^[0-9]+$} $e] {
                            set Nick $Nick[lindex $l [expr $e -1]]:1.0
                        } elseif [string equal $e ")"] {
                            set Nick $Nick):1.0
                        } {
                            set Nick $Nick$e
                        }
                    }
                    
                }
                # et c'est fini
                #return $Nick
                puts $fidT "$Nick ;"
                close $fidT
                close $fidS
            }
        }
    }
    # traductoin fichier matrice leaves*variables vers fichier records label file fo treedyn
    proc MakeLabelFile {} {
        global S
        set fSource $S(MakeLabelFileIN)
        set fTarget $S(MakeLabelFileOUT)
        if {$fSource != "" && $fTarget != ""} {
            set fidS [open $fSource r]
            set fidT [open $fTarget w]
            # premiere ligne = liste de variable
            set nbrows 1
            set lrowsBad ""
            gets $fidS variables
            while {[eof $fidS] != 1} {
                incr nbrows
                gets $fidS row
                # verification a faire sur le nombre de valeurs correspondant nombre de variables
                set data ""
                if {[llength $variables] == [llength $row]} {
                    # le premier couple var val doit etre EU / $eu on ecrit que $eu sans {}
                    set data   [lindex $row 0 0]
                    #ok
                    foreach var [lrange $variables 1 end] val [lrange $row 1 end]   {
                        set data   [concat $data $var [format "%s%s%s" "{" $val "}"]]
                    }
                    puts $fidT $data
                } else  {
                    # attention si retour charriot sur la derniere ligne du fichier
                    if {$row != ""}  {
                        set lrowsBad [concat $lrowsBad "Row: $nbrows ([lindex $row 0]) \n"]
                    }
                }
            }
            if {$lrowsBad != ""} {
                tk_messageBox -type ok -default ok -icon warning \
                        -message "Missing non-paired item/value list ($fSource):\n $lrowsBad"
            }
            close $fidS
            close $fidT
        }
    }
    #### Panel de selection de fichiers
    proc FileSelectionPanel {} {
        global S
        
        set typelist {
            {"All Files" {*}}
            {"Newick Files" {.nwk .tree .txt}}
            {"TreeDyn TDY Files" {.tdy}}
            {"TreeDyn TGF Files" {.tgf}}
        }
        set files [tk_getOpenFile -initialdir $S(userDIR) \
                -multiple true -title "Open Tree(s) File(s)" -filetypes $typelist]
        # ne pa changer la dir (cd ..) courante sinon les extensions...
        if {$files != ""} {
            set S(userDIR) [file dirname $files]
            foreach f $files {
                .int.p.cs.page0.cs.ld.l insert 0 $f
            }
        }
    }
    #
    proc MIbackfile {} {
        set files [.fsp.lfb.l get 0 end]
        destroy .fsp
        .int.n.canvas.notebook.cs.page1.cs.ld.l delete 0 end
        foreach f $files {
            .int.n.canvas.notebook.cs.page1.cs.ld.l insert 0 $f
        }
    }
    #
    proc MIupdateAvailableFile {} {
        global S
        .fsp.lfa.l delete 0 end
        set filter [.fsp.fi get]
        if {$filter == "ALL"} { set pattern *
        } else  {
            set pattern [format "%s%s" * $filter]
        }
        #[format "%s%s" $S(userDIR)  /?.nwk]
        set AFN [lsort [glob -nocomplain -type f -dir $S(userDIR) $pattern]]
        set S(MultiImportAFN) "[llength $AFN] File(s)"
        foreach f $AFN {
            .fsp.lfa.l insert end [file tail $f]
        }
        MIConfigBg
    }
    #
    proc MIConfigBg {} {
        global S
        # config bg si deja en selection
        set lfselectavecDir {}
        set lfselectsansDir {}
        foreach e [.fsp.lfb.l get 0 end] {
            lappend lfselectsansDir [file tail $e]
            lappend lfselectavecDir $e
        }
        set index 0
        foreach f [.fsp.lfa.l get 0 end] {
            if {[lsearch $lfselectavecDir [format "%s%s%s" $S(userDIR) / $f]] != -1}  {
                .fsp.lfa.l itemconfigure $index -background NavajoWhite2
            } elseif {[lsearch $lfselectsansDir $f] != -1}  {
                .fsp.lfa.l itemconfigure $index -background NavajoWhite3
            } else  {
                .fsp.lfa.l itemconfigure $index -background LightGoldenrodYellow
            }
            incr index
        }
    }
    #
    proc MIupdateDirectories {} {
        global S
        .fsp.ld.l delete 0 end
        foreach d [lsort [glob -nocomplain -type d -dir $S(userDIR) *]] {
            .fsp.ld.l insert end [file tail $d]
        }
        .fsp.ld.l insert 0 ..
    }
    #
    proc MIupdateFol {f} {
        global S
        set S(userDIR) $f
        MIupdateDirectories
        MIupdateAvailableFile
        MIupdateFilter
    }
    #
    proc MIaddFile {} {
        global S
        set li [.fsp.lfa.l curselection] ;# des index
        set lsel {}
        foreach i $li {
            lappend lsel [.fsp.lfa.l get $i]
            .fsp.lfa.l itemconfigure $i -background NavajoWhite2
        }
        set lall2 [.fsp.lfb.l get 0 end]
        .fsp.lfb.l delete 0 end
        foreach e $lsel {
            lappend lall2 [format "%s%s%s" $S(userDIR) / $e]
        }
        foreach e $lall2 {
            .fsp.lfb.l insert 0 $e
        }
        # deselection des fichiers liste available
        .fsp.lfa.l selection clear 0 end
        # conservation dir deja visitees
        if {[lsearch $S(MultiImportDII) $S(userDIR)] == -1} {
            MIupdateFolRebuild
        }
    }
    #
    proc MIaddFileMouse {listbox x y} {
        global S
        set newfile [format "%s%s%s" $S(userDIR) / [.fsp.lfa.l get @$x,$y]]
        .fsp.lfa.l selection clear @$x,$y
        .fsp.lfb.l insert 0 $newfile
        # conservation dir deja visitees
        if {[lsearch $S(MultiImportDII) $S(userDIR)] == -1} {
            MIupdateFolRebuild
        }
    }
    #
    proc MIupdateFolRebuild {} {
        global S
        .fsp.dir.m delete 0 end
        lappend S(MultiImportDII) $S(userDIR)
        foreach e [file volume] {
            .fsp.dir.m add command -label $e -command "Integration::MIupdateFol $e"
        }
        .fsp.dir.m add separator
        foreach e $S(MultiImportDII) {
            .fsp.dir.m add command -label $e -command "Integration::MIupdateFol $e"
        }
    }
    #
    proc MIremFile {} {
        # attention retrait a partir de l'index le plus bat
        # le delete remet a jour les index
        set li [lsort -decreasing [.fsp.lfb.l curselection]] ;# des index
        foreach i $li {
            .fsp.lfb.l delete $i
        }
        # deselection des fichiers liste available
        .fsp.lfa.l selection clear 0 end
    }
    # retrait d'un elt par double-1 sans toucher la selection
    proc MIremFileMouse {listbox x y} {
        $listbox delete @$x,$y
    }
    #
    proc MIupdateDirectoriesMouse {listbox x y} {
        global S
        set repertoire [$listbox get @$x,$y]
        if {$repertoire != ".."} {
            if {[string length $S(ImportDIR)] == 3} {
                set S(ImportDIR) [format "%s%s" $S(userDIR) $repertoire]
            } else  {
                set S(ImportDIR) [format "%s%s%s" $S(userDIR) / $repertoire]
            }
        } else  {
            set S(ImportDIR) [file dirname $S(userDIR)]
        }
        MIupdateDirectories
        MIupdateAvailableFile
    }
    #
    proc MIupdateFilter {} {
        global S
        .fsp.fi select ALL
    }
    #
    proc RobinsonFoulds {} {
    }
    #
    proc TranslationSelectFile  {txt var} {
        global S
        set typelist {
            {"All Files" {*}}
        }
        set file [tk_getOpenFile  -initialdir $S(userDIR)  \
                -filetypes $typelist -defaultextension "*" \
                -title $txt]
        if {$file != ""} {set S(userDIR) [file dirname $file] ; set S($var) $file}
        
    }
    # procedure de changement des noms des feuilles si les noms des feuilles
    # attention ne pas melanger entre des longueurs de branche et des nombres pour des noms de feuilles
    # feuilles : (f:  soit ,f: attention bien cadrer a gauche et a droite, ne pas prendre que $f:)
    # impossible de melanger avec longueurs de branche
    # qui sont soit ":v," soit ":v)"
    proc NewickTranslation {} {
        global S
        set filename $S(FSPtransTrF)
        if [catch {open $filename r} fid] {
            puts stderr "Error Opening File"
        } else {
            set filename2 $S(FSPtransFF)
            if [catch {open $filename2 r} fid2] {
                puts stderr "Error Opening File"
            } else {
                set translation [read $fid]
                set source [read $fid2]
                regsub -all {\n} $source "" source
                set fidTARGET [open $S(FSPtransTF)  a]
                foreach {val var trans} $translation {
                    set feuilleFrom [format "%s%s%s" "\\(" $val ":" ]
                    set feuilleVers [format "%s%s%s" "\(" $trans ":" ]
                    #set feuilleVers [format "%s%s%s" "\(" [string toupper $trans] ":" ]
                    set trouve [regsub  $feuilleFrom $source $feuilleVers source]
                    if {$trouve == 0} {
                        set feuilleFrom [format "%s%s%s" , $val : ]
                        set feuilleVers [format "%s%s%s" , $trans : ]
                        #set feuilleVers [format "%s%s%s" , [string toupper $trans] : ]
                        regsub  $feuilleFrom $source $feuilleVers source
                    }
                }
                puts $fidTARGET $source
                close $fid
                close $fid2
                close $fidTARGET
            }
        }
    }
    proc FileConcatenation {} {
        global S
        set fSource [.int.p.cs.page0.cs.ld.l get 0 end]
        set fTarget $S(FSPtargetfile)
        if {$fSource != "" && $fTarget != ""} {
            set fidT [open $fTarget a]
            foreach f $fSource {
                set fid [open $f r]
                set data [read $fid]
                puts $fidT $data
                close $fid
            }
            close $fidT
        }
    }
}
################################################################################


################################################################################
# ILLUSTRATION
################################################################################
namespace eval Illustration {
    
    proc BracketDrawCreateNode {w shape x y} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            set leafs [Tools::NodeNoToLe $t $n]
            set l1 [lindex $leafs 0]
            set l2 [lindex $leafs end]
            set co1 [$w coords $l1]; set co2 [$w coords $l2]
            set x1 [lindex $co1 0] ; set y1 [lindex $co1 1]
            set x2 [lindex $co2 0] ; set y2 [lindex $co2 1]
            set id [format "%s%s"  NBKT [Tools::GenId]]
            switch -exact $shape {
                bracket {
                    $w create rectangle $x1 $y1 [expr $x1 +5] $y2 \
                            -fill $S(col) -width 1 -tags "nbracket nbracketrec $id DRAW T$t" \
                            -stipple @[file join + stipple $S(stipple)]
                    set ym [expr ($y1 + $y2) / 2.0]
                    $w create text [expr $x1 + 10] $ym -text $S(AnnotateNote) \
                            -anchor w -font $S(gfo) -fill $S(col) -tags "nbracket nbracketext $id DRAW T$t"
                }
            }
            # passage mode move
            set S(tool) move
            bindtags $w [list $S(tool) $w Canvas . all]
        }
    }
    ### Draw bracket, forcer la ligne verticalite
    # possibilite de grande taille, dessin vectoriel
    # shape sera soit bracket soit accolade
    #
    proc BracketDrawCreate {w shape x y} {
        global S
        set id [$w find closest $x $y]
        set tags [$w gettags $id]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$t != ""} {
            set x [$w canvasx $x] ; set y [$w canvasy $y]
            set id [format "%s%s"  BKT [Tools::GenId]]
            set S(bracketdrawOri) $x
            set S(bracketdrawId) $id
            set S(bracketdrawIdT) T$t
            switch -exact $shape {
                bracket {
                    $w create line [expr $x -5] $y $x $y \
                            -fill black -width 1 -tags "bracket $id DRAW T$t"
                    $w create line $x $y $x $y \
                            -fill black -width 1 -tags "bracket $id rubbershape DRAW T$t"
                }
                accolade {
                    #A FAIRE
                }
            }
        }
    }
    #
    proc BracketDrawDrag {w x y} {
        global S
        set x [$w canvasx $x] ; set y [$w canvasy $y]
        set coords [$w coords "rubbershape"]
        set coords [lreplace $coords 2 3 $S(bracketdrawOri) $y]
        eval $w coords "rubbershape" $coords
    }
    #
    proc BracketDrawEnd {w x y} {
        global S
        BracketDrawDrag $w $S(bracketdrawOri) $y
        set x [$w canvasx $x] ; set y [$w canvasy $y]
        $w create line [expr $S(bracketdrawOri) - 5] $y [expr $S(bracketdrawOri) + 1] $y \
                -fill black -width 1 -tags "bracket $S(bracketdrawId) DRAW $S(bracketdrawIdT)"
        $w dtag "rubbershape"
    }
    proc BracketNproperties {w i what} {
        global S
        switch -- $what {
            text {
                set id [$w find withtag [list $i && nbracketext]]
                set co [$w coords $id]
                set xi [lindex $co 0] ; set yi [lindex $co 1]
                
                set col [lindex [$w itemconfigure $id -fill] end]
                set fo [lindex [$w itemconfigure $id -font] end]
                
                set tags [$w gettags $id]
                $w delete $id
                $w create text $xi $yi -text $S(AnnotateNote) \
                        -anchor w -font $fo -fill $col -tags $tags
            }
            color {
                set id [$w find withtag [list $i && nbracketrec]]
                $w itemconfigure $id -fill $S(col)
                set id [$w find withtag [list $i && nbracketext]]
                $w itemconfigure $id -fill $S(col)
            }
            stipple {
                set id [$w find withtag [list $i && nbracketrec]]
                $w itemconfigure $id -stipple @[file join + stipple $S(stipple)]
            }
            font {
                set id [$w find withtag [list $i && nbracketext]]
                $w itemconfigure $id -font $S(gfo)}
        }
    }
    
    #
    proc BracketAddLabel {w i} {
        global S
        set tags [$w gettags $i]
        set id [lindex $tags [lsearch -glob $tags BKT*]]
        $w delete LAB$id
        set cod [$w bbox $id]
        set x [lindex $cod 2]
        set y1 [lindex $cod 1]
        set y2 [lindex $cod 3]
        set y [expr ($y1 + $y2) / 2.0]
        $w create text $x $y -text $S(AnnotateNote) \
                -anchor w \
                -font $S(gfo) -tags "bracket LAB$id $id DRAW"
    }
    #
    proc BracketAlign {w i} {
        global S
        set tags [$w gettags $i]
        set id [lindex $tags [lsearch -glob $tags BKT*]]
        set cod [$w bbox $id]
        set x [lindex $cod 2]
        set bkt [$w find withtag bracket]
        foreach i $bkt {
            set coi [$w bbox $i]
            set newc [list $x [lrange $cod 1 end]]
            $w coords $i $newc
        }
        
    }
    ###
    proc NodeBgContour {w x y} {
        global S B
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set lxy [Figuration::NodeColorBgSubTreeContour $w $t $n]
        set c0 [$w bbox $n]
        set x0 [lindex $c0 0]
        set y0 [lindex $c0 1]
        set id [format "%s%s"  $t [Tools::GenId]]
        set tag [format "%s%s%s" BGS ¶ $id]
        $w create polygon "$x0 $y0 $lxy $x0 $y0" -smooth 1 -splinesteps 100 \
                -fill $S(col) -outline $S(col) -tags "bgtree T$t $tag"
        $w lower bgtree
        # MEM
        set B(BGStre,$id) $t
        set B(BGSnod,$id) $n
        set B(BGScol,$id) $S(col)
        # Liste des BGS par tree
        lappend B($t,bgs) $id
        
    }
    #
    proc NodeIllustration {w x y} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            set co [$w coords $n]
            set x [lindex $co 0]
            set y [lindex $co 1]
            set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
            
            Illustration::drawsymbol  $w $x $y [list T$t AnnotMatrix AM$t $tagC AMatrixCo]
            update
        }
    }
    #
    proc NodeIllustration2 {w x y} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            set co [$w coords $n]
            set y [lindex $co 1]
            set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
            Illustration::drawsymbol  $w $x $y [list T$t AnnotMatrix AM$t $tagC AMatrixCo]
            update
        }
    }
    #
    proc SymbolInsert {w x y} {
        global S
        Illustration::drawsymbol  $w [$w canvasx $x] [$w canvasy $y] [list DRAW symbol]
    }
    proc LillLtoolbox {w x y} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set p [format "%s%s" $n *]
            set leu {}
            foreach e $T($t,ue_cod) {
                if {[string match $p $e] == 1} {
                    lappend leu $T($t,ctl,$e)
                }
            }
            LillL $w $t $leu
        }
    }
    # Leaves Illustration mode Leave
    proc LillL  {w t leu} {
        global T S
        # tag serie
        switch -exact $S($t,type) {
            PhyNJ - ClaSla - ClaRec {
                set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                foreach l $leu {
                    #set l $T($t,ctl,$code)
                    set i [$w find withtag [list ILLL¶$l && T$t]]
                    if {$i == ""} {
                        set i [$w find withtag [list [format "%s%s" EUL  $l] && T$t]]
                        set co [$w coords $i]
                        set y [lindex $co 1]
                        set x [lindex [$w bbox $i] 2]
                    } else  {
                        # cas si plusieurs ajout on recup le i de plus gran x
                        set co [$w coords [lindex $i 0]]
                        set y [lindex $co 1]
                        set x 0
                        foreach ii $i {
                            set xii [lindex [$w bbox $ii] 2]
                            if {$xii >= $x} {
                                set x $xii
                            }
                        }
                    }
                    if {$x != "" && $y != ""} {
                        Illustration::drawsymbol  $w $x $y [list ILLCo¶$l T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo]
                    }
                }
            }
            PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                LillL360bis $w $t $leu
            }
            ClaCir1 - ClaCir2 - ClaCir3 {
                LillL360 $w $t $leu
            }
        }
    }
    #
    proc LillL360 {} {
    }
    #
    proc LillL360bis {} {
    }
    #
    proc LillCtoolbox {w x y } {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set p [format "%s%s" $n *]
            set leu {}
            foreach e $T($t,ue_cod) {
                if {[string match $p $e] == 1} {
                    lappend leu $T($t,ctl,$e)
                }
            }
            LillC $w $t $leu
        }
    }
    # Leaves Illustration mode Columns
    # tab la variable de tabulation entre differentes colonnes
    proc LillC {w t leu } {
        global S ann T
        if {$S(illustration-tabulation) == 1} {
            set S($t,LabelMatrixBase) [expr $S($t,LabelMatrixBase) + $S(TabulationAnnot)]
        }
        #set S($t,LabelMatrixBase) [expr $S($t,LabelMatrixBase) + $S(TabulationAnnot)]
        #
        switch -exact $S($t,type) {
            PhyNJ - ClaSla - ClaRec {
                # recherche x
                
                
                # recherche x
                ################################################################################
                #                 if {$S(illustration-tabulation) == 1} {
                #                     set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                #                     set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                #                     set XMAX3 [lindex [$w bbox [list T$t && AnnotMatrix]] 2]
                #                     if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                #                     if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
                #                     set x [expr $XMAX + $S($t,LabelMatrixBase)]
                #                 } else  {
                #                     set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                #                     set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                #                     if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                #                     set x [expr $XMAX + $S($t,LabelMatrixBase)]
                #                 }
                ################################################################################
                
                set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                set x [expr $XMAX + $S($t,LabelMatrixBase)]
                # tag de colonne
                set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                foreach l $leu {
                    # recherche y (code arrete terminale)
                    set item [$w find withtag [list [format "%s%s" EU  $l ] && T$t]]
                    if {$item != ""} {
                        set co [$w coords $item]
                        set y [lindex $co 1]
                        drawsymbol  $w $x $y [list ILLCo¶$l T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo]
                    }
                }
            }
            PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                # ENCORE DU TRAVAIL A FAIRE
                # PB du rectangle / oval, des zones de dessin arbre en dehors de l'oval
                # LillC360bis $w $t $leu
                LillC360bis2 $w $t $leu
                
            }
            ClaCir1 - ClaCir2 - ClaCir3 {
                LillC360 $w $t $leu
            }
        }
        #Navigation::FitToContents $w
    }
    proc drawsymbol {w x y tags} {
        global S
        set S(symbolcolorfill) $S(col)
        set S(symbolcoloroutline) $S(col)
        set S(symbolstipple) $S(stipple)
        
        switch $S(symboltype) {
            01 {
                # carre rectangle ok
                $w create rectangle [expr $x-$S(symboldx)] [expr $y-$S(symboldy)] [expr $x+$S(symboldx)] [expr $y+$S(symboldy)] \
                        -fill $S(symbolcolorfill) -outline $S(symbolcoloroutline)  \
                        -tags $tags  -stipple @[file join + stipple $S(symbolstipple)]
            }
            02 {
                # cercle/ocal ok
                $w create oval [expr $x-$S(symboldx)] [expr $y-$S(symboldy)] [expr $x+$S(symboldx)] [expr $y+$S(symboldy)] \
                        -fill $S(symbolcolorfill) -outline $S(symbolcoloroutline)  \
                        -tags $tags  -stipple @[file join + stipple $S(symbolstipple)]
            }
            03 {
                # losange ok
                $w create polygon [expr $x-$S(symboldx)] $y $x [expr $y-$S(symboldy)] [expr $x+$S(symboldx)] $y $x [expr $y+$S(symboldy)] \
                        -fill $S(symbolcolorfill) -outline $S(symbolcoloroutline)  \
                        -tags $tags -stipple @[file join + stipple $S(symbolstipple)]
            }
            04 {
                # triangle right ok
                $w create polygon [expr $x-$S(symboldx)] [expr $y-$S(symboldy)]  [expr $x+$S(symboldx)] $y  [expr $x-$S(symboldx)] [expr $y+$S(symboldy)] \
                        -fill $S(symbolcolorfill)  -outline $S(symbolcoloroutline)  \
                        -tags $tags -stipple @[file join + stipple $S(symbolstipple)]
            }
            05 {
                # triangle left ok
                $w create polygon [expr $x+$S(symboldx)] [expr $y-$S(symboldy)]  [expr $x+$S(symboldx)] [expr $y+$S(symboldy)]  [expr $x-$S(symboldx)] $y \
                        -fill $S(symbolcolorfill) -outline $S(symbolcoloroutline)  \
                        -tags $tags -stipple @[file join + stipple $S(symbolstipple)]
            }
            06 {
                # triangle bottom ok
                $w create polygon [expr $x-$S(symboldx)] [expr $y-$S(symboldy)] [expr $x+$S(symboldx)] [expr $y-$S(symboldy)] $x  [expr $y+$S(symboldy)] \
                        -fill $S(symbolcolorfill) -outline $S(symbolcoloroutline)  \
                        -tags $tags -stipple @[file join + stipple $S(symbolstipple)]
            }
            07 {
                # triangle top
                $w create polygon [expr $x-$S(symboldx)] [expr $y+$S(symboldy)] [expr $x+$S(symboldx)] [expr $y+$S(symboldy)] $x  [expr $y-$S(symboldy)] \
                        -fill $S(symbolcolorfill) -outline $S(symbolcoloroutline)  \
                        -tags $tags -stipple @[file join + stipple $S(symbolstipple)]
            }
            08 {
                #case a cocher 0 OK
                $w create rectangle [expr $x-$S(symboldx)] [expr $y-$S(symboldy)] [expr $x+$S(symboldx)] [expr $y+$S(symboldy)] \
                        -outline $S(symbolcoloroutline)  \
                        -tags $tags -stipple @[file join + stipple $S(symbolstipple)]
            }
            09 {
                #case a cocher 1 OK
                $w create rectangle [expr $x-$S(symboldx)] [expr $y-$S(symboldy)] [expr $x+$S(symboldx)] [expr $y+$S(symboldy)] \
                        -outline $S(symbolcoloroutline)  \
                        -tags $tags -stipple @[file join + stipple $S(stipple)]
                $w create line [expr $x-$S(symboldx)] [expr $y-$S(symboldy)] [expr $x+$S(symboldx)] [expr $y+$S(symboldy)] \
                        -fill $S(symbolcolorfill)  \
                        -tags $tags
                $w create line [expr $x-$S(symboldx)] [expr $y+$S(symboldy)] [expr $x+$S(symboldx)] [expr $y-$S(symboldy)] \
                        -fill $S(symbolcolorfill)  \
                        -tags $tags
            }
        }
    }
    proc LillCpolygon {w t leu } {
        global S ann T
        #
        if [catch {expr $S($t,LabelMatrixBase) + $S(TabulationAnnot)} result] {
            set S($t,LabelMatrixBase) $S(TabulationAnnot)
        } else  {
            # tabulation entre colonnes
            # possiblite de rester sur la meme colonne
            if {$S(illustration-tabulation) == 1} {
                set S($t,LabelMatrixBase) $result
            }
        }
        #
        switch -exact $S($t,type) {
            PhyNJ - ClaSla - ClaRec {
                # recherche x
                if {$S(illustration-tabulation) == 1} {
                    set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                    set XMAX3 [lindex [$w bbox [list T$t && AnnotMatrix]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
                    set x [expr $XMAX + $S($t,LabelMatrixBase)]
                } else  {
                    set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    set x [expr $XMAX + $S($t,LabelMatrixBase)]
                }
                # tag de colonne
                set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                foreach l $leu {
                    # recherche y (code arrete terminale)
                    set item [$w find withtag [list [format "%s%s" EU  $l ] && T$t]]
                    if {$item != ""} {
                        set co [$w coords $item]
                        set y [lindex $co 1]
                        # avoir 2 caracteres pour bon centrage
                        #set illtxt [concat " " [lindex $S(ill-car-fon) 0 ]]
                        #set illfon [lrange $S(ill-car-fon) 1 end]
                        set illtxt [concat " " $S(ill-car) ]
                        set illfon $S(ill-fon)
                        
                        # On va chercher pour la variable en selection la liste des coords du polygon a trace
                        # f est un facteur d'amplification Ã  appliquer sur les coord du polygon
                        # x et y sont utiliser pour appliquer une translation en x et y respectivement
                        set item [$w create text $x $y  \
                                -text $illtxt \
                                -anchor center  -justify center \
                                -fill $S(col) \
                                -font $illfon \
                                -tags "ILLCo¶$l T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo"]
                        $w raise $item
                        update
                    }
                }
            }
            PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
            }
            ClaCir1 - ClaCir2 - ClaCir3 {
            }
        }
    }
    ###
    proc LillC360 {w t leu} {
        global S ann T
        set d $S($t,LabelMatrixBase)
        set co [$w bbox [list Z && T$t]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        
        set C(dx) [expr abs(($x2 - $x1)) /2.0]
        set C(dy) [expr abs(($y2 - $y1)) /2.0]
        set a_ref [expr 360.0/ [llength $T($t,ue_cod)]] ;# unite d'angle
        set n 0
        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
        if { $S($t,type) == "ClaCir2"} {
            # inversion de la liste des eus
            set LLE {}
            foreach e $T($t,ue_cod) {
                set LLE [concat $e $LLE]
            }
            set n 1
        } else  {
            set LLE $T($t,ue_cod)
        }
        foreach e  $LLE {
            set C(angle,$e) [expr $n*$a_ref]
            if  { [lsearch $leu $T($t,ctl,$e)] != -1} {
                # degres -> radians
                set angrad [expr (2 * acos(-1) * $C(angle,$e)) / 360.0]
                # d est l'augmentation du rayon du cercle
                set x [expr ($C(dx) + $d ) * cos($angrad)]
                set y [expr ($C(dy) + $d ) * sin($angrad)]
                set l $T($t,ctl,$e)
                Illustration::drawsymbol  $w [expr $x + $x1 + $C(dx)] [expr $y  + $y1 + $C(dy)] \
                        [list ILLCo¶$l T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo]
                update
            }
            incr n
        }
        unset C
    }
    ###
    # s est soit tab- soit tab+
    # cette fonction permet d'incementer (+) // decrementer (-)
    # la variable de tabulation pour les arbres en target
    # manuellement (afin de tab entre 2 series de requetes)
    proc IllCTabulation {s} {
        global S T
        # A-list window/tree des arbres en target d'une session treedyn
        foreach {w t} [Selection::TreeTar] {
            switch -exact $s  {
                tab+ {
                    if [catch {expr $S($t,LabelMatrixBase) + $S(TabulationAnnot)} result] {
                        set S($t,LabelMatrixBase) $S(TabulationAnnot)
                    } else  {
                        set S($t,LabelMatrixBase) $result
                    }
                }
                tab- {
                    if [catch {expr $S($t,LabelMatrixBase) - $S(TabulationAnnot)} result] {
                        # rien
                    } else  {
                        set S($t,LabelMatrixBase) $result
                    }
                }
            }
        }
    }
    proc IllCTabulationSet {s v} {
        global S T
        # A-list window/tree des arbres en target d'une session treedyn
        foreach {w t} [Selection::TreeTar] {
            switch -exact $s  {
                tab+ {
                    if [catch {expr $S($t,LabelMatrixBase) + $v} result] {
                        set S($t,LabelMatrixBase) $v
                    } else  {
                        set S($t,LabelMatrixBase) $result
                    }
                }
                tab- {
                    if [catch {expr $S($t,LabelMatrixBase) - $v} result] {
                        # rien
                    } else  {
                        set S($t,LabelMatrixBase) $result
                    }
                }
                tab= {
                    set S($t,LabelMatrixBase) $v
                    
                }
            }
        }
    }
    
    proc LillC360bis2 {w t leu} {
        global S ann T
        # cercle d'illustration fixer R le rayon du cercle d'illustration
        # on peut fixer une valeur pour par ex. 200 + tabulation
        # mais mieux de chercher une valeur adaptee Ã  chaque
        # arbre
        # set R [expr 200 + $S($t,LabelMatrixBase)]
        #set co [$w bbox [list L && T$t]]
        set co [$w bbox [list Z && T$t]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set Rx [expr double(($x2 - $x1) /2.0)]
        set Ry [expr double(($y2 - $y1) /2.0)]
        if {$Rx > $Ry} {
            set R [expr $Rx + $S($t,LabelMatrixBase)]
        } else  {
            set R [expr $Ry + $S($t,LabelMatrixBase)]
        }
        set a_ref [expr double(6.28318530717958 / [llength $T($t,ue_cod)])]
        set n 0
        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
        foreach e $T($t,ue_cod) {
            set a [expr double($n*$a_ref)]
            if  {[lsearch $leu $T($t,ctl,$e)] != -1} {
                set x [expr double($R * cos($a))]
                set y [expr double($R * sin($a))]
                set l $T($t,ctl,$e)
                Illustration::drawsymbol  $w $x $y [list ILLCo¶$l AnnotMatrix AM$t MA¶$l T$t $tagC AMatrixCo]
            }
            incr n
        }
        # centrage sur arbre tags root "[format "%s%s" $t C] T$t Z"
        set co [$w coords [format "%s%s" $t C]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set xcenter [expr ($x1 + $x2) /2.0]
        set ycenter [expr ($y1 + $y2) /2.0]
        $w move $tagC $xcenter $ycenter
    }
    ###
    proc LillC360bis {w t leu} {
        global S ann T
        
        #set f [expr double($R / $T($t,xmax))]
        set d $S($t,LabelMatrixBase)
        set co [$w bbox [list Z && T$t]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set C(dx) [expr abs(($x2 - $x1)) /2.0]
        set C(dy) [expr abs(($y2 - $y1)) /2.0]
        # pb il y a 4 zones de dessin en dehors de l'oval : forme phycir, phyrad etc.
        # on va donc toujours dessiner un cercle, on prend ds ce cas
        # le plus grand cote, soit dx soit dy, et on corrige x et y
        set delta [expr (abs($C(dx) - $C(dy))) / 2.0]
        if {[expr abs($x2 - $x1)] < [expr abs($y2 - $y1)]} {
            # update des x
            set x1 [expr $x1 - $delta]
            set x2 [expr $x2 + $delta]
            # update dx
            set C(dx) $C(dy)
        } {
            # update des y
            set y1 [expr $y1 - $delta]
            set y2 [expr $y2 + $delta]
            # update dy
            set C(dy) $C(dx)
        }
        $w create oval [expr $x1 -$d] [expr $y1 -$d] [expr $x2 +$d] [expr $y2 +$d] \
                -tags "T$t" -outline grey80
        
        $w create rectangle [expr $x1 -$d] [expr $y1 -$d] [expr $x2 +$d] [expr $y2 +$d] \
                -tags "T$t" -outline grey80
        
        set a_ref [expr 360.0/ [llength $T($t,ue_cod)]] ;# unite d'angle
        set n 0
        foreach e  $T($t,ue_cod) {
            set C(angle,$e) [expr $n*$a_ref]
            if  { [lsearch $leu $T($t,ctl,$e)] != -1} {
                # passer Ã  l'egalite nom de feuilles
                # degres -> radians
                set angrad [expr (2 * acos(-1) * $C(angle,$e)) / 360.0]
                # OK
                # d est l'augmentation du rayon du cercle
                #set x [expr ($C(r) + $d ) * cos($angrad)]
                #set y [expr ($C(r) + $d ) * sin($angrad)]
                # $w create oval [expr $x + $x1 + $C(r) -2] [expr $y  + $y1 + $C(r) -2] \
                # [expr $x + $x1 + $C(r) +2] [expr $y  + $y1 + $C(r) +2] \
                # -fill $S(col) -outline $S(col) \
                # -tags "T$t"
                set x [expr ($C(dx) + $d ) * cos($angrad)]
                set y [expr ($C(dy) + $d ) * sin($angrad)]
                $w create oval [expr $x + $x1 + $C(dx) -2] [expr $y  + $y1 + $C(dy) -2] \
                        [expr $x + $x1 + $C(dx) +2] [expr $y  + $y1 + $C(dy) +2] \
                        -fill $S(col) -outline $S(col) \
                        -tags "T$t" \
                    }
            incr n
        }
        unset C
    }
    ###
    proc CreateShape {w shape x y} {
        global S
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        set id [$w find closest $x $y]
        set tags [$w gettags $id]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$t != ""} {
            switch -exact $shape {
                line {
                    $w create $shape $x $y $x $y \
                            -fill $S(col) -width 1 -tags "rubbershape DRAW T$t"
                }
                rectangle - oval {
                    $w create $shape $x $y $x $y \
                            -fill $S(col) -outline $S(col) -width 1 -tags "rubbershape DRAW T$t" \
                            -stipple @[file join + stipple $S(stipple)]
                }
            }
            $w lower rubbershape
        }
    }
    #
    proc CreateShapeFill {w shape x y} {
        global S
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        set id [$w find closest $x $y]
        set tags [$w gettags $id]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$t != ""} {
            switch -exact $shape {
                line {
                    $w create $shape $x $y $x $y \
                            -outline $S(col) -width 1 -tags "rubbershape DRAW T$t"
                }
                rectangle - oval {
                    $w create $shape $x $y $x $y \
                            -outline $S(col) -width 1 -tags "rubbershape DRAW T$t"
                }
            }
        }
    }
    ###
    proc DragShape {w x y} {
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        set coords [$w coords "rubbershape"]
        set coords [lreplace $coords 2 3 $x $y]
        eval $w coords "rubbershape" $coords
    }
    ###
    proc EndShape {w x y} {
        DragShape $w $x $y
        $w dtag "rubbershape"
    }
}
################################################################################


################################################################################
# IMPORT EXPORT
################################################################################
namespace eval ImportExport {
    
    
    proc OpenPanel {{target new}} {
        global Export S T
        set typelist {
            {"All Files" {*}}
            {"Newick Files" {.nwk .tree .txt}}
            {"TreeDyn TDY Files" {.tdy}}
            {"TreeDyn TGF Files" {.tgf}}
        }
        set file [tk_getOpenFile -initialdir $S(userDIR)  -title "Open a Tree File" -filetypes $typelist]
        if {$file != ""} {set S(userDIR) [file dirname $file]}
        if [catch {open $file r} fid] {
            puts stderr "Incorrect File Format"
        } else {
            # en preference
            set S(SimpleImportNBC) 1
            set S(ImportAUTOTAR) 1
            
            if {$target == "new"} {
                set w [NewCanvas]
            } {
                set w $target
            }
            regsub ".c" $w  "" top
            wm withdraw $top
            # construction bar de progression, on utilise MI
            MIMakeProgressBarGen 1
            # un seul fichier, on utilise les fonction MI
            switch -glob $file  {
                *.txt - *.nwk - *.tree {MIimportNWK $w $file}
                *.tdy {MIimportTDY $w $file}
                *.tgf {MIimportTGF $w $file}
                default {MIimportNWK $w $file}
            }
            # reorganisation des arbres en matrice
            # pour respecter TGF si columns est sur 0 pas de reorganisation
            if {$S(SimpleImportNBC) != 0} {
                set c $S(SimpleImportNBC)
                set r [expr ([llength $S($w,t)] / $c) + 1]
                Navigation::Reorganize $w $c $r
                # apres une reorganisation integrant du tgf il faut remettre a jour
                # reposition des connectors
                Reflection::UpdateAll $w
            }
            destroy .progress
            wm deiconify $top
            
            if {$S(ImportAUTOTAR) == 1} {
                Selection::TreeTargetUnSelectAll
                Selection::TreeTargetSelectAllperW2 $w
            }
        }
    }
    #
    proc TreeSubToTreeDyn {data} {
        global S T
        set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        set code $t
        set T($t,nwk) $data
        TreeInit $t
        NewickParser_Root $t $data
        set w [ImportExport::NewCanvas]
        set S($t,w) $w
        # set S($t,tit) [format "%s%s" # $S($tsource,tit)]
        # set S($t,type) $S($tsource,type)
        set S($t,tit) xxx
        set S($t,type) PhyNJ
        set S($t,tar) 1
        lappend S($w,t) $t
        Conformation::ArrToCanType2 $t $w
        NodeBind $w $t
        Operation::TreeViewerPanelUpdate
        #Figuration::TransitionVG $w $tsource $node $t
        Figuration::RestaureT $w $t
    }
    # cas d'une collection de sous-arbres
    proc TreeSubToTreeDynMultiple {data wi he row col} {
        global S T
        set w [ImportExport::NewCanvas]
        set S($t,w) $w
        set l [split $data ";"]
        foreach s $l {
            set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
            lappend S(ilt) $t
            set code $t
            set T($t,nwk) $data
            TreeInit $t
            NewickParser_Root $t $data
            set S($t,tit) xxx
            set S($t,type) PhyNJ
            set S($t,tar) 1
            lappend S($w,t) $t
            Conformation::ArrToCanType2 $t $w $wi $he
            NodeBind $w $t
            Figuration::RestaureT $w $t
            Operation::TreeViewerPanelUpdate
        }
        Navigation::Reorganize $w $col $row
    }
    ### NEWICK PARSER Version A, le parser de TreeDyn actuellement, F. Chevenet
    ### T($t,dbl,$code) longeur de branche
    ### T($t,$t,nwk,$code)  la chaine newick de code node $code
    ### T($t,ctl,$code) "code to leaf"
    ### T($t,ltc,$dt) "leaf to code"
    ### T($t,all_cod) la liste des codes nodes
    ### T($t,ue_cod) la liste des codes feuilles
    ### #T($t,ue_lab) la liste des noms des feuilles
    ### T($t,cbg,$n) la liste des codes nodes de level $n
    ### T($t,sox,$code) pour chaque feuille : la somme des branch length de la racine a la feuille
    ### set T($t,xmax) la valeur max des T($t,sox,$code)
    ### set T($t,tot) le niveau de profondeur maximal
    ### remplacer le stockage de s par les index de debut et de fin
    proc NewickParser_Root {t s} {
        global T S
        set code $t
        set n 0
        set sx 0
        #
        set T($t,xmax) 0
        set T($t,tot) 0
        set T($t,all_cod) $code
        set T($t,dbv,$code) 0
        set T($t,dbl,$code) 0
        set T($t,nwk,$code) $s
        set tp [string last ")" $s]
        set dt [string range $s 0 $tp]
        set dx [string range $s [expr $tp + 1] end]
        set id [BgBdx $dt]
        set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
        set bd [string range $dt 1 [expr $id - 1]]
        lappend T($t,cbg,$n) $n
        NewickParser2 $t $bg [format "%s%s" $code  g] [expr $n + 1] $sx
        NewickParser2 $t $bd [format "%s%s" $code  d] [expr $n + 1] $sx
    }
    ###
    proc NewickParser2 {t s code n sx} {
        global T S
        lappend T($t,all_cod) $code
        set T($t,nwk,$code) $s
        if {[string match *,* $s]} {
            ######
            if {[Dicho $s] == 1} {
                set s [format "%s%s%s" ( $s ):0]
            }
            ######
            set tp [string last ")" $s]
            set dt [string range $s 0 $tp]
            set dx [string range $s [expr $tp + 1] end]
            set T($t,dbl,$code) [string range $dx [expr [string last ":" $dx] + 1] end]
            set T($t,dbv,$code) [string range $dx 0 [expr [string last ":" $dx] - 1]]
            ######
            if {[string compare [string range $dt 0 0] ( ] != 0 || \
                        [string compare [string range $dt end end] ) ] != 0} {
                set dt [format "%s%s%s" ( $dt )]
            }
            set id [BgBdx $dt]
            set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
            set bd [string range $dt 1 [expr $id - 1]]
            lappend T($t,cbg,$n) [format "%s%s" $code $n]
            NewickParser2 $t $bg [format "%s%s%s" $code $n g] [expr $n +1] [expr $sx + $T($t,dbl,$code)]
            NewickParser2 $t $bd [format "%s%s%s" $code $n d] [expr $n +1] [expr $sx + $T($t,dbl,$code)]
        } { set tp [string last ":" $s]
            set dt [string range $s 0 [expr $tp - 1]]
            set dx [string range $s [expr $tp + 1] end]
            set T($t,dbl,$code) [string range $dx [expr [string last ":" $dx] + 1] end]
            set T($t,ctl,$code) $dt
            set T($t,ltc,$dt) $code
            lappend T($t,ue_cod) $code
            lappend T($t,ue_lab) $dt
            set sx [expr $sx + $dx]
            set T($t,sox,$code) $sx
            if {$sx >= $T($t,xmax)} {set T($t,xmax) $sx}
            if {$n >= $T($t,tot)} {set T($t,tot) $n}
            return
        }
    }
    ###
    proc NewCanvas { {largeur 800} {hauteur 600} } {
        global S
        set S(Z) [set S(Y) [set S(X) [set S(SF) [expr 400/2.]]]]
        set S(ZU) 10
        set S(ZFO,0) [expr 1+.002*$S(ZU)]
        set S(ZFO,1) [expr 1+.01*$S(ZU)]
        set S(ZF) $S(ZFO,0)
        set w [ImportExport::NewWindowName]
        toplevel $w -width 400 -height 400
        set x [expr ([winfo screenwidth $w]  - [winfo reqwidth $w] ) /2]
        set y [expr ([winfo screenheight $w]  - [winfo reqheight $w] ) /2]
        #wm geometry $w "[expr $largeur +100]x[expr $hauteur +100]+$x+$y"
        wm geometry $w "400x400+$x+$y"
        wm protocol $w WM_DELETE_WINDOW "ImportExport::DeleteCanvas $w.c"
        wm resizable $w 1 1
        wm title $w [format "%s%s" TreeDyn# [lindex $S(ilw) end ]]
        wm withdraw .
        set c $w.c
        set S($c,t) {}
        set S($c,con) {} ;# la liste des ID des connectors de la fenetre
        set S($c,com) {} ;# la liste des ID des comments de la fenetre
        set S(sav,$c) ""
        # modif dec 2004
        set S($c,BIcol) ?
        set S($c,BIrow) ?
        scrollbar $w.xsbar -orient horizontal -command "$w.c xview"
        scrollbar $w.ysbar -orient vertical -command "$w.c yview"
        canvas $w.c -width $largeur -height $hauteur  \
                -xscrollcommand "$w.xsbar set" -yscrollcommand "$w.ysbar set"\
                -highlightthickness 0
        grid $w.c -row 0 -column 0 -sticky news
        grid $w.xsbar -row 1 -column 0 -sticky ew
        grid $w.ysbar -row 0 -column 1 -sticky ns
        grid rowconfigure $w 0  -weight 1
        grid columnconfigure $w 0 -weight 1
        CanvasBind $c
        return $c
    }
    
    proc CanvasBind {c} {
        global S tcl_platform
        #
        bind $c <Any-Enter> "Interface::AnyEnterCanvas %W"
        #bind $c <Any-Leave> "Interface::AnyLeaveCanvas %W ; Annotation::CanvasTextSelect %W %x %y ; Annotation::CanvasTextEnd  %W "
        bind $c <Any-Leave> "Interface::AnyLeaveCanvas %W ; Annotation::CanvasTextDone %W"
        # menus contextuels
        if {$tcl_platform(os) == "Darwin"} {
            bind $c <Button-2> {Interface::D3Switch %W %x %y}
            bind $c <Control-Button-1> {Interface::D3Switch %W %x %y}
            bind $c <Button-3> {ImportExport::ToolSwitch %W %x %y}
        } else {
            bind $c <Button-3> {Interface::D3Switch %W %x %y}
            bind $c <Button-2> {ImportExport::ToolSwitch %W %x %y}
        }
        bind $c <Motion> {Interface::ToolIcon %W %x %y}
        # zoom jerome BINDING
        Navigation::action
        # NAVIGATION
        bind zoompc  <Button-1> {Navigation::ZoomPC %W %x %y}
        bind zoomx   <Button-1> {Navigation::ZoomFXFY %W %x %y 1.1 1}
        bind zoomy   <Button-1> {Navigation::ZoomFXFY %W %x %y 1 1.1}
        bind zoomxy  <Button-1> {Navigation::ZoomFXFY %W %x %y 1.1 1.1}
        bind zoomx   <Shift-Button-1>  {Navigation::ZoomFXFY %W %x %y 0.9 1}
        bind zoomy   <Shift-Button-1>  {Navigation::ZoomFXFY %W %x %y 1 0.9}
        bind zoomxy  <Shift-Button-1>  {Navigation::ZoomFXFY %W %x %y 0.9 0.9}
        #local navigator
        bind zoomxnl1  <Button-1> {Navigation::ZoomFXFY %W %x %y 1.1 1 1}
        bind zoomynl1  <Button-1> {Navigation::ZoomFXFY %W %x %y 1 1.1 1}
        bind zoomxynl1 <Button-1> {Navigation::ZoomFXFY %W %x %y 1.1 1.1 1}
        bind zoomxnl1  <Shift-Button-1> {Navigation::ZoomFXFY %W %x %y 0.9 1 1}
        bind zoomynl1  <Shift-Button-1>  {Navigation::ZoomFXFY %W %x %y 1 0.9 1}
        bind zoomxynl1 <Shift-Button-1>  {Navigation::ZoomFXFY %W %x %y 0.9 0.9 1}
        # zoom continu
        bind zoomxnl2  <Button-1> {Navigation::ZoomHold %W %x %y x+ 1}
        bind zoomynl2  <Button-1> {Navigation::ZoomHold %W %x %y y+ 1}
        bind zoomxynl2 <Button-1> {Navigation::ZoomHold %W %x %y xy+ 1}
        bind zoomxnl2  <Shift-Button-1>  {Navigation::ZoomHold %W %x %y x- 1}
        bind zoomynl2  <Shift-Button-1>  {Navigation::ZoomHold %W %x %y y- 1}
        bind zoomxynl2 <Shift-Button-1>  {Navigation::ZoomHold %W %x %y xy- 1}
        # release
        bind zoomxnl1  <ButtonRelease-1> {set S(zx) 0}
        bind zoomynl1  <ButtonRelease-1> {set S(zx) 0}
        bind zoomxynl1 <ButtonRelease-1> {set S(zx) 0}
        bind zoomxnl2  <ButtonRelease-1> {set S(zx) 0}
        bind zoomynl2  <ButtonRelease-1> {set S(zx) 0}
        bind zoomxynl2 <ButtonRelease-1> {set S(zx) 0}
        bind zoomuser  <Button-1> {Navigation::ZoomFXFYuser %W %x %y }
        bind zoomuser  <Shift-Button-1>  {Navigation::ZoomFXFYuser %W %x %y }
        bind zoomxb  <Button-1> {Navigation::ZoomHold %W %x %y x+}
        bind zoomyb  <Button-1> {Navigation::ZoomHold %W %x %y y+}
        bind zoomxyb <Button-1> {Navigation::ZoomHold %W %x %y xy+}
        bind zoomxb  <Shift-Button-1>  {Navigation::ZoomHold %W %x %y x-}
        bind zoomyb  <Shift-Button-1>  {Navigation::ZoomHold %W %x %y y-}
        bind zoomxyb <Shift-Button-1>  {Navigation::ZoomHold %W %x %y xy-}
        bind move      <Button-1> {Navigation::Move %W %x %y}
        bind move      <Shift-Button-1> {Navigation::MoveALL %W %x %y}
        bind movel      <Button-1> {Navigation::MoveL %W %x %y}
        bind magnify  <Button-1> {Interface::Magnify %W %x %y}
        bind reset    <Button-1> {Navigation::ResetGV %W %x %y}
        bind delete    <Button-1> {Navigation::DeleteToolbox %W %x %y}
        bind copypaste <Shift-Button-1>         {ImportExport::CoPaAsNeWi %W %x %y}
        bind copypaste <Button-1>   {ImportExport::CoPaSaWi %W %x %y}
        bind copypastenavi <Button-1> {Navigation::BrowserCP %W %x %y}
        bind copypastecollection <Button-1> {Navigation::CoPaCollection %W %x %y}
        # CONFORMATION
        bind rotation    <Button-1> {Conformation::Rotation %W %x %y +}
        bind rotation    <Shift-Button-1> {Conformation::Rotation %W %x %y -}
        bind rotation    <ButtonRelease-1> {set S(rotation) 0 ; Reflection::UpdateAll %W}
        bind swap        <Button-1> {Conformation::Swap   %W }
        bind outgroup    <Button-1> {Conformation::Outgroup %W  newitem}
        bind outgroup    <Shift-Button-1> {Conformation::Outgroup %W  newwindow}
        bind ladder      <Button-1>       {Conformation::LaddUp %W }
        bind ladder      <Shift-Button-1> {Conformation::LaddDown %W }
        bind confcircext <Button-1>  {Conformation::SwitchConfiguration %W %x %y PhyCir1}
        #bind confcircext2 <Shift-Button-1>  {Conformation::SwitchConfiguration %W %x %y ClaCir2}
        bind confcircext2 <Button-1>  {Conformation::SwitchConfiguration %W %x %y ClaCir1}
        bind confcircint <Button-1>  {Conformation::SwitchConfiguration %W %x %y ClaCir3}
        bind confrect    <Button-1>  {Conformation::SwitchConfiguration %W %x %y PhyNJ}
        bind confrect    <Shift-Button-1>  {Conformation::SwitchConfiguration %W %x %y ClaRec}
        # FIGURATION
        bind bgcolorst1  <Button-1>          {Figuration::NodeColorBgSubTreeToolbox %W add1}
        bind bgcolorst1  <Shift-Button-1>    {Figuration::NodeColorBgSubTreeToolbox %W remove}
        bind bgcolorst1  <Control-Button-1>  {Figuration::NodeColorBgSubTreeToolbox %W removeall}
        bind bgcolorst1  <Button-3>  {Figuration::NodeColorBgSubTreeToolbox %W menushape}
        bind fgcolor    <Button-1>        {Figuration::NodeColorFgTreeToolbox  %W}
        bind fgcolor    <Shift-Button-1>        {Figuration::NodeColorFgTreeToolboxRemove  %W}
        bind bgcolor    <Button-1>        {Figuration::NodeColorBgLeafToolbox  %W add}
        bind bgcolor    <Shift-Button-1>  {Figuration::NodeColorBgLeafToolbox  %W remove}
        bind fgcolorleaf <Button-1>       {Figuration::NodeColorFgLeafToolbox  %W}
        bind fgcolorleaf <Shift-Button-1>       {Figuration::NodeColorFgLeafToolboxRemove  %W}
        bind catchcolor <Button-1>        {Figuration::CatchColor %W}
        bind textset    <Button-1>        {Figuration::FontSetGlobalToolbox %W }
        bind textsize+- <Button-1>        {Figuration::FontSize %W +}
        bind textsize+- <Shift-Button-1>  {Figuration::FontSize %W -}
        bind textitalic <Button-1>        {Figuration::FontSlant %W}
        bind textbold   <Button-1>        {Figuration::FontWeight %W}
        bind textunder  <Button-1>        {Figuration::FontUnderline %W}
        bind textover   <Button-1>        {Figuration::FontOverstrike %W}
        bind catchfont <Button-1>         {Figuration::CatchFont %W}
        bind width+-    <Button-1>               {Figuration::NodeLineWidthToolbox %W ++}
        bind width+-    <Shift-Button-1>         {Figuration::NodeLineWidthToolbox %W --}
        bind width+-    <Control-Button-1>       {Figuration::NodeLineWidthToolbox %W +}
        bind width+-    <Control-Shift-Button-1> {Figuration::NodeLineWidthToolbox %W -}
        bind dash       <Button-1>               {Figuration::NodeLineDashToolbox %W 1}
        bind dash       <Shift-Button-1>         {Figuration::NodeLineDashToolbox %W 0}
        bind catchline  <Button-1>               {}
        bind select <Button-1> {Figuration::SelectD1 %W %x %y}
        bind select <Double-Button-1> {Figuration::SelectD1D1 %W %x %y}
        bind select <Shift-Button-1> {Figuration::SelectShiftD1 %W %x %y}
        # ANNOTATION
        bind textnode    <Button-1> {Annotation::InsertTextNode %W %x %y}
        bind symbolnode   <Button-1> {Annotation::InsertSymbolNode %W %x %y}
        bind subtreeshape   <Button-1> {Annotation::SubtreeShape %W %x %y}
        bind subtreeshapem   <Button-1> {Annotation::SubtreeShapeM %W %x %y}
        bind plotnode   <Button-1> {Annotation::PlotNode %W %x %y}
        bind plotnodem   <Button-1> {Annotation::PlotNodeM %W %x %y}
        #bind textleafl    <Button-1> {Annotation::LannLtoolbox %W %x %y}
        bind nodeillustration  <Shift-ButtonPress-1> {Illustration::NodeIllustration %W %x %y}
        bind nodeillustration  <ButtonPress-1> {Illustration::NodeIllustration2 %W %x %y}
        #bind leafillustrationL <ButtonPress-1> {Illustration::LillLtoolbox %W %x %y}
        bind leafillustrationC <ButtonPress-1> {Illustration::LillCtoolbox %W %x %y}
        bind leafillustrationC <Shift-ButtonPress-1> {Illustration::LillLtoolbox %W %x %y}
        bind textleafc    <Button-1> {Annotation::LannCtoolbox %W %x %y}
        bind textleafc    <Shift-Button-1> {Annotation::LannLtoolbox %W %x %y}
        #bind textnodebl  <Button-1> {Annotation::NodeDBL %W %x %y}
        #bind textnodebl  <Shift-Button-1> {Annotation::NodeDBV %W %x %y}
        #bind textnodeblp  <Button-1> {Annotation::NodeDBLp %W %x %y}
        #bind textnodeblp  <Shift-Button-1> {Annotation::NodeDBVp %W %x %y}
        bind valafter  <Button-1> {Annotation::NodeDBL %W %x %y}
        bind valafter  <Shift-Button-1> {Annotation::NodeDBLp %W %x %y}
        bind valbefore  <Button-1> {Annotation::NodeDBV %W %x %y}
        bind valbefore  <Shift-Button-1> {Annotation::NodeDBVp %W %x %y}
        bind httpleaf <Button-1> {Annotation::AnnotHttp %W %x %y}
        bind movematrix <Button-1> {Annotation::ANmoveMatrix %W %x %y}
        bind movecol <Button-1> {Annotation::ANmoveCOL %W %x %y}
        bind annfgcol <Button-1> {Annotation::ANannfgcol %W %x %y}
        bind annfgrow <Button-1> {Annotation::ANannfgrow %W %x %y}
        bind annfocol <Button-1> {Annotation::ANannfocol %W %x %y}
        bind annforow <Button-1> {Annotation::ANannforow %W %x %y}
        bind annanchw <Button-1> {Annotation::ANannanchw %W %x %y}
        bind annanche <Button-1> {Annotation::ANannanche %W %x %y}
        # IDENTIFICATION
        bind d3menus     <Button-1> {Identification::I_Switch %W %x %y}
        bind localisation     <Button-1> {Localisation::L_Switch %W %x %y}
        # ABSTRACTION
        bind subtree   <Button-1> {Decomposition::SubTree %W %x %y}
        bind shrink      <Button-1> {Abstraction::ShrinkToolbox %W }
        bind shrink3      <Button-1> {Abstraction::Shrink3Toolbox %W}
        bind shrink4      <Button-1> {Abstraction::Shrink4Toolbox %W}
        bind collapse    <Button-1> {Abstraction::CollapseToolbox %W }
        bind collapse    <Shift-Button-1> {Abstraction::CollapseUnToolbox %W }
        bind absleaf    <Button-1> {Abstraction::leafShrinkToolbox %W }
        bind absleaf    <Shift-Button-1> {Abstraction::leafShrinkUnToolbox %W }
        # REFLECTION
        bind transition1  <Button-1> {Reflection::Transition-I %W }
        bind transition2 <ButtonRelease-1> {Reflection::Transition-II %W}
        bind transition3  <ButtonRelease-1> {Reflection::Transition-III %W}
        bind congruence  <Button-1> {Reflection::Congruence %W }
        bind connect  <Button-1> {Reflection::Connection %W}
        # ILLUSTRATION
        bind bracketdraw <Shift-ButtonPress-1> {Illustration::BracketDrawCreate %W bracket %x %y}
        bind bracketdraw <ButtonPress-1> {Illustration::BracketDrawCreateNode %W bracket %x %y}
        bind bracketdraw <B1-Motion> {Illustration::BracketDrawDrag %W %x %y}
        bind bracketdraw <ButtonRelease-1> {Illustration::BracketDrawEnd %W %x %y}
        bind accoladedraw <ButtonPress-1> {Illustration::BracketDrawCreate %W accolade %x %y}
        bind accoladedraw <B1-Motion> {Illustration::BracketDrawDrag %W %x %y}
        bind accoladedraw <ButtonRelease-1> {Illustration::BracketDrawEnd %W %x %y}
        bind textinsert <ButtonPress-1> {Annotation::CanvasTextSelect %W %x %y}
        bind textinsert <KeyPress> {Annotation::CanvasTextEditAdd %W %A}
        bind textinsert <KeyPress-Return> {Annotation::CanvasTextEditAdd %W "\n"}
        bind textinsert <KeyPress-BackSpace> {Annotation::CanvasTextEditBacksp %W}
        bind textinsert  <KeyPress-Delete> {Annotation::CanvasTextEditBacksp %W}
        bind textinsert  <Double-Button-1> {Annotation::CanvasTextEnd  %W }
        bind symbolinsert  <ButtonPress-1> {Illustration::SymbolInsert %W %x %y}
        bind drawrectangle <ButtonPress-1> {Illustration::CreateShape %W rectangle %x %y}
        bind drawrectangle <B1-Motion> {Illustration::DragShape %W %x %y}
        bind drawrectangle <ButtonRelease-1> {Illustration::EndShape %W %x %y}
        #bind drawrectangle <Shift-ButtonPress-1> {Illustration::CreateShapeFill %W rectangle %x %y}
        bind drawrectangle <Shift-B1-Motion> {Illustration::DragShape %W %x %y}
        bind drawrectangle <Shift-ButtonRelease-1> {Illustration::EndShape %W %x %y}
        bind drawoval <ButtonPress-1> {Illustration::CreateShape %W oval %x %y}
        bind drawoval <B1-Motion> {Illustration::DragShape %W %x %y}
        bind drawoval <ButtonRelease-1> {Illustration::EndShape %W %x %y}
        #bind drawoval <Shift-ButtonPress-1> {Illustration::CreateShapeFill %W oval %x %y}
        bind drawoval <Shift-B1-Motion> {Illustration::DragShape %W %x %y}
        bind drawoval <Shift-ButtonRelease-1> {Illustration::EndShape %W %x %y}
        bind drawline <ButtonPress-1> {Illustration::CreateShape %W line %x %y}
        bind drawline <B1-Motion> {Illustration::DragShape %W %x %y}
        bind drawline <ButtonRelease-1> {Illustration::EndShape %W %x %y}
        bind bgcolorcont <Button-1> {Illustration::NodeBgContour %W %x %y}
        # Package SuperTree
        bind stcollapse <Button-1> {SuperTree::stcollapse %W %x %y ; Navigation::FitToContents %W}
        bind stdelete <Button-1> {SuperTree::stdelete %W %x %y ; Navigation::FitToContents %W}
        bind stcollapsemulti <Button-1> {SuperTree::stcollapsemulti %W %x %y ; Navigation::FitToContents %W}
        bind stdeletemulti <Button-1> {SuperTree::stdeletemulti %W %x %y ; Navigation::FitToContents %W}
        bind stcopinsertnode <Button-1> {SuperTree::stcopinsertnode %W %x %y ; Navigation::FitToContents %W}
        bind stcopinsertpoly <Button-1> {SuperTree::stcopinsertpoly %W %x %y ; Navigation::FitToContents %W}
        bind stcopreplace <Button-1> {SuperTree::stcopreplace %W %x %y ; Navigation::FitToContents %W}
        bind stcopypaste <Button-1> {SuperTree::stcopypasteStart %W %x %y ; Navigation::FitToContents %W}
        bind stdelete <Button-1> {SuperTree::stDeleteGo %W %x %y ; Navigation::FitToContents %W}
        bind stcollapse <Button-1> {SuperTree::stCollapseGo %W %x %y ; Navigation::FitToContents %W}
        bind stpolytotale <Button-1> {SuperTree::stPolytomyTotale %W %x %y ; Navigation::FitToContents %W}
        bind stpolypartial <Button-1> {SuperTree::stPolytomyPartielle %W %x %y ; Navigation::FitToContents %W}
        #package amelie
        bind  faiadd <Button-1> {Amelie::Toolboxfaiadd %W %x %y}
        bind  fairem <Button-1> {Amelie::Toolboxfairem %W %x %y}
        bind  arcx <Button-1> {Amelie::ToolboxArcx %W %x %y}
        bind  faix <Button-1> {Amelie::ToolboxFaix %W %x %y}
        bind  selx <Button-1> {Amelie::ToolboxSelx %W %x %y}
        bind  arccour <Button-1> {Amelie::ToolboxArccour %W %x %y}
        bind  arccol <Button-1> {Amelie::ToolboxArccol %W %x %y}
        bind  faicol <Button-1> {Amelie::ToolboxFaicol %W %x %y}
        bind  selcol <Button-1> {Amelie::ToolboxSelcol %W %x %y}
        bind  arcdel <Button-1> {Amelie::ToolboxArcdel %W %x %y}
        bind  faidel <Button-1> {Amelie::ToolboxFaidel %W %x %y}
        bind  seldel <Button-1> {Amelie::ToolboxSeldel %W %x %y}
        # pack TreeXY
        bind  ttoxy <Button-1> {TreeXY::ttoxyGO %W %x %y}
        bind  treepatfromt    <Button-1> {TreeMat::treepatfromt %W %x %y}
        # package TreeALI
        bind  trealg+  <Button-1> {TreeALI::algtre+ %W %x %y}
        bind  trealg-  <Button-1> {TreeALI::algtre- %W %x %y}
        # MISC
        $c bind ConnectIcon <Any-Enter> "$c config -cursor hand2"
        $c bind ConnectIcon <Any-Leave> "$c config -cursor top_left_arrow"
        $c bind Connect <Any-Enter> "$c config -cursor hand2"
        $c bind Connect <Any-Leave> "$c config -cursor top_left_arrow"
        #leafselection
        bind leafsel <Button-1> {LeafSelection::CheckControlBarD1 %W %x %y}
        bind leafsel <Shift-Button-1>  {LeafSelection::CheckControlBarShiftD1 %W %x %y}
        bind leafsel <Control-Button-1>  {LeafSelection::CheckControlBarCtrlD1 %W %x %y}
        
        bind annothttp <Button-1> {Operation::AnnotHTTPgo %W %x %y}
    }
    ###
    proc ToolSwitch {w x y} {
        global S
        if {$S(tool) != "move"} {
            set S(alterTool) $S(tool)
            set S(tool) move
            Interface::AnyEnterCanvas $w
        } else {
            set S(tool) $S(alterTool)
            Interface::AnyEnterCanvas $w
        }
    }
    ###
    proc NewWindowName {} {
        global S
        set indicew [expr [lrange  [lsort  -integer -increasing $S(ilw)] end end] + 1]
        lappend S(ilw) $indicew
        set windowname [format "%s%s" .t $indicew]
        set S($windowname,t) {}
        return $windowname
    }
    ### l'indice t est unique (quel que soit w)
    proc NewTree {} {
        global S T
        set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        TreeInit $t
        set typelist {
            {"TreeDyn Files" {".tdy"} }
            {"All Files" {*}}
        }
        set file [tk_getOpenFile  -filetypes $typelist -initialdir $S(userDIR)  \
                -defaultextension "tdy" -title "Load TDY File"]
        if {$file != ""} {set S(userDIR) [file dirname $file]}
        if {$file != ""} {
            source $file
            xxxEncode $t
            set w [ImportExport::NewCanvas]
            set S($t,tit) [Tools::PathCut2 $file]
            set S($t,w) $w
            lappend S($w,t) $t
            Conformation::PhyNJ $t $w
            NodeBind $w $t
            Operation::TreeViewerPanelUpdate
        }
        
    }
    ### l'indice t est unique (quel que soit w)
    ### newtree direct est appel auto apres import
    proc NewTreeDirect {file} {
        global S T
        set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        TreeInit $t
        source $file
        xxxEncode $t
        set w [ImportExport::NewCanvas]
        set S($t,tit) [Tools::PathCut2 $file]
        set S($t,w) $w
        lappend S($w,t) $t
        Conformation::PhyNJ $t $w
        NodeBind $w $t
        Operation::TreeViewerPanelUpdate
    }
    ###
    proc debug {w} {
    }
    ###
    proc NewTreeByInsertion {w} {
        global S T
        set typelist {
            {"TreeDyn Files" {".tdy"} }
            {"All Files" {*}}
        }
        set file [tk_getOpenFile -filetypes $typelist -initialdir $S(userDIR) -defaultextension "tdy" -title "Load TDY File"]
        if {$file != ""} {set S(userDIR) [file dirname $file]}
        if [catch {open $file r} fid] {
            puts stderr "***"
        } else {
            set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
            lappend S(ilt) $t
            lappend S($w,t) $t
            set S($t,w) $w
            TreeInit $t
            set S($t,filefullpatch) $file
            set S($t,tit) [Tools::PathCut2 $file]
            source $file
            xxxEncode $t
            Conformation::PhyNJ $t $w
            NodeBind $w $t
            Operation::TreeViewerPanelUpdate
        }
    }
    ###
    proc NodeBind {w t} {
        $w bind T$t <Any-Enter> "$w config -cursor hand2"
        $w bind T$t <Any-Leave> "$w config -cursor top_left_arrow"
        #$w bind T$t <Any-Enter> "NodeHighlightItem $w $t"
        #$w bind T$t <Any-Leave> "NodeUnHighlightItem $w $t"
    }
    ###
    proc xxxEncode {t} {
        global T
        set uold xxx
        set unew $t
        set kvT [array get T xxx*]
        foreach {key value} $kvT {
            regsub  -all xxx $value $t valueswi
            unset T($key) ; regsub  -all xxx $key $t keyswi ; set T($keyswi) $valueswi
        }
    }
    ### TreeInit
    proc TreeInit {t} {
        global T S B
        set S($t,orient) W
        set S($t,a_ori) 0 ;# angle aditionel utilise dans les rotations
        set S($t,a_uni) 0 ;# unite d'angle
        set S($t,tit) "" ;# le pathcut2 du fichier tdy
        set S($t,type) PhyNJ    ;# le type de tree par defaut
        set S($t,init) 0 ;# cette variable fixe le mode inclusif/exclusif du panel identification
        set S($t,display_eu) $S(display_eu)
        set S($t,LabelMatrixBase) 5 ;# matrice d'annotation
        set T($t,eu_collapse) {} ;# liste des noms de feuilles a retirer en abstraction
        set T($t,xmax) 0        ;# branch length max
        set T($t,tot) 0         ;# level max
        set T($t,all_cod) {}    ;# codes nodes
        set T($t,ue_cod) {}     ;# UE - codes LISTE ORDONNEE
        set T($t,ue_lab) {}     ;# UE - labels LISTE ORDONNEE
        set B($t,shi) {}        ;# List des nodes shrink
        set B($t,qyn) {}        ;# list des items querynode
        set B($t,ova) {}        ;# la liste des node reliant 1 tree (decomposition)
        set B($t,bll) {}        ;# la liste des nodes ayant des BLL (bulles labels link : eu;db,users)
        set B($t,bgs) {}        ;# la liste des items background nodes
        set B($t,bgl) {}        ;# la liste des items background leaves
        set B($t,con) {}        ;# la liste des reseaux de connection
    }
    ###
    proc CoPy {w what t n } {
        global S
        set S(cp) [list $w $what $t $n]
    }
    ### argument de copytree2 : w tsource node  x y {canvaswidth 150} {canvasheight 150}
    proc Paste {wtarget} {
        global S
        set wsource [lindex $S(cp) 0]
        set what [lindex $S(cp) 1]
        set tsource [lindex $S(cp) 2]
        set node [lindex $S(cp) 3]
        switch $what {
            tree - node {
                set xtarget 0
                set ytarget 0
                ImportExport::CopyTree2 $wtarget $tsource $node $xtarget $ytarget
            }
            canvas {
                foreach t $S($wsource,t) {
                    set co [$wsource bbox T$t]
                    set xtarget [lindex $co 0]
                    set ytarget [lindex $co 1]
                    ImportExport::CopyTree2 $wtarget $t $t $xtarget $ytarget
                }
            }
        }
    }
    ### CoPaAsNeWi
    proc CoPaAsNeWi {w x y } {
        global T S
        set tags [$w gettags [$w find withtag current]]
        if {[lsearch -exact $tags Z] != -1} {
            set n [string trimright \
                    [lindex $tags [lsearch -glob $tags *C]] C]
            set t [string range \
                    [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$n != "" && $t != ""} {CopyTree $t $n} {CopyTree $t $t}
        }
    }
    ### CopyTree # As New Window
    proc CopyTree {tsource node} {
        global S T
        set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        set code $t
        set data $T($tsource,nwk,$node)
        set T($t,nwk) $data
        TreeInit $t
        if {[catch [ImportExport::NewickParser_Root $t $data] result] != 0} {
            CleanArrayTree $t
        }  else {
            #modif dec 2004
            set T($t,xmax) $T($tsource,xmax)
            set w [ImportExport::NewCanvas]
            set S($t,w) $w
            set S($t,tit) [format "%s%s" # $S($tsource,tit)]
            set S($t,type) $S($tsource,type)
            set S($t,tar) 1
            lappend S($w,t) $t
            Conformation::ArrToCanType2 $t $w
            NodeBind $w $t
            Figuration::TransitionVG $w $tsource $node $t
            Figuration::RestaureT $w $t
            Operation::TreeViewerPanelUpdate
        }
    }
    ###
    proc CoPaSaWi { w x y } {
        global T S
        
        set tags [$w gettags [$w find withtag current]]
        if {[lsearch -exact $tags Z] != -1} {
            set n [string trimright \
                    [lindex $tags [lsearch -glob $tags *C]] C]
            set t [string range \
                    [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$n != "" && $t != ""} {CopyTree2 $w $t $n $x $y} {CopyTree2 $w $t $t $x $y}
        }
    }
    ### CopyTree2 # As New ITEM
    proc CopyTree2 {w tsource node  x y {canvaswidth 150} {canvasheight 150}} {
        global S T
        set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        lappend S($w,t) $t
        set code $t
        set data $T($tsource,nwk,$node)
        set T($t,nwk) $data
        TreeInit $t
        
        if {[catch [ImportExport::NewickParser_Root $t $data] result] != 0} {
            CleanArrayTree $t
        }  else {
            #modif dec 2004
            set T($t,xmax) $T($tsource,xmax)
            set S($t,w) $w
            set S($t,tit) [format "%s%s" # $S($tsource,tit)]
            set S($t,type) $S($tsource,type)
            set S($t,tar) 1
            # il vaudrait mieux prendre la taille du sous-arbre
            # set co [$S($tsource,w) bbox [list T$tsource && Z]]
            # set wi  [expr abs([lindex $co 0] - [lindex $co 2])]
            # set he  [expr abs([lindex $co 1] - [lindex $co 3])]
            # Conformation::ArrToCanType2 $t $w $x $y $wi $he
            #Conformation::ArrToCanType2 $t $w $x $y
            Conformation::ArrToCanType2 $t $w [$w canvasx $x] [$w canvasy $y]
            NodeBind $w $t
            Figuration::TransitionVG $w $tsource $node $t
            Figuration::RestaureT $w $t
            Operation::TreeViewerPanelUpdate
        }
        $w raise T$t
        ### passage en mode MOVE automatique
        set S(tool) move
        bindtags $w [list $S(tool) $w Canvas . all]
        #Navigation::MoveT $w $t [winfo pointerx $w] [winfo pointery $w]
        Navigation::MoveT $w $t $x $y
        return $t
    }
    # NewickLoad
    # Load + REGSUB
    # NETTOYAGE Newick : c.r. " " ; - ] [
    # OK ORIGINAL regsub -all "\n|;| |-|\[|\]" $data "" data
    # OK regsub -all "\n|;| " $data "" data
    proc NewNewick {} {
        global S
        set typelist {
            {"All Files" {*}}
        }
        set file [tk_getOpenFile -initialdir $S(userDIR) -filetypes $typelist -title "Load Newick File"]
        if {$file != ""} {set S(userDIR) [file dirname $file]}
        if [catch {open $file r} fid] {
            puts stderr "Incorrect File Format"
        } else {
            set s [read -nonewline $fid]
            close $fid
            regsub -all "\n| |;" $s "" s
            return $s
        }
    }
    # remplacer les sub-chaines newick par un index de debut/fin de la chaine source
    # inserer une variable contenant pour chaque node le nombre de nodes (virtuels + leafs)
    # ecriture du fichier a integrer ds le parser newick
    proc Import {type} {
        global Export S
        ### Fichier Source
        set typelist {
            {"All Files" {*}}
        }
        set file [tk_getOpenFile  -initialdir $S(userDIR) -filetypes $typelist -title "TreeDyn : Import From $type To TreeDyn"]
        if {$file != ""} {set S(userDIR) [file dirname $file]}
        ### NETTOYAGE Newick : c.r. " " ; - ] [
        ### regsub -all "\n|;| |-|\[|\]" $data ""UpdateArrayCanvas data
        # attention pas de suppression des "-" car des notations scientifiques pour des petites valeurs
        if [catch {open $file r} fid] {
            Interface::TreeDynMessage "Error"
        } else {
            set s [read -nonewline $fid]
            switch -exact $type {
                Newick {
                    regsub -all "\n|;| " $s "" s
                    regsub -all {\[} $s "" s
                    # suppression des signes - sur les longueurs de branches
                    #regsub -all {:-} $s ":" s
                    regsub -all {:-[0-9]*.[0-9]+|:-[0-9]+} $s ":0.0" s
                    regsub -all {\]} $s "" s
                }
                Nexus {
                    regsub -all "\n" $s "" s
                    set s [Conformation::NexusToNewick $s]
                }
            }
            close $fid
            ### Import & Ecriture Fichier TreeDyn
            # si file "treetarget" ou file  "treetarget.nwk" (par exemple)
            if  {[string last . $file] == "-1"} {
                set targetfile [format "%s%s" $file .tdy]
            } else  {
                set targetfile  [format "%s%s" [string range $file 0 [expr [string last . $file] -1]] .tdy]
            }
            if {[catch [TreeDynTranslation $type $s] err] != 0} {
                Interface::TreeDynMessage "Error"
            } else {
                destroy .f
                set fid [open $targetfile w]
                set lkv [array get Export]
                foreach {key value} $lkv {
                    puts $fid "set T(xxx,$key) \{$value\}"
                }
                close $fid
                ImportExport::NewTreeDirect $targetfile
            }
            if {$Export(Duplication) != {}} {
                set msg  "Newick Incoherence by Leaf's Name Duplication: \n"
                foreach e $Export(Duplication) {
                    append msg "* $e \n"
                }
                tk_messageBox -type ok -default ok  -message $msg -icon warning
            }
            unset Export
        }
    }
    # actuellement fct retiree
    proc ImportMulti {type} {
        global Export S T
        ### Fichier Source
        set typelist {
            {"All Files" {*}}
        }
        set file [tk_getOpenFile -initialdir $S(userDIR)  -filetypes $typelist -title "TreeDyn : Import From $type To TreeDyn"]
        if {$file != ""} {set S(userDIR) [file dirname $files]}
        ### NETTOYAGE Newick : c.r. " " ; - ] [
        ### regsub -all "\n|;| |-|\[|\]" $data "" data
        # attention pas de suppression des "-" car des notations scientifiques pour des petites valeurs
        if [catch {open $file r} fid] {
            Interface::TreeDynMessage "Error"
        } else {
            set s [read -nonewline $fid]
            switch -exact $type {
                Newick {
                    regsub -all "\n| " $s "" s
                    regsub -all {\[} $s "" s
                    #regsub -all {:-} $s ":" s
                    regsub -all {:-[0-9]*.[0-9]+|:-[0-9]+} $s ":0.0" s
                    regsub -all {\]} $s "" s
                    set l [split $s ";"]
                    
                }
                # Nexus {
                # regsub -all "\n" $s "" s
                # set s [Conformation::NexusToNewick $s]
                # }
            }
            close $fid
            ### Import & Ecriture Fichier TreeDyn
            set id 0
            set w [NewCanvas]
            foreach s [lrange $l 0 end-1] {
                incr id
                if  {[string last . $file] == "-1"} {
                    set targetfile [format "%s%s" $file .tdy]
                } else  {
                    set targetfile  [format "%s%s" [string range $file 0 [expr [string last . $file] -1]] .tdy]
                }
                if {$targetfile != ""} {
                    if {[catch [TreeDynTranslation $type $s] err] != 0} {
                        Interface::TreeDynMessage "Error"
                    } else {
                        destroy .f
                        set fid [open $targetfile w]
                        set lkv [array get Export]
                        foreach {key value} $lkv {
                            puts $fid "set T(xxx,$key) \{$value\}"
                        }
                        close $fid
                        unset Export
                        set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
                        lappend S(ilt) $t
                        lappend S($w,t) $t
                        set S($t,w) $w
                        TreeInit $t
                        set S($t,tit) [Tools::PathCut2 $targetfile]
                        source $targetfile
                        xxxEncode $t
                        Conformation::PhyNJ $t $w $S(newW) $S(newH)
                        NodeBind $w $t
                        Operation::TreeViewerPanelUpdate
                    }
                }
            }
        }
    }
    #
    proc MIimport {{files {}}} {
        global Export S T tcl_platform
        if {$tcl_platform(os) == "Darwin"} {
            if {$S(userDIR) == ""} {set S(userDIR) [pwd]}
        }
        if {$files == {}} {
            set typelist {
                {"All Files" {*}}
                {"Newick Files" {.nwk .tree .txt}}
                {"TreeDyn TDY Files" {.tdy}}
                {"TreeDyn TGF Files" {.tgf}}
            }
            set files [tk_getOpenFile -initialdir $S(userDIR) \
                    -multiple true -title "Open Tree(s) File(s)" -filetypes $typelist]
            # ne pa changer la dir (cd ..) courante sinon les extensions...
            if {$files != ""} {set S(userDIR) [file dirname [lindex $files 0]]}
        }
        set nb 0
        set lfiles $files
        foreach file $lfiles {
            switch -glob $file  {
                *.txt - *.nwk - *.tree {
                    set fid [open $file r]
                    set s [read -nonewline $fid]
                    close $fid
                    set n [regsub -all ";" $s "" s]
                    if {$n != -1} {set nb [expr $nb + $n]}
                }
                *.tdy {
                    incr nb
                }
                *.tgf {
                    # entete fichier tgf
                    ### v1.5 - 2002
                    #set E(tree) {1 2 3 4 5 6}
                    set fid [open $file r]
                    gets $fid
                    eval [gets $fid]
                    set nb [expr $nb + [llength $E(tree)]]
                    close $fid
                }
                default {
                    set fid [open $file r]
                    set s [read -nonewline $fid]
                    close $fid
                    set n [regsub -all ";" $s "" s]
                    if {$n != -1} {set nb [expr $nb + $n]}
                }
            }
        }
        set S(MultiImportTRE) "$nb Tree(s)"
        set S(MultiImportSFN) "[llength $lfiles] File(s)"
        # les fichiers a importer
        #set files [$S(MIw).lfb.l get 0 end]
        if {$files != ""} {
            # la fenetre cible
            if {$S(MultiImportTAR) == "new"} {
                set w [NewCanvas ]
                # on construit tous les arbres et ensuite on affiche
                # le withdraw sur le path de la toplevel
                regsub ".c" $w  "" top
            } {
                #set w [format "%s%s%s" .t $S(MultiImportTAR) .c]
                #set top [format "%s%s" .t $S(MultiImportTAR)]
                set w $S(MultiImportTAR)
                regsub ".c" $w  "" top
            }
            wm withdraw $top
            # construction bar de progression
            MIMakeProgressBarGen [lindex [split $S(MultiImportTRE) " "] 0]
            # fichier par fichier switch sur suffixe, default sur newick (si pas de suffixe)
            foreach file $files {
                switch -glob $file  {
                    *.txt - *.nwk - *.tree {MIimportNWK $w $file}
                    *.tdy {MIimportTDY $w $file}
                    *.tgf {MIimportTGF $w $file
                        set S(MultiImportNBC) 0
                        set S($w,filefullpath) $file
                        wm title [winfo parent $w] $file
                    }
                    default {MIimportNWK $w $file}
                }
            }
            # reorganisation des arbres en matrice
            # pour respecter TGF si columns est sur 0 pas de reorganisation
            set S($w,BIcol) 1
            set S($w,BIrow) [llength $S($w,t)]
            
            if {$S(MultiImportNBC) != 0} {
                set c $S(MultiImportNBC)
                set r [expr ([llength $S($w,t)] / $c) + 1]
                Navigation::Reorganize $w $c $r
                # apres une reorganisation integrant du tgf il faut remettre a jour
                # reposition des connectors, itou en SIimport
                Reflection::UpdateAll $w
            }
            #
            if {$S(ImportAUTOTAR) == 1} {
                Selection::TreeTargetUnSelectAll
                Selection::TreeTargetSelectAllperW2 $w
            }
            destroy .progress
            wm deiconify $top
        }
    }
    proc MIimportNWK {w file} {
        global S Export T
        # lecture
        set fid [open $file r]
        set s [read -nonewline $fid]
        close $fid
        # nettoyage
        regsub -all "\n" $s "" s
        regsub -all " " $s "¶" s
        #regsub -all "\n" $s "" s PAS SI SIMPLE
        regsub -all {\[} $s "" s
        #regsub -all {:-} $s ":" s ;# passer la valeur à 0
        regsub -all {:-[0-9]*.[0-9]+|:-[0-9]+} $s ":0.0" s
        #regsub -all {:-} $s ":" s ;# passer la valeur à 0
        regsub -all {\]} $s "" s
        # update progress bar
        set S(ImportExportNN) [file rootname [file tail $file]]
        # splitting sur ; si un fichier contient plusieurs chaines newick
        set l [split $s ";"]
        set id 0
        foreach s [lrange $l 0 end-1] {
            # update progress bar
            .progress.n step
            # parsing
            if {[catch [NewickToTreeDyn $s] err] != 0} {
                Interface::TreeDynMessage "Error"
            } else {
                incr id
                #update progress bar
                .progress.i reset
                set max 0
                foreach c [split $s {}] {
                    if {[string equal $c ","]} {incr max}
                }
                .progress.i configure -steps $max
                set titre [format "%s%s" [file rootname [file tail $file]] $id]
                set S(ImportExportNI) $titre
                # Export vers file
                if {$S(MultiImportTDY) == 1} {
                    # titre, on rajoute .tdy pour le nom du fichier
                    set fid [open [file join [file dirname $file] [format "%s%s" $titre .tdy]] w]
                    set lkv [array get Export]
                    foreach {key value} $lkv {
                        puts $fid "set T(xxx,$key) \{$value\}"
                    }
                    close $fid
                }
                # Export vers T
                set lkv [array get Export]
                foreach {key value} $lkv {
                    set T(xxx,$key) $value
                }
                unset Export
                # graphic
                set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
                lappend S(ilt) $t
                lappend S($w,t) $t
                
                set S($t,w) $w
                set S($w,filefullpath) $file
                wm title [winfo parent $w] $file
                TreeInit $t
                set S($t,tit) $titre
                xxxEncode $t
                # si petit arbre on utilise toute la hauteur de la fenetre
                if {[expr 10.0 * [llength $T($t,ue_cod)] ] >= $S(newH)} {
                    set S(newH) [expr 10.0 * [llength $T($t,ue_cod)] ]
                }
                Conformation::PhyNJ $t $w $S(newW) $S(newH)
                NodeBind $w $t
                Operation::TreeViewerPanelUpdate
                
            }
        }
    }
    #variante la meme sauf file remplace par s, une chaine nwk
    proc MIimportNWKs {w s} {
        global S Export T
        # nettoyage
        #original
        # ORIGINAL OK regsub -all "\n| " $s "" s
        regsub -all "\n| " $s "¶" s
        #regsub -all "\n" $s "" s PAS SI SIMPLE
        regsub -all {\[} $s "" s
        regsub -all {:-[0-9]*.[0-9]+|:-[0-9]+} $s ":0.0" s
        #regsub -all {:-} $s ":" s
        regsub -all {\]} $s "" s
        # update progress bar
        
        # splitting sur ; si un fichier contient plusieurs chaines newick
        set l [split $s ";"]
        set id 0
        foreach s [lrange $l 0 end-1] {
            # update progress bar
            .progress.n step
            # parsing
            if {[catch [NewickToTreeDyn $s] err] != 0} {
                Interface::TreeDynMessage "Error"
            } else {
                incr id
                #update progress bar
                .progress.i reset
                set max 0
                foreach c [split $s {}] {
                    if {[string equal $c ","]} {incr max}
                }
                .progress.i configure -steps $max
                # set titre [format "%s%s" [file rootname [file tail $file]] $id]
                # set S(ImportExportNI) $titre
                # Export vers file
                if {$S(MultiImportTDY) == 1} {
                    # titre, on rajoute .tdy pour le nom du fichier
                    set fid [open [file join [file dirname $file] [format "%s%s" $titre .tdy]] w]
                    set lkv [array get Export]
                    foreach {key value} $lkv {
                        puts $fid "set T(xxx,$key) \{$value\}"
                    }
                    close $fid
                }
                # Export vers T
                set lkv [array get Export]
                foreach {key value} $lkv {
                    set T(xxx,$key) $value
                }
                unset Export
                # graphic
                set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
                lappend S(ilt) $t
                lappend S($w,t) $t
                set S($t,w) $w
                TreeInit $t
                set S($t,tit) PROTO
                xxxEncode $t
                # si petit arbre on utilise toute la hauteur de la fenetre
                if {[expr 10.0 * [llength $T($t,ue_cod)] ] >= $S(newH)} {
                    set S(newH) [expr 10.0 * [llength $T($t,ue_cod)] ]
                    puts $S(newH)
                }
                
                Conformation::PhyNJ $t $w $S(newW) $S(newH)
                NodeBind $w $t
                Operation::TreeViewerPanelUpdate
            }
        }
    }
    #
    proc MIimportTDY {w file} {
        global S T
        source $file
        set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        lappend S($w,t) $t
        set S($t,w) $w
        TreeInit $t
        set S($t,tit) [file rootname [file tail $file]]
        xxxEncode $t
        set S(newH) [expr 10.0 * [llength $T($t,ue_cod)] ]
        Conformation::PhyNJ $t $w $S(newW) $S(newH)
        NodeBind $w $t
        Operation::TreeViewerPanelUpdate
    }
    ###
    proc MIimportTGF {w script} {
        global S T B
        if {$script != ""} {
            source $script
            # lvar1
            set lvar1 {dbl nwk ctl sox gfg lfg gld gls gfo }
            # lvar2
            set lvar2 {ue_cod all_cod } ;# variables stockant des nodes
            # lvar3
            set lvar3 {ltc cbg} ;# variables stockant des nodes avec k variable
            # lvar4
            set lvar4 {xmax tot ue_lab}
            foreach t $E(tree) {
                ######### ARRAY T
                # OK variables lvar1
                set tnew [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
                lappend S(ilt) $tnew
                foreach var $lvar1 {
                    foreach {k v} [array get ET [format "%s%s%s%s%s" $t , $var , *]] {
                        regsub [format "%s%s%s%s%s" $t , $var , $t ] $k [format "%s%s%s%s%s" $tnew , $var , $tnew] knew
                        set T($knew) [string trimleft $v]
                    }
                }
                # OK variables lvar2
                foreach var $lvar2 {
                    regsub -all " $t" $ET($t,$var) " $tnew"  newvalue
                    set T($tnew,$var) [string trimleft $newvalue]
                }
                # OK variables lvar3
                foreach var $lvar3 {
                    foreach {k v} [array get ET [format "%s%s%s%s%s" $t , $var , *]] {
                        regsub [format "%s%s" $t , ] $k [format "%s%s" $tnew , ] knew
                        regsub -all " $t" $v " $tnew" vnew
                        set T($knew) [string trimleft $vnew]
                    }
                }
                # OK variables lvar4
                foreach var $lvar4 {
                    set T($tnew,$var) [string trimleft $ET($t,$var)]
                }
                ######### ARRAY S
                foreach {k v} [array get ES [format "%s%s" $t ,* ]] {
                    regsub [format "%s%s" $t ,]  $k  [format "%s%s" $tnew ,] knew
                    set S($knew) [string trimleft $v]
                }
                ######### ARRAY B
                # BGS
                set lid {}
                foreach id $EB($t,bgs) {
                    set newid [string replace $id 0 [expr [string length $t] -1] $tnew]
                    lappend lid $newid
                    regsub -all " $t" $EB(BGSnod,$id) " $tnew" v
                    set B(BGSnod,$newid) [string trimleft $v]
                    set B(BGStre,$newid) $tnew
                    set B(BGScol,$newid) [string trimleft $EB(BGScol,$id)]
                }
                set B($tnew,bgs) [string trimleft $lid]
                # BGL
                set lid {}
                foreach id $EB($t,bgl) {
                    set newid [string replace $id 0 [expr [string length $t] -1] $tnew]
                    lappend lid $newid
                    regsub -all " $t" $EB(BGLnod,$id) " $tnew" v
                    set B(BGLnod,$newid) [string trimleft $v]
                    set B(BGLtre,$newid) $tnew
                    set B(BGLcol,$newid) [string trimleft $EB(BGLcol,$id)]
                }
                set B($tnew,bgl) [string trimleft $lid]
                # BLL
                set lid {}
                foreach id $EB($t,bll) {
                    set newid [string replace $id 0 [expr [string length $t] -1] $tnew]
                    lappend lid $newid
                    regsub -all " $t" $EB(BLLnod,$id) " $tnew" v
                    set B(BLLnod,$newid) [string trimleft $v]
                    set B(BLLtre,$newid) $tnew
                    set B(BLLtxt,$newid) [string trimleft $EB(BLLtxt,$id)]
                    regsub -all "¶$t" $EB(BLLidt,$id) "¶$tnew" v
                    set B(BLLidt,$newid) [string trimleft $v]
                    regsub -all "¶$t" $EB(BLLidl,$id) "¶$tnew" v
                    set B(BLLidl,$newid) [string trimleft $v]
                    set B(BLLcol,$newid) [string trimleft $EB(BLLcol,$id)]
                    set B(BLLgfo,$newid) [string trimleft $EB(BLLgfo,$id)]
                    set B(BLLxxx,$newid) [string trimleft $EB(BLLxxx,$id)]
                    set B(BLLyyy,$newid) [string trimleft $EB(BLLyyy,$id)]
                }
                #set B($tnew,bll) $lid
                set B($tnew,bll) [string trimleft $lid]
                # QYN
                set lid {}
                foreach id $EB($t,qyn) {
                    set newid [string replace $id 0 [expr [string length $t] -1] $tnew]
                    lappend lid $newid
                    set B(QYNres,$newid) [string trimleft $EB(QYNres,$id)]
                    set B(QYNqry,$newid) [string trimleft $EB(QYNqry,$id)]
                    set B(QYNtre,$newid) $tnew
                    regsub -all "¶$t" $EB(QYNidt,$id) "¶$tnew" v
                    set B(QYNidt,$newid) [string trimleft $v]
                    set B(QYNcol,$newid) [string trimleft $EB(QYNcol,$id)]
                    set B(QYNgfo,$newid) [string trimleft $EB(QYNgfo,$id)]
                    set B(QYNxxx,$newid) [string trimleft $EB(QYNxxx,$id)]
                    set B(QYNyyy,$newid) [string trimleft $EB(QYNyyy,$id)]
                }
                set B($tnew,qyn) [string trimleft $lid]
                # SHI
                set lid {}
                foreach id $EB($t,shi) {
                    set newid [string replace $id 0 [expr [string length $t] -1] $tnew]
                    lappend lid $newid
                    regsub -all " $t" $EB(SHInod,$id) " $tnew"  v
                    set B(SHInod,$newid) [string trimleft $v]
                    set B(SHItxt,$newid) [string trimleft $EB(SHItxt,$id)]
                    set B(SHItre,$newid) $tnew
                    set B(SHIcol,$newid) [string trimleft $EB(SHIcol,$id)]
                    set B(SHIsta,$newid) [string trimleft $EB(SHIsta,$id)]
                }
                set B($tnew,shi) [string trimleft $lid]
                # OVA
                set lid {}
                foreach id $EB($t,ova) {
                    set newid [string replace $id 0 [expr [string length $t] -1] $tnew]
                    lappend lid $newid
                    regsub -all " $t" $EB(OVAnod1,$id) " $tnew"  v
                    set B(OVAnod1,$newid) [string trimleft $v]
                    regsub -all " $t" $EB(OVAnod2,$id) " $tnew"  v
                    set B(OVAnod2,$newid) [string trimleft $v]
                    set B(OVAtrx,$newid) [string trimleft $EB(OVAtrx,$id)]
                    set B(OVAtry,$newid) [string trimleft $EB(OVAtry,$id)]
                    set B(OVAtre,$newid) $tnew
                }
                set B($tnew,ova) [string trimleft $lid]
                
                ######### ITEMS
                foreach id $EC($t,ids) {
                    regsub -all "¶$t" $EC($t,tags,$id) "¶$tnew" EC($t,tags,$id)
                    regsub -all " $t" $EC($t,tags,$id) " $tnew" EC($t,tags,$id)
                    regsub  " T$t" $EC($t,tags,$id) " T$tnew" EC($t,tags,$id)
                    eval $w create $EC($t,opts,$id) -tags [list $EC($t,tags,$id)]
                }
                ######## CONNECTORS, un peu special, premiere partie ici
                # NB compatibilite avec les verssions precedentes de treedyn qui n'avaient pas S(con)
                
                if { [catch {set v [list $ES(con)]} res]} {
                    # rien
                    set ES(con) {}
                } {
                    foreach id $ES(con) {
                        regsub -all " $t" $EB(CONnod,$id) " $tnew"  EB(CONnod,$id)
                        regsub -all " $t" $EB(CONtre,$id) " $tnew"  EB(CONtre,$id)
                    }
                }
                set S($tnew,w) $w
                lappend S($w,t) $tnew
                ImportExport::NodeBind $w $tnew
                Operation::TreeViewerPanelUpdate
                Decomposition::ReTag $w $tnew
                Decomposition::UpdateLink $w $tnew
            }
            # CONNECTORS, seconde partie
            # ATTENTION pas mise a jour de l'id, mais generation de nouveau id
            # if { [catch {set v [list $ES(con)]} res]} {
            # # rien
            # } {
            # pas la peine le catch precedent initalise la variable
            foreach id $ES(con) {
                set newid [Tools::GenId]
                lappend S($w,con) $newid
                set B(CONnot,$newid) [string trimleft $EB(CONnot,$id)]
                set B(CONnod,$newid) [string trimleft $EB(CONnod,$id)]
                set B(CONtre,$newid) [string trimleft $EB(CONtre,$id)]
                # retagage
                # BUG si restauration dans la fenetre contenant l'original (eg meme tags)
                $w itemconfigure Connect¶$id -tags [list Connect Connect¶$newid]
                $w itemconfigure ConIconTag¶$id -tags [list ConnectIcon ConIconTag¶$newid $newid]
            }
            # }
            # FIN
            $w configure -scrollregion [$w bbox all]
            update
            unset ET ; unset ES ; unset EB
        }
    }
    ### Progress Bar Generic: nb est un nombre d'arbres ou un nombre de fichiers, etc.
    proc MIMakeProgressBarGen {nb} {
        destroy .progress
        toplevel .progress
        wm withdraw .progress
        wm resizable .progress 0 0
        wm overrideredirect .progress 1
        set max $nb
        label .progress.l  -text "TreeDyn Importation"
        iwidgets::feedback .progress.i -labelvariable S(ImportExportNI) -steps $max
        iwidgets::feedback .progress.n -labelvariable S(ImportExportNN) -steps $max
        .progress.n reset
        .progress.i reset
        set x [expr ([winfo screenwidth .progress] - [winfo reqwidth .progress]) /2]
        set y [expr ([winfo screenheight .progress] - [winfo reqheight .progress]) /2]
        #wm geometry .progress "250x300+$x+$y"
        wm geometry .progress "+$x+$y"
        pack .progress.l .progress.i .progress.n  -side top -fill both -expand yes
        wm deiconify .progress
    }
    ### NewickToTreeDyn
    proc NewickToTreeDyn {s} {
        global Export
        set code xxx ; set n 0
        set Export(xmax) 0
        set Export(tot) 0
        set Export(all_cod) $code
        set Export(ue_lab) {}
        set Export(ue_cod) {}
        set Export(Duplication) {}
        #liste de tous les codes nodes
        # TEST presence de longueur de branches
        if {[string match *:* $s] == 0} {
            regsub -all "," $s {:1.0,} s
            regsub -all {\)} $s {:1.0)} s
        }
        set Export(dbl,$code) 0 ;# longeur de branche du code node
        set Export(nwk,$code) $s ;# chaine newick du code node
        ######
        if {[Dicho $s] == 1} {
            set s [format "%s%s%s" ( $s ):0]
        }
        ######
        set tp [string last ")" $s]
        set dt [string range $s 0 $tp]
        #set dx [string range $s [expr $tp + 1] end]
        ######
        if {[string compare [string range $dt 0 0] ( ] != 0 || \
                    [string compare [string range $dt end end] ) ] != 0} {
            set dt [format "%s%s%s" ( $dt )]
        }
        ######
        set id [BgBdx $dt]
        set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
        set bd [string range $dt 1 [expr $id - 1]]
        lappend Export(cbg,$n) 0 ;#la liste des codes nodes de level $n
        incr n
        NewickParser $bg [format "%s%s" $code g] $n 0
        NewickParser $bd [format "%s%s" $code d] $n 0
        return
    }
    ###
    proc NewickParser {s code n sx} {
        global Export
        .progress.i step
        lappend Export(all_cod) $code ;# liste de tous les codes nodes
        set Export(nwk,$code) $s ;# chaine newick du code node
        if {[string match *,* $s]} {
            ######
            if {[Dicho $s] == 1} {
                set s [format "%s%s%s" ( $s ):0]
            }
            ######
            set tp [string last ")" $s]
            set dt [string range $s 0 $tp]
            
            set dx [string range $s [expr $tp + 1] end]
            set Export(dbl,$code) [expr abs([string range $dx [expr [string last ":" $dx] + 1] end])] ;# longeur de branche du code node
            set Export(dbv,$code) [string range $dx 0 [expr [string last ":" $dx] - 1]] ; #bootstrap value
            ######
            if {[string compare [string range $dt 0 0] ( ] != 0 || \
                        [string compare [string range $dt end end] ) ] != 0} {
                set dt [format "%s%s%s" ( $dt )]
            }
            ######
            set id [BgBdx $dt]
            set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
            set bd [string range $dt 1 [expr $id - 1]]
            lappend Export(cbg,$n) [format "%s%s" $code $n] ;#la liste des codes nodes de level $n
            NewickParser $bg [format "%s%s%s" $code $n g] [expr $n +1] [expr $sx + $Export(dbl,$code)]
            NewickParser $bd [format "%s%s%s" $code $n d] [expr $n +1] [expr $sx + $Export(dbl,$code)]
        } {
            set tp [string last ":" $s]
            set dt [string range $s 0 [expr $tp - 1]]
            
            set dx [string range $s [expr $tp + 1] end]
            set Export(dbl,$code) [expr abs([string range $dx [expr [string last ":" $dx] + 1] end])]
            # liste des labels leaf
            if {[lsearch $Export(ue_lab) $dt] == -1}  {
                lappend Export(ue_lab) $dt
                set Export(ctl,$code) $dt ;# code to leaf
                set Export(ltc,$dt) $code ;# leaf to code
            } else {
                set newdt [format "%s%s%s" $dt - [Tools::GenId]]
                lappend Export(Duplication) "$dt swtich to $newdt"
                lappend Export(ue_lab) $newdt
                set Export(ctl,$code) $newdt ;# code to leaf
                set Export(ltc,$newdt) $code ;# leaf to code
            }
            lappend Export(ue_cod) $code ;# liste de codes leaf
            set sx [expr $sx + $dx]
            set Export(sox,$code) $sx
            if {$sx >= $Export(xmax)} {set Export(xmax) $sx}
            if {$n >= $Export(tot)} {set Export(tot) $n}
            return
        }
    }
    ### identifier l'index de la virgule separant les deux membres : gauche et droit
    ### possiblite de le faire une seule fois pour toutes
    ### sachant s -> index de , ?
    # ATTENTION il y avait une version BgBdx qui avait switch -exact $c sans --
    proc BgBdx {s} {
        set i -1
        set id -1
        foreach c [split $s {}] {
            incr id
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
                , {if {$i == 0} {return $id}}
            }
        }
        return ""
    }
    ### Dicho
    proc Dicho {s} {
        set i 0 ; set id 0 ; set r 1
        foreach c [split $s {}] {
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
            }
            if {$i == 0} {
                set r [string match *,* [string range $s [expr $id + 1] end]]
                break
            }
            incr id
        }
        return $r
    }
    ### NexusToTreeDyn
    proc NexusToTreeDyn {s} {
    }
    ###
    proc getOpenFile {{elts {All *} }} {
        global S
        if {[winfo exists .fileopen] == 1} {destroy .fileopen}
        set w [frame .fileopen]
        set type {}
        foreach {text suffixe} $elts {
            lappend type [list $text .$suffixe]
        }
        set file [tk_getOpenFile  -initialdir $S(userDIR) -filetypes $type \
                -parent $w -title "Select a File"]
        if {$file != ""} {set S(userDIR) [file dirname $file]}
        if [string compare $file ""] {destroy .fileopen ; return $file}
    }
    ###
    proc getSaveFile { {elts {All *} }  } {
        global S
        if {[winfo exists .filesave] == 1} {destroy .filesave}
        set w [frame .filesave]
        set type {}
        foreach {text suffixe} $elts {
            lappend type [list $text .$suffixe]
        }
        set file [tk_getSaveFile -initialdir $S(userDIR) -filetypes $type \
                -parent $w -title "Select a File"]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        if [string compare $file ""] {destroy .filesave ; return $file}
    }
    ### par defaut draw_save sauve tous les tree d'une fenetre,
    ### sinon what doit contenir un id tree
    proc draw_save {w m {what all}} {
        global env S T
        set typelist {
            {"TreeDyn Graphic File" {".tgf"} }
            {"All Files" {*}}
        }
        switch -exact $m {
            save   {
                if {$S(sav,$w) != ""} {set file $S(sav,$w)} {
                    set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".tgf" \
                            -filetypes $typelist  -title "Save Canvas as TGF file..."]
                    if {$file != "" } {set S(userDIR) [file dirname $file]}
                    set S(sav,$w) $file
                }
            }
            saveas {
                set file [tk_getSaveFile  -initialdir $S(userDIR) -defaultextension ".tgf" \
                        -filetypes $typelist  -title "Save Canvas as TGF file..."]
                if {$file != "" } {set S(userDIR) [file dirname $file]}
                set S(sav,$w) $file
            }
        }
        if {$file != ""} {
            wm title [winfo parent $w] [Tools::PathCut2 $file]
            if {$what == "all"} {
                set script [canvas_saveArray $w $S($w,t)]
                append script [canvas_saveItems $w $S($w,t)]
            } else  {
                set script [canvas_saveArray $w $what]
                append script [canvas_saveItems $w $what]
            }
            ### stepbar
            destroy .f
            set max 0
            set data [split $script "\n"]
            set max [llength  $data]
            toplevel .f -relief raised  -borderwidth 2
            wm resizable .f 0 0
            wm overrideredirect .f 1
            iwidgets::feedback .f.fb -labeltext "Saving $file" -steps $max
            set x [expr ([winfo screenwidth .f] - [winfo reqwidth .f]) /2]
            set y [expr ([winfo screenheight .f] - [winfo reqheight .f]) /2]
            wm geometry .f "+$x+$y"
            pack .f.fb -padx 5 -pady 5 -fill both -expand yes
            .f.fb reset
            # save
            set cmd {
                set fid [open $file w]
                #puts $fid $script
                foreach elt $data {
                    puts $fid $elt
                    .f.fb step
                }
                close $fid
                destroy .f
            }
            if {[catch $cmd err] != 0} {
                Interface::TreeDynMessage "Error"
            }
        }
    }
    ###
    proc canvas_saveArray {w lt} {
        global S T B
        set script    "### $S(version)\n"
        append script "set E(tree) \{$lt\} \n"
        #set script "set E(tree) \{$lt\} \n"
        # attention a conserver l'espace entre "\{" et $v
        foreach t $lt {
            set pattern  [format "%s%s%s" $t , * ]
            ######### ARRAY T
            append script "### T\n"
            foreach {k v} [array get T [format "%s%s" $t *]] {
                append script "set ET($k) \{ $v\} \n"
            }
            ######### ARRAY S
            append script "### S\n"
            foreach {k v} [array get S [format "%s%s" $t *]] {
                append script "set ES($k) \{ $v\} \n"
            }
            ######### ARRAY B ici pas d'espace avant v
            append script "### B\n"
            foreach {k v} [array get B [format "%s%s" $t *]] {
                append script "set EB($k) \{$v\} \n"
            }
            # B // BGS
            foreach Id $B($t,bgs) {
                set pattern [format "%s%s%s" BGS* , $Id]
                foreach {k v} [array get B $pattern] {
                    append script "set EB($k) \{ $v\} \n"
                }
            }
            # B // BGL
            foreach Id $B($t,bgl) {
                set pattern [format "%s%s%s" BGL* , $Id]
                foreach {k v} [array get B $pattern] {
                    append script "set EB($k) \{ $v\} \n"
                }
            }
            # B // SHI
            foreach Id $B($t,shi) {
                set pattern [format "%s%s%s" SHI* , $Id]
                foreach {k v} [array get B $pattern] {
                    append script "set EB($k) \{ $v\} \n"
                }
            }
            # B // BLL
            foreach Id $B($t,bll) {
                set pattern [format "%s%s%s" BLL* , $Id]
                foreach {k v} [array get B $pattern] {
                    append script "set EB($k) \{ $v\} \n"
                }
            }
            # B // QYN
            
            foreach i $B($t,qyn) {
                set pattern [format "%s%s%s" QYN* , $i]
                foreach {k v} [array get B $pattern] {
                    append script "set EB($k) \{ $v\} \n"
                }
            }
            # B // OVA
            foreach i $B($t,ova) {
                set pattern [format "%s%s%s" OVA* , $i]
                foreach {k v} [array get B $pattern] {
                    append script "set EB($k) \{ $v\} \n"
                }
            }
        }
        # items sans reference a un IDtree, ou faisant reference a plusieurs IDtree
        # B // CON = connectors
        append script "set ES(con) \{$S($w,con)\} \n"
        foreach i $S($w,con) {
            set pattern [format "%s%s%s" CON* , $i]
            foreach {k v} [array get B $pattern] {
                append script "set EB($k) \{ $v\} \n"
            }
        }
        # B // COM = comments
        
        # FIN
        return $script
    }
    ###
    proc canvas_saveItems {w lt} {
        global S
        foreach t $lt {
            set lid { }
            foreach item [$w find withtag T$t] {
                set id [Tools::GenId]
                lappend lid $id
                set tags [$w gettags $item]
                set type   [$w type $item]
                set coords [$w coords $item]
                set opts ""
                foreach desc [$w itemconfigure $item] {
                    set name [lindex $desc 0]
                    set init [lindex $desc 3]
                    set val  [lindex $desc 4]
                    # correction bug canvas qui place la valeur "bezier" au lieu de "true"
                    # comme valeur de l'option -smooth dans les items canvas
                    if {$val == "bezier"} {set val true}
                    if {$val != $init} {
                        if {$name != "-tags"} {
                            lappend opts $name $val
                        }
                    }
                }
                append script "set EC($t,opts,$id) \{ $type $coords $opts\} \n"
                append script "set EC($t,tags,$id) \{ $tags\} \n"
            }
            append script "set EC($t,ids) \{ $lid\} \n"
        }
        # items graphique non identifie par $id
        # cas des connectors par exemple
        # cas des notes canvas par exemple
        # CONNECTORS, 2 type d'items : line et chaine d'iconification (tags distincts)
        foreach item [$w find withtag {Connect || ConnectIcon}] {
            set id [Tools::GenId]
            lappend lid $id
            set tags [$w gettags $item]
            set type   [$w type $item]
            set coords [$w coords $item]
            set opts ""
            foreach desc [$w itemconfigure $item] {
                set name [lindex $desc 0]
                set init [lindex $desc 3]
                set val  [lindex $desc 4]
                if {$val != $init} {
                    if {$name != "-tags"} {
                        lappend opts $name $val
                    }
                }
            }
            append script "set EC($t,opts,$id) \{ $type $coords $opts\} \n"
            append script "set EC($t,tags,$id) \{ $tags\} \n"
        }
        #essai save legend
        foreach item [$w find withtag Legend] {
            set id [Tools::GenId]
            lappend lid $id
            set tags [$w gettags $item]
            set type   [$w type $item]
            set coords [$w coords $item]
            set opts ""
            foreach desc [$w itemconfigure $item] {
                set name [lindex $desc 0]
                set init [lindex $desc 3]
                set val  [lindex $desc 4]
                if {$val != $init} {
                    if {$name != "-tags"} {
                        lappend opts $name $val
                    }
                }
            }
            append script "set EC($t,opts,$id) \{ $type $coords $opts\} \n"
            append script "set EC($t,tags,$id) \{ $tags\} \n"
        }
        append script "set EC($t,ids) \{ $lid\} \n"
        # FIN
        return $script
    }
    proc RestaureTree {w} {
        global S
        set typelist {
            {"TreeDyn Graphic File" {".tgf"} }
            {"All Files" {*}}
        }
        set script [tk_getOpenFile -initialdir $S(userDIR)
        -filetypes $typelist  -title "Load TGF file..."]
        if {$script != ""} {set S(userDIR) [file dirname $script]}
        MIimportTGF $w $script
    }
    ###
    proc LoadRestaureTree {} {
        RestaureTree [ImportExport::NewCanvas]
    }
    ###  Save as Newick File
    proc SaveNewick {w t n} {
        global S T
        # n = $t si save sur un tree
        set typelist {
            {"Newick Files" {".nwk"} }
            {"All Files" {*}}
        }
        set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".nwk" \
                -filetypes $typelist -title "Save as Newick file..."]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        if {$file != ""} {
            set fid [open $file w]
            puts $fid $T($t,nwk,$n)
            if {[string range $T($t,nwk,$n) end end] != ";"} {puts $fid ";"}
            close $fid
        }
    }
    ### Destruction totale
    proc DeleteTree {w t} {
        set choix [tk_messageBox -type okcancel -default ok  -message "Delete Tree ?" -icon question]
        if {$choix == "ok"} {
            UpdateArrayCanvas $w $t
        }
    }
    ###
    proc UpdateArrayCanvas {w t}  {
        global T S B
        ### canvas
        $w delete T$t
        ### array T
        foreach {key value} [array get T $t,*] {
            unset T($key)
        }
        ### array S
        foreach {key value} [array get S $t,*] {
            unset S($key)
        }
        # array B/BLL
        foreach bll $B($t,bll) {
            foreach key  [array names B *,$bll] {
                unset B($key)
            }
        }
        unset B($t,bll)
        # array B/SHI
        foreach shi $B($t,shi) {
            
            foreach key  [array names B *,$shi] {
                unset B($key)
            }
        }
        unset B($t,shi)
        #array B/ OVA
        foreach ova $B($t,ova) {
            foreach key  [array names B *,$ova] {
                unset B($key)
            }
        }
        #array B/ QYN
        unset B($t,ova)
        foreach qyn $B($t,qyn) {
            foreach key  [array names B *,$qyn] {
                unset B($key)
            }
        }
        unset B($t,qyn)
        #mise a jour la liste des tree   S(ilt)
        set index [lsearch -exact $S(ilt) $t]
        set S(ilt) [concat [lrange $S(ilt) 0 [expr $index - 1]] \
                [lrange $S(ilt) [expr $index + 1] end]]
        #mise a jour la liste des tree   S(w,t)
        set index [lsearch -exact $S($w,t) $t]
        set S($w,t) [concat [lrange $S($w,t) 0 [expr $index - 1]] \
                [lrange $S($w,t) [expr $index + 1] end]]
        
    }
    ###
    proc DeleteCanvas {w} {
        global S
        set choix [tk_messageBox -type okcancel -default ok  -message "Delete Window ?" -icon question]
        if {$choix == "ok"} {
            foreach t $S($w,t) {
                UpdateArrayCanvas $w $t
            }
            set toplevelwindow [string trimright $w .c ]
            destroy $toplevelwindow
            set indice [string trimleft $toplevelwindow .t ]
            set index [lsearch -exact $S(ilw) $indice]
            set S(ilw) [concat [lrange $S(ilw) 0 [expr $index - 1]] \
                    [lrange $S(ilw) [expr $index + 1] end]]
        }
    }
    #
    proc ExportFile {c} {
        global S T tcl_platform
        raise [winfo toplevel $c]
        update
        switch $tcl_platform(platform) {
            "unix" {
                set typelist {
                    {"Adobe PostScript Format (PS)" {".ps"}}
                    {"Graphics Interchange Format (GIF)" {".gif"}}
                    {"Joint Picture Expert Group Format (JPEG)" {".jpg"}}
                    {"Paintbrush Format (PCX)" {".pcx"}}
                    {"Pixmap Image type (PIXMAP)" {".pix"}}
                    {"Portable Network Graphics format (PNG))" {".png"}}
                    {"Portable Pixmap format (PPM)" {".ppm"}}
                    {"SGI Native Format (SGI)" {".sgi"}}
                    {"Sun Raster Format (SUN)" {".ras"}}
                    {"Tagged Image File Format (TIFF)" {".tif"}}
                    {"Truevision Targa Format (TGA)" {".tga"}}
                    {"X Windows Bitmap Format (XBM)" {".xbm"}}
                    {"X Windows Pixmap Format (XPM)" {".xpm"}}
                    {"Windows Bitmap Format (BMP)" {".bmp"}}
                    {"Windows Icon Format (ICO)" {".ico"}}
                }
            }
            "windows" {
                set typelist {
                    {"Adobe PostScript Format (PS)" {".ps"}}
                    {"Graphics Interchange Format (GIF)" {".gif"}}
                    {"Joint Picture Expert Group Format (JPEG)" {".jpg"}}
                    {"Paintbrush Format (PCX)" {".pcx"}}
                    {"Pixmap Image type (PIXMAP)" {".pix"}}
                    {"Portable Network Graphics format (PNG))" {".png"}}
                    {"Portable Pixmap format (PPM)" {".ppm"}}
                    {"SGI Native Format (SGI)" {".sgi"}}
                    {"Sun Raster Format (SUN)" {".ras"}}
                    {"SVG" {".svg"}}
                    {"Tagged Image File Format (TIFF)" {".tif"}}
                    {"Truevision Targa Format (TGA)" {".tga"}}
                    {"X Windows Bitmap Format (XBM)" {".xbm"}}
                    {"X Windows Pixmap Format (XPM)" {".xpm"}}
                    {"Windows Bitmap Format (BMP)" {".bmp"}}
                    {"Windows Icon Format (ICO)" {".ico"}}
                }
            }
        }
        
        set file [tk_getSaveFile -initialdir $S(userDIR)  -defaultextension ".ps" \
                -filetypes $typelist -title "Export as..."]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        if {$file != ""} {
            switch -glob $file {
                *.ps  {
                    foreach {x0 y0 x1 y1} [$c bbox all] {}
                    set w [expr $x1 - $x0]
                    set h [expr $y1 - $y0]
                    #test
                    set font [font create -family Wingdings -size 10 -weight normal]
                    global fontmap ; # not sure if this needs to be global or not
                    set fontmap($font) [list Wingdings [expr 18 * [tk scaling]]]
                    parray fontmap ; # just for info
                    #.c postscript -file testdump.ps -fontmap fontmap
                    $c postscript  -file  $file -colormode color \
                            -x $x0 -y $y0 -width $w -height $h \
                            -pagex 0 -pagey 0 -pagewidth 20.c -pageheight 30.c \
                            -pageanchor nw -fontmap fontmap
                }
                *.svg {
                    ::can2svg::canvas2file $c $file
                }
                *.wmf {
                    set emfdc [wmf open]
                    set size [gdi copybits $emfdc -window $c -calc]
                    eval gdi copybits $emfdc -window $c -source [ list $size ] -scale 1.01
                    set emf [wmf close $emfdc]
                    wmf copy $emf -file $file
                    wmf delete $emf
                    
                }
                *.bmp {
                    JeromeCanvasSave $c $file  bmp
                }
                *.pcx           {
                    JeromeCanvasSave $c $file  pcx
                }
                *.pix           {
                    raise [winfo toplevel $c]
                    update
                    set img [image create pixmap  -data $c]
                    $img write $file
                }
                *.ppm           {
                    JeromeCanvasSave $c $file  ppm
                }
                *.ico        {
                    JeromeCanvasSave $c $file  ico
                }
                *.sgi        {
                    JeromeCanvasSave $c $file  sgi
                }
                *.ras        {
                    JeromeCanvasSave $c $file  sun
                }
                *.tga        {
                    JeromeCanvasSave $c $file  tga
                }
                *.jpg {
                    JeromeCanvasSave $c $file  jpeg
                }
                *.gif {
                    JeromeCanvasSave $c $file gif
                }
                *.png {
                    JeromeCanvasSave $c $file png
                }
                *.xpm {
                    JeromeCanvasSave $c $file xpm
                }
                *.xbm {
                    JeromeCanvasSave $c $file xbm
                }
                *.tif {
                    JeromeCanvasSave $c $file  tiff
                }
            }
        }
    }
    #
    proc JeromeCanvasSave {w file {format JPEG}} {
        $w configure -scrollregion [$w bbox all]
        raise [winfo toplevel $w]
        update
        
        set initialFractX [$w xview]
        set initialFractY [$w yview]
        
        $w xview moveto 0
        $w yview moveto 0
        
        update idletasks
        
        set fractStepX [lindex [$w xview] 1]
        set fractStepY [lindex [$w yview] 1]
        
        set width [expr [lindex [$w bbox all] 2] - [lindex [$w bbox all] 0]]
        set height [expr [lindex [$w bbox all] 3] - [lindex [$w bbox all] 1]]
        
        set image [image create photo -width $width -height $height]
        
        if {$fractStepX==0} {set fractStepX 1}
        if {$fractStepY==0} {set fractStepY 1}
        
        for {set i 0} {$i<1} {set i [expr $i + $fractStepX]} {
            for {set j 0} {$j<1} {set j [expr $j + $fractStepY]} {
                $w xview moveto $i
                $w yview moveto $j
                
                update idletasks
                
                set tfractStepX [lindex [$w xview] 0]
                set tfractStepY [lindex [$w yview] 0]
                
                set temp [image create photo -format window -data $w]
                
                $image copy $temp -from 0 0 -to [expr round($tfractStepX * $width)] [expr round($tfractStepY * $height)]
                
                image delete $temp
            }
        }
        $image write $file -format $format
        image delete $image
        $w xview moveto [lindex $initialFractX 0]
        $w yview moveto [lindex $initialFractY 0]
    }
    ### panel d'exportation Html
    proc HTMLexportPanel {} {
        global result prompt S html
        set S(variable) ""
        destroy .htmlexport
        set f [toplevel .htmlexport]
        wm title $f "HTML export"
        # CONTROLS Load labels file / Select labels file / Tree Target ok cancel
        #load
        frame $f.controls
        button $f.controls.load -text "Load annotations..." -command Database::LoadAnnotations
        # Select Target(s)
        menubutton $f.controls.target -text "Document(s) to export"  \
                -menu $f.controls.target.m  -direction below
        set z  [menu  $f.controls.target.m -tearoff 0]
        $z configure -postcommand "ImportExport::HTMLexportWindowTarget $z"
        # OK Cancel buttons
        set b [frame $f.buttons]
        button $f.controls.ok -text Export -command "ImportExport::HTMLexportGo"
        button $f.controls.cancel -text Cancel -command "destroy .htmlexport"
        # PACK CONTROLS
        pack $f.controls.load $f.controls.target $f.controls.ok $f.controls.cancel -side left -fill x -expand yes
        pack  $f.controls -fill x -expand yes
        ### URL
        iwidgets::Labeledframe $f.url -labelpos nw -labeltext "URLs"
        # URL PREFIX
        set urlprefix [$f.url childsite]
        checkbutton $urlprefix.mode -text "URL linked to leaves" -variable html(modeurl) \
                -command "ImportExport::HTMLexportURLonoff"
        set wop [frame $urlprefix.a]
        menubutton $wop.loca -indicatoron 1  -text "URL prefix: " -menu $wop.loca.m
        set mc [menu  $wop.loca.m -tearoff 0]
        $mc add radio -label "http://pbil.univ-lyon1.fr/" \
                -variable S(url-prefix) \
                -value "http://pbil.univ-lyon1.fr/cgi-bin/acnuc-search-ac?db=GenBank&query="
        $mc add radio -label "http://www.ncbi.nlm.nih.gov/entrez" \
                -variable S(url-prefix) \
                -value "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=Nucleotide&cmd=search&val="
        entry $wop.msg -width 80 -textvariable S(url-prefix)
        pack $urlprefix.mode -anchor w
        grid $wop.loca -row 1 -column 0
        grid $wop.msg -row 1 -column 1 -sticky news
        grid rowconfigure $wop 0  -weight 1
        grid columnconfigure $wop 1 -weight 1
        # URL SUFFIX
        set urlsuffix [$f.url childsite]
        set wip [frame $urlsuffix.b ]
        menubutton $wip.loca -indicatoron 1 -text "URL suffix: " -menu $wip.loca.m
        set mc [menu  $wip.loca.m -tearoff 0]
        entry $wip.msg -width 80 -textvariable S(url-suffix)
        pack $urlsuffix.mode
        grid $wip.loca -row 1 -column 0
        grid $wip.msg -row 1 -column 1 -sticky news
        grid rowconfigure $wip 0  -weight 1
        grid columnconfigure $wip 1 -weight 1
        pack $f.url
        # TAG ALT
        iwidgets::Labeledframe $f.alttags -labelpos nw -labeltext "Alt Tags"
        set cs [$f.alttags childsite]
        set cscheck [frame $cs.check ]
        checkbutton $cscheck.mode -text "Annotations linked to leaves"  -variable html(modetag) \
                -command "ImportExport::HTMLexportTAGonoff ; ImportExport::HTMLexportUpdateLabels"
        checkbutton $cscheck.nodes -text "Also Nodes" -variable html(modetagnode) \
                -command "ImportExport::HTMLexportTAGonoff"
        set cslist [frame $cs.list ]
        set walt1 [frame $cslist.al1 ]
        set walt2 [frame $cslist.al2 ]
        set lavailable [Interface::Lbs $walt1 Available 10 5 no]
        set lselect [Interface::Lbs $walt2 Selection 10 5 no]
        puts $lselect
        button $walt1.update -text Update  -command ImportExport::HTMLexportUpdateLabels
        grid $walt1.update -row 3 -column 0 -sticky news
        button $walt2.clear -text Clear  -command {.htmlexport.alttags.childsite.list.al2.l delete 0 end}
        grid $walt2.clear -row 3 -column 0 -sticky news
        # recherche de valeurs communes aux subtrees
        #pack $cscheck.mode $cscheck.nodes -side left
        pack $cscheck.mode -side left
        pack $walt1 $walt2  -side left -expand true -fill both
        pack $cscheck $cslist -side top -expand true -fill both
        # mise a jour listbox
        ImportExport::HTMLexportUpdateLabels
        ImportExport::HTMLexportURLonoff
        ImportExport::HTMLexportTAGonoff
        # BIND
        bind .htmlexport.alttags.childsite.list.al1.l <Button-1> "ImportExport::HTMLexportAltTagSelect %W %x %y"
        bind .htmlexport.alttags.childsite.list.al2.l <Button-1> "ImportExport::HTMLexportAltTagRemove %W %x %y"
        # pack
        pack  $wop $wip $f.alttags  -side top -expand true -fill x
    }
    proc HTMLexportWindowTarget {m} {
        global S html
        $m delete 0 end
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                $m add checkbutton -label [wm title .t$wi] -variable html(windowtarget,.t$wi) -command "raise .t$wi"
            }
        }
    }
    
    proc HTMLexportTAGonoff {} {
        global html
        switch $html(modetag) {
            0 {.htmlexport.alttags.childsite.list.al1.l  configure -state disabled
                .htmlexport.alttags.childsite.list.al2.l  configure -state disabled
                .htmlexport.alttags.childsite.list.al1.update  configure -state disabled
                .htmlexport.alttags.childsite.list.al2.clear  configure -state disabled}
            1 {.htmlexport.alttags.childsite.list.al1.l configure -state normal
                .htmlexport.alttags.childsite.list.al2.l  configure -state normal
                .htmlexport.alttags.childsite.list.al1.update  configure -state normal
                .htmlexport.alttags.childsite.list.al2.clear  configure -state normal}
        }
    }
    proc HTMLexportURLonoff {} {
        global html
        switch $html(modeurl) {
            0 {.htmlexport.url.childsite.a.loca configure -state disabled
                .htmlexport.url.childsite.a.msg configure -state disabled
                .htmlexport.url.childsite.b.loca configure -state disabled
                .htmlexport.url.childsite.b.msg configure -state disabled}
            1 {.htmlexport.url.childsite.a.loca configure -state normal
                .htmlexport.url.childsite.a.msg configure -state normal
                .htmlexport.url.childsite.b.loca configure -state normal
                .htmlexport.url.childsite.b.msg configure -state normal}
        }
    }
    proc HTMLexportUpdateLabels {} {
        global S
        if {[winfo exists .htmlexport] == "1"} {
            # menu url suffix
            .htmlexport.url.childsite.b.loca.m delete 0 end
            # .htmlexport.urlsuffix.loca.m add command -label "Load Labels..." \
            # -command "ImportExport::LoadLabels ; ImportExport::UpdateLabels"
            .htmlexport.url.childsite.b.loca.m add separator
            # listbox alt tag
            .htmlexport.alttags.childsite.list.al1.l delete 0 end
            foreach lf $S(ldatabase) {
                foreach tag [lsort -dictionary [Database::dbQueryVarAll $lf]] {
                    # menu url suffix
                    .htmlexport.url.childsite.b.loca.m add radio -label "$lf $tag" \
                            -variable S(url-suffix) \
                            -value "$lf $tag" \
                            -command "set S(database) $lf ; set S(variable) $tag"
                    # listbox alt tag
                    .htmlexport.alttags.childsite.list.al1.l insert end "$lf $tag"
                }
            }
        }
    }
    proc HTMLexportAltTagSelect {w x y} {
        set couple [$w get @$x,$y]
        .htmlexport.alttags.childsite.list.al2.l insert end $couple
        
    }
    #
    proc HTMLexportAltTagRemove {w x y} {
        $w delete @$x,$y
    }
    proc HTMLexportGo {} {
        global html T S tcl_platform
        set AlistWinTree  {}
        foreach key [array names html windowtarget,*] {
            if {$html($key) == 1} {
                set wi [string range $key [expr [string first , $key] + 1] end ]
                lappend AlistWinTree $wi
            }
        }
        if {$AlistWinTree == {}} {
            tk_messageBox -message "No document selected" -type ok; return
        } else  {
            set lfile {}
            foreach wi $AlistWinTree {
                raise $wi
                set canvasi $wi.c
                regsub -all " " [wm title $wi] "" s
                regsub -all "#" $s "" s
                set file [file join $S(userDIR) [format "%s%s%s" $s [Tools::GenId] .html]]
                lappend lfile $file
                if {$html(modeurl) == 0 && $html(modetag) == 0} {
                    exportHTMLwithOutMap $file $canvasi
                } else  {
                    exportHTMLwithMapGo $file $canvasi
                }
            }
            set choix [tk_messageBox -type okcancel -default ok  -message "Visualize ?" -icon question]
            if {$choix == "ok"} {
                catch {
                    foreach file $lfile {
                        switch $tcl_platform(platform) {
                            "unix" {catch { exec mozilla  $file &} err}
                            "windows" {catch {eval exec "{C:/program files/internet explorer/iexplore.exe}" $file &} err}
                        }
                    }
                }
            }
        }
    }

    #
    proc  exportHTMLwithMapGo {file c} {
        global S T
        raise [winfo toplevel $c]
        update
        regsub -all ".html" $file ".gif" filegif
        set tit [file tail $file]
        # fichier gif
        set f [file tail $filegif]
        JeromeCanvasSave $c $filegif gif
        # encapsulation HTML CAP
        set fid [open $file w]
        puts $fid "<HTML>"
        puts $fid "<HEAD>"
        puts $fid "<TITLE>$tit</TITLE>"
        puts $fid "<meta name=\"author\" content=\"TreeDyn http://www.treedyn.org IRD\">"
        puts $fid "</HEAD>"
        puts $fid "<BODY>"
        puts $fid "<FONT COLOR=black FACE=HELVETICA SIZE=1>"
        # encapsulation HTML MAP
        puts $fid "<IMG SRC=\"$f\"  border=\"0\" usemap=\"#treedynMap\">"
        puts $fid "<MAP name=\"treedynMap\">"
        
        foreach t $S($c,t) {
            foreach leaf $T($t,ue_lab) {
                set item [$c find withtag [list [format "%s%s" EUL  $leaf ] && T$t]]
                
                # attention si state hidden
                set st [lindex [$c itemconfigure $item -state] end]
                if {$st == "hidden" || $item == ""} {
                    # si leaves hiddden , on regarde si des annotations en LeavesReplace existent
                    # donc on regarde le tag ADD¶$leaf en prenant le permier elt de la liste
                    set item [lindex [$c find withtag [list [format "%s%s" ADD¶  $leaf ] && T$t]] 0]
                    #set item [list [$c find withtag [list [format "%s%s" ADD¶  $leaf ] && T$t]] ]
                    # et chercher le plus grand
                    if {$item == ""} {
                        # si pas d'annotation ADD on prend le code de l'arrete terminale
                        set item [$c find withtag [list [format "%s%s" EU  $leaf] && T$t]]
                    }
                }
                # les coordonnees
                set coTree [$c bbox T$t]
                set xTree [$c canvasx [lindex $coTree 0]]
                set yTree [$c canvasy [lindex $coTree 1]]
                set co [$c bbox $item]
                # les coordonnees sont OK
                #puts "LEAF [format "%s%s" EUL  $leaf ] && T$t COORDS: [format "%s%s"  $co hhhhhh]"      
################################################################################
#                 set x1 [$c canvasx [lindex $co 0]]
#                 set y1 [$c canvasy [lindex $co 1]]
#                 set x2 [$c canvasx [lindex $co 2]]
#                 set y2 [$c canvasy [lindex $co 3]]
#                 set co [list [expr $x1 - $xTree]   [expr $y1 - $yTree]  [expr $x2- $xTree]   [expr $y2- $yTree]]
#                 set co [list $x1 $y1 $x2 $y2]
################################################################################
                set x1 [lindex $co 0]
                set y1 [lindex $co 1]
                set x2 [lindex $co 2]
                set y2 [lindex $co 3]
                set co [list $x1 $y1 $x2 $y2]

                # ALT TAG couples database / variable
                set alttag ""
                set couples [.htmlexport.alttags.childsite.list.al2.l get 0 end]
                foreach e $couples {
                    set database [lindex $e 0]
                    set variable [lindex $e 1]
                    set S(database) $database
                    upvar #0 $S(database) X
                    # les records relatifs a une feuille dans une database
                    set record [Database::dbQueryRecordsFromVarVal $S(database) EU $leaf]
                    regsub -all "{}" $record "" record
                    if {$record != {}} {
                        foreach ri $record {
                            foreach {vari val} $X($ri) {
                                if {[string equal $variable $vari] == 1}  {
                                    set alttag [concat $alttag [string toupper $variable:] $val \n]
                                }
                            }
                        }
                    }
                }
                # URL suffix
                set database [lindex $S(url-suffix) 0]
                set variable [lindex $S(url-suffix) 1]
                set S(database) $database
                upvar #0 $S(database) X
                set record [Database::dbQueryRecordsFromVarVal $S(database) EU $leaf]
                set itemtext -
                if {$record == ""} {
                    set itemtext -
                } else {
                    foreach ri $record {
                        foreach {vari val} $X($ri) {
                            if {[string equal $variable $vari] == 1}  {
                                set itemtext $val
                            }
                        }
                    }
                }
                if {$alttag == ""} {
                    if {$itemtext == "-"} {
                        #rien
                    } else  {
                        set url [format "%s%s" $S(url-prefix) $itemtext]
                        puts $fid "<area shape=\"rect\" coords=\"$co\" href=\"$url\" target=\"TreeDyn\">"
                    }
                } else  {
                    if {$itemtext == "-"} {
                        puts $fid "<area shape=\"rect\" coords=\"$co\" alt=\"$alttag\">"
                    } else  {
                        set url [format "%s%s" $S(url-prefix) $itemtext]
                        puts $fid "<area shape=\"rect\" coords=\"$co\" href=\"$url\" alt=\"$alttag\" target=\"TreeDyn\">"
                    }
                }
            }
        }
        # encapsulation HTML TAIL
        puts $fid "</MAP>"
        puts $fid "</FONT>"
        puts $fid "<FONT COLOR=black FACE=HELVETICA SIZE=1>"
        puts $fid "<BR>"
        puts $fid "<a href=\"http://www.treedyn.org\">TreeDyn HTML export</a>"
        puts $fid "</FONT>"
        puts $fid "</HTML>"
        puts $fid "</BODY>"
        close $fid
    }
    #
    proc exportHTMLwithOutMap {file c} {
        global S T
        
        
        raise [winfo toplevel $c]
        update
        # fichier gif
        regsub -all ".html" $file ".gif" filegif
        set f [file tail $filegif]
        JeromeCanvasSave $c $filegif gif
        set fid [open $file w]
        puts $fid "<HTML>"
        puts $fid "<BODY>"
        puts $fid "<IMG SRC=\"$f\"  border=\"0\" alt=\"TreeDyn HTML export\""
        puts $fid "</HTML>"
        puts $fid "</BODY>"
        close $fid
    }
    
}

################################################################################


################################################################################
# NAVIGATION
################################################################################
namespace eval Navigation {
    
    ### les proc fct sur un tree si le pointeur souris est proche d'un arbre
    ### sinon sur tous les arbres de w (si le pointeur est loin de tous les arbres)
    ### le pointeur a une zone plus ou moins grande de selection (parametre s de SelectTree)
    proc Move {w x y} {
        global S T B
        set S(mox) $x
        set S(moy) $y
        $w delete box
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags TXT] != -1} {
                # text libre
                bind move <B1-Motion> "Navigation::MoveBulle %W %x %y $id"
            }  elseif  {[lsearch -exact $tags DBV] != -1} {
                # text libre
                bind move <B1-Motion> "Navigation::MoveBulle %W %x %y $id"
            }  elseif {[lsearch -exact $tags DBL] != -1} {
                # text libre
                bind move <B1-Motion> "Navigation::MoveBulle %W %x %y $id"
            } elseif {[lsearch -exact $tags bullab] != -1} {
                # special = bullabBLL¶$ID
                set i  [lindex $tags [lsearch -glob $tags BLL*]]
                set S(mov)   $i
                bind move <B1-Motion> "Annotation::BLLmove  %W %x %y $i"
            } elseif {[lsearch -exact $tags map] != -1} {
                # background bitmap
                set S(mov) map
                bind move <B1-Motion> "Navigation::MoveMap %W %x %y"
            }  elseif {[lsearch -exact $tags SCA] != -1} {
                # scale
                set i  [lindex $tags [lsearch -glob $tags TSCA*]]
                set S(mov) $i
                bind move <B1-Motion> "Navigation::DragMove %W %x %y $i"
            } elseif {[lsearch -glob $tags bullann] != -1} {
                bind move <Button-1> {Annotation::ANmovebullann %W %x %y}
            } elseif {[lsearch -glob $tags bracket] != -1} {
                # BRACKET
                set S(mov)  [lindex $tags [lsearch -glob $tags BKT*]]
                bind move <B1-Motion> "Navigation::DragMove %W %x %y $S(mov)"
            } elseif {[lsearch -glob $tags nbracket] != -1} {
                # BRACKET node
                set S(mov)  [lindex $tags [lsearch -glob $tags NBKT*]]
                bind move <B1-Motion> "Navigation::DragMoveX %W %x %y $S(mov)"
            } elseif {[lsearch -exact $tags Morpho] != -1} {
                # oval rectangle line MOR$ID
                set S(mov)  [lindex $tags [lsearch -glob $tags MOR*]]
                bind move <B1-Motion> "Navigation::DragMove %W %x %y $S(mov)"
            }  elseif {[lsearch -exact $tags DRAW] != -1} {
                # oval rectangle line
                set S(mov) current
                bind move <B1-Motion> "Navigation::DragMove %W %x %y current"
            }  elseif {[lsearch -exact $tags SuperTreeM] != -1} {
                # oval rectangle line
                set i  [lindex $tags [lsearch -glob $tags ST*]]
                set S(mov) $i
                bind move <B1-Motion> "Navigation::DragMove %W %x %y $i"
            } elseif {[lsearch -exact $tags querynode] != -1} {
                # special = querynode
                set S(mov)   $id
                bind move <B1-Motion> "Annotation::QueryNodeMove %W %x %y $id"
            } elseif {[lsearch -exact $tags ConnectIcon] != -1} {
                # special = querynode
                set S(mov)   $id
                bind move <B1-Motion> "Navigation::ConnectIconMove %W %x %y $id"
            } elseif {[lsearch -exact $tags ConnectIcon] != -1} {
                # special = querynode
                set S(mov)   $id
                bind move <B1-Motion> "Navigation::ConnectIconMove %W %x %y $id"
            }  elseif {[lsearch -exact $tags Legend] != -1} {
                # special = Legend
                set S(mov)  [lindex $tags [lsearch -glob $tags LE*]]
                bind move <B1-Motion> "Navigation::DragMove %W %x %y $S(mov)"
            }   elseif {[lsearch -exact $tags ShrinkT] != -1} {
                # ShrinkT
                set S(mov)   $id
                bind move <B1-Motion> "Annotation::BLLmove  %W %x %y $id"
            } elseif {[lsearch -glob $tags TD*] != -1} {
                # arbre issus d'une decomposition
                set S(mov)  [lindex $tags [lsearch -glob $tags TD*]]
                set id [lindex [split $S(mov) ¶] end]
                set t $B(OVAtre,$id)
                # avant le move on retag tous les elements
                Decomposition::ReTag $w $t
                bind move <B1-Motion> {Navigation::MoveTT %W %x %y}
            }  elseif {[lsearch -glob $tags T*] != -1} {
                # arbre
                set i [lindex $tags [lsearch -glob $tags T*]]
                set t [string range $i 1 end]
                set S(mov)   T$t
                bind move <B1-Motion> {Navigation::MoveTree %W %x %y}
            }
        }
    }
    # la feuille > T1 EUL119447 L current
    # le background > bgleaf T1 BGL¶1107107375073 current
    # l'arrete terminale > 1g1g2d3d4g5d6d7d8d9d10d11d12d13d EU119447 T1 1g1g2d3d4g5d6d7d8d9d10d11d12d13dC Z current
    proc MoveL {w x y} {
        global S T B
        set S(mox) $x
        set S(moy) $y
        set id [$w find withtag current]
        set tags [$w gettags $id]
        set t [string range [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set leavename [string range [lindex $tags [lsearch -glob $tags EUL*]] 3 end]
        set id2 nil
        if {$leavename != ""} {
            set codenode $T($t,ltc,$leavename)
            foreach  i $B($t,bgl) {
                if {[string match $codenode $B(BGLnod,$i)] == 1 } {
                    # alors tag specifique background = BGL¶ $id
                    set id2 BGL¶$i
                    break
                }
            }
        }
        bind movel <B1-Motion> "Navigation::MoveLeaf %W %x %y $id $id2"
    }
    ### feuille avec background
    proc MoveLeaf {w x y i {i2 nil} } {
        global S B
        set dx [expr $x - $S(mox)]
        set dy [expr $y - $S(moy)]
        $w move $i $dx $dy
        if {$i2 != "nil"} {$w move $i2 $dx $dy}
        set S(mox) $x
        set S(moy) $y
        $w raise $i
    }
    ###
    proc MoveALL {w x y} {
        global S T B
        set S(mox) $x
        set S(moy) $y
        $w delete box
        set S(mov)   all
        bind move <B1-Motion> "Navigation::MoveAllMotion %W %x %y"
    }
    ###
    proc ConnectIconMove {w x y i} {
        global S T B
        set tags [$w gettags $i]
        set id [lindex $tags [lsearch -glob $tags ConIconTag¶*]]
        $w move $id [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
    }
    ###
    proc MoveAllMotion {w x y} {
        global S T
        $w move $S(mov) [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
    }
    ### move sur T connu
    proc MoveT {w t x y} {
        global S T
        set S(mox) $x
        set S(moy) $y
        set S(mov) T$t
        bind move <B1-Motion> "Navigation::MoveTree %W %x %y"
    }
    ### le move d'une sous partie d'un arbre (decomposition)
    proc MoveTT {w x y} {
        global B S T
        #set x [$w canvasx $x] ; set y [$w canvasy $y]
        $w move $S(mov) [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
        # MAJ de tous les link associes a $t
        set id [lindex [split $S(mov) ¶] end]
        set t $B(OVAtre,$id)
        Decomposition::UpdateLink $w $t
        set cot [$w coords [format "%s%s%s"  link ¶ $id ]]
        if {$cot != ""} {
            set B(OVAtrx,$id) [expr abs([lindex $cot 2] - [lindex $cot 0])]
            set B(OVAtry,$id) [expr abs([lindex $cot 3] -[lindex $cot 1]) ]
        }
        Reflection::UpdateAll $w
    }
    ###
    proc MoveTree {w x y} {
        global S T
        $w move $S(mov) [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
        Reflection::UpdateAll $w
        #$w configure -scrollregion [$w bbox all]
    }
    ###
    proc MoveMap {w x y} {
        global S T
        $w move current [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
    }
    ###
    proc DragMove {w x y tag} {
        global S
        $w move $tag [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
    }
    ###
    proc DragMoveX {w x y tag} {
        global S
        $w move $tag [expr $x - $S(mox)] 0
        set S(mox) $x
        set S(moy) $y
    }
    ### text libre
    proc MoveBulle {w x y i} {
        global S B
        set dx [expr $x - $S(mox)]
        set dy [expr $y - $S(moy)]
        $w move current $dx $dy
        set S(mox) $x
        set S(moy) $y
        $w raise $i
    }
    # ZOOM JEROME
    ################################################################################
    proc ZoomTarget {w x y} {
        global Zoom S
        set id [$w find closest $x $y]
        if  {$id != ""} {
            set tags [$w gettags $id]
            set n  [lindex $tags [lsearch -glob $tags T*]]
            set t [string range $n 1 end]
            set Zoom(target) T$t
            
        }
    }
    #
    proc zoom {w x y type} {
        global Zoom
        
        set width [expr [lindex [$w bbox all] 2] - [lindex [$w bbox all] 0]]
        set height [expr [lindex [$w bbox all] 3] - [lindex [$w bbox all] 1]]
        
        if {$y<$Zoom(lastY) && $height>20} {
            set scaleY 0.9
            if {$type == "normal"} {set scaleX 0.9}
        } elseif {$y>$Zoom(lastY) && $height<1000000} {
            set scaleY 1.1
            if {$type == "normal"} {set scaleX 1.1}
        } else {
            set scaleY 1
            if {$type == "normal"} {set scaleX 1}
        }
        
        if {$type!="normal"} {
            if {$x>$Zoom(lastX) && $width<1000000} {
                set scaleX 1.1
            } elseif {$x<$Zoom(lastX) && $width>20} {
                set scaleX 0.9
            } else {set scaleX 1}
        }
        if {$type=="horizontal"} {set scaleY 1}
        if {$type=="vertical"} {set scaleX 1}
        if {$Zoom(target) == "all"} {
            $w scale $Zoom(target) [lindex [$w bbox all] 0] [lindex [$w bbox all] 1] $scaleX $scaleY
        } else  {
            $w scale $Zoom(target) [expr [lindex [$w bbox $Zoom(target)] 0] + $width/2] [expr $height/2 + [lindex [$w bbox $Zoom(target)] 1]] $scaleX $scaleY
        }
        
        set Zoom(lastY) $y
        set Zoom(lastX) $x
        $w configure -scrollregion [$w bbox all]
    }
    proc action {} {
        global Zoom
        bind zoom1 <ButtonPress-1> {
            set Zoom(lastX) %x
            set Zoom(lastY) %y
            set Zoom(target) all
        }
        bind zoom2 <ButtonPress-1> {
            set Zoom(lastX) %x
            set Zoom(lastY) %y
            set Zoom(target) all
        }
        bind zoom3 <ButtonPress-1> {
            set Zoom(lastX) %x
            set Zoom(lastY) %y
            set Zoom(target) all
        }
        bind zoom4 <ButtonPress-1> {
            set Zoom(lastX) %x
            set Zoom(lastY) %y
            set Zoom(target) all
        }
        bind zoom1 <Shift-ButtonPress-1> {
            set Zoom(lastX) %x
            set Zoom(lastY) %y
            Navigation::ZoomTarget %W %x %y
        }
        bind zoom2 <Shift-ButtonPress-1> {
            set Zoom(lastX) %x
            set Zoom(lastY) %y
            Navigation::ZoomTarget %W %x %y
        }
        bind zoom3 <Shift-ButtonPress-1> {
            set Zoom(lastX) %x
            set Zoom(lastY) %y
            Navigation::ZoomTarget %W %x %y
        }
        bind zoom4 <Shift-ButtonPress-1> {
            set Zoom(lastX) %x
            set Zoom(lastY) %y
            Navigation::ZoomTarget %W %x %y
        }
        bind zoom1 <B1-Motion> {Navigation::zoom %W %x %y horizontal}
        bind zoom2 <B1-Motion> {Navigation::zoom %W %x %y vertical}
        bind zoom3 <B1-Motion> {Navigation::zoom %W %x %y extend}
        bind zoom4 <B1-Motion> {Navigation::zoom %W %x %y normal}
        bind zoom1 <Shift-B1-Motion> {Navigation::zoom %W %x %y horizontal}
        bind zoom2 <Shift-B1-Motion> {Navigation::zoom %W %x %y vertical}
        bind zoom3 <Shift-B1-Motion> {Navigation::zoom %W %x %y extend}
        bind zoom4 <Shift-B1-Motion> {Navigation::zoom %W %x %y normal}
        bind zoom1 <ButtonRelease-1> {Navigation::ZoomRestore %W}
        bind zoom2 <ButtonRelease-1> {Navigation::ZoomRestore %W}
        bind zoom3 <ButtonRelease-1> {Navigation::ZoomRestore %W}
        bind zoom4 <ButtonRelease-1> {Navigation::ZoomRestore %W}
    }
    #
    proc ZoomRestore {w} {
        global S
        # sur tous les arbres de la fenetre
        foreach t $S($w,t) {
            Figuration::RestaureBGLall $w $t
            Figuration::RestaureBGSall $w $t
            Reflection::UpdateAll $w
        }
    }
    ### ZOOM via points cardinaux
    proc ZoomPC {w x y } {
        global B
        set id [$w find closest $x $y]
        if  {$id != ""} {
            set tags [$w gettags $id]
            if {[lsearch -exact $tags box] != -1} {
                if {[lsearch -glob $tags TD*] != -1} {
                    # cas de subtree issue de decomposition
                    set n  [lindex $tags [lsearch -glob $tags TD*]]
                    set id [lindex [split $n ¶] end]
                    # avant zoom on retag tous les elements
                    set t $B(OVAtre,$id)
                    Decomposition::ReTag $w $B(OVAtre,$id)
                    set cotag "$n && ! bullab && ! Link && ! [format "%s%s%s"  link ¶ $id]"
                    bind zoompc <B1-Motion> "Navigation::ZoomBrush %W %x %y $n [list $tags] [list $cotag]\
                            ; Decomposition::UpdateLink $w $B(OVAtre,$id)"
                } {
                    #tree standard
                    set n  [lindex $tags [lsearch -glob $tags T*]]
                    set t [string range $n 1 end]
                    set cotag "$n && ! bullab && ! Link"
                    bind zoompc <B1-Motion> "Navigation::ZoomBrush %W %x %y $n [list $tags] [list $cotag]"
                }
                bind zoompc   <ButtonRelease-1> "Navigation::ZoomPCrelease $w $t"
            } else {
                $w delete box
                bind zoompc <B1-Motion> ""
                Navigation::SelectTree $w $x $y
            }
        }
    }
    proc ZoomPCrelease {w t} {
        global S
        Figuration::RedrawBGLall $w $t
        Reflection::UpdateAll $w
        $w delete bbox
        bind zoompc   <ButtonRelease-1> ""
        $w config -cursor top_left_arrow
        set S(tool) move
        bindtags $w [list $S(tool) $w Canvas . all]
    }
    ### ZOOM via move sur les points cardinaux de la brush sur browser global
    proc ZoomBrush {w x y n tags cotag} {
        global B
        set coords [$w bbox box]
        
        set x1 [lindex $coords 0]
        set y1 [lindex $coords 1]
        set x2 [lindex $coords 2]
        set y2 [lindex $coords 3]
        
        set wb [expr $x2 - $x1]
        set hb [expr $y2 - $y1]
        $w delete box
        # on ne prend pas en compte les BLL et leur link
        set coords [$w bbox $cotag]
        set x1 [lindex $coords 0]
        set y1 [lindex $coords 1]
        set x2 [lindex $coords 2]
        set y2 [lindex $coords 3]
        set wt [expr $x2 - $x1]
        set ht [expr $y2 - $y1]
        if {$wb == 0} {set fx  1
        } else  {
            set fx [expr double($wb) / $wt ]
        }
        if {$wt == 0} {set fy  1
        } else  {
            set fy [expr double($hb) / $ht]
        }
        if {[lsearch -exact $tags SE] != -1} {
            $w scale $n $x1 $y1 $fx $fy
            Navigation::Bbox_Create $w $n $x1 $y1 $x $y
        } elseif {[lsearch -exact $tags SW] != -1} {
            $w scale $n $x2 $y1 $fx $fy
            Navigation::Bbox_Create $w $n $x $y1 $x2 $y
        } elseif {[lsearch -exact $tags NE] != -1} {
            $w scale $n $x1 $y2 $fx $fy
            Navigation::Bbox_Create $w $n $x1 $y $x $y2
        } elseif {[lsearch -exact $tags NW] != -1} {
            $w scale $n $x2 $y2 $fx $fy
            Navigation::Bbox_Create $w $n $x $y $x2 $y2
        }
        $w configure -scrollregion [$w bbox all]
    }
    ###
    proc ZoomFactorPanel {} {
        global S
        if {[winfo exists .zoomfactor] == 1} {
            wm deiconify .zoomfactor
            
        } else  {
            set w .zoomfactor
            #destroy $w
            toplevel $w -relief raised -borderwidth 2
            wm geometry $w "+[winfo pointerx $w]+[winfo pointery $w]"
            set wx [frame $w.x]
            label $wx.lx -text "X Zoom Factor:"
            spinbox $wx.fx  \
                    -from 0.01 -to 10 -incr 0.01 -width 4 -textvariable S(Xfactor)
            pack     $wx.lx $wx.fx -side left
            
            set wy [frame $w.y]
            label $wy.ly  -text "Y Zoom Factor:"
            spinbox $wy.fy   \
                    -from 0.01 -to 10 -incr 0.01 -width 4 -textvariable S(Yfactor)
            pack $wy.ly $wy.fy -side left
            pack $wx $wy   -expand yes -fill x -side top
            
            #bind $w.move  <Button-3> "Navigation::ZoomFactorM3 %W"
            #bind $w.move  <B1-Motion> "Navigation::ZoomFactorMoveMotion %W %x %y"
            #bind $w <Any-Leave> "Navigation::ZoomFactorPanelUpdate $ww.e"
        }
    }
    proc ZoomFactorPanelUpdate {editor} {
        global S
        #set S(AnnotateNote) [$editor get 1.0 end]
    }
    ### Zoom User fixe facteur de zoom entre 0 et 1
    proc ZoomFXFYuser {w x y {type 0}} {
        global S B
        set fx $S(Xfactor)
        set fy $S(Yfactor)
        set id [$w find closest $x $y]
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -glob $tags TD*] != -1} {
                set what  [lindex $tags [lsearch -glob $tags TD*]]
                set n  [lindex $tags [lsearch -glob $tags T*]]
                set t [string range $n 1 end]
                $w scale $what $x $y $fx $fy
                Decomposition::UpdateLink $w $t
                $w  configure -scrollregion [$w bbox all]
            } else  {
                set n  [lindex $tags [lsearch -glob $tags T*]]
                set t [string range $n 1 end]
                if {$type} {
                    set w $B($t,zoombrowserwindow)
                    set t $B($t,zoombrowsertree)
                    $w scale T$t $x $y $fx $fy
                    $w configure -scrollregion [$w bbox all]
                } else  {
                    $w scale T$t $x $y $fx $fy
                    $w  configure -scrollregion [$w bbox all]
                }
            }
            bind zoomx  <ButtonRelease-1> "set S(zx) 0 ; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
            bind zoomy  <ButtonRelease-1> "set S(zx) 0 ; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
            bind zoomxy <ButtonRelease-1> "set S(zx) 0 ; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
        }
    }
    #
    proc ZoomFXFY {w x y fx fy {type 0}} {
        global B
        set id [$w find closest $x $y]
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -glob $tags TD*] != -1} {
                set what  [lindex $tags [lsearch -glob $tags TD*]]
                set n  [lindex $tags [lsearch -glob $tags T*]]
                set t [string range $n 1 end]
                $w scale $what $x $y $fx $fy
                Decomposition::UpdateLink $w $t
                $w  configure -scrollregion [$w bbox all]
            } else  {
                set n  [lindex $tags [lsearch -glob $tags T*]]
                set t [string range $n 1 end]
                if {$type} {
                    set w $B($t,zoombrowserwindow)
                    set t $B($t,zoombrowsertree)
                    $w scale T$t $x $y $fx $fy
                    $w configure -scrollregion [$w bbox all]
                } else  {
                    $w scale T$t $x $y $fx $fy
                    $w  configure -scrollregion [$w bbox all]
                }
            }
            bind zoomx  <ButtonRelease-1> "set S(zx) 0 ; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
            bind zoomy  <ButtonRelease-1> "set S(zx) 0 ; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
            bind zoomxy <ButtonRelease-1> "set S(zx) 0 ; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
        }
    }
    ###
    proc ZoomHold {w x y s {type 0}} {
        global S B
        set id [$w find closest $x $y]
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -glob $tags TD*] != -1} {
                # arbre issus d'une decomposition
                set what  [lindex $tags [lsearch -glob $tags TD*]]
                set n  [lindex $tags [lsearch -glob $tags T*]]
                set t [string range $n 1 end]
                set S(zx) $x
                set S(zy) $y
                # serie special de fct zoom car integrant la mise a jour des link
                # des arbres en decomposition , pour ne pas alourdir les autres
                # zoom
                switch $s {
                    x+   {ZoomHoldX_special $S(ZF) $w $what $t}
                    x-   {ZoomHoldX_special [expr 1./$S(ZF)] $w $what $t}
                    y+   {ZoomHoldY_special $S(ZF) $w $what $t}
                    y-   {ZoomHoldY_special [expr 1./$S(ZF)] $w $what $t}
                    xy+  {ZoomHoldXY_special $S(ZF) $w $what $t}
                    xy-  {ZoomHoldXY_special [expr 1./$S(ZF)] $w $what $t}
                }
            } else  {
                set n  [lindex $tags [lsearch -glob $tags T*]]
                if {$n != ""} {
                    set t [string range $n 1 end]
                    if {$type} {
                        set w $B($t,zoombrowserwindow)
                        set t $B($t,zoombrowsertree)
                    }
                    set S(zx) $x
                    set S(zy) $y
                    switch $s {
                        x+   {ZoomHoldX $S(ZF) $w T$t}
                        x-   {ZoomHoldX [expr 1./$S(ZF)] $w T$t}
                        y+   {ZoomHoldY $S(ZF) $w T$t}
                        y-   {ZoomHoldY [expr 1./$S(ZF)] $w T$t}
                        xy+  {ZoomHoldXY $S(ZF) $w T$t}
                        xy-  {ZoomHoldXY [expr 1./$S(ZF)] $w T$t}
                    }
                }
            }
            bind zoomxb  <ButtonRelease-1> "set S(zx) 0; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
            bind zoomyb  <ButtonRelease-1> "set S(zx) 0 ; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
            bind zoomxyb <ButtonRelease-1> "set S(zx) 0 ; Figuration::RedrawBGLall $w $t ; Reflection::UpdateAll $w"
        }
    }
    ###
    proc ZoomHoldXY {zf c what} {
        global S
        
        if {$S(zx)} {
            catch {eval ZoomHoldXY_scale [expr ($S(zx)-$S(X))/$S(Z)] \
                        [expr ($S(zy)-$S(Y))/$S(Z)] \
                        $zf $c $what}
            update
            after $S(ZU) "Navigation::ZoomHoldXY $zf $c $what"
        }
    }
    ###
    proc ZoomHoldXY_special {zf c what t} {
        global S
        Decomposition::UpdateLink $c $t
        #Reflection::UpdateAll $w
        if {$S(zx)} {
            catch {eval ZoomHoldXY_scale [expr ($S(zx)-$S(X))/$S(Z)] \
                        [expr ($S(zy)-$S(Y))/$S(Z)] \
                        $zf $c $what}
            update
            after $S(ZU) "Navigation::ZoomHoldXY_special $zf $c $what $t"
        }
    }
    ###
    proc ZoomHoldXY_scale {x y z c what} {
        global S T
        set x [expr $x*$S(Z)+$S(X)]
        set y [expr $y*$S(Z)+$S(Y)]
        #$c scale [list $what && !R] $x $y $z $z
        $c scale $what $x $y $z $z
        set S(Z) [expr $S(Z)*$z]
        $c configure -scrollregion [$c bbox all]
        set S(X) [expr $x+$z*($S(X)-$x)]
        set S(Y) [expr $y+$z*($S(Y)-$y)]
    }
    ###
    proc ZoomHoldX {zf c what} {
        global S
        if {$S(zx)} {
            catch {eval ZoomHoldX_scale [expr ($S(zx)-$S(X))/$S(Z)] \
                        [expr ($S(zy)-$S(Y))/$S(Z)] \
                        $zf $c $what}
            update
            after $S(ZU) "Navigation::ZoomHoldX $zf $c $what"
        }
    }
    ###
    proc ZoomHoldX_special {zf c what t} {
        global S
        Decomposition::UpdateLink $c $t
        if {$S(zx)} {
            catch {eval ZoomHoldX_scale [expr ($S(zx)-$S(X))/$S(Z)] \
                        [expr ($S(zy)-$S(Y))/$S(Z)] \
                        $zf $c $what}
            update
            after $S(ZU) "Navigation::ZoomHoldX_special $zf $c $what $t"
        }
    }
    ###
    proc ZoomHoldX_scale {x y z c what} {
        global S  T
        set x [expr $x*$S(Z)+$S(X)]
        set y [expr $y*$S(Z)+$S(Y)]
        $c scale $what $x $y $z 1
        set S(Z) [expr $S(Z)*$z]
        $c configure -scrollregion [$c bbox all]
        set S(X) [expr $x+$z*($S(X)-$x)]
        set S(Y) [expr $y+$z*($S(Y)-$y)]
    }
    ###
    proc ZoomHoldY {zf c what} {
        global S
        if {$S(zx)} {
            catch {eval ZoomHoldY_scale [expr ($S(zx)-$S(X))/$S(Z)] \
                        [expr ($S(zy)-$S(Y))/$S(Z)] \
                        $zf $c $what}
            update
            after $S(ZU) "Navigation::ZoomHoldY $zf $c $what"
        }
    }
    ###
    proc ZoomHoldY_special {zf c what t} {
        global S
        Decomposition::UpdateLink $c $t
        if {$S(zx)} {
            catch {eval ZoomHoldY_scale [expr ($S(zx)-$S(X))/$S(Z)] \
                        [expr ($S(zy)-$S(Y))/$S(Z)] \
                        $zf $c $what}
            update
            after $S(ZU) "Navigation::ZoomHoldY_special $zf $c $what $t"
        }
    }
    ###
    proc ZoomHoldY_scale {x y z c what} {
        global S T
        set x [expr $x*$S(Z)+$S(X)]
        set y [expr $y*$S(Z)+$S(Y)]
        $c scale $what 1 $y 1 $z
        set S(Z) [expr $S(Z)*$z]
        $c configure -scrollregion [$c bbox all]
        set S(X) [expr $x+$z*($S(X)-$x)]
        set S(Y) [expr $y+$z*($S(Y)-$y)]
    }
    ###
    proc ZoomHoldMousWheel {w d x y s {type 0}} {
        global S B
        set id [$w find closest $x $y]
        if  {$id != ""} {
            set tags [$w gettags $id]
            set n  [lindex $tags [lsearch -glob $tags T*]]
            set t [string range $n 1 end]
            if {$type} {
                set w $B($t,zoombrowserwindow)
                set t $B($t,zoombrowsertree)
            }
            set S(zx) $x
            set S(zy) $y
            if {$d > 0} {
                ZoomHoldXY $S(ZF) $w $t
            } else  {
                ZoomHoldXY [expr 1./$S(ZF)] $w $t
            }
        }
    }
    ### FitToContents
    proc FitToContents {w} {
        global S
        $w configure -scrollregion [$w bbox all]
        #update
    }
    ###  FitToWindow
    proc FitToWindow {w t} {
        global S T
        foreach {x0 y0 x1 y1} [$w bbox all] {}
        set widw [winfo width $w]
        set heiw [winfo height $w]
        set fx [expr abs($widw. /[expr $x1 - $x0])]
        set fy [expr abs($heiw. /[expr $y1 - $y0])]
        $w scale T$t 0 0 $fx $fy
        $w configure -scrollregion [$w bbox all]
    }
    proc FitToWindowMultiple {w} {
        global S T
        #set n [llength $S($w,t)]
        foreach {x0 y0 x1 y1} [$w bbox all] {}
        #set widw [expr [winfo width $w] / $n]
        #set heiw [expr [winfo height $w] / $n]
        set widw [winfo width $w]
        set heiw [winfo height $w]
        set fx [expr abs($widw. /[expr $x1 - $x0])]
        set fy [expr abs($heiw. /[expr $y1 - $y0])]
        foreach t $S($w,t) {
            $w scale T$t 0 0 $fx $fy
        }
        $w configure -scrollregion [$w bbox all]
    }
    ###
    proc FitToFullScreen {w} {
        global S  T
        set wi [winfo screenwidth .]
        set he [winfo screenheight .]
        set wparent  [winfo parent $w]
        set s [format "%s%s%s%s" $wi x $he +0+0]
        wm geometry $wparent $s
        raise $w
    }
    #  Browser CopyPaste
    proc BrowserCP {w x y} {
        global B T S
        if {[winfo exists .navcp] == 0 }  {
            destroy .navcp
            set nw .navcp
            set wbcp $nw.c
            toplevel $nw -width $S(browserCP_width) -height $S(browserCP_height)
            wm resizable $nw 1 1
            wm title $nw "Navigation : Copy&Paste"
            canvas $wbcp -width $S(browserCP_width) -height $S(browserCP_height) \
                    -highlightthickness 0 -background LightGoldenrodYellow
            grid $wbcp -row 0 -column 0 -sticky news
            grid rowconfigure $nw 0  -weight 1
            grid columnconfigure $nw 0 -weight 1
            bind $wbcp <Configure> {Navigation::ReDisplayAfterResizingBrowserCP %W}
            wm protocol $nw WM_DELETE_WINDOW {}
        }
        set tags [$w gettags [$w find withtag current]]
        if {$tags != ""} {
            set wbcp .navcp.c
            $wbcp delete all
            set node [string trimright \
                    [lindex $tags [lsearch -glob $tags *C]] C]
            #####
            set tfrom [string range \
                    [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$node == ""} {set node $tfrom}
            if {[llength [Tools::NodeNoToLe $tfrom $node]] >= 2 } {
                set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
                lappend S(ilt) $t
                set data $T($tfrom,nwk,$node)
                set T($t,nwk) $data
                ImportExport::TreeInit $t
                ImportExport::NewickParser_Root $t $data
                # modif dec 2004 la copy garde le xmax de la structure de rattachement
                set T($t,xmax) $T($tfrom,xmax)
                set S($t,w) $wbcp
                set S($t,type) $S($tfrom,type)
                Conformation::ArrToCanType2 $t .navcp.c \
                        0 0 [expr $S(browserCP_width) -30] [expr  $S(browserCP_height) -10]
            }
        }
    }
    # Copy & PAste to a collection
    proc CoPaCollection {w x y} {
        global S T
        set tags [$w gettags [$w find withtag current]]
        if {[lsearch -exact $tags Z] != -1} {
            set n [string trimright \
                    [lindex $tags [lsearch -glob $tags *C]] C]
            set t [string range \
                    [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$n == "" && $t != ""} {set n $t}
            if {$S(collection) == ""} {
                CoPaCollectionCreateInsert $w $t $n
            } else  {
                # si une ou plusierus collection : menu de gestion des collections
                if {[winfo exists $w.collection ] == 1} {destroy $w.collection}
                set m [menu $w.collection -tearoff 0]
                #titre
                $m add command -label "Collection:"
                $m add separator
                $m add command -label "Create a new collection"   \
                        -command "Navigation::CoPaCollectionCreateInsert $w $t $n"
                $m add separator
                # pour chaque collection
                foreach col $S(collection) {
                    $m add command -label "Collection $col"  \
                            -command "Navigation::CoPaCollectionInsert $w $t $n $col"
                }
                tk_popup $m [winfo pointerx $w] [winfo pointery $w]
            }
        }
    }
    proc DeleteToolbox {w x y} {
        if {[winfo exists $w.deletemenu ] == 1} {destroy $w.deletemenu}
        set m [menu $w.deletemenu -tearoff 0]
        set i [$w find withtag current]
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        global B
        if {$i != {}}  {
            set tags [$w gettags $i]
            ################################################################################
            #             if {[lsearch -glob $tags *C] != -1} {
            #                 $m add command -label "Subtree"
            #             } elseif  {[lsearch -exact $tags Morpho] != -1} {
            #                 $m add command -label "Shape:"
            #                 $m add command -label "Delete" -command "Annotation::BLLDelete $w $i"
            #             } elseif  {[lsearch -exact $tags Plot] != -1} {
            #                 $m add command -label "Scatterplot:"
            #                 $m add command -label "Delete" -command "Annotation::BLLDelete $w $i"
            #             } elseif  {[lsearch -exact $tags querynode] != -1} {
            #                 set id [lindex [split [lindex $tags [lsearch -glob $tags QYN*]] ¶] end]
            #                 $m add command -label $B(QYNqry,$id)
            #                 $m add command -label Delete -command "Annotation::QueryNodeDelete $w $id"
            #             } elseif  {[lsearch -exact $tags bullab] != -1} {
            #                 $m add command -label Labels
            #                 $m add command -label Delete -command "Annotation::BLLDelete $w $i"
            #             } elseif  {[lsearch -exact $tags DBL] != -1} {
            #                 $m add command -label "Bootstrap Value"
            #                 $m add command -label Delete -command "$w delete $i"
            #             } elseif  {[lsearch -exact $tags DBV] != -1} {
            #                 $m add command -label [string toupper "Branch Length"]
            #                 $m add command -label Delete -command "$w delete $i"
            #             }   elseif  {[lsearch -exact $tags Connect] != -1} {
            #                 set id [lindex [split [lindex $tags [lsearch -glob $tags Connect¶*]] ¶] end]
            #                 $m add command -label "Node Network"
            #                 $m add command -label "Delete Network" -command "Interface::D3ConnectorAction $w $id delete"
            #             }   elseif  {[lsearch -exact $tags ConnectIcon] != -1} {
            #                 set id [lindex [split [lindex $tags [lsearch -glob $tags Connect¶*]] ¶] end]
            #                 $m add command -label "Node Network"
            #                 $m add command -label "Delete Network" -command "Interface::D3ConnectorAction $w $id delete"
            #             }  elseif  {[lsearch -exact $tags bgtree] != -1} {
            #                 $m add command -label "Tree background"
            #                 $m add command -label "Delete" -command "Interface::D3ActionBgTree $w $i delete"
            #             } elseif  {[lsearch -exact $tags Legend] != -1} {
            #                 $m add command -label "Legend"
            #                 $m add command -label "Delete" -command "Interface::D3ActionLegend $w $id delete"
            #             } elseif  {[lsearch -exact $tags L] != -1} {
            #                 $m add command -label "Leaf"
            #             } elseif  {[lsearch -exact $tags bracket] != -1} {
            #                 $m add command -label "Bracket"
            #                 $m add command -label Delete -command "$w delete $id"
            #             } elseif  {[lsearch -exact $tags DRAW] != -1} {
            #                 $m add command -label Illustration -command ""
            #                 $m add command -label Delete -command "$w delete $i"
            #             } elseif  {[lsearch -exact $tags ni] != -1} {
            #                 $m add command -label "Node Illustration" -command ""
            #                 $m add command -label Delete -command "$w delete $i"
            #             }  elseif  {[lsearch -exact $tags SuperTreeM] != -1} {
            #                 $m add command -label "Presence/Absence SuperTree:"
            #                 $m add command -label "Delete" -command "$w delete $i"
            #             }  elseif  {[lsearch -exact $tags bitmap] != -1} {
            #                 $m add command -label Bitmap
            #                 $m add command -label Delete -command "$w delete $i"
            #             }  elseif  {[lsearch -exact $tags  TXT] != -1} {
            #                 $m add command -label Text
            #                 $m add command -label Delete -command "$w delete $i"
            #             }   elseif  {[lsearch -exact $tags  SCA] != -1} {
            #                 $m add command -label Scale
            #                 $m add command -label Delete -command "Interface::ScaleDelete $w $t"
            #             }   elseif  {[lsearch -exact $tags AnnotMatrix] != -1} {
            #                 set maq  [lindex $tags [lsearch -glob $tags MA*]]
            #                 set q [lindex [split $maq ¶] end]
            #                 set serie [lindex $tags [lsearch -glob $tags COL*]]
            #
            #                 $m add command -label "Annotation $q" -command ""
            #                 $m add command -label "Delete this annotation" -command "$w delete $i"
            #                 $m add command -label "Delete serie" -command "$w delete $serie"
            #                 $m add command -label "Delete all" -command "set S($t,LabelMatrixBase) 0 ; $w delete AM$t"
            #             }   else {
            #                 # ?
            #                 $m add command -label "?"
            #             }
            ################################################################################
        } elseif {[$w find overlapping [expr $x -30]  [expr $y - 30] [expr $x+30] [expr $y+30] ] == "" } {
            $m add command -label "Delete (document): "
            $m add command -label "Node annotations/illustrations" -command "Navigation::deleteDocumentAnnotationN $w"
            $m add command -label "Leaves annotations/illustrations" -command "Navigation::deleteDocumentAnnotationL $w"
            
        } else {
            # TREE
            $m add command -label "Delete (tree): "
            set id [$w find closest $x $y]
            set tags [$w gettags $id]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$t != ""} {
                #$m add command -label "Delete Tree" -command ""
                $m add command -label "Node annotations/illustrations" -command "Interface::D3ActionTree $w $t removeallannotation"
                $m add command -label "Leaves annotations/illustrations" -command "$w delete AM$t"
                
            }
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    proc deleteDocumentAnnotationL {w} {
        global S
        foreach t $S($w,t) {$w delete AM$t}
    }
    proc deleteDocumentAnnotationN {w} {
        global S
        foreach t $S($w,t) {Interface::D3ActionTree $w $t removeallannotation}
    }
    # Menus d'initialisation des variables graphiques
    proc ResetGV {w x y} {
        if {[winfo exists $w.resetmenu ] == 1} {destroy $w.resetmenu}
        set m [menu $w.resetmenu -tearoff 0]
        set i [$w find withtag current]
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        if {$i != {}}  {
            set tags [$w gettags $i]
            # NODE
            if {[lsearch -glob $tags *C] != -1} {
                set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
                set n [string trimright \
                        [lindex $tags [lsearch -glob $tags *C]] C]
                $m add command -label "Reset (node): "
                $m add separator
                resetSubtree $m $w $t $n
                $m add separator
                menu $m.t -tearoff 0
                $m add cascade -label "Reset (tree): " -menu $m.t
                resetTree $m.t $w $t
                $m add separator
                menu $m.d -tearoff 0
                $m add cascade -label "Reset (document): " -menu $m.d
                resetDocument $m.d $w
                
            } else {$m add command -label "?"}
        } elseif {[$w find overlapping [expr $x -30]  [expr $y - 30] [expr $x+30] [expr $y+30] ] == "" } {
            # CANVAS
            $m add command -label "Reset (document): "
            $m add separator
            resetDocument $m $w
        } else {
            # TREE
            set id [$w find closest $x $y]
            set tags [$w gettags $id]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$t != ""} {
                $m add command -label "Reset (tree): "
                $m add separator
                resetTree $m $w $t
                $m add separator
                menu $m.d -tearoff 0
                $m add cascade -label "Reset (document): " -menu $m.d
                resetDocument $m.d $w
            }
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    
    proc resetDocumentVar {w  v} {
        global S
        foreach ti $S($w,t) {
            switch $v {
                tbg {Figuration::GraVarInitBgSubTree $w $ti}
                tfg {Figuration::GraVarInitFgTree $w $ti}
                tlw {Figuration::GraVarInitLineWidth $w $ti}
                tld {Figuration::GraVarInitLineDash $w $ti}
                t {
                    Figuration::GraVarInitBgSubTree $w $ti
                    Figuration::GraVarInitFgTree $w $ti
                    Figuration::GraVarInitLineWidth $w $ti
                    Figuration::GraVarInitLineDash $w $ti
                }
                lbg {Figuration::GraVarInitBgLeaf $w $ti}
                lfg {Figuration::GraVarInitFgLeaf $w $ti}
                lfo {Figuration::GraVarInitFont $w $ti}
                l {
                    Figuration::GraVarInitBgLeaf $w $ti
                    Figuration::GraVarInitFgLeaf $w $ti
                    Figuration::GraVarInitFont $w $ti
                }
                tl {
                    Figuration::GraVarInitBgSubTree $w $ti
                    Figuration::GraVarInitFgTree $w $ti
                    Figuration::GraVarInitLineWidth $w $ti
                    Figuration::GraVarInitLineDash $w $ti
                    Figuration::GraVarInitBgLeaf $w $ti
                    Figuration::GraVarInitFgLeaf $w $ti
                    Figuration::GraVarInitFont $w $ti
                }
            }
        }
    }
    proc resetTreeVar {w ti v} {
        global S
        switch $v {
            tbg {Figuration::GraVarInitBgSubTree $w $ti}
            tfg {Figuration::GraVarInitFgTree $w $ti}
            tlw {Figuration::GraVarInitLineWidth $w $ti}
            tld {Figuration::GraVarInitLineDash $w $ti}
            t {
                Figuration::GraVarInitBgSubTree $w $ti
                Figuration::GraVarInitFgTree $w $ti
                Figuration::GraVarInitLineWidth $w $ti
                Figuration::GraVarInitLineDash $w $ti
            }
            lbg {Figuration::GraVarInitBgLeaf $w $ti}
            lfg {Figuration::GraVarInitFgLeaf $w $ti}
            lfo {Figuration::GraVarInitFont $w $ti}
            l {
                Figuration::GraVarInitBgLeaf $w $ti
                Figuration::GraVarInitFgLeaf $w $ti
                Figuration::GraVarInitFont $w $ti
            }
            tl {
                Figuration::GraVarInitBgSubTree $w $ti
                Figuration::GraVarInitFgTree $w $ti
                Figuration::GraVarInitLineWidth $w $ti
                Figuration::GraVarInitLineDash $w $ti
                Figuration::GraVarInitBgLeaf $w $ti
                Figuration::GraVarInitFgLeaf $w $ti
                Figuration::GraVarInitFont $w $ti
            }
        }
    }
    proc resetNodeVar {w ti n v} {
        global S
        switch $v {
            tbg {Figuration::GraVarInitBgSubTree $w $ti $n}
            tfg {Figuration::GraVarInitFgTree $w $ti $n}
            tlw {Figuration::GraVarInitLineWidth $w $ti $n}
            tld {Figuration::GraVarInitLineDash $w $ti $n}
            t {
                Figuration::GraVarInitBgSubTree $w $ti $n
                Figuration::GraVarInitFgTree $w $ti $n
                Figuration::GraVarInitLineWidth $w $ti $n
                Figuration::GraVarInitLineDash $w $ti $n
            }
            lbg {Figuration::GraVarInitBgLeaf $w $ti $n}
            lfg {Figuration::GraVarInitFgLeaf $w $ti $n}
            lfo {Figuration::GraVarInitFont $w $ti $n}
            l {
                Figuration::GraVarInitBgLeaf $w $ti $n
                Figuration::GraVarInitFgLeaf $w $ti $n
                Figuration::GraVarInitFont $w $ti $n
            }
            tl {
                Figuration::GraVarInitBgSubTree $w $ti $n
                Figuration::GraVarInitFgTree $w $ti $n
                Figuration::GraVarInitLineWidth $w $ti $n
                Figuration::GraVarInitLineDash $w $ti $n
                Figuration::GraVarInitBgLeaf $w $ti $n
                Figuration::GraVarInitFgLeaf $w $ti $n
                Figuration::GraVarInitFont $w $ti $n
            }
        }
    }
    proc resetDocument {m w} {
        $m add command -label "Tree(s): "
        $m add command -label "Background Color" -command "Navigation::resetDocumentVar $w tbg"
        $m add command -label "Foreground Color" -command "Navigation::resetDocumentVar $w tfg"
        $m add command -label "Line Width" -command "Navigation::resetDocumentVar $w tlw"
        $m add command -label "Line Dash" -command "Navigation::resetDocumentVar $w tld"
        $m add command -label "All" -command "Navigation::resetDocumentVar $w t"
        $m add separator
        $m add command -label "Leaves: "
        $m add command -label "Background Color" -command "Navigation::resetDocumentVar $w lbg"
        $m add command -label "Foreground Color" -command "Navigation::resetDocumentVar $w lfg"
        $m add command -label "Font" -command "Navigation::resetDocumentVar $w lfo"
        $m add command -label "All" -command "Navigation::resetDocumentVar  $w l"
        $m add separator
        $m add command -label "All" -command "Navigation::resetDocumentVar $w tl"
    }
    proc resetTree {m w t} {
        $m add command -label "Subtree: "
        $m add command -label "Background Color" -command "Navigation::resetTreeVar $w $t tbg"
        $m add command -label "Foreground Color" -command "Navigation::resetTreeVar $w $t tfg"
        $m add command -label "Line Width" -command "Navigation::resetTreeVar $w $t tlw"
        $m add command -label "Line Dash" -command "Navigation::resetTreeVar $w $t tld"
        $m add command -label "All" -command "Navigation::resetTreeVar $w $t t"
        $m add separator
        $m add command -label "Leaves: "
        $m add command -label "Background Color" -command "Navigation::resetTreeVar $w $t lbg"
        $m add command -label "Foreground Color" -command "Navigation::resetTreeVar $w $t lfg"
        $m add command -label "Font" -command "Navigation::resetTreeVar $w $t lfo"
        $m add command -label "All" -command "Navigation::resetTreeVar $w $t l"
        $m add separator
        $m add command -label "All" -command "Navigation::resetTreeVar $w $t tl"
    }
    proc resetSubtree {m w t n} {
        $m add command -label "Subtree: "
        $m add command -label "Background color" -command "Navigation::resetNodeVar $w $t $n tbg"
        $m add command -label "Foreground color" -command "Navigation::resetNodeVar $w $t $n tfg"
        $m add command -label "Line width" -command "Navigation::resetNodeVar $w $t $n tlw"
        $m add command -label "Line dash" -command "Navigation::resetNodeVar $w $t $n tld"
        $m add command -label "All" -command "Navigation::resetNodeVar $w $t $n t"
        $m add separator
        $m add command -label "Subtree (recurssive): "
        $m add command -label "Background color" -command "Navigation::resetNodeVar  $w $t [format "%s%s" $n *] tbg"
        $m add command -label "Foreground color" -command "Navigation::resetNodeVar $w $t [format "%s%s" $n *] tfg"
        $m add command -label "Line width" -command "Navigation::resetNodeVar $w $t [format "%s%s" $n *] tlw"
        $m add command -label "Line dash" -command "Navigation::resetNodeVar $w $t [format "%s%s" $n *] tld"
        $m add command -label "All" -command "Navigation::resetNodeVar $w $t [format "%s%s" $n *] t"
        $m add separator
        $m add command -label "Leaves: "
        $m add command -label "Background color" -command "Navigation::resetNodeVar $w $t $n lbg"
        $m add command -label "Foreground color" -command "Navigation::resetNodeVar $w $t $n lfg"
        $m add command -label "Font" -command "Navigation::resetNodeVar $w $t $n lfo"
        $m add command -label "All" -command "Navigation::resetNodeVar $w $t $n l"
        $m add separator
        $m add command -label "All, Subtree" -command "Navigation::resetNodeVar $w $t $n tl"
        $m add command -label "All, Subtree (recurssive)" -command "Navigation::resetNodeVar $w $t $n tl"
    }
    #
    proc CoPaCollectionCreateInsert {w t n} {
        global S T
        # si aucune collection
        # le [Tools::GenId] est l'ID de la collection
        set IDcollection [Tools::GenId]
        # S(collection) est la liste des ID collections
        lappend S(collection) $IDcollection
        # creation de la fenetre de collection
        set collection [ImportExport::NewCanvas]
        #chaque ID collection reference la path window correspondant
        set S(collection,$IDcollection) $collection
        # ...final, copy paste
        Navigation::CoPaCollectionInsert $w $t $n $IDcollection
    }
    #
    proc CoPaCollectionInsert {wsource tsource nodesource IDcollection} {
        global S T
        set wtarget $S(collection,$IDcollection)
        set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        lappend S($wtarget,t) $t
        set code $t
        set data $T($tsource,nwk,$nodesource)
        set T($t,nwk) $data
        ImportExport::TreeInit $t
        if {[catch [ImportExport::NewickParser_Root $t $data] result] != 0} {
            ImportExport::CleanArrayTree $t
        }  else {
            set T($t,xmax) $T($tsource,xmax)
            set S($t,w) $wtarget
            set S($t,tit) -
            set S($t,type) $S($tsource,type)
            Conformation::ArrToCanType2 $t $wtarget
            ImportExport::NodeBind $wtarget $t
            Figuration::TransitionVG $wtarget $tsource $nodesource $t
            Figuration::RestaureT $wtarget $t
            Operation::TreeViewerPanelUpdate
        }
    }
    ###
    proc ReDisplayAfterResizingBrowserCP {w} {
        global S
        set fx [expr double([winfo width $w]) / $S(browserCP_width)]
        set fy [expr double([winfo height $w]) / $S(browserCP_height)]
        $w scale all 0 0 $fx $fy
        set S(browserCP_width) [winfo width $w]
        set S(browserCP_height) [winfo height $w]
    }
    # Browser Global View + Brush
    # etalonage a faire (position et taille)
    proc makeBrowerGlobal {w t} {
        global B T S
        set tsource $t
        set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        set code $t
        set data $T($tsource,nwk,$tsource)
        set T($t,nwk,$t) $data
        ImportExport::TreeInit $t
        set S($t,display_eu) hidden
        if {[catch [ImportExport::NewickParser_Root $t $data] result] != 0} {
            ImpotExport::UpdateArrayCanvas $w $t
            Interface::TreeDynMessage "Error"
        }  else {
            set nw [ImportExport::NewWindowName]
            set wp $nw.c
            set S($t,w) $wp
            lappend S($wp,t) $t
            set B($wp,x) 0
            set B($wp,y) 0
            set B($wp,w_source_width)  150
            set B($wp,w_source_height) 150
            set B($wp,w_source_tree) T$t
            set B($wp,w_target_tree) T$tsource
            set B($wp,w_target_window) $w
            set B($wp,fx) 1.0
            set B($wp,fy) 1.0
            set coords [$w bbox $B($wp,w_target_tree)]
            set wtree [expr [lindex $coords 2] - [lindex $coords 0]]
            set htree [expr [lindex $coords 3] - [lindex $coords 1]]
            set fx [expr 150.0 / $wtree]
            set fy [expr 150.0 / $htree]
            # set B($wp,brush_width) [expr [winfo width $w] * $fx]
            # set B($wp,brush_height) [expr [winfo height $w] * $fy]
            set B($wp,brush_width) 50
            set B($wp,brush_height) 50
            toplevel $nw -width 150 -height 150
            wm resizable $nw 1 1
            wm title $nw "Navigation : Global Browser"
            canvas $wp -width $B($wp,w_source_width) -height $B($wp,w_source_height) \
                    -highlightthickness 0 -background LightGoldenrodYellow
            grid $wp -row 0 -column 0 -sticky news
            grid rowconfigure $nw 0  -weight 1
            grid columnconfigure $nw 0 -weight 1
            Conformation::ArrToCanSwitch2 $t $wp $S($tsource,type)
            #Conformation::ArrToCanType2 $t $wp
            Brush_Create $wp 0 0 $B($wp,brush_width) $B($wp,brush_height)
            bind $wp <Configure> "Navigation::ReDisplayAfterResizing $wp"
            bind $wp <Button-1>  "Navigation::BrowserB1 %W %x %y"
            $w bind T$t <Any-Enter> "$w config -cursor hand2"
            $w bind T$t <Any-Leave> "$w config -cursor top_left_arrow"
        }
    }
    ###
    proc ReDisplayAfterResizing {w} {
        global B
        set fx [expr double([winfo width $w]) / $B($w,w_source_width)]
        set fy [expr double([winfo height $w]) / $B($w,w_source_height)]
        $w scale $B($w,w_source_tree) 0 0 $fx $fy
        set B($w,w_source_width) [winfo width $w]
        set B($w,w_source_height) [winfo height $w]
    }
    ###
    proc BrowserB1 {w x y} {
        global B
        set B($w,x) $x
        set B($w,y) $y
        set tags [$w gettags [$w find withtag current]]
        if {[lsearch -exact $tags SE] != -1} {
            bind $w <B1-Motion> "Navigation::BrowserB1MotionResizeBrush %W %x %y SE"
        } elseif {[lsearch -exact $tags SW] != -1} {
            bind $w <B1-Motion> "Navigation::BrowserB1MotionResizeBrush %W %x %y SW"
        } elseif {[lsearch -exact $tags NE] != -1} {
            bind $w <B1-Motion> "Navigation::BrowserB1MotionResizeBrush  %W %x %y NE"
        } elseif {[lsearch -exact $tags NW] != -1} {
            bind $w <B1-Motion> "Navigation::BrowserB1MotionResizeBrush  %W %x %y NW"
        } else {
            bind $w <B1-Motion> "Navigation::BrowserB1MotionMoveBrush %W %x %y"
        }
    }
    ###
    proc BrowserB1MotionMoveBrush  {w x y } {
        global B
        $w move box [expr $x - $B($w,x)] [expr $y - $B($w,y)]
        set coords [$w coords box]
        set wbrush [expr [lindex $coords 2] - [lindex $coords 0]]
        set hbrush [expr [lindex $coords 3] - [lindex $coords 1]]
        Navigation::Brush_UpdateTargetXY $w $x $y
    }
    ###
    proc BrowserB1MotionResizeBrush {w x y ori} {
        set coords [$w coords box]
        set x1 [lindex $coords 0]
        set y1 [lindex $coords 1]
        set x2 [lindex $coords 2]
        set y2 [lindex $coords 3]
        $w delete box
        $w delete bbox
        switch $ori {
            NW {Navigation::Brush_Create $w $x $y $x2 $y2}
            SW {Navigation::Brush_Create $w $x $y1 $x2 $y}
            NE {Navigation::Brush_Create $w $x1 $y $x $y2}
            SE {Navigation::Brush_Create $w $x1 $y1 $x $y}
        }
        $w itemconfigure bbox -fill yellow
        #Brush_UpdateTargetXY $w $x $y
        Brush_UpdateTargetWH $w $x $y
    }
    ###
    proc Brush_Create {w x1 y1 x2 y2} {
        global B
        set B($w,brush_width)  [expr $x2 - $x1]
        set B($w,brush_height) [expr $y2 - $y1]
        $w create rectangle $x1 $y1 $x2 $y2 -tag box -outline blue -width 1
        $w create rectangle [expr $x1 -2] [expr $y1 - 2] [expr $x1 + 2] [expr $y1 + 2] \
                -tags "bbox box NW" -fill orange
        $w create rectangle [expr $x1 -2] [expr $y2 - 2] [expr $x1 + 2] [expr $y2 + 2] \
                -tags "bbox box SW" -fill orange
        $w create rectangle [expr $x2 -2] [expr $y1 - 2] [expr $x2 + 2] [expr $y1 + 2] \
                -tags "bbox box NE" -fill orange
        $w create rectangle [expr $x2 -2] [expr $y2 - 2] [expr $x2 + 2] [expr $y2 + 2] \
                -tags "bbox box SE" -fill orange
        $w bind bbox <Any-Enter> "$w itemconfigure bbox -fill yellow"
        $w bind bbox <Any-Leave> "$w itemconfigure bbox -fill orange"
    }
    ###
    proc Brush_UpdateTargetXY {w x y} {
        global B
        set coords [$B($w,w_target_window) bbox $B($w,w_target_tree)]
        set wtree [expr [lindex $coords 2] - [lindex $coords 0]]
        set htree [expr [lindex $coords 3] - [lindex $coords 1]]
        set fx [expr double($wtree) / [winfo width $w]]
        set fy [expr double($htree) / [winfo height $w]]
        set dx [expr $B($w,x) - $x]
        set dy [expr $B($w,y) - $y]
        $B($w,w_target_window) move $B($w,w_target_tree) [expr $dx * $fx] [expr $dy * $fy]
        set B($w,x) $x
        set B($w,y) $y
    }
    ###
    proc Brush_UpdateTargetWH {w x y} {
        global B
        if {$B($w,brush_width) == 0} {set fx  $B($w,fx)
        } else  {
            set fx [expr $B($w,w_source_width) / $B($w,brush_width) ]
        }
        if {$B($w,brush_height) == 0} {set fy  $B($w,fy)
        } else  {
            set fy [expr $B($w,w_source_height) / $B($w,brush_height)]
        }
        if  {$fx < $B($w,fx)} {set ffxx 0.95
        } elseif  {$fx > $B($w,fx)} {
            set ffxx 1.05
        } else {set ffxx 1.00}
        if  {$fy < $B($w,fy)} {set ffyy 0.95
        } elseif  {$fy > $B($w,fy)} {
            set ffyy 1.05
        } else {set ffyy 1.00}
        set coords [$B($w,w_target_window) bbox $B($w,w_target_tree)]
        set xx [lindex $coords 0]
        set yy [lindex $coords 1]
        $B($w,w_target_window) scale $B($w,w_target_tree) $xx $yy $ffxx $ffyy
        $B($w,w_target_window) configure -scrollregion [$B($w,w_target_window) bbox all]
        set B($w,fx) $fx
        set B($w,fy) $fy
    }
    # Browser Local
    # le pointeur souris def une zone dans la vue primaire
    # D1 zoom, D3 unzoom de cette zone dans la vue secondaire
    proc makeBrowerLocal {w t} {
        global B T S
        set tsource $t
        set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        set code $t
        set data $T($tsource,nwk,$tsource)
        #set T($t,fil) $T($tsource,fil)
        set T($t,nwk,$t) $data
        ImportExport::TreeInit $t
        set S($t,display_eu) normal
        if {[catch [ImportExport::NewickParser_Root $t $data] result] != 0} {
            ImpotExport::UpdateArrayCanvas $w $t
            Interface::TreeDynMessage "Error"
        }  else {
            set nw [ImportExport::NewWindowName]
            set wp $nw.c
            set B(ZoomBrowserWindowName) $nw.c
            set B($tsource,zoombrowserwindow) $nw.c
            set B($tsource,zoombrowsertree) $t
            set S($t,w) $wp
            lappend S($wp,t) $t
            set B($wp,w_source_width)  150
            set B($wp,w_source_height) 150
            set B($wp,w_source_tree) T$t
            toplevel $nw -width 150 -height 150
            wm resizable $nw 1 1
            wm title $nw "Navigation : Local Browser"
            eval {iwidgets::toolbar} $nw.ta
            #zoomxnl1
            $nw.ta add radiobutton  zoomxnl2 \
                    -variable S(tool) -value zoomxnl2 \
                    -image TIMzoomxb
            $nw.ta add radiobutton zoomynl2 \
                    -variable S(tool) -value zoomynl2 \
                    -image TIMzoomyb
            $nw.ta add radiobutton  zoomxynl2 \
                    -variable S(tool) -value zoomxynl2 \
                    -image TIMzoomxyb
            canvas $wp -width $B($wp,w_source_width) -height $B($wp,w_source_height) \
                    -highlightthickness 0 -background LightGoldenrodYellow
            grid $nw.ta -row 0 -column 0 -columnspan 2 -sticky news
            grid $wp -row 1 -column 1 -sticky news
            grid rowconfigure $nw 1  -weight 1
            grid columnconfigure $nw 1 -weight 1
            Conformation::ArrToCanSwitch2 $t $wp $S($tsource,type)
            bind $wp <Configure> "Navigation::ReDisplayAfterResizingZoomBrowser $wp"
            #bind $wp <Button-1>  "Navigation::BrowserB1 %W %x %y"
            $wp bind T$t <Any-Enter> "$w config -cursor hand2"
            $wp bind T$t <Any-Leave> "$w config -cursor top_left_arrow"
        }
    }
    ###
    proc ReDisplayAfterResizingZoomBrowser {w} {
        global B
        set fx [expr double([winfo width $w]) / $B($w,w_source_width)]
        set fy [expr double([winfo height $w]) / $B($w,w_source_height)]
        $w scale $B($w,w_source_tree) 0 0 $fx $fy
        set B($w,w_source_width) [winfo width $w]
        set B($w,w_source_height) [winfo height $w]
    }
    # ### sensibilite s
    # ### si un tree dans la zone Select Tree retourne $t
    # ### sinon retourne 0
    proc SelectTree {w x y } {
        set s 15
        set coords ""
       
        set id [lindex \
                [$w find overlapping [expr $x - $s]  [expr $y - $s] \
                [expr $x + $s] [expr $y + $s] ] \
                end]
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -glob $tags TD*] != -1} {
                # cas de la selection d'un sous arbre decompose
                set n  [lindex $tags [lsearch -glob $tags TD*]]
                if {$n != ""} {
                    set taglink [format "%s%s%s"  link ¶ [lindex [split $n ¶] end]]
                    $w delete highlight
                    # on ne prend pas en compte les items de type bll, ni le link du subtree
                    # ni le link des BLL
                    set coords [$w bbox [list $n && !$taglink && ! bullab && ! Link]]
                }
            } else  {
                set n  [lindex $tags [lsearch -glob $tags T*]]
                if {$n != ""} {
                    $w delete highlight
                    # on ne prend pas en compte les items de type bllet leur link
                    set coords [$w bbox [list $n && ! bullab && ! Link]]
                }
            }
            if {$coords != ""} {
                $w delete highlight
                set x1 [lindex $coords 0]
                set y1 [lindex $coords 1]
                set x2 [lindex $coords 2]
                set y2 [lindex $coords 3]
                Navigation::Bbox_Create $w $n $x1 $y1 $x2 $y2
                return [string range $n 1 end]
            } else  {
                return 0}
        } else  {
            return 0
        }
    }
    ###
    proc Bbox_Create {w n x1 y1 x2 y2} {
        global B
        $w create rectangle [expr $x1 -2] [expr $y1 - 2] [expr $x1 + 2] [expr $y1 + 2] \
                -tags "highlight $n bbox box NW" -fill orange
        $w create rectangle [expr $x1 -2] [expr $y2 - 2] [expr $x1 + 2] [expr $y2 + 2] \
                -tags "highlight $n bbox box SW" -fill orange
        $w create rectangle [expr $x2 -2] [expr $y1 - 2] [expr $x2 + 2] [expr $y1 + 2] \
                -tags "highlight $n bbox box NE" -fill orange
        $w create rectangle [expr $x2 -2] [expr $y2 - 2] [expr $x2 + 2] [expr $y2 + 2] \
                -tags "highlight $n bbox box SE" -fill orange
        $w bind NW <Any-Enter> "Navigation::BBoxEnter %W NW"
        $w bind SW <Any-Enter> "Navigation::BBoxEnter %W SW"
        $w bind NE <Any-Enter> "Navigation::BBoxEnter %W NE"
        $w bind SE <Any-Enter> "Navigation::BBoxEnter %W SE"
        $w bind bbox <Any-Leave> "Navigation::BBoxLeave $w"
    }
    ###
    proc BBoxEnter {w s} {
        global tcl_platform
        $w itemconfigure bbox -fill yellow
        switch $tcl_platform(platform) {
            "unix" {
                switch $s {
                    NW {$w config -cursor hand2}
                    SW {$w config -cursor hand2}
                    NE {$w config -cursor hand2}
                    SE {$w config -cursor hand2}
                }
            }
            "windows" {
                switch $s {
                    NW {$w config -cursor size_nw_se}
                    SW {$w config -cursor size_ne_sw}
                    NE {$w config -cursor size_ne_sw}
                    SE {$w config -cursor size_nw_se}
                }
            }
        }
    }
    ###
    proc BBoxLeave {w} {
        $w itemconfigure bbox -fill orange
        $w config -cursor top_left_arrow
    }
    # ?
    proc SelectObject {w x y } {
        set s 50
        set id [lindex \
                [$w find overlapping [expr $x - $s]  [expr $y - $s] \
                [expr $x + $s] [expr $y + $s] ] \
                0]
        if  {$id != ""} {
            set tags [$w gettags $id]
            if {[lsearch -glob $tags T*] != -1} {
                # NODE N
                $m add command -label "Node" -command ""
            } elseif  {[lsearch -exact $tags S1] != -1} {
                #  TEXT  COMMENT
                $m add command -label "Delete" -command "$w delete [$w find withtag current] "
            } elseif {[lsearch -exact $tags S2] != -1} {
                #  TEXT QUERY
                $m add command -label "Query" -command "TBA::MajSelGra2 $w $i"
                $m add command -label "Delete" -command "$w delete $tag"
            } elseif {[lsearch -exact $tags S3] != -1} {
                #  TEXT LEAF
                set m [menu .menuitem -tearoff 0 -title Labels]
                $m add command -label "text leaf" -command ""
            } elseif {[lsearch -exact $tags S4] != -1} {
                #  TEXT ASSOCIE A UN NODE
                set m [menu .menuitem -tearoff 0 -title Labels]
                $m add command -label "bulle link" -command ""
            } elseif {[lsearch -exact $tags D] != -1} {
                #  ITEM GRAPHIQUE (cercle, carre)
                set m [menu .menuitem -tearoff 0 -title Labels]
                $m add command -label "Raise" -command "$w raise current"
                $m add command -label "Lower" -command "$w lower current"
                $m add command -label "Delete" -command "$w delete current"
            }  else {
                set m [menu .menuitem -tearoff 0 -title Labels]
                $m add command -label "?" -command ""
            }
            return $m
            set n  [lindex $tags [lsearch -glob $tags T*]]
            $w delete highlight
            set coords [$w bbox $n]
            if {$coords != ""} {
                set x1 [lindex $coords 0]
                set y1 [lindex $coords 1]
                set x2 [lindex $coords 2]
                set y2 [lindex $coords 3]
            }
            foreach x [list $x1 $x2] {
                foreach y [list $y1 $y2] {
                    $w create rectangle [expr $x -2] [expr $y - 2] [expr $x+2] [expr $y+2] -tags "highlight $n"
                }
            }
            return [string range $n 1 end]
        } else  {
            return all
        }
    }
    # organisation des arbres d'un canvas en rows columns
    proc Reorganize {w {c ?} {r ?}} {
        global S
        set heMAX 0
        set wiMAX 0
        if {$S($w,BIcol) == "?"} {set S($w,BIcol) 3}
        if {$S($w,BIrow) == "?"} {set S($w,BIrow) [expr round(0.5 + ([llength $S($w,t)]/3))]  }
        if {$c == "?"} { set c $S($w,BIcol)}
        if {$r == "?"} { set r $S($w,BIrow)}
        #
        foreach ti $S($w,t) {
            # NON [$w bbox [list Z && T$ti]] (prise en compte taille des feuilles)
            set coords [$w bbox T$ti]
            set wi [expr abs([lindex $coords 0] - [lindex $coords 2])]
            if {$wi >= $wiMAX} {set wiMAX $wi}
            set he [expr abs([lindex $coords 1] - [lindex $coords 3])]
            if {$he >= $heMAX} {set heMAX $he}
        }
        set n [llength $S($w,t)]
        set index -1
        for  {set i 0} {$i < $r} {incr i} {
            for  {set j 0} {$j < $c} {incr j} {
                incr index
                if {$index < $n} {
                    set ti [lindex $S($w,t) $index]
                    # attention le move ajoute, donc remettre a zero avant
                    set coords [$w bbox T$ti]
                    set x [lindex $coords 0]
                    set y [lindex $coords 1]
                    $w move T$ti [expr  0 - $x] [expr  0 - $y]
                    set px [expr $j * $wiMAX]
                    set py [expr $i * $heMAX]
                    $w move T$ti $px $py
                }
            }
        }
        Navigation::FitToContents $w
    }
    proc spinCol {w} {
        global S
        .reorg.ro set [expr round(([llength $S($w,t)] / [.reorg.co get]) + 0.5 )]
        set S($w,BIcol) [.reorg.co get]
        set S($w,BIrow) [.reorg.ro get]
    }
    proc spinRow {w} {
        global S
        .reorg.co set [expr round(([llength $S($w,t)] / [.reorg.ro get]) + 0.5 )]
        set S($w,BIcol) [.reorg.co get]
        set S($w,BIrow) [.reorg.ro get]
    }
    proc spinCol2 {w ir ic} {
        global S
        eval $ir set [expr round(([llength $S($w,t)] / [$ic get]) + 0.5 )]
        set S($w,BIcol) [$ic get]
        set S($w,BIrow) [$ir get]
    }
    proc spinRow2 {w ir ic} {
        global S
        eval $ic set [expr round(([llength $S($w,t)] / [$ir get]) + 0.5 )]
        set S($w,BIcol) [$ic get]
        set S($w,BIrow) [$ir get]
    }
    proc ReorganizeAll {w} {
        global S
        eval destroy .reorg
        set n [llength $S($w,t)]
        set p [toplevel .reorg ]
        wm title .reorg "Rows x Columns"
        wm geometry $p "+250+250"
        label $p.col -text "Column(s): "
        label $p.rol -text "Row(s)   : "
        spinbox  $p.co -from 1 -to $n -increment 1 -command "Navigation::spinCol $w"
        spinbox  $p.ro -from 1 -to $n -increment 1 -command "Navigation::spinRow $w"
        if {$S($w,BIcol) == "?"} {set S($w,BIcol) 1}
        if {$S($w,BIrow) == "?"} {set S($w,BIrow) [llength $S($w,t)]}
        $p.co set $S($w,BIcol)
        $p.ro set $S($w,BIrow)
        button $p.ok -text Ok -command "Navigation::Reorganize $w"
        button $p.quit -text Cancel  -command "destroy $p"
        #  GRID
        grid $p.col -row 1 -column 0
        grid $p.co  -row 1 -column 1
        grid $p.rol -row 2 -column 0
        grid $p.ro  -row 2 -column 1
        grid $p.ok  -row 3 -column 0
        grid $p.quit  -row 3 -column 1
        
    }
    # Interface::UserToolboxMoveMotion tous les trees d'une fenetre
    proc ResizeAll {w} {
        global S
        eval destroy .resize
        set wi [toplevel .resize]
        wm geometry $wi "+[winfo pointerx $w]+[winfo pointery $w]"
        wm title .resize "Resize"
        iwidgets::entryfield .resize.ns -width 4 -textvariable S(newW) -labeltext "New Width  (pixels): " -validate integer -fixed 30
        iwidgets::entryfield .resize.nn  -width 4  -textvariable S(newH) -labeltext "New Height (pixels):" -validate integer  -fixed 30
        # button
        frame .resize.controls
        button .resize.controls.ok -text Apply -command "Navigation::ResizeAllGo $w"
        button .resize.controls.quit -text Cancel -command "destroy .resize"
        # PACK
        pack .resize.controls.ok .resize.controls.quit -side left -anchor center -fill x -expand yes
        #pack  $wi.move -expand yes -fill x
        pack .resize.ns -fill x -expand yes
        pack .resize.nn -fill x -expand yes
        pack  .resize.controls -fill x -expand yes
    }
    # proc associee a un return sur les entry hauteur/largeur , main panel, onglet navigation
    proc ResizeAuto {} {
        # retourne la A-liste $windows $tree pour tous les tree en target d'une session treedyn
        set Alist     [Selection::TreeTar]
        foreach {wi ti} $Alist {
            Navigation::ResizeOneGo $wi $ti
            Figuration::RestaureT $wi $ti
        }
    }
    #
    proc ResizeAllGo {w} {
        global S
        foreach ti $S($w,t) {
            # NON [$w bbox [list Z && T$ti]]
            set co [$w bbox T$ti]
            set x [lindex $co 0]
            set y [lindex $co 1]
            Conformation::ArrToCanType3 $ti $w $x $y $S(newW) $S(newH)
            #
            Figuration::RestaureT $w $ti
            Reflection::UpdateAll $w
        }
    }
    #
    proc ResizeOne {w t} {
        global S
        eval destroy .resize
        set wi [toplevel .resize ]
        wm title .resize "Resize"
        wm geometry $wi "+[winfo pointerx $w]+[winfo pointery $w]"
        iwidgets::entryfield .resize.ns  -width 4 -textvariable S(newW) \
                -labeltext "New Width  (pixels): "  -validate integer -fixed 30
        iwidgets::entryfield .resize.nn -width 4 -textvariable S(newH) \
                -labeltext "New Height (pixels):" -validate integer  -fixed 30
        # button
        frame .resize.controls
        button .resize.controls.ok -text Apply -command "Navigation::ResizeOneGo $w $t"
        button .resize.controls.quit -text Cancel -command "destroy .resize"
        # PACK
        pack .resize.controls.ok .resize.controls.quit -side left -anchor center -expand yes -fill x
        pack .resize.ns -fill x -expand yes
        pack .resize.nn -fill x -expand yes
        pack .resize.controls -expand yes -fill x
    }
    proc ResizeOneGo  {w t} {
        global S
        set co [$w bbox T$t]
        set x [lindex $co 0]
        set y [lindex $co 1]
        Conformation::ArrToCanType3 $t $w $x $y $S(newW) $S(newH)
        Figuration::RestaureT $w $t
    }
}
################################################################################


################################################################################
# ANNOTATION
################################################################################
namespace eval Annotation {
    
    #
    proc  HTTPPanel {} {
        global S
        set S(httpref) ?
        
        toplevel .annothttp
        wm title .annothttp {W3}
        # frame control
        set f [frame .annothttp.control ]
        #
        # boxlist url
        iwidgets::combobox $f.combourl -width 12 -labeltext "URL:"
        foreach e [list "http://pbil.univ-lyon1.fr/cgi-bin/acnuc-search-ac?query="] {
            $f.combourl insert list end $e
        }
        $f.combourl selection set "http://pbil.univ-lyon1.fr/cgi-bin/acnuc-search-ac?query="
        # Entry reference gene/pr etc
        iwidgets::entryfield $f.ref  -textvariable S(httpref) -labeltext "Ref:" -command Annotation::AnnotHttp2
        # boxlist database
        iwidgets::combobox $f.combo -labeltext "Database:" -selectioncommand Annotation::AnnotHttp2
        foreach e [list GenBank EMBL EMGLib NRSub SwissProt NBRF "Hobacgen nucl." \
                "Hobacgen prot." "Hovergen nucl." "Hovergen prot." "RTKdb nucl." "RTKdb prot." \
                "HoGenome nucl." "HoGenome prot." "Hovergen Clean nucl." "Hovergen Clean prot." \
                "HAMAP nucl." "HAMAP prot." "MitALib prot." "MitALib nucl." "Hoppsigen Nurebase nucl." \
                "Nurebase prot." "TestForm prot." "TestForm nucl."] {
                    $f.combo insert list end $e
                }
        $f.combo selection set GenBank
        # browser
        set htm [optcl::new -window .annothttp.htm Shell.Explorer.2] ;# MSIE ActiveX Control
        set S(navigator) $htm
        .annothttp.htm config -width 500 -height 400
        #
        grid $f.combourl -row 0 -column 0 -columnspan 2 -sticky news
        grid $f.combo -row 1 -column 0 -sticky news
        grid $f.ref -row 1 -column 1 -sticky news
        grid $f -row 0 -column 0 -sticky news
        grid .annothttp.htm -row 1 -column 0 -sticky news
        grid rowconfigure .annothttp 1 -weight 1
        grid columnconfigure .annothttp 0 -weight 1
    }
    #
    proc AnnotHttp {w x y} {
        global S T
        set unit [$w itemcget current -text]
        if {$unit != ""} {
            if {[winfo exists .annothttp] == 0 }  {HTTPPanel}
            set S(httpref) $unit
            set url [.annothttp.control.combourl getcurselection]
            append url $unit
            append url "&db="
            append url [.annothttp.control.combo getcurselection]
            $S(navigator) navigate $url
        }
    }
    #
    proc AnnotHttp2 {} {
        global S T
        set unit $S(httpref)
        if {$unit != "" && $unit != "?"} {
            if {[winfo exists .annothttp] == 0 }  {HTTPPanel}
            set url [.annothttp.control.combourl getcurselection]
            append url $unit
            append url "&db="
            append url [.annothttp.control.combo getcurselection]
            $S(navigator) navigate $url
        }
    }
    #
    # .ann.l.lfa.l
    proc MatrixAnnotateGo {} {
        global S ann T
        set lv {}
        set lindex [.ann.l.lfa.l curselection]
        foreach i $lindex {
            lappend lv [.ann.l.lfa.l get $i]
        }
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        MatrixAnnotateGoGo $lv $ltreetarget
    }
    proc MatrixColorsAnnotateGo {} {
        global S ann T
        set lv {}
        set lindex [.ann.l.lfa.l curselection]
        foreach i $lindex {
            lappend lv [.ann.l.lfa.l get $i]
        }
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        MatrixColorsAnnotateGoGo $lv $ltreetarget
        
    }
    #
    proc MatrixAnnotateGoGo {lv ltreetarget} {
        global S ann T
        foreach ti $ltreetarget {
            set w $S($ti,w)
            set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
            set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
            set XMAX3 [lindex [$w bbox [list T$ti && AnnotMatrix]] 2]
            if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
            if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
            if [catch {expr $S($ti,LabelMatrixBase) + 7} result] {
                set S($ti,LabelMatrixBase) 7
            } else  {
                set S($ti,LabelMatrixBase) $result
            }
            #set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
            #set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
            #if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                    set colnumber 0
                    foreach var $lv {
                        incr colnumber 1
                        incr x $ann(binmatPadding)
                        set dx [expr $ann(binmatWidth) / 2]
                        set dy [expr $ann(binmatHeight) / 2]
                        # tag de colonne
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        if {$ann(binmatColumnsNumber) == 1} {
                            set spliNB 0
                            foreach lettre [split $colnumber {}] {
                                set ycolumns [lindex [$w bbox [list T$ti && Z]] 1]
                                $w create text $x [expr $ycolumns - 10 - $spliNB] -text $lettre \
                                        -fill black -tags "T$ti AnnotMatrix"
                                incr spliNB 8
                            }
                        }
                        foreach l $T($ti,ue_lab) {
                            # recherche y
                            set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$ti]]
                            if {$item == ""} {
                                set items [$w find withtag [list ADD¶$l && T$ti]]
                                set y 0
                                foreach ii $items {
                                    set yii [lindex [$w coords $ii] 1]
                                    if {$yii >= $y} {
                                        set y $yii
                                    }
                                }
                            } else  {
                                set co [$w coords $item]
                                set y [lindex $co 1]
                            }
                            # construction de itemtext sur query
                            # attention si des feuilles ds l'arbre mais absentes du fichier de labels !
                            set records  [Database::dbQueryRecordsFromVarVal $database EU $l]
                            if {$records == {}} {
                                $w create text [expr $x-$dx+1] [expr $y-$dy+1] -text - \
                                        -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC  AMatrixCo NBC$colnumber"
                            } elseif {[llength $records] >= 2} {
                                $w create text [expr $x-$dx+1] [expr $y-$dy+1] -text * \
                                        -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC  AMatrixCo NBC$colnumber"
                            } else  {
                                set record [lindex $records 0]
                                foreach {vari val} $X($record) {
                                    
                                    if {[string equal $var $vari] == 1}  {
                                        if {$val == "1"} {
                                            set k 1
                                            set color $ann(binmatColor1)
                                        } else  {
                                            set k 0
                                            set color $ann(binmatColor0)
                                        }
                                        $w create rectangle [expr $x-$dx] [expr $y-$dy] [expr $x+$dx] [expr $y+$dy] \
                                                -fill $color -outline $color  \
                                                -tags "T$ti AnnotMatrix AM$ti BIN¶$k MA¶$l $tagC  AMatrixCo NBC$colnumber"
                                    }
                                }
                                
                            }
                        }
                    }
                    Navigation::FitToContents $w
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    # A FAIRE
                }
                ClaCir1 - ClaCir2 - ClaCir3 {
                    # A FAIRE
                }
            }
        }
    }
    #
    proc MatrixColorsAnnotateGoGo {lv ltreetarget} {
        global S ann T
        foreach ti $ltreetarget {
            set w $S($ti,w)
            set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
            set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
            set XMAX3 [lindex [$w bbox [list T$ti && AnnotMatrix]] 2]
            if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
            if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
            if [catch {expr $S($ti,LabelMatrixBase) + 7} result] {
                set S($ti,LabelMatrixBase) 7
            } else  {
                set S($ti,LabelMatrixBase) $result
            }
            #set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
            #set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
            #if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                    set colnumber 0
                    foreach var $lv {
                        incr colnumber 1
                        incr x $ann(binmatPadding)
                        set dx [expr $ann(binmatWidth) / 2]
                        set dy [expr $ann(binmatHeight) / 2]
                        # tag de colonne
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        if {$ann(binmatColumnsNumber) == 1} {
                            set spliNB 0
                            foreach lettre [split $colnumber {}] {
                                set ycolumns [lindex [$w bbox [list T$ti && Z]] 1]
                                $w create text $x [expr $ycolumns - 10 - $spliNB] -text $lettre \
                                        -fill black -tags "T$ti AnnotMatrix"
                                incr spliNB 8
                            }
                        }
                        foreach l $T($ti,ue_lab) {
                            # recherche y
                            set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$ti]]
                            if {$item == ""} {
                                set items [$w find withtag [list ADD¶$l && T$ti]]
                                set y 0
                                foreach ii $items {
                                    set yii [lindex [$w coords $ii] 1]
                                    if {$yii >= $y} {
                                        set y $yii
                                    }
                                }
                            } else  {
                                set co [$w coords $item]
                                set y [lindex $co 1]
                            }
                            # construction de itemtext sur query
                            # attention si des feuilles ds l'arbre mais absentes du fichier de labels !
                            set records  [Database::dbQueryRecordsFromVarVal $database EU $l]
                            if {$records == {}} {
                                $w create text [expr $x-$dx+1] [expr $y-$dy+1] -text - \
                                        -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC  AMatrixCo NBC$colnumber"
                            } elseif {[llength $records] >= 2} {
                                $w create text [expr $x-$dx+1] [expr $y-$dy+1] -text * \
                                        -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC  AMatrixCo NBC$colnumber"
                            } else  {
                                set record [lindex $records 0]
                                foreach {vari val} $X($record) {
                                    if {[string equal $var $vari] == 1}  {
                                        set rgb [split $val ,]
                                        set r [lindex $rgb 0]
                                        set g [lindex $rgb 1]
                                        set b [lindex $rgb 2]
                                        set color [format "#%.2x%.2x%.2x" $r $g $b ]
                                        $w create rectangle [expr $x-$dx] [expr $y-$dy] [expr $x+$dx] [expr $y+$dy] \
                                                -fill $color -outline $color  \
                                                -tags "T$ti AnnotMatrix AM$ti BIN¶$$val MA¶$l $tagC  AMatrixCo NBC$colnumber"
                                    }
                                }
                            }
                        }
                    }
                    Navigation::FitToContents $w
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    # A FAIRE
                }
                ClaCir1 - ClaCir2 - ClaCir3 {
                    # A FAIRE
                }
            }
        }
    }
    proc DrawAnnotateGo {} {
    }
    # panel dedie affichage des valeurs de boot / length branch
    proc ANPanelBL {} {
        global S tcl_platform
        set S(ANBLoperation) displayvalue
        set S(ANBLoperationName) "Node foreground color"
        set S(ANBLoperationName2) "Node dash line"
        set S(ANBL-what) apres
        set S(ANBL-how) tout
        set S(ANBL-howleaves) 1
        set S(ANBLwhere) "--x--"
        set S(ANBLreset) 0
        set S(ANBLoperation)  dashline
        if {[winfo exists .anbl] == 1} {
            wm deiconify .anbl
        } else  {
            set w [toplevel .anbl]
            wm title $w "Newick Annotation"
            wm protocol .anbl WM_DELETE_WINDOW {}
            # tabnotebook general
            switch $tcl_platform(platform) {
                "unix" {
                    if  {$tcl_platform(os) == "Darwin"} {
                        set color systemButtonFace
                    } else  {
                        set color #efebe7
                    }
                }
                "windows" {
                    set color systemButtonFace
                }
            }
            iwidgets::tabnotebook .anbl.n -width 250 -height 300 -tabpos n -equaltabs 0 \
                    -background $color -backdrop $color -tabbackground $color
            set p1 [.anbl.n add -label "Annotations" -compound left]
            set p2 [.anbl.n add -label "Tree" -compound left]
            .anbl.n view "Annotations"
            pack .anbl.n -expand yes -fill both
            ##### P1
            # tree target
            set cs [frame $p1.target]
            menubutton $cs.target -text "Tree(s)" -menu $cs.target.m -indicatoron 1 -direction below
            set z  [menu  $cs.target.m -tearoff 0]
            $z configure -postcommand "Database::TreeTarget $z"
            pack $cs.target
            pack $cs
            # ce qui va etre traite, avant ou apres les :
            set wl [frame $p1.what]
            radiobutton $wl.avant -text "X:"  -anchor w -variable S(ANBL-what)  -value avant
            radiobutton $wl.apres -text ":X"   -anchor w -variable S(ANBL-what)  -value apres
            pack $wl.avant $wl.apres -side left -expand yes -fill x
            pack $wl
            # toutes / pas toutes (seuil)
            set wh [frame $p1.how]
            radiobutton $wh.tout -text "All" -anchor w -variable S(ANBL-how) -value tout
            radiobutton $wh.seuil -text " "  -anchor w -variable S(ANBL-how)  -value seuil
            iwidgets::entryfield $wh.seuilval -width 4 -textvariable S(ANBL-seuil) \
                    -labeltext "Treshlod: " -labelpos w -fixed 30
            pack $wh.tout $wh.seuil $wh.seuilval   -side left -expand yes -fill x
            pack $wh
            # considerer les valeurs associees aux feuilles ?
            checkbutton $p1.leaves -text "Values linked to leaves" -anchor w -variable S(ANBL-howleaves)
            pack $p1.leaves
            #reset
            set wr [frame $p1.reset]
            radiobutton $wr.add -text "Add"  -anchor w -variable S(ANBLreset)  -value 0
            radiobutton $wr.clear -text "Clear"   -anchor w -variable S(ANBLreset)  -value 1
            pack $wr.add $wr.clear -side left -expand yes -fill x
            pack $wr
            # position affichage
            set whe [frame $p1.where  ]
            menubutton $whe.wherem  -text "Where: " -menu $whe.wherem.m   -direction below -indicator on -relief raised
            set mce [menu  $whe.wherem.m -tearoff 0]
            $mce add radio -label  "----x" -variable S(ANBLwhere) -value "----x"
            $mce add radio -label  "--x--" -variable S(ANBLwhere) -value "--x--"
            $mce add radio -label  "x----" -variable S(ANBLwhere) -value "x----"
            message $whe.msg -width 200 -textvariable S(ANBLwhere)
            pack $whe.wherem $whe.msg -side left -expand yes -fill x
            pack $wh.tout $wh.seuil $wh.seuilval   -side left -expand yes -fill x
            pack $wh
            pack $whe
            #
            set wfig [frame $p1.fig]
            button $wfig.color -text "Color" -command  "Interface::PopUp Color"
            button $wfig.font -text "Font" -command  "Interface::PopUp Font"
            pack $wfig.color $wfig.font -side left -expand 1 -fill x
            pack $wfig -expand 1 -fill x
            #
            set wc [frame $p1.control]
            button $wc.reset -text "Reset" -command  "Annotation::ANBLReset"
            button $wc.validate -text "Display" -command  "Annotation::ANBLgo"
            pack $wc.reset $wc.validate -expand yes -fill x
            pack $wc -expand yes -fill x
            
            ##### P2
            # tree target
            set cs [frame $p2.target]
            menubutton $cs.target -text "Tree(s)" -menu $cs.target.m -indicatoron 1 -direction below
            set z  [menu  $cs.target.m -tearoff 0]
            $z configure -postcommand "Database::TreeTarget $z"
            pack $cs.target
            pack $cs
            # ce qui va etre traite, avant ou apres les :
            set wl [frame $p2.what]
            radiobutton $wl.avant -text "X:"  -anchor w -variable S(ANBL-what)  -value avant
            radiobutton $wl.apres -text ":X"   -anchor w -variable S(ANBL-what)  -value apres
            pack $wl.avant $wl.apres -side left -expand yes -fill x
            pack $wl
            # seuil
            set wh [frame $p2.how]
            #entry $wh.seuil -text " "  -anchor w -variable S(ANBL-how)  -value seuil
            iwidgets::entryfield $wh.seuilval -width 4 -textvariable S(ANBL-seuil) \
                    -labeltext "Treshlod: " -labelpos w -fixed 30
            pack  $wh.seuilval   -side left -expand yes -fill x
            pack $wh
            #OPERATION
            set wo [frame $p2.operation]
            set mo [Annotation::ANBLoperation $wo ]
            pack $mo
            pack $wo
            #
            set wc [frame $p2.control]
            button $wc.reset -text "Reset" -command  "Annotation::ANBLfigbvReset"
            button $wc.validate -text "Display" -command  "Annotation::ANBLfigbv"
            pack  $wc.reset $wc.validate -expand yes -fill x
            pack $wc -expand yes -fill x
        }
    }
    proc ANBLReset {} {
        global S
        foreach {w t} [Selection::TreeTar] {
            $w delete [list T$t && DBL]
        }
    }
    #
    proc ANBLfigbvReset {} {
        foreach {w t} [Selection::TreeTar] {
            Figuration::GraVarInitFgTree $w $t
            Figuration::GraVarInitLineDash $w $t
        }
    }
    # figuration (pointilles) sur tree en fonction seuil bootstrap values 
    proc ANBLfigbv {} {
        global T S
        foreach {w t} [Selection::TreeTar] {
            set l [lrange $T($t,all_cod) 1 end]
            set l [Tools::SousL $l $T($t,ue_cod)]
            switch -- $S(ANBL-what) {
                apres {
                    foreach i $l {
                        if {$T($t,dbl,$i) != "" && $T($t,dbl,$i) < $S(ANBL-seuil) } {
                            switch -- $S(ANBLoperation) {
                                dashline {Figuration::NodeLineDash $t $i 1}
                                fgcolor {Figuration::NodeColorFgTree $t $i $S(col)}
                            }
                            
                        }
                    }
                }
                avant {
                    foreach i $l {
                        if {$T($t,dbv,$i) != "" && $T($t,dbv,$i) < $S(ANBL-seuil) } {
                            switch -- $S(ANBLoperation) {
                                dashline {Figuration::NodeLineDash $t $i 1}
                                fgcolor {Figuration::NodeColorFgTree $t $i $S(col)}
                            }
                            
                        }
                    }
                }
                
            }
            
        }
    }
    proc ANBLoperation {w} {
        global S
        # operation
        set wop [frame $w.wop ]
        menubutton $wop.loca -text "Operation: " -menu $wop.loca.m  -direction below -indicator on -relief raised
        set mc [menu  $wop.loca.m -tearoff 0]
        $mc add radio -label  "Node dash line" -variable S(ANBLoperation) \
                -value dashline -command {set S(ANBLoperationName2) "Node dash line"}
        $mc add radio -label  "Node foreground color" -variable S(ANBLoperation) \
                -value fgcolor -command {set S(ANBLoperationName2) "Node foreground color"}
        message $wop.msg -width 200 -textvariable S(ANBLoperationName2)
        pack $wop.loca $wop.msg -side left -expand yes -fill x
        return $wop
    }
    proc ANBLgo {} {
        global T S
        if {$S(ANBLreset)} {
            foreach {w t} [Selection::TreeTar] {
                $w delete [list T$t && DBL]
            }
        }
        switch -- $S(ANBL-what) {
            apres {
                switch -- $S(ANBL-how) {
                    tout {
                        foreach {w t} [Selection::TreeTar] {
                            set l [lrange $T($t,all_cod) 1 end]
                            # si 0 on retire les codes feuilles
                            if {$S(ANBL-howleaves) == 0} {
                                set l [Tools::SousL $l $T($t,ue_cod)]
                            }
                            foreach i $l {
                                if {[$w itemcget $i -state] != "hidden"} {
                                    set co [$w coords $i]
                                    if {$co != ""} {
                                        switch -- $S(ANBLwhere) {
                                            "----x" {
                                                set x [expr [lindex $co 0] + 2]
                                                set y [expr [lindex $co 1] - 7]
                                                set anchor nw
                                            }
                                            "--x--" {
                                                set x [expr abs([lindex $co 0] + (([lindex $co 2] - [lindex $co 0]) / 2.0) ) ]
                                                set y [expr [lindex $co 1] - 5]
                                                set anchor center
                                            }
                                            "x----" {
                                                set x [expr [lindex $co 2] + 2]
                                                set y [lindex $co 1]
                                                set anchor sw
                                            }
                                        }
                                        if {$T($t,dbl,$i) != ""} {
                                            eval {$w create text} \
                                                    {$x $y} \
                                                    {-text $T($t,dbl,$i) -fill $S(col) \
                                                        -font $S(gfo) -anchor $anchor -tags "T$t DBL"}
                                        }
                                    }
                                }
                            }
                        }
                    }
                    seuil {
                        foreach {w t} [Selection::TreeTar] {
                            set l [lrange $T($t,all_cod) 1 end]
                            # si 0 on retire les codes feuilles
                            if {$S(ANBL-howleaves) == 0} {
                                set l [Tools::SousL $l $T($t,ue_cod)]
                            }
                            foreach i $l {
                                if {[$w itemcget $i -state] != "hidden"} {
                                    set co [$w coords $i]
                                    if {$co != ""} {
                                        switch -- $S(ANBLwhere) {
                                            "----x" {
                                                set x [expr [lindex $co 0] + 2]
                                                set y [expr [lindex $co 1] - 7]
                                                set anchor nw
                                            }
                                            "--x--" {
                                                set x [expr abs([lindex $co 0] + (([lindex $co 2] - [lindex $co 0]) / 2.0) ) ]
                                                set y [expr [lindex $co 1] - 5]
                                                set anchor center
                                            }
                                            "x----" {
                                                set x [expr [lindex $co 2] + 2]
                                                set y [lindex $co 1]
                                                set anchor sw
                                            }
                                        }
                                        if {$T($t,dbl,$i) != "" && $T($t,dbl,$i) >= $S(ANBL-seuil) } {
                                            eval {$w create text} \
                                                    {$x $y} \
                                                    {-text $T($t,dbl,$i) -fill $S(col) \
                                                        -font $S(gfo) -anchor $anchor -tags "T$t DBL"}
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            avant {
                switch -- $S(ANBL-how) {
                    tout {
                        foreach {w t} [Selection::TreeTar] {
                            set l [lrange $T($t,all_cod) 1 end]
                            set l [Tools::SousL $l $T($t,ue_cod)]
                            # si 0 on retire les codes feuilles
                            #if {$S(ANBL-howleaves) == 0} {
                            #    set l [Tools::SousL $l $T($t,ue_cod)]
                            #}
                            foreach i $l {
                                if {[$w itemcget $i -state] != "hidden"} {
                                    set co [$w coords $i]
                                    if {$co != ""} {
                                        switch -- $S(ANBLwhere) {
                                            "----x" {
                                                set x [expr [lindex $co 0] + 2]
                                                set y [expr [lindex $co 1] - 7]
                                                set anchor nw
                                            }
                                            "--x--" {
                                                set x [expr abs([lindex $co 0] + (([lindex $co 2] - [lindex $co 0]) / 2.0) ) ]
                                                set y [expr [lindex $co 1] - 5]
                                                set anchor center
                                            }
                                            "x----" {
                                                set x [expr [lindex $co 2] + 2]
                                                set y [lindex $co 1]
                                                set anchor sw
                                            }
                                        }
                                        if {$T($t,dbv,$i) != ""} {
                                            eval {$w create text} \
                                                    {$x $y} \
                                                    {-text $T($t,dbv,$i) -fill $S(col) \
                                                        -font $S(gfo) -anchor $anchor -tags "T$t DBL"}
                                        }
                                    }
                                }
                            }
                        }
                    }
                    seuil {
                        foreach {w t} [Selection::TreeTar] {
                            set l [lrange $T($t,all_cod) 1 end]
                            set l [Tools::SousL $l $T($t,ue_cod)]
                            # si 0 on retire les codes feuilles
                            #if {$S(ANBL-howleaves) == 0} {
                            #    set l [Tools::SousL $l $T($t,ue_cod)]
                            #}
                            foreach i $l {
                                if {[$w itemcget $i -state] != "hidden"} {
                                    set co [$w coords $i]
                                    if {$co != ""} {
                                        switch -- $S(ANBLwhere) {
                                            "----x" {
                                                set x [expr [lindex $co 0] + 2]
                                                set y [expr [lindex $co 1] - 7]
                                                set anchor nw
                                            }
                                            "--x--" {
                                                set x [expr abs([lindex $co 0] + (([lindex $co 2] - [lindex $co 0]) / 2.0) ) ]
                                                set y [expr [lindex $co 1] - 5]
                                                set anchor center
                                            }
                                            "x----" {
                                                set x [expr [lindex $co 2] + 2]
                                                set y [lindex $co 1]
                                                set anchor sw
                                            }
                                        }
                                        if {$T($t,dbv,$i) != "" && $T($t,dbv,$i) >= $S(ANBL-seuil) } {
                                            eval {$w create text} \
                                                    {$x $y} \
                                                    {-text $T($t,dbv,$i) -fill $S(col) \
                                                        -font $S(gfo) -anchor $anchor -tags "T$t DBL"}
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } 

    ### ANNOTATION PANEL
    proc ANPanelNew {} {
        global S
        set ann(ann-position) justify
        set ann(ann-fgfiguration) asleaf
        set ann(ann-fofiguration) asleaf
        set ann(ann-leavemod) add
        set ann(ann-prefix) " "
        set ann(ann-suffix) ""
        set ann(ann-exposant) 0
        set ann(binmatPadding) 6
        set ann(binmatHeight) 4
        set ann(binmatWidth) 4
        set ann(binmatColor0) white
        set ann(binmatColor1) black
        set ann(binmatOutline) 1
        set ann(binmatColumnsNumber) 0
        if {[winfo exists .ann] == 1} {
            wm deiconify .ann
        } else  {
            set w [toplevel .annotation]
            wm title $w "Annotation"
            wm geometry .annotation 600x600
            wm protocol .annotation WM_DELETE_WINDOW {Annotation::AnnotateQuit}
            
            ### CONTROLS
            set w1 [frame .annotation.c]
            # button load annotations
            button $w1.l1 -text "Load annotations..." -command  "Annotation::AnnotateLoadLabel"
            # MENU choix Fichier de Label(s)
            iwidgets::optionmenu $w1.m1 -command "Annotation::AnnotateLabelsFileSwitch $w1.m1"
            foreach lf $S(ldatabase) {$w1.m1 insert end $lf}
            # button load script
            button $w1.l2 -text "Load script..." -command  "Database::dbLoad"
            # MENU choix script
            iwidgets::optionmenu $w1.m2 -command ""
            
            # menubutton treetarget Target
            menubutton $w1.target -text "Tree(s)" -menu $w1.target.m  -direction below
            set z  [menu  $w1.target.m -tearoff 0]
            $z configure -postcommand "Database::TreeTarget $z"
            # boutton quit
            button  $w1.e -text "Quit" -command  "Annotation::AnnotateQuit"
            ### PACK CONTROLS
            pack   $w1.l1 $w1.m1  $w1.l2 $w1.m2 $w1.target $w1.e -side left -expand no
            
            
            ### PANED WINDOW
            iwidgets::panedwindow .annotation.p
            
            ### TOP tktable annotation
            .annotation.p add "top"
            set p1 [.annotation.p childsite "top"]
            iwidgets::tabnotebook $p1.n -width 200 -height 200  -tabpos n
            set p1t1 [$p1.n add -label "Annotations, variables list" -compound left]
            set p1t2 [$p1.n add -label "Annotations, tabular view" -compound left]
            $p1.n view "Annotations, variables list"
            pack $p1.n -expand yes -fill both
            
            ### MIDDLE mode
            .annotation.p add "middle"
            set p2 [.annotation.p childsite "middle"]
            iwidgets::tabnotebook $p2.n -width 200 -height 100 -tabpos n
            # on annotate avec les valeurs d'une variable
            set p2t1 [$p2.n add -label "Text" -compound left]
            # on annote avec un symbol pour chaque valeur de la variable
            set p2t2 [$p2.n add -label "Symbols"]
            # selection multiple de variable binaire, symbol de couleur pour chaque valeur
            set p2t3 [$p2.n add -label "Matrix 0/1"]
            # select multi de variable avec definition de classe symbol de couleur pour chaque classe
            set p2t4 [$p2.n add -label "Matrix n"]
            # les variables sont des series x y on annotae avec nuage bivarie, diagramme batons, etc
            set p2t5 [$p2.n add -label "X/Y"]
            # les variables sont des series xy qui decrivent des formes (morphometrie)
            set p2t6 [$p2.n add -label "Shape"]
            $p2.n view "Text"
            pack $p2.n -expand yes -fill both
            
            ### BOTTOM scripting
            .annotation.p add "bottom"
            set p3 [.annotation.p childsite "bottom"]
            iwidgets::tabnotebook $p3.n -width 200 -height 300 -tabpos n
            set p3t1 [$p3.n add -label "Scripting"]
            $p3.n view "Scripting"
            pack $p3.n -expand yes -fill both
            
            ### PACK
            pack $w1 -expand no
            .annotation.p fraction 30 25 45
            pack .annotation.p -expand yes -fill both
            
            
            # REMPLISSAGE P1T1
            
            # list Variables du fichier de label courant
            set wd [frame $p1t1.lfa]
            scrollbar $wd.yscroll -bd 1 -command "$wd.l yview" -width 5
            scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview " -width 5
            listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                    -width 25 -height 5 -selectmode extended
            puts "listbox $wd.l"
            grid $wd.l -row 0 -column 0 -sticky news
            grid $wd.yscroll -row 0 -column 1 -sticky ns
            grid $wd.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $wd 0 -weight 1
            grid columnconfigure $wd 0 -weight 1
            
            # boutton selection
            button $p1t1.bselect -image IMGselectl2r  \
                    -command "Annotation::AnnotateAddItem $p1t1.lfa.l $p1t1.lfa2.l "
            set wd2 [frame $p1t1.lfa2]
            scrollbar $wd2.yscroll -bd 1 -command "$wd2.l yview" -width 5
            scrollbar $wd2.xscroll -bd 1 -orient horizontal -command "$wd2.l xview " -width 5
            listbox   $wd2.l -xscroll "$wd2.xscroll set" -yscroll "$wd2.yscroll set" \
                    -width 25 -height 5 -selectmode extended
            #puts "listbox $wd2.l"
            grid $wd2.l -row 0 -column 0 -sticky news
            grid $wd2.yscroll -row 0 -column 1 -sticky ns
            grid $wd2.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $wd2 0 -weight 1
            grid columnconfigure $wd2 0 -weight 1
            
            pack $p1t1.lfa -side left -expand yes -fill both
            pack $p1t1.bselect -side left -expand no
            pack $p1t1.lfa2 -side left -expand yes -fill both
            bind $wd.l <ButtonRelease> ""
            
            # REMPLISSAGE P3T1
            # tout
            set ws1 [frame $p3t1.s1]
            scrollbar $ws1.yscroll -bd 1 -command "$ws1.l yview" -width 5
            scrollbar $ws1.xscroll -bd 1 -orient horizontal -command "$ws1.l xview " -width 5
            listbox   $ws1.l -xscroll "$ws1.xscroll set" -yscroll "$ws1.yscroll set" \
                    -width 25 -height 5 -selectmode extended
            # .annotation.p.pane2.childsite.n.canvas.notebook.cs.page1.cs.s1.l
            grid $ws1.l -row 0 -column 0 -sticky news
            grid $ws1.yscroll -row 0 -column 1 -sticky ns
            grid $ws1.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $ws1 0 -weight 1
            grid columnconfigure $ws1 0 -weight 1
            # controls
            set ws1c [frame $p3t1.s1c]
            button $ws1c.bselect -image IMGieadd  -command ""
            pack $ws1c.bselect
            # la selection user
            set ws2 [frame $p3t1.s2]
            scrollbar $ws2.yscroll -bd 1 -command "$ws2.l yview" -width 5
            scrollbar $ws2.xscroll -bd 1 -orient horizontal -command "$ws2.l xview " -width 5
            listbox   $ws2.l -xscroll "$ws2.xscroll set" -yscroll "$ws2.yscroll set" \
                    -width 25 -height 5 -selectmode extended
            # .annotation.p.pane2.childsite.n.canvas.notebook.cs.page1.cs.s2.l
            grid $ws2.l -row 0 -column 0 -sticky news
            grid $ws2.yscroll -row 0 -column 1 -sticky ns
            grid $ws2.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $ws2 0 -weight 1
            grid columnconfigure $ws2 0 -weight 1
            # controls
            set ws2c [frame $p3t1.s2c]
            button $ws2c.b1 -text "remove i" -command  ""
            button $ws2c.b2 -text "eval i" -command  ""
            button $ws2c.b3 -text "edit i" -command  ""
            button $ws2c.b4 -text "up i" -command  ""
            button $ws2c.b5 -text "down i" -command  ""
            button $ws2c.b6 -text "clear" -command  ""
            button $ws2c.b7 -text "save" -command  ""
            button $ws2c.b8 -text "save as" -command  ""
            button $ws2c.b9 -text "run" -command  ""
            pack $ws2c.b1 $ws2c.b2 $ws2c.b3 $ws2c.b4 $ws2c.b5 $ws2c.b6 $ws2c.b7 $ws2c.b8 $ws2c.b9 -side left
            pack   $p3t1.s1 $ws1c  $p3t1.s2 $ws2c -side top -expand yes -fill x
            
            #REMPLISSAGE P2T1
            #
            iwidgets::Labeledframe $p2t1.f -labelpos ne -labeltext "Font"
            set cs1 [$p2t1.f childsite]
            radiobutton $cs1.user -text "user selection" -variable ann(ann-fofiguration) -anchor w \
                    -value asuser \
                    -command "Interface::PopUpPanel2 ColorFontPanel ; .cf.n view Font"
            radiobutton $cs1.leaf -text "as Leaf" -anchor w \
                    -variable ann(ann-fofiguration) -value asleaf
            #
            iwidgets::Labeledframe $p2t1.c -labelpos ne -labeltext "Color" \
                    -labelfont {Helvetica 7 bold}
            set cs2 [$p2t1.c childsite]
            radiobutton $cs2.fguser -text "user selection" -variable ann(ann-fgfiguration) -anchor w \
                    -value asuser \
                    -command "Interface::PopUpPanel2 ColorFontPanel ; .cf.n view Color"
            radiobutton $cs2.fgleaf -text "as Leaf" -anchor w \
                    -variable ann(ann-fgfiguration) -value asleaf
            #
            iwidgets::Labeledframe $p2t1.d -labelpos ne -labeltext "Options" \
                    -labelfont {Helvetica 7 bold}
            set cs3 [$p2t1.d childsite]
            iwidgets::entryfield $cs3.pre  -width 9 -textvariable ann(ann-prefix) -labeltext "Prefix"
            iwidgets::entryfield $cs3.suf  -width 9 -textvariable ann(ann-suffix) -labeltext "Suffix"
            iwidgets::entryfield $cs3.up  -width 4 -textvariable ann(ann-exposant) -labeltext "Y translation"
            #
            iwidgets::Labeledframe $p2t1.e -labelpos ne -labeltext "Mode"
            set cs4 [$p2t1.e childsite]
            
            radiobutton $cs4.replace -text "Replace"   -anchor w \
                    -variable ann(ann-textmod) -value replace
            radiobutton $cs4.add -text "Add"   -anchor w \
                    -variable ann(ann-textmod)  -value add
            radiobutton $cs4.addcol -text "Add Columns"   -anchor w \
                    -variable ann(ann-textmod)  -value addcolumns
            #
            button $p2t1.go -text "Annotate" -command "set ann(ann-position) add ; Annotation::ANGo"
            pack $cs1.user $cs1.leaf -expand yes -fill both
            pack $cs2.fguser $cs2.fgleaf -expand yes -fill both
            pack $cs3.pre $cs3.suf $cs3.up -anchor w
            pack  $cs4.replace $cs4.add $cs4.addcol -anchor w
            pack $p2t1.f $p2t1.c $p2t1.d $p2t1.e -side left -expand yes -fill both
            pack $cs1 $cs2 $cs3 $cs4 -side left -expand yes -fill both
            pack $p2t1.go -expand yes -fill both
        }
    }
    # ls : listbox source ; lt listbox target
    proc AnnotateAddItem {ls lt} {
        global S
        if {$S(database) != ""} {
            set lindexvariables [$ls curselection] ;# des index
            foreach index $lindexvariables {
                set variable [$ls get $index]
                $ls itemconfigure $index -background NavajoWhite2
                set lvalues [Database::dbQueryValFromVar $S(database) $variable]
                foreach value [lsort -dictionary $lvalues] {
                    $lt insert end [format "%s%s%s%s%s" $value < $variable < $S(database)]
                }
            }
        }
    }
    proc AnnotateQuit {} {
        set choix [tk_messageBox -type okcancel -default ok  \
                -message "Exit Annotation Browser ?" -icon question]
        if {$choix == "ok"} {
            eval destroy .annotation
        }
    }
    #
    proc AnnotateLoadLabel {} {
        global S
        set filtre {}
        lappend filtre [list {TreeDyn Label File} .txt]
        set typelist {
            {"TreeDyn Labels Files" {".tlf"} }
            {"All Files" {*}}
        }
        set filename [tk_getOpenFile -initialdir $S(userDIR)  -defaultextension "tlf" \
                -filetypes $typelist -title "Load TreeDyn Labels File..."]
        if {$filename != ""} {set S(userDIR) [file dirname $filename]}
        if [catch {open $filename r} fid] {
            puts stderr "Error Opening File"
        } else {
            set currentfile [Tools::PathCut2 $filename]
            if {[lsearch $S(ldatabase) $currentfile] != -1 } {
                upvar #0 $currentfile X
                array unset X
            } else  {
                set S(database) $currentfile
                lappend S(ldatabase) $currentfile
            }
            Database::db $currentfile
            while {[eof $fid] != 1} {
                set id [incr S(lastid)]
                gets $fid data
                regsub -all " " [lindex $data 0] "¶" sans
                set datasans [lreplace $data 0 0 $sans]
                eval $currentfile [concat $id EU $datasans]
                #eval $currentfile [concat $id EU $data]
            }
            close $fid
        }
        
        
        # mise a jour menu de la liste des labels file
        .annotation.c.m1 delete 0 end
        foreach lf $S(ldatabase) {.annotation.c.m1 insert end $lf}
        .annotation.c.m1 select $currentfile
        # mise a jour listbox des variables
        set lvar [Database::dbQueryVarAll $S(database)]
        # remplissage listbox
        .annotation.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l delete 0 end
        eval {.annotation.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l insert end} $lvar
    }
    #
    proc AnnotateLabelsFileSwitch {m} {
        global S
        set select [$m get]
        switch -exact $select {
            "?" {puts Default}
            default {set S(database) $select}
        }
        # mise a jour listbox des variables
        set lvar [Database::dbQueryVarAll $S(database)]
        # remplissage listbox
        .annotation.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l delete 0 end
        eval {.annotation.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l insert end} $lvar
    }
    ### ANNOTATION PANEL
    proc ANPanel {} {
        global S ann tcl_platform
        # init
        set ann(ann-position) justify
        set ann(ann-fgfiguration) asleaf
        set ann(ann-fofiguration) asleaf
        set ann(ann-leavemod) add
        set ann(ann-prefix) " "
        set ann(ann-suffix) ""
        set ann(ann-exposant) 0
        set ann(binmatPadding) 6
        set ann(binmatHeight) 4
        set ann(binmatWidth) 4
        set ann(binmatColor0) grey
        set ann(binmatColor1) black
        set ann(binmatOutline) 1
        set ann(binmatColumnsNumber) 0
        if {[winfo exists .ann] == 1} {
            wm deiconify .ann
        } else  {
            set w [toplevel .ann ]
            wm title .ann "Annotation"
            wm geometry .ann 450x600
            #
            frame .ann.l
            button .ann.l.load -text "Load annotations..." -command Database::LoadAnnotations
            button .ann.l.sc -text Script -command "Interface::PopUpPanel ScriptingPanel ; Scripting::OpenScriptCAP"
            pack .ann.l.sc -fill x -expand yes
            pack .ann.l.load -fill x -expand yes
            # Select Label(s)
            set m .ann.l.m
            iwidgets::optionmenu $m -command "Annotation::ANLabelsFileSwitch $m"
            foreach lf $S(ldatabase) {$m insert end $lf}
            pack $m -fill x -expand yes
            # Select Target(s)
            menubutton .ann.l.target -text "Tree Target(s)" -menu .ann.l.target.m  -direction below
            set z  [menu  .ann.l.target.m -tearoff 0]
            $z configure -postcommand "Annotation::ANTarget $z"
            pack .ann.l.target -fill x -expand yes
            ################ VARIABLES
            # select all/unselect all available leaves
            frame .ann.l.ale
            button .ann.l.ale.sel -text "Select all"  -command ".ann.l.lfa.l selection set 0 end"
            button .ann.l.ale.uns -text "UnSelect all"  -command ".ann.l.lfa.l selection clear 0 end"
            pack .ann.l.ale.sel .ann.l.ale.uns -side left -fill x -expand yes
            pack .ann.l.ale -fill x -expand yes
            # list Variables du fichier de label courant
            set wd [frame .ann.l.lfa ]
            scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
            scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
            listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                    -width 35 -height 30 -selectmode extended
            grid $wd.l -row 0 -column 0 -sticky news
            grid $wd.yscroll -row 0 -column 1 -sticky ns
            grid $wd.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $wd 0 -weight 1
            grid columnconfigure $wd 0 -weight 1
            pack .ann.l.lfa
            # tabnotebook general
            switch $tcl_platform(platform) {
                "unix" {
                    if  {$tcl_platform(os) == "Darwin"} {
                        set color systemButtonFace
                    } else  {
                        set color #efebe7
                    }
                }
                "windows" {
                    set color systemButtonFace
                }
            }
            iwidgets::tabnotebook .ann.g -width 200 -height 400 -tabpos n -equaltabs 0 \
                    -background $color -backdrop $color -tabbackground $color
            set t1 [.ann.g add -image IMGannt1 -label "Text" ]
            set t2 [.ann.g add -image IMGannt2 -label "2 colors matrix" ]
            set t3 [.ann.g add -image IMGannt3 -label "Items" ]
            set t4 [.ann.g add  -label "RGB matrix" ]
            .ann.g view "Text"
            
            
            ### tabnotebook variables quantitatives/qualitatives (non binaires)
            iwidgets::tabnotebook $t1.n -width 200 -height 400 -tabpos n \
                    -background $color -backdrop $color -tabbackground $color
            set toolbox1 [$t1.n add -label "Leaves"]
            set toolbox2 [$t1.n add -label "Columns"]
            $t1.n view "Columns"
            # T3 ITEMS
            set ann(DrawFactor) 50
            set ann(DrawNode) 1
            set ann(DrawFill) 0
            set ann(DrawXsize) 15
            set ann(DrawYsize) 15
            set ann(DrawFactorRectangle) 100
            set ann(DrawHeightRectangle) 20
            set ann(XYmode) scatter
            # parametres affichages du contour
            #SHAPE
            iwidgets::Labeledframe $t3.c -labelpos ne -labeltext "Shape"
            set f1 [$t3.c childsite]
            # factor amplification
            iwidgets::entryfield $f1.factor  -width 4 -textvariable ann(DrawFactor) -labeltext "Amplification"
            # affichage noeuds du contour
            checkbutton $f1.nodes -text "Display Nodes" -variable ann(DrawNode)
            # filling the polygon
            checkbutton $f1.fill -text "Fill" -variable ann(DrawFill)
            # toolbar pour tool calcul de forme moyenne sur les nodes
            eval {iwidgets::toolbar} $f1.ta
            $f1.ta add radiobutton  subtreeshape  -overrelief sunken \
                    -variable S(tool) -value subtreeshape  \
                    -image IMGshapenode
            $f1.ta add radiobutton  subtreeshapem  -overrelief sunken \
                    -variable S(tool) -value subtreeshapem  \
                    -image IMGshapenodem
            # boutton annotate
            button $f1.go -text "Annotate" -command "Annotation::DrawANGo"
            pack $f1.factor
            pack $f1.nodes $f1.fill -expand yes -fill x -anchor w
            pack $f1.ta $f1.go -side top -expand yes -fill x -anchor w
            pack $f1  -expand yes -fill x
            pack $t3.c -expand yes -fill x
            # XY nuage bivarie
            iwidgets::Labeledframe $t3.c2 -labelpos ne -labeltext "XY"
            set f2 [$t3.c2 childsite]
            # WIDTH and HEIGHT fenetre nuage (pixels)
            iwidgets::entryfield $f2.nux  -width 4 -textvariable ann(DrawXsize) -labeltext "Window Width"
            iwidgets::entryfield $f2.nuy  -width 4 -textvariable ann(DrawYsize) -labeltext "Window Height"
            #
            set wmode [frame $f2.mode]
            radiobutton $wmode.a -text "XY" -variable ann(XYmode) -value scatter
            radiobutton $wmode.b -text "BA" -variable ann(XYmode) -value batons
            radiobutton $wmode.c -text "Xcu" -variable ann(XYmode) -value curve
            pack $wmode.a $wmode.b $wmode.c -side left
            # toolbar pour tool calcul de forme moyenne sur les nodes
            eval {iwidgets::toolbar} $f2.ta
            $f2.ta add radiobutton  plotnode  -overrelief sunken \
                    -variable S(tool) -value plotnode  \
                    -image IMGplotnode
            $f2.ta add radiobutton  plotnodem  -overrelief sunken \
                    -variable S(tool) -value plotnodem  \
                    -image IMGplotnodem
            # boutton annotate
            button $f2.go -text "Annotate" -command "Annotation::DrawPlotANGo"
            pack $f2.nux $f2.nuy $wmode $f2.ta $f2.go -side top -side top -expand yes -fill x
            pack $f2  -expand yes -fill x
            pack $t3.c2  -expand yes -fill x
            ##rectangle (histograme)
            iwidgets::Labeledframe $t3.c3 -labelpos ne -labeltext "Rectangle"
            set f3 [$t3.c3 childsite]
            # factor amplification X
            iwidgets::entryfield $f3.factor  -width 4 -textvariable ann(DrawFactorRectangle) -labeltext "X Factor"
            # hauteur rectangle
            iwidgets::entryfield $f3.rectwidth  -width 4 -textvariable ann(DrawHeightRectangle) -labeltext "Window Height"
            # boutton annotate
            button $f3.go -text "Annotate" -command "Annotation::DrawANGo"
            pack $f3.factor $f3.rectwidth $f3.go -side top -expand yes -fill x
            pack $f3  -expand yes -fill x
            pack $t3.c3  -expand yes -fill x    
            
            # T2 MATRICE SYMBOL VARIABLE BINAIRE
            iwidgets::Labeledframe $t2.c -labelpos ne -labeltext "Color"
            set tcs1 [$t2.c childsite]
            button $tcs1.b0 -text "  0  " -background $ann(binmatColor0) -command "Annotation::SwitchCol0 $tcs1.b0"
            button $tcs1.b1 -text "  1  " -background $ann(binmatColor1) -command "Annotation::SwitchCol1 $tcs1.b1"
            pack $tcs1.b0 $tcs1.b1 -side top -expand true -fill x
            pack $tcs1 -expand true -fill x
            # t2 taille selection
            iwidgets::Labeledframe $t2.ta -labelpos ne -labeltext "Dimensions"
            set tcs2 [$t2.ta childsite]
            iwidgets::entryfield $tcs2.width  -width 3 -textvariable ann(binmatWidth) -labeltext "Width"
            iwidgets::entryfield $tcs2.height  -width 3 -textvariable ann(binmatHeight) -labeltext "Height"
            iwidgets::entryfield $tcs2.pad  -width 3 -textvariable ann(binmatPadding) -labeltext "Padding"
            #checkbutton $tcs2.out -text "Outline" -variable ann(binmatOutline)
            checkbutton $tcs2.coln -text "Columns Number" -variable ann(binmatColumnsNumber)
            pack $tcs2.width $tcs2.height $tcs2.pad  $tcs2.coln -anchor e
            pack $tcs2
            # boutton go
            button $t2.go -text "Annotate" -command "Annotation::MatrixAnnotateGo"
            pack $t2.c $t2.ta  $t2.go -expand yes -fill x
            
            # T4 MATRICE SYMBOL VARIABLE RGB
            iwidgets::Labeledframe $t4.ta -labelpos ne -labeltext "Dimensions"
            set tcs4 [$t4.ta childsite]
            iwidgets::entryfield $tcs4.width  -width 3 -textvariable ann(binmatWidth) -labeltext "Width"
            iwidgets::entryfield $tcs4.height  -width 3 -textvariable ann(binmatHeight) -labeltext "Height"
            iwidgets::entryfield $tcs4.pad  -width 3 -textvariable ann(binmatPadding) -labeltext "Padding"
            #checkbutton $tcs2.out -text "Outline" -variable ann(binmatOutline)
            checkbutton $tcs4.coln -text "Columns Number" -variable ann(binmatColumnsNumber)
            pack $tcs4.width $tcs4.height $tcs4.pad  $tcs4.coln -anchor e
            pack $tcs4
            pack $t4.ta -expand yes -fill x
            # boutton go
            button $t4.go -text "Annotate" -command "Annotation::MatrixColorsAnnotateGo"
            pack  $t4.go -expand yes -fill x
            # toolbox 1
            iwidgets::Labeledframe $toolbox1.f -labelpos ne -labeltext "Font"
            set cs1 [$toolbox1.f childsite]
            radiobutton $cs1.user -text "user selection" -variable ann(ann-fofiguration) -anchor w \
                    -value asuser -command "Interface::PopUpPanel2 ColorFontPanel ; .cf.n view Font"
            radiobutton $cs1.leaf -text "as Leaf" -anchor w -variable ann(ann-fofiguration) -value asleaf
            iwidgets::Labeledframe $toolbox1.c -labelpos ne -labeltext "Foreground Color"
            set cs2 [$toolbox1.c childsite]
            radiobutton $cs2.fguser -text "user selection" -variable ann(ann-fgfiguration) -anchor w -value asuser \
                    -command "Interface::PopUpPanel2 ColorFontPanel ; .cf.n view Color"
            radiobutton $cs2.fgleaf -text "as Leaf"  -anchor w -variable ann(ann-fgfiguration) -value asleaf
            iwidgets::Labeledframe $toolbox1.d -labelpos ne -labeltext "+ Text"
            set cs3 [$toolbox1.d childsite]
            iwidgets::entryfield $cs3.pre  -width 9 -textvariable ann(ann-prefix) -labeltext "Prefix"
            iwidgets::entryfield $cs3.suf  -width 9 -textvariable ann(ann-suffix) -labeltext "Suffix"
            iwidgets::entryfield $cs3.up  -width 4 -textvariable ann(ann-exposant) -labeltext "Y translation"
            iwidgets::Labeledframe $toolbox1.e -labelpos ne -labeltext "Position"
            set cs4 [$toolbox1.e childsite]
            radiobutton $cs4.add -text "Add"  -anchor w -variable ann(ann-leavemod)  -value add
            radiobutton $cs4.replace -text "Replace" -anchor w -variable ann(ann-leavemod) -value replace
            pack $cs1.user $cs1.leaf -expand yes -fill both
            pack $cs2.fguser $cs2.fgleaf -expand yes -fill both
            pack $cs3.pre $cs3.suf $cs3.up -anchor w
            pack $cs4.add $cs4.replace -anchor w
            pack $toolbox1.f $toolbox1.c $toolbox1.d $toolbox1.e -expand yes -fill both
            pack $cs1 $cs2 $cs3 $cs4 -expand yes -fill both
            button $toolbox1.go -text "Annotate" -command "set ann(ann-position) add ; Annotation::ANGo"
            pack $toolbox1.go -expand yes -fill x
            # toolbox 2
            iwidgets::Labeledframe $toolbox2.f -labelpos ne -labeltext "Font"
            set cs1 [$toolbox2.f childsite]
            radiobutton $cs1.user -text "user selection" -variable ann(ann-fofiguration) -anchor w -value asuser \
                    -command "Interface::PopUpPanel2 ColorFontPanel ; .cf.n view Font"
            radiobutton $cs1.leaf -text "as Leaf" -anchor w -variable ann(ann-fofiguration) -value asleaf
            iwidgets::Labeledframe $toolbox2.c -labelpos ne -labeltext "Foreground Color"
            set cs2 [$toolbox2.c childsite]
            radiobutton $cs2.fguser -text "user selection" -variable ann(ann-fgfiguration) -anchor w \
                    -value asuser -command "Interface::PopUpPanel2 ColorFontPanel ; .cf.n view Color"
            radiobutton $cs2.fgleaf -text "as Leaf"  -anchor w -variable ann(ann-fgfiguration)  -value asleaf
            iwidgets::Labeledframe $toolbox2.d -labelpos ne -labeltext "+ Text"
            set cs3 [$toolbox2.d childsite]
            iwidgets::entryfield $cs3.pre  -width 9 -textvariable ann(ann-prefix) -labeltext "Prefix"
            iwidgets::entryfield $cs3.suf  -width 9 -textvariable ann(ann-suffix) -labeltext "Suffix"
            iwidgets::entryfield $cs3.up  -width 4 -textvariable ann(ann-exposant) -labeltext "Y translation"
            pack $cs1.user $cs1.leaf -expand yes -fill both
            pack $cs2.fguser $cs2.fgleaf -expand yes -fill both
            pack $cs3.pre $cs3.suf $cs3.up -anchor w
            pack $toolbox2.f $toolbox2.c $toolbox2.d  -expand yes -fill both
            pack $cs1 $cs2 $cs3 -expand yes -fill both
            button $toolbox2.go -text Annotate -command "set ann(ann-position) justify ;Annotation::ANGo"
            pack   $toolbox2.go -expand yes -fill x
            pack  $toolbox2 -anchor w -expand yes -fill both
            pack $t1.n -expand yes -fill both
            pack .ann.l .ann.g -side left -expand yes -fill both
            ANVariablesUpdate ;# si des fichiers de labels deja dl via panel identification
        }
    }
    #
    proc SwitchCol0 {w} {
        global S ann
        $w configure -background $S(col)
        set ann(binmatColor0) $S(col)
    }
    #
    proc SwitchCol1 {w} {
        global S ann
        $w configure -background $S(col)
        set ann(binmatColor1) $S(col)
    }
    #
    proc ANmoveMatrix {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set S(mox) $x
            set S(moy) $y
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                # motion sur AM$t
                set i  [lindex $tags [lsearch -glob $tags T*]]
                set t [string range $i 1 end]
                bind movematrix <B1-Motion> "Annotation::ANmoveMotion %W %x %y AM$t"
            }
        }
    }
    #
    proc ANmoveCOL {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set S(mox) $x
            set S(moy) $y
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                bind movecol <B1-Motion> "Annotation::ANmoveMotion %W %x %y $tag"
            }
        }
    }
    #
    proc ANmoveMotion {w x y tag} {
        global S T
        $w move $tag [expr $x - $S(mox)] 0
        #$w move $tag [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
    }
    proc ANannfgcol {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                set onofftag [lindex $tags [lsearch -glob $tags BIN¶*]]
                $w itemconfigure [list $tag && $onofftag] -fill $S(col) -outline $S(col)
            }
        }
    }
    proc ANannfgrow {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags MA¶*]]
                set onofftag [lindex $tags [lsearch -glob $tags BIN¶*]]
                set toto [list $tag && $onofftag]
                catch {$w itemconfigure $toto -fill $S(col)} -outline $S(col)
            }
        }
    }
    proc ANannfocol {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            if {[$w type $id] == "text"} {
                set tags [$w gettags $id]
                if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                    set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                    set li [$w find withtag $tag]
                    foreach i $li {
                        if {[$w type $i] == "text"} {
                            $w itemconfigure $i -font $S(gfo)}
                    }
                    
                }
            }
        }
    }
    proc ANannRowCol {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                set lid [$w find withtag $tag]
                foreach i $lid {
                    set co [$w coords $i]
                    #set x [$w canvasx [lindex $co 0]] ; set y [$w canvasy [lindex $co 1]]
                    set x [lindex $co 0] ; set y [lindex $co 1]
                    set text [lindex [$w itemconfigure $i -text] end]
                    if {$text != "" && $text != " -"} {
                        set id [format "%s%s" 1 [Tools::GenId]]
                        set idtext [format "%s%s%s" anntext ¶ $id]
                        set idlink [format "%s%s%s" annlink ¶ $id]
                        set  font [lindex [$w itemconfigure $i -font] end]
                        set color [lindex [$w itemconfigure $i -fill] end]
                        $w delete $i
                        regsub -all " " $text "\n" newtext
                        set newtext [string trimleft $newtext "\n"]
                        # -stipple @[file join + stipple $S(stipple)]
                        $w create oval [expr $x -3] [expr $y - 3] [expr $x + 3] [expr $y + 3] \
                                -fill black -outline black -tags $tags
                        $w create text [expr $x + 30 ]  $y   \
                                -text $newtext  -anchor nw  \
                                -tags "bullann $idtext $tags" -font $font -fill $color
                        #
                        $w create line  $x $y [expr $x + 30 ]  $y  \
                                -width 1 -fill $color -tags "Link $idlink $tags"
                    } else  {
                        $w delete i
                    }
                }
            }
        }
        $w bind bullann <Button-1> {Annotation::ANmovebullann %W %x %y}
    }
    proc ANmovebullann {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set S(mox) $x
            set S(moy) $y
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags bullann] != -1} {
                set tag [lindex $tags [lsearch -glob $tags anntext¶*]]
                $w bind bullann <B1-Motion> "Annotation::ANmotionbullann %W %x %y $tag"
            }
        }
    }
    #
    proc ANmotionbullann {w x y tag} {
        global S T
        # move du text
        $w move $tag [expr $x - $S(mox)] [expr $y - $S(moy)]
        # delete et reconstruction du lien
        set taglink [format "%s%s%s" annlink ¶ [string trimleft $tag anntext¶ ]]
        set co [$w coords $taglink]
        set xl [lindex $co 0] ; set yl [lindex $co 1]
        set tags [$w gettags $taglink]
        set color [lindex [$w itemconfigure $taglink -fill] end]
        $w delete $taglink
        set idc [$w create line  $xl $yl [$w canvasx $x] [$w canvasy $y]  \
                -width 1 -fill $color -tags "Link $taglink $tags"]
        $w lower $idc
        # ok
        set S(mox) $x
        set S(moy) $y
    }
    proc ANannillcol {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                $w itemconfigure $tag -font $S(ill-fon)
            }
        }
    }
    proc ANannillcar {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                $w itemconfigure $tag -text $S(ill-car) -font $S(ill-fon)
            }
        }
    }
    
    proc ANannforow {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags MA¶*]]
                $w itemconfigure $tag -font $S(gfo)
            }
        }
    }
    proc ANannanchw {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                $w itemconfigure $tag -anchor w
            }
        }
    }
    proc ANannanche {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags AnnotMatrix] != -1} {
                set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                $w itemconfigure $tag -anchor e
            }
        }
    }
    #
    proc AnnotationPanelUpdate {} {
        global S
        set m .ann.l.m
        if {[winfo exists .ann] == "1"} {
            $m delete 0 end
            foreach lf $S(ldatabase) {$m insert end $lf}
            $m select end
            ANVariablesUpdate
        }
    }
    #
    proc ANLabelsFileSwitch {m} {
        global S
        set select [$m get]
        switch -exact $select {
            "?" {puts Default}
            default {set S(database) $select}
        }
        ANVariablesUpdate
        #pour l'instant
        #.ann.l.lfb.l delete 0 end
    }
    # mise a jour liste des variables pour le fichier de label courant
    proc ANVariablesUpdate {} {
        global S
        # liste des variables
        set lvar [Database::dbQueryVarAll $S(database)]
        # remplissage listbox
        .ann.l.lfa.l delete 0 end
        eval {.ann.l.lfa.l insert end} $lvar
        # reconfiguration background des feuilles de la listbox
        # pour celles deja en selection
        # if {[.ann.l.lfb.l get 0 end] != {}} {ANConfigBg}
    }
    # config bg si deja en selection
    proc ANConfigBg {} {
        global S
        set li {}
        set lni {}
        set lavailable [.ann.l.lfa.l get 0 end] ;# var available
        set selectL [.ann.l.lfb.l get 0 end] ;# feuilles en selection
        foreach e $lavailable {
            set r [lsearch $selectL $e]
            set index [lsearch $lavailable $e]
            if {$r != -1} {
                .ann.l.lfa.l itemconfigure $index -background NavajoWhite2
            } else {
                .ann.l.lfa.l itemconfigure $index -background LightGoldenrodYellow
            }
        }
    }
    #
    proc ANaddVarMouse {listbox x y} {
        global S abs
        set leaf [$listbox get @$x,$y]
        set selectL [.ann.l.lfb.l get 0 end]
        if {[lsearch $selectL $leaf] == -1}  {
            .ann.l.lfb.l insert end $leaf
        }
        .ann.l.lfa.l selection clear @$x,$y
        ANConfigBg
    }
    # boutton ajout de la selection leave available dans la liste selection
    proc ANAddL {} {
        global S abs
        # mise a jour listbox fichiers selection
        # on conserve l'ordre des groupes de selection
        set li [.ann.l.lfa.l curselection] ;# des index
        set lsel {}
        foreach i $li {
            lappend lsel [.ann.l.lfa.l get $i]
            .ann.l.lfa.l itemconfigure $i -background NavajoWhite2
        }
        set lall2 [.ann.l.lfb.l get 0 end]
        .ann.l.lfb.l delete 0 end
        # c moche je sais
        foreach e $lsel {
            lappend lall2 $e
        }
        #
        foreach e [Tools::DelRep $lall2] {
            .ann.l.lfb.l insert 0 $e
        }
        # deselection des fichiers liste available
        .ann.l.lfa.l selection clear 0 end
        # update nb de tree total
    }
    #
    proc ANRemL {} {
        global abs
        # attention retrait a partir de l'index le plus bat
        # le delete remet a jour les index
        set li [lsort -decreasing [.ann.l.lfb.l curselection]] ;# des index
        foreach i $li {
            .ann.l.lfb.l delete $i
        }
        # deselection des fichiers liste available
        .ann.l.lfa.l selection clear 0 end
        ANConfigBg
    }
    #
    proc ANremVarMouse {listbox x y} {
        global S abs
        $listbox delete @$x,$y
        ANConfigBg
    }
    #
    proc ANTarget {m} {
        global S
        $m  delete 0 end
        $m add command -label "Select All" -command "Selection::TreeTargetSelectAll"
        $m add command -label "UnSelect All" -command "Selection::TreeTargetUnSelectAll"
        $m add separator
        # un menu par fenetre, avec select/unselect all par fenetre
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set ms [format "%s%s%s" $m. w [Tools::GenId]]
                $m add cascade -label [wm title .t$wi] -menu $ms
                menu $ms -tearoff 0
                $ms add command -label "Select All" -command "Selection::TreeTargetSelectAllperW $wi"
                $ms add command -label "Unselect All" -command "Selection::TreeTargetUnSelectAllperW $wi"
                $ms add separator
                set win [format "%s%s%s" .t $wi .c]
                foreach t $S($win,t) {
                    $ms add checkbutton -label $S($t,tit) -variable S($t,tar) \
                            -columnbreak 0 -command "Selection::ShwoTree $t"
                }
            }
        }
    }
    # Query Leaves Annotation Mode Leave
    proc qLannL {w t leu} {
        global S ann T
        # tag de colonne
        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
        foreach l $leu {
            set i [$w find withtag [list ADD¶$l && T$t]]
            if {$i == ""} {
                set i [$w find withtag [list [format "%s%s" EU  $l] && T$t]]
                set co [$w coords $i]
                set y [lindex $co 1]
                set i2 [$w find withtag [list [format "%s%s" EUL  $l] && T$t]]
                
                if {[$w itemcget $i2 -state] == "hidden"} {
                    set x [lindex [$w bbox $i] 2]
                } else  {
                    set x [lindex [$w bbox $i2] 2]
                }
                
            } else  {
                set co [$w coords [lindex $i 0]]
                set y [expr [lindex $co 1] + 6]
                set x 0
                foreach ii $i {
                    set xii [lindex [$w bbox $ii] 2]
                    if {$xii >= $x} {
                        set x $xii
                    }
                }
            }
            #
            if {$x != "" && $y != ""} {
                if {$S(DisplayVOV) == 0} {set sss [lrange $S(query) 2 end]}
                set lc [split $sss {}]
                set nbc [llength $lc]
                if  {[expr $nbc / 2 * 2] == $nbc} {
                    set s $sss
                } else  {
                    set s " $sss"
                }
                
                $w create text $x $y -text $s \
                        -font $S(gfo) \
                        -fill $S(col) \
                        -anchor center  -justify center \
                        -tags "ADD¶$l T$t  AnnotMatrix $tagC AM$t MA¶$l" -anchor w
            }
            
        }
    }
    #
    proc qLannC {w t leu} {
        global S ann T
        switch -exact $S($t,type) {
            PhyNJ - ClaSla - ClaRec {
                # recherche x
                if {$S(illustration-tabulation) == 1} {
                    set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                    set XMAX3 [lindex [$w bbox [list T$t && AnnotMatrix]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
                    set x [expr $XMAX + $S($t,LabelMatrixBase)]
                } else  {
                    set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    set x [expr $XMAX + $S($t,LabelMatrixBase)]
                }
                
                # tag de colonne
                set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                foreach l $leu {
                    # recherche y (code arrete terminale)
                    set item [$w find withtag [list [format "%s%s" EU  $l ] && T$t]]
                    if {$item != ""} {
                        set co [$w coords $item]
                        set y [lindex $co 1]
                        # avoir un nombre pair de caractere pour bien centrer
                        # sinon on ajoute devant un espace
                        #if {$S(DisplayVOV) == 0} {set sss [lrange $S(query) 2 end]}
                        if {$S(DisplayVOV) == 0} {set sss $S(query)}
                        set lc [split $sss {}]
                        set nbc [llength $lc]
                        if  {[expr $nbc / 2 * 2] == $nbc} {
                            set s $sss
                        } else  {
                            set s " $sss"
                        }
                        $w create text $x $y  \
                                -text  $s \
                                -fill $S(col) \
                                -font $S(gfo) \
                                -anchor w  -justify center \
                                -tags "T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo"
                    }
                }
            }
            PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                qLannC360 $w $t $leu
            }
            ClaCir1 - ClaCir2 - ClaCir3 {
                qLannC360 $w $t $leu
            }
        }
    }
    ###
    proc qLannC360old {w t leu} {
        global S ann T
        #puts coucou
        set d $S($t,LabelMatrixBase)
        #set co [$w bbox [list Z && T$t]]
        set co [$w bbox [list L && T$t]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set C(dx) [expr abs(($x2 - $x1)) /2.0]
        set C(dy) [expr abs(($y2 - $y1)) /2.0]
        
        # test pour eviter l'oval
        #if {$C(dx) >= $C(dy)} {set C(dy) $C(dx)}  {set C(dx) $C(dy)}
        set R [expr 200 + $S($t,LabelMatrixBase)]
        
        
        set a_ref [expr 360.0/ [llength $T($t,ue_cod)]] ;# unite d'angle
        set n 0
        # tag de colonne
        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
        # inversion de la liste des eus
        if { $S($t,type) == "ClaCir2"} {
            set LLE {}
            foreach e $T($t,ue_cod) {
                set LLE [concat $e $LLE]
            }
            set n 1
        } else  {
            set LLE $T($t,ue_cod)
        }
        # leger decalage du a anchor/justify si l'annotation a un seul caractere
        # on ajoute a l'avant un espace
        foreach e $LLE {
            set C(angle,$e) [expr $n*$a_ref]
            if  {[lsearch $leu $T($t,ctl,$e)] != -1} {
                # degres -> radians
                set angrad [expr (2 * acos(-1) * $C(angle,$e)) / 360.0]
                # d est l'augmentation du rayon du cercle
                set x [expr ($C(dx) + $d ) * cos($angrad)]
                set y [expr ($C(dy) + $d ) * sin($angrad)]
                
                set l $T($t,ctl,$e)
                # query
                if {$S(DisplayVOV) == 0} {set sss [lrange $S(query) 2 end]}
                # avoir un nombre pair de caractere pour bien centrer
                # sinon on ajoute devant un espace
                set lc [split $sss {}]
                set nbc [llength $lc]
                if  {[expr $nbc / 2 * 2] == $nbc} {
                    set s $sss
                } else  {
                    set s " $sss"
                }
                $w create text [expr $x + $x1 + $C(dx)] [expr $y  + $y1 + $C(dy)] \
                        -text $s \
                        -anchor center  -justify center \
                        -fill $S(col) \
                        -font $S(gfo) \
                        -tags "ILLCo¶$l T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo"
            }
            incr n
        }
        unset C
    }
    # NB pb si les feuilles de sont pas affichees
    # en plus attention en circulaire sans longueur de branche
    proc qLannC360 {w t leu} {
        global S ann T
        # cercle d'illustration fixer R le rayon du cercle d'illustration
        # on peut fixer une valeur pour par ex. 200 + tabulation
        # mais mieux de chercher une valeur adaptee Ã  chaque
        # arbre
        # set R [expr 200 + $S($t,LabelMatrixBase)]
        set co [$w bbox [list L && T$t]]
        # si les feuilles ne sont pas affichees on prend les arretes terminales
        set co [$w bbox [list Z && T$t]]
        # et si on utillisait toujours sur Z ?
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set Rx [expr ($x2 - $x1) /2.0]
        set Ry [expr ($y2 - $y1) /2.0]
        if {$Rx > $Ry} {
            set R [expr $Rx + $S($t,LabelMatrixBase)]
        } else  {
            set R [expr $Ry + $S($t,LabelMatrixBase)]
        }
        set a_ref [expr 6.28318530717958 / [llength $T($t,ue_cod)]]
        set n 0
        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
        # inversion ordre liste feuilles selon conformation
        if { $S($t,type) == "ClaCir2"} {
            set LLE {}
            foreach e $T($t,ue_cod) {
                set LLE [concat $e $LLE]
            }
            set n 1
        } else  {
            set LLE $T($t,ue_cod)
        }
        # leger decalage du a anchor/justify si l'annotation a un seul caractere
        # ou nombre impair, on ajoute a l'avant un espace
        foreach e $LLE {
            set a [expr double($n*$a_ref)]
            if  {[lsearch $leu $T($t,ctl,$e)] != -1} {
                set x [expr $R * cos($a)]
                set y [expr $R * sin($a)]
                # TAG
                set l $T($t,ctl,$e)
                # query
                if {$S(DisplayVOV) == 0} {set sss [lrange $S(query) 2 end]}
                # avoir un nombre pair de caractere pour bien centrer
                # sinon on ajoute devant un espace
                set lc [split $sss {}]
                set nbc [llength $lc]
                if  {[expr $nbc / 2 * 2] == $nbc} {
                    set s $sss
                } else  {
                    set s " $sss"
                }
                $w create text $x $y \
                        -text $s \
                        -anchor center  -justify center \
                        -fill $S(col) \
                        -font $S(gfo) \
                        -tags "ILLCo¶$l T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo"
            }
            incr n
        }
        # centrage sur arbre tags root "[format "%s%s" $t C] T$t Z"
        set co [$w coords [format "%s%s" $t C]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set xcenter [expr ($x1 + $x2) /2.0]
        set ycenter [expr ($y1 + $y2) /2.0]
        $w move $tagC $xcenter $ycenter
    }
    # Leaves Annotation Mode Leave
    proc LannLtoolbox {w x y} {
        global T
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set p [format "%s%s" $n *]
            set leu {}
            foreach e $T($t,ue_cod) {
                if {[string match $p $e] == 1} {
                    lappend leu $T($t,ctl,$e)
                }
            }
            LannL $w $t $leu
        }
    }
    #
    proc LannL {w t leu} {
        global S ann T
        switch -exact $S($t,type) {
            PhyNJ - ClaSla - ClaRec {
                # tag de colonne
                set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                foreach l $leu {
                    set i [$w find withtag [list ADD¶$l && T$t]]
                    if {$i == ""} {
                        set i [$w find withtag [list [format "%s%s" EU  $l] && T$t]]
                        set co [$w coords $i]
                        set y [lindex $co 1]
                        set i2 [$w find withtag [list [format "%s%s" EUL  $l] && T$t]]
                        
                        if {[$w itemcget $i2 -state] == "hidden"} {
                            set x [lindex [$w bbox $i] 2]
                        } else  {
                            set x [lindex [$w bbox $i2] 2]
                        }
                        
                    } else  {
                        set co [$w coords [lindex $i 0]]
                        set y [lindex $co 1]
                        set x 0
                        foreach ii $i {
                            set xii [lindex [$w bbox $ii] 2]
                            if {$xii >= $x} {
                                set x $xii
                            }
                        }
                    }
                    if {$x != "" && $y != ""} {
                        # avoir un nombre pair de caractere pour bien centrer
                        # sinon on ajoute devant un espace
                        set lc [split $S(AnnotateNote) {}]
                        set nbc [llength $lc]
                        if  {[expr $nbc / 2 * 2] == $nbc} {
                            set s $S(AnnotateNote)
                        } else  {
                            set s " $S(AnnotateNote)"
                        }
                        $w create text $x $y -text $s \
                                -font $S(gfo) \
                                -fill $S(col) \
                                -anchor center  -justify center \
                                -tags "ADD¶$l T$t $tagC AnnotMatrix AM$t MA¶$l" -anchor w
                    }
                }
                
            }
            PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                # rien pour l'instant
            }
            ClaCir1 - ClaCir2 - ClaCir3 {
                # pour l'instant on reste sur LannC360 mais il faudra
                # passer par une proc LannL360
                LannC360 $w $t $leu
            }
        }
    }
    # AnnotMatrix AM$t MA¶$l
    proc LannCtoolbox {w x y} {
        global T
        set tags [$w gettags [$w find withtag current]]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set p [format "%s%s" $n *]
            set leu {}
            foreach e $T($t,ue_cod) {
                if {[string match $p $e] == 1} {
                    lappend leu $T($t,ctl,$e)
                }
            }
            LannC $w $t $leu
        }
    }
    #
    proc LannC {w t leu} {
        global S ann T
        switch -exact $S($t,type) {
            PhyNJ - ClaSla - ClaRec {
                # recherche x
                if {$S(illustration-tabulation) == 1} {
                    set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                    set XMAX3 [lindex [$w bbox [list T$t && AnnotMatrix]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
                    set x [expr $XMAX + $S($t,LabelMatrixBase)]
                } else  {
                    set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    set x [expr $XMAX + $S($t,LabelMatrixBase)]
                }
                
                # tag de colonne
                set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                foreach l $leu {
                    # recherche y (code arrete terminale)
                    set item [$w find withtag [list [format "%s%s" EU  $l ] && T$t]]
                    if {$item != ""} {
                        set co [$w coords $item]
                        set y [lindex $co 1]
                        # avoir un nombre pair de caractere pour bien centrer
                        # sinon on ajoute devant un espace
                        set lc [split $S(AnnotateNote) {}]
                        set nbc [llength $lc]
                        if  {[expr $nbc / 2 * 2] == $nbc} {
                            set s $S(AnnotateNote)
                        } else  {
                            set s " $S(AnnotateNote)"
                        }
                        $w create text $x $y  \
                                -text  $s \
                                -fill $S(col) \
                                -font $S(gfo) \
                                -anchor center  -justify center \
                                -tags "T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo"
                    }
                }
            }
            PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                LannC360 $w $t $leu
            }
            ClaCir1 - ClaCir2 - ClaCir3 {
                LannC360 $w $t $leu
            }
        }
    }
    ###
    proc LannC360 {w t leu} {
        global S ann T
        # cercle d'illustration fixer R le rayon du cercle d'illustration
        # on peut fixer une valeur pour par ex. 200 + tabulation
        # mais mieux de chercher une valeur adaptee Ã  chaque
        # arbre
        # set R [expr 200 + $S($t,LabelMatrixBase)]
        set co [$w bbox [list L && T$t]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set Rx [expr ($x2 - $x1) /2.0]
        set Ry [expr ($y2 - $y1) /2.0]
        if {$Rx > $Ry} {
            set R [expr $Rx + $S($t,LabelMatrixBase)]
        } else  {
            set R [expr $Ry + $S($t,LabelMatrixBase)]
        }
        set a_ref [expr 6.28318530717958 / [llength $T($t,ue_cod)]]
        set n 0
        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
        # inversion ordre liste feuilles selon conformation
        if { $S($t,type) == "ClaCir2"} {
            set LLE {}
            foreach e $T($t,ue_cod) {
                set LLE [concat $e $LLE]
            }
            set n 1
        } else  {
            set LLE $T($t,ue_cod)
        }
        # leger decalage du a anchor/justify si l'annotation a un seul caractere
        # on ajoute a l'avant un espace
        foreach e $LLE {
            set a [expr double($n*$a_ref)]
            if  {[lsearch $leu $T($t,ctl,$e)] != -1} {
                set x [expr $R * cos($a)]
                set y [expr $R * sin($a)]
                # TAG
                set l $T($t,ctl,$e)
                # avoir un nombre pair de caractere pour bien centrer
                # sinon on ajoute devant un espace
                set lc [split $S(AnnotateNote) {}]
                set nbc [llength $lc]
                if  {[expr $nbc / 2 * 2] == $nbc} {
                    set s $S(AnnotateNote)
                } else  {
                    set s " $S(AnnotateNote)"
                }
                #-text $S(AnnotateNote)
                $w create text $x $y \
                        -text $s \
                        -anchor center  -justify center \
                        -fill $S(col) \
                        -font $S(gfo) \
                        -tags "ILLCo¶$l T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo"
            }
            incr n
        }
        # centrage sur arbre tags root "[format "%s%s" $t C] T$t Z"
        set co [$w coords [format "%s%s" $t C]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set xcenter [expr ($x1 + $x2) /2.0]
        set ycenter [expr ($y1 + $y2) /2.0]
        $w move $tagC $xcenter $ycenter
    }
    proc DrawANGo {} {
        global S ann T
        set lv {}
        set lindex [.ann.l.lfa.l curselection]
        foreach i $lindex {
            lappend lv [.ann.l.lfa.l get $i]
        }
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        DrawANGoGo $lv $ltreetarget
    }
    
    proc DrawANGoGo {lv ltreetarget} {
        global S ann T
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    
                    foreach var $lv {
                        set w $S($ti,w)
                        set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
                        set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
                        set XMAX3 [lindex [$w bbox [list T$ti && AnnotMatrix]] 2]
                        if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                        if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
                        if [catch {expr $S($ti,LabelMatrixBase) + $S(TabulationAnnot)} result] {
                            set S($ti,LabelMatrixBase) $S(TabulationAnnot)
                        } else  {
                            set S($ti,LabelMatrixBase) $result
                        }
                        set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                        # tag de colonne
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        foreach l $T($ti,ue_lab) {
                            #
                            # x  et y appliquent une translation en et y respectivement
                            # f est un facteur d'amplication de taille
                            set lcoordsCONTOUR {} ; set f 100.0
                            # recherche y
                            set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$ti]]
                            if {$item == ""} {
                                set items [$w find withtag [list ADD¶$l && T$ti]]
                                set y 0
                                foreach ii $items {
                                    set yii [lindex [$w coords $ii] 1]
                                    if {$yii >= $y} {
                                        set y $yii
                                    }
                                }
                            } else  {
                                set co [$w coords $item]
                                set y [lindex $co 1]
                            }
                            switch $ann(ann-fgfiguration) {
                                asleaf {set itemfgcolor [$w itemcget $item -fill]}
                                asuser {set itemfgcolor $S(col)}
                            }
                            switch $ann(ann-fofiguration) {
                                asleaf {set itemfont [$w itemcget $item -font]}
                                asuser {set itemfont $S(gfo)}
                            }
                            # construction de itemtext sur query
                            set record [Database::dbQueryRecordsFromVarVal $database EU $l]
                            set itemtext ""
                            if {$record == {}} {
                                set itemtext "-"
                            } else  {
                                foreach ri $record {
                                    foreach {vari val} $X($ri) {
                                        if {[string equal $var $vari] == 1}  {
                                            append itemtext " $val"
                                        }
                                    }
                                }
                            }
                            set ID [Tools::GenId]
                            # transformation coordonnees
                            foreach {xi yi} $itemtext {
                                set xx [expr $x + ($xi * $ann(DrawFactor))]
                                set yy [expr $y + ($yi * $ann(DrawFactor))]
                                append lcoordsCONTOUR $xx
                                append lcoordsCONTOUR " "
                                append lcoordsCONTOUR $yy
                                append lcoordsCONTOUR " "
                                if {$ann(DrawNode) == 1} {
                                    $w create rectangle [expr $xx -1] [expr $yy-1] [expr $xx+1] [expr $yy+1] -fill white -outline black \
                                            -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo Morpho MOR$ID"
                                }
                                
                            }
                            set iitteemm  [$w create polygon $lcoordsCONTOUR -fill white -outline black \
                                    -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo Morpho MOR$ID" ]
                            $w lower $iitteemm
                        }
                    }
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    # A FAIRE
                }
                ClaCir1 - ClaCir2 - ClaCir3 {
                    # A FAIRE
                }
            }
        }
    }
    proc DrawPlotANGo {} {
        global S ann T
        set lv {}
        set lindex [.ann.l.lfa.l curselection]
        foreach i $lindex {
            lappend lv [.ann.l.lfa.l get $i]
        }
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        DrawPlotANGoGo $lv $ltreetarget
    }
    proc DrawPlotANGoGo {lv ltreetarget} {
        global S ann T
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    
                    foreach var $lv {
                        set w $S($ti,w)
                        set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
                        set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
                        set XMAX3 [lindex [$w bbox [list T$ti && AnnotMatrix]] 2]
                        if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                        if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
                        if [catch {expr $S($ti,LabelMatrixBase) + $S(TabulationAnnot)} result] {
                            set S($ti,LabelMatrixBase) $S(TabulationAnnot)
                        } else  {
                            set S($ti,LabelMatrixBase) $result
                        }
                        set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                        # tag de colonne
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        foreach l $T($ti,ue_lab) {
                            #
                            # x  et y appliquent une translation en et y respectivement
                            # f est un facteur d'amplication de taille
                            set lcoordsCONTOUR {} ; set f 100.0
                            
                            
                            # recherche y
                            set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$ti]]
                            if {$item == ""} {
                                set items [$w find withtag [list ADD¶$l && T$ti]]
                                set y 0
                                foreach ii $items {
                                    set yii [lindex [$w coords $ii] 1]
                                    if {$yii >= $y} {
                                        set y $yii
                                    }
                                }
                            } else  {
                                set co [$w coords $item]
                                set y [lindex $co 1]
                            }
                            switch $ann(ann-fgfiguration) {
                                asleaf {set itemfgcolor [$w itemcget $item -fill]}
                                asuser {set itemfgcolor $S(col)}
                            }
                            switch $ann(ann-fofiguration) {
                                asleaf {set itemfont [$w itemcget $item -font]}
                                asuser {set itemfont $S(gfo)}
                            }
                            # construction de itemtext sur query
                            set record [Database::dbQueryRecordsFromVarVal $database EU $l]
                            set itemtext ""
                            if {$record == {}} {
                                set itemtext "-"
                            } else  {
                                foreach ri $record {
                                    foreach {vari val} $X($ri) {
                                        if {[string equal $var $vari] == 1}  {
                                            append itemtext " $val"
                                        }
                                    }
                                }
                            }
                            # transformation coordonnees
                            set ximax 0 ; set yimax 0
                            # recherche xmax ymax
                            foreach {xi yi} $itemtext {
                                if {$xi >= $ximax} {set ximax $xi}
                                if {$yi >= $yimax} {set yimax $yi}
                            }
                            set fx [expr $ann(DrawXsize) / $ximax]
                            set fy [expr $ann(DrawYsize) / $yimax]
                            switch $ann(XYmode) {
                                scatter {
                                    foreach {xi yi} $itemtext {
                                        set xx [expr $x + ($xi * $fx)]
                                        set yy [expr $y + ($yi * $fy)]
                                        $w create line $xx $yy [expr $xx +1] [expr $yy +1] -fill black \
                                                -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo"
                                    }
                                }
                                batons {
                                    foreach {xi yi} $itemtext {
                                        set xx [expr $x + ($xi * $fx)]
                                        set yy [expr $y + ($yi * $fy)]
                                        $w create line $xx [expr $y + $ann(DrawYsize) + 3] $xx [expr $yy +1] -fill black \
                                                -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo"
                                    }
                                }
                                curve {
                                    set ldot ""
                                    foreach {xi yi} $itemtext {
                                        set xx [expr $x + ($xi * $fx)]
                                        set yy [expr $y + ($yi * $fy)]
                                        $w create line $xx $yy [expr $xx +1] [expr $yy +1] -fill black \
                                                -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo"
                                        append ldot " $xx $yy"
                                    }
                                    $w create line $ldot -fill black \
                                            -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo"
                                }
                            }
                            
                            # voir si bbox
                            set iit [$w create rectangle \
                                    [expr $x - $ann(DrawXsize) - 3 ] [expr $y - $ann(DrawYsize) - 3] \
                                    [expr $x + $ann(DrawXsize) + 3] [expr $y + $ann(DrawYsize) + 3] -fill white -outline black \
                                    -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo" ]
                            $w lower $iit
                        }
                    }
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    # A FAIRE
                }
                ClaCir1 - ClaCir2 - ClaCir3 {
                    # A FAIRE
                }
            }
        }
    }
    #
    proc PlotNode {w x y} {
        global S T
        destroy $w.sbshape
        set m [menu $w.sbshape -tearoff 0  ]
        
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        
        if {$n != ""} {
            if {$S(database) == ""} {
                $m add command -label "Load Labels File" -command "Database::LoadTransitionFile"
            } else {
                $m add command -label "Load Labels File" -command "Database::LoadTransitionFile"
                $m add separator
                $m add command -label "Select a variable" -command ""
                set listevariables [Database::dbQueryVarAll $S(database)]
                foreach v $listevariables {
                    $m add command -label $v -command "Annotation::PlotNodeGo $w $t $n $S(database) $v $x $y"
                }
            }
        } else  {
            $m add command -label "Select a subtree" -command ""
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    #
    proc PlotNodeM {w x y} {
        global S T
        destroy $w.sbshape
        set m [menu $w.sbshape -tearoff 0  ]
        
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        
        if {$n != ""} {
            if {$S(database) == ""} {
                $m add command -label "Load Labels File" -command "Database::LoadTransitionFile"
            } else {
                $m add command -label "Load Labels File" -command "Database::LoadTransitionFile"
                $m add separator
                $m add command -label "Select a variable" -command ""
                set listevariables [Database::dbQueryVarAll $S(database)]
                foreach v $listevariables {
                    $m add command -label $v -command "Annotation::PlotNodeMGo $w $t $n $S(database) $v"
                }
            }
        } else  {
            $m add command -label "Select a subtree" -command ""
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    #
    proc PlotNodeMGo {w t n database variable} {
        set ln [Tools::NodeNoCoFaToNoCoCh $t $n]
        foreach ni $ln {
            if {$ni == $t} {
                set co [$w coords [format "%s%s" $n C]]
                set x [lindex $co 0]
                set y [expr ([lindex $co 3] - [lindex $co 1]) / 2.0]
            } else  {
                set co [$w coords $ni]
                set x [lindex $co 0]
                set y [lindex $co 1]
            }
            PlotNodeGo $w $t $ni $database $variable $x $y
        }
    }
    #
    proc PlotNodeGo {w t n database variable x y} {
        global S T ann B
        # liste feuilles sources
        set SouRefLea [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        
        # liste records correspondant aux feuilles sources
        set MatchingRecords {}
        foreach f $SouRefLea {
            set recordsOK [Database::dbQueryRecordsFromVarPatVal $database EU $f]
            foreach r $recordsOK {
                lappend MatchingRecords $r
            }
        }
        # liste valeurs pour $variable sur les matching records
        upvar #0 $database X
        set MatchingValues {}
        foreach r $MatchingRecords {
            set toc $X($r)
            if {!([set pos [lsearch $toc $variable]]%2)} {
                set val [lindex $toc [incr pos]]
                if {[lsearch -exact $MatchingValues $val] == -1} {lappend MatchingValues $val}
            }
        }
        # $MatchingValues est une liste de liste de coordonnees non ordonnee
        set nb [llength $MatchingValues] ;# on va calculer la moyenne
        foreach lc $MatchingValues  {
            set cindex 0
            foreach c $lc {
                incr cindex
                if [catch {expr $Somme($cindex) + $c} result] {
                    set Somme($cindex) $c
                } else  {
                    set Somme($cindex) $result
                }
            }
        }
        # passage array vers liste
        # probleme recuperer dans l'ordre
        set itemtext {}
        for {set i 1} {$i <= $cindex} {incr i 1} {
            append itemtext " [expr $Somme($i) / $nb]"
        }
        # transformation coordonnees
        set ID [Tools::GenId]
        
        
        # transformation coordonnees
        set ximax 0 ; set yimax 0
        # recherche xmax ymax
        foreach {xi yi} $itemtext {
            if {$xi >= $ximax} {set ximax $xi}
            if {$yi >= $yimax} {set yimax $yi}
        }
        set fx [expr $ann(DrawXsize) / $ximax]
        set fy [expr $ann(DrawYsize) / $yimax]
        switch $ann(XYmode) {
            scatter {
                foreach {xi yi} $itemtext {
                    set xx [expr $x + ($xi * $fx)]
                    set yy [expr $y + ($yi * $fy)]
                    $w create line $xx $yy [expr $xx +1] [expr $yy +1] -fill black \
                            -tags "T$t bullab BLL¶$ID AnnotMatrix AM$t AMatrixCo Plot Plot$ID"
                }
            }
            batons {
                foreach {xi yi} $itemtext {
                    set xx [expr $x + ($xi * $fx)]
                    set yy [expr $y + ($yi * $fy)]
                    $w create line $xx [expr $y + $ann(DrawYsize) + 3] $xx [expr $yy +1] -fill black \
                            -tags "T$t bullab BLL¶$ID AnnotMatrix AM$t AMatrixCo Plot Plot$ID"
                }
            }
            curve {
                set ldot ""
                foreach {xi yi} $itemtext {
                    set xx [expr $x + ($xi * $fx)]
                    set yy [expr $y + ($yi * $fy)]
                    $w create line $xx $yy [expr $xx +1] [expr $yy +1] -fill black \
                            -tags "T$t bullab BLL¶$ID AnnotMatrix AM$t AMatrixCo Plot Plot$ID"
                    append ldot " $xx $yy"
                }
                $w create line $ldot -fill black \
                        -tags "T$t AnnotMatrix AM$t MA¶$l $tagC AMatrixCo"
            }
        }
        
        set iit [$w create rectangle \
                [expr $x - $ann(DrawXsize) - 3] [expr $y - $ann(DrawYsize) - 3] \
                [expr $x + $ann(DrawXsize) + 3] [expr $y + $ann(DrawYsize) + 3] -fill white -outline black \
                -tags "T$t bullab BLL¶$ID AnnotMatrix AM$t AMatrixCo Plot Plot$ID" ]
        $w lower $iit
        BLLmake4 $w $t $x $y $ID $n
    }
    #
    proc SubtreeShape {w x y} {
        global S T
        destroy $w.sbshape
        set m [menu $w.sbshape -tearoff 0  ]
        
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        
        if {$n != ""} {
            if {$S(database) == ""} {
                $m add command -label "Load Labels File" -command "Database::LoadTransitionFile"
            } else {
                $m add command -label "Load Labels File" -command "Database::LoadTransitionFile"
                $m add separator
                $m add command -label "Select a variable" -command ""
                set listevariables [Database::dbQueryVarAll $S(database)]
                foreach v $listevariables {
                    $m add command -label $v -command "Annotation::SubtreeShapeGo $w $t $n $S(database) $v $x $y"
                }
            }
        } else  {
            $m add command -label "Select a subtree" -command ""
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    #
    proc SubtreeShapeM {w x y} {
        global S T
        destroy $w.sbshape
        set m [menu $w.sbshape -tearoff 0  ]
        
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        
        if {$n != ""} {
            if {$S(database) == ""} {
                $m add command -label "Load Labels File" -command "Database::LoadTransitionFile"
            } else {
                $m add command -label "Load Labels File" -command "Database::LoadTransitionFile"
                $m add separator
                $m add command -label "Select a variable" -command ""
                set listevariables [Database::dbQueryVarAll $S(database)]
                foreach v $listevariables {
                    $m add command -label $v -command "Annotation::SubtreeShapeMGo $w $t $n $S(database) $v"
                }
            }
        } else  {
            $m add command -label "Select a subtree" -command ""
        }
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    proc SubtreeShapeMGo {w t n database variable} {
        set ln [Tools::NodeNoCoFaToNoCoCh $t $n]
        foreach ni $ln {
            if {$ni == $t} {
                set co [$w coords [format "%s%s" $n C]]
                set x [lindex $co 0]
                set y [expr ([lindex $co 3] - [lindex $co 1]) / 2.0]
            } else  {
                set co [$w coords $ni]
                set x [lindex $co 0]
                set y [lindex $co 1]
            }
            SubtreeShapeGo $w $t $ni $database $variable $x $y
        }
    }
    #
    proc SubtreeShapeGo {w t n database variable x y} {
        global S T ann B
        # liste feuilles sources
        set SouRefLea [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        
        # liste records correspondant aux feuilles sources
        set MatchingRecords {}
        foreach f $SouRefLea {
            set recordsOK [Database::dbQueryRecordsFromVarPatVal $database EU $f]
            foreach r $recordsOK {
                lappend MatchingRecords $r
            }
        }
        # liste valeurs pour $variable sur les matching records
        upvar #0 $database X
        set MatchingValues {}
        foreach r $MatchingRecords {
            set toc $X($r)
            if {!([set pos [lsearch $toc $variable]]%2)} {
                set val [lindex $toc [incr pos]]
                if {[lsearch -exact $MatchingValues $val] == -1} {lappend MatchingValues $val}
            }
        }
        # $MatchingValues est une liste de liste de coordonnees non ordonnee
        set nb [llength $MatchingValues] ;# on va calculer la moyenne
        foreach lc $MatchingValues  {
            set cindex 0
            foreach c $lc {
                incr cindex
                if [catch {expr $Somme($cindex) + $c} result] {
                    set Somme($cindex) $c
                } else  {
                    set Somme($cindex) $result
                }
            }
        }
        # passage array vers liste
        # probleme recuperer dans l'ordre
        set itemtext {}
        for {set i 1} {$i <= $cindex} {incr i 1} {
            append itemtext " [expr $Somme($i) / $nb]"
        }
        # transformation coordonnees
        set ID [Tools::GenId]
        foreach {xi yi} $itemtext {
            set xx [expr $x + ($xi * $ann(DrawFactor))]
            set yy [expr $y + ($yi * $ann(DrawFactor))]
            append lcoordsCONTOUR $xx
            append lcoordsCONTOUR " "
            append lcoordsCONTOUR $yy
            append lcoordsCONTOUR " "
            if {$ann(DrawNode) == 1} {
                $w create rectangle [expr $xx -1] [expr $yy-1] [expr $xx+1] [expr $yy+1] -fill white -outline black \
                        -tags "T$t bullab BLL¶$ID AnnotMatrix AM$t AMatrixCo Morpho MOR$ID"
            }
        }
        if {$S(stipple) == "z.xbm"} {
            if {$ann(DrawFill) == 1} {
                set iitt [$w create polygon $lcoordsCONTOUR -outline black -fill $S(col) \
                        -tags "bullab BLL¶$ID T$t AnnotMatrix AM$t AMatrixCo Morpho MOR$ID"]
            } else  {
                set iitt [$w create polygon $lcoordsCONTOUR -outline black -fill white \
                        -tags "bullab BLL¶$ID T$t AnnotMatrix AM$t AMatrixCo Morpho MOR$ID"]
            }
        } else  {
            set iitt [$w create polygon $lcoordsCONTOUR -fill $S(col) -outline black \
                    -stipple @[file join  + stipple $S(stipple)]  \
                    -tags "bullab BLL¶$ID T$t AnnotMatrix AM$t AMatrixCo Morpho MOR$ID"]
        }
        $w lower $iitt
        BLLmake4 $w $t $x $y $ID $n
    }
    # nb anchor a remplacer par justify
    proc ANGoNew {} {
        global S ann T
        set lv {}
        set lib .annotation.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l
        set lindex [$lib curselection]
        foreach i $lindex {
            lappend lv [$lib get $i]
        }
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        ANGoGo $lv $ltreetarget
    }
    proc ANGo {} {
        global S ann T
        set lv {}
        set lindex [.ann.l.lfa.l curselection]
        foreach i $lindex {
            lappend lv [.ann.l.lfa.l get $i]
        }
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        ANGoGo $lv $ltreetarget
    }
    #
    proc ANGoLeaves {lv ltreetarget} {
        global S ann T
        switch $ann(ann-leavemod) {
            add {
                ANGoLeavesAdd $lv $ltreetarget
            }
            replace {
                ANGoLeavesReplace $lv $ltreetarget
            }
        }
    }
    # lv liste de variables
    proc ANGoGoNew {lv ltreetarget} {
        global S ann T
        switch $ann(ann-textmod) {
            add {
                ANGoLeavesAdd $lv $ltreetarget
                #
                
                set li .annotation.p.pane2.childsite.n.canvas.notebook.cs.page1.cs.s1.l
                #$li insert end "color $ann(ann-fgfiguration) asleaf
                #set ann(ann-fofiguration)
                foreach v $lv {
                    $li insert end  "AN LeavesAdd {$S(database) {$v}} {prefix \"$ann(ann-prefix)\" suffix \"$ann(ann-suffix)\" exposant \"$ann(ann-exposant)\"}"
                }
            }
            replace {
                ANGoLeavesReplace $lv $ltreetarget
                set li .annotation.p.pane2.childsite.n.canvas.notebook.cs.page1.cs.s1.l
                foreach v $lv {
                    $li insert end  "AN LeavesReplace {$S(database) {$v}} {prefix \"$ann(ann-prefix)\" suffix \"$ann(ann-suffix)\" exposant \"$ann(ann-exposant)\"}"
                }
            }
            addcolumns   {
                ANGoColumns $lv $ltreetarget
                set li .annotation.p.pane2.childsite.n.canvas.notebook.cs.page1.cs.s1.l
                foreach v $lv {
                    $li insert end  "AN LeavesAddColumns {$S(database) {$v}} {prefix \"$ann(ann-prefix)\" suffix \"$ann(ann-suffix)\" exposant \"$ann(ann-exposant)\"}"
                }
            }
        }
    }
    proc ANGoGo {lv ltreetarget} {
        global S ann T
        switch $ann(ann-position) {
            add {
                ANGoLeaves $lv $ltreetarget
            }
            justify   {
                ANGoColumns $lv $ltreetarget
            }
        }
    }
    # set S($t,type) ClaCir5 (circulaire interne)
    proc ANGoColumns {lv ltreetarget} {
        global S ann T
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    foreach var $lv {
                        set w $S($ti,w)
                        set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
                        set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
                        set XMAX3 [lindex [$w bbox [list T$ti && AnnotMatrix]] 2]
                        if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                        if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
                        if [catch {expr $S($ti,LabelMatrixBase) + 7} result] {
                            set S($ti,LabelMatrixBase) 7
                        } else  {
                            set S($ti,LabelMatrixBase) $result
                        }
                        set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                        #set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
                        #set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
                        #if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                        #set S($ti,LabelMatrixBase) [expr $S($ti,LabelMatrixBase) + $S(TabulationAnnot)]
                        #set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                        #
                        #
                        # tag de colonne
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        foreach l $T($ti,ue_lab) {
                            # recherche y
                            set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$ti]]
                            if {$item == ""} {
                                set items [$w find withtag [list ADD¶$l && T$ti]]
                                set y 0
                                foreach ii $items {
                                    set yii [lindex [$w coords $ii] 1]
                                    if {$yii >= $y} {
                                        set y $yii
                                    }
                                }
                            } else  {
                                set co [$w coords $item]
                                set y [lindex $co 1]
                            }
                            switch $ann(ann-fgfiguration) {
                                asleaf {set itemfgcolor [$w itemcget $item -fill]}
                                asuser {set itemfgcolor $S(col)}
                            }
                            switch $ann(ann-fofiguration) {
                                asleaf {set itemfont [$w itemcget $item -font]}
                                asuser {set itemfont $S(gfo)}
                            }
                            # construction de itemtext sur query
                            set record [Database::dbQueryRecordsFromVarVal $database EU $l]
                            set itemtext ""
                            if {$record == {}} {
                                set itemtext "-"
                            } else  {
                                foreach ri $record {
                                    foreach {vari val} $X($ri) {
                                        if {[string equal $var $vari] == 1}  {
                                            append itemtext " $val"
                                        }
                                    }
                                }
                            }
                            # coordonnees
                            set texto [format "%s%s%s" $ann(ann-prefix) $itemtext $ann(ann-suffix)]
                            $w create text $x [expr $y + $ann(ann-exposant)] \
                                    -text $texto \
                                    -fill $itemfgcolor \
                                    -font $itemfont \
                                    -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo" -anchor w
                        }
                    }
                    Navigation::FitToContents $w
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    # A FAIRE
                }
                ClaCir1 - ClaCir2 - ClaCir3 {
                    # A FAIRE
                }
            }
        }
    }
    
    # ATTENTION PB si leaf hidden
    proc ANGoLeavesAdd {lv ltreetarget} {
        global S ann T
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    foreach var $lv {
                        set w $S($ti,w)
                        # tag de colonne
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        foreach l $T($ti,ue_lab) {
                            set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$ti]]
                            set itemfgcolor [$w itemcget $item -fill]
                            set itemfont [$w itemcget $item -font]
                            set record [Database::dbQueryRecordsFromVarVal $database EU $l]
                            set itemtext ""
                            if {$record == {}} {
                                set itemtext "-"
                            } else  {
                                foreach ri $record {
                                    foreach {vari val} $X($ri) {
                                        if {[string equal $var $vari] == 1}  {
                                            append itemtext $val
                                        }
                                    }
                                }
                            }
                            foreach vi $itemtext {
                                set i [$w find withtag [list ADD¶$l && T$ti]]
                                if {$i == ""} {
                                    set i [$w find withtag [list [format "%s%s" EU  $l] && T$ti]]
                                    set co [$w coords $i]
                                    set y [lindex $co 1]
                                    set i2 [$w find withtag [list [format "%s%s" EUL  $l] && T$ti]]
                                    
                                    if {[$w itemcget $i2 -state] == "hidden"} {
                                        set x [lindex [$w bbox $i] 2]
                                    } else  {
                                        set x [lindex [$w bbox $i2] 2]
                                    }
                                } else  {
                                    set co [$w coords [lindex $i 0]]
                                    set y [lindex $co 1]
                                    set x 0
                                    foreach ii $i {
                                        set xii [lindex [$w bbox $ii] 2]
                                        if {$xii >= $x} {
                                            set x $xii
                                        }
                                    }
                                }
                                switch $ann(ann-fgfiguration) {
                                    asleaf {
                                        set item [$w find withtag [list [format "%s%s" EUL  $l] && T$ti]]
                                        set itemfgcolor [$w itemcget $item -fill]
                                    }
                                    asuser {set itemfgcolor $S(col)}
                                }
                                switch $ann(ann-fofiguration) {
                                    asleaf {
                                        set item [$w find withtag [list [format "%s%s" EUL  $l] && T$ti]]
                                        set itemfont [$w itemcget $item -font]
                                    }
                                    asuser {set itemfont $S(gfo)}
                                }
                                if {$x != "" && $y != ""} {
                                    set vi [string trimleft $vi " "]
                                    set texto [format "%s%s%s" $ann(ann-prefix) $vi $ann(ann-suffix)]
                                    $w create text $x [expr $y + $ann(ann-exposant)] -text "$texto" \
                                            -font $itemfont \
                                            -fill $itemfgcolor \
                                            -tags "ADD¶$l T$ti MA$l $tagC AnnotMatrix AM$ti" -anchor w
                                }
                            }
                        }
                    }
                    Navigation::FitToContents $w
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    # A FAIRE
                }
                ClaCir1 - ClaCir2 - ClaCir3 {
                    # A FAIRE
                }
            }
        }
    }
    #
    proc ANGoLeavesReplace {lv ltreetarget} {
        global S ann T
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    
                    foreach var $lv {
                        set w $S($ti,w)
                        # tag de colonne
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        
                        foreach l $T($ti,ue_lab) {
                            set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$ti]]
                            set itemfgcolor [$w itemcget $item -fill]
                            set itemfont [$w itemcget $item -font]
                            set record [Database::dbQueryRecordsFromVarVal $database EU $l]
                            set itemtext ""
                            if {$record == {}} {
                                set itemtext "-"
                            } else  {
                                foreach ri $record {
                                    foreach {vari val} $X($ri) {
                                        if {[string equal $var $vari] == 1}  {
                                            append itemtext $val
                                        }
                                    }
                                }
                            }
                            foreach vi $itemtext {
                                set i [$w find withtag [list ADD¶$l && T$ti]]
                                if {$i == ""} {
                                    set i [$w find withtag [list [format "%s%s" EUL  $l] && T$ti]]
                                    set co [$w coords $i]
                                    set y [lindex $co 1]
                                    set x [lindex [$w bbox $i] 0]
                                } else  {
                                    # cas si plusieurs ajout on recup le i de plus gran x
                                    set co [$w coords [lindex $i 0]]
                                    set y [lindex $co 1]
                                    set x 0
                                    foreach ii $i {
                                        set xii [lindex [$w bbox $ii] 2]
                                        if {$xii >= $x} {
                                            set x $xii
                                        }
                                    }
                                }
                                
                                switch $ann(ann-fgfiguration) {
                                    asleaf {
                                        set item [$w find withtag [list [format "%s%s" EUL  $l] && T$ti]]
                                        set itemfgcolor [$w itemcget $item -fill]
                                    }
                                    asuser {set itemfgcolor $S(col)}
                                }
                                switch $ann(ann-fofiguration) {
                                    asleaf {
                                        set item [$w find withtag [list [format "%s%s" EUL  $l] && T$ti]]
                                        set itemfont [$w itemcget $item -font]
                                    }
                                    asuser {set itemfont $S(gfo)}
                                }
                                set vi [string trimleft $vi " "]
                                $w itemconfigure $item -state hidden
                                set texto [format "%s%s%s" $ann(ann-prefix) $vi $ann(ann-suffix)]
                                $w create text $x [expr $y + $ann(ann-exposant)] -text "$texto" \
                                        -font $itemfont \
                                        -fill $itemfgcolor \
                                        -tags "ADD¶$l T$ti  MA$l $tagC AnnotMatrix AM$ti" -anchor w
                            }
                        }
                    }
                    Navigation::FitToContents $w
                }
                
                
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    # A FAIRE
                }
                ClaCir1 - ClaCir2 - ClaCir3 {
                    # A FAIRE
                }
            }
        }
    }
    ###
    proc CanvasTextSelect  {w x y} {
        global S
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        CanvasTextDone $w
        if {[$w type current] == "text"} {
            $w addtag "EdiText" withtag current
        } else {
            set ltags {EdiText TXT}
            foreach ti $S($w,t) {
                lappend ltags "T$ti"
            }
            $w create text $x $y -font $S(gfo) -fill $S(col)  -justify left -tags $ltags
        }
        focus $w
        $w focus "EdiText"
        $w icursor "EdiText" @$x,$y
    }
    ###
    proc CanvasTextEditAdd  {w s} {
        $w insert  "EdiText" insert $s
    }
    ###
    proc CanvasTextEnd  {w } {
        $w delete "EdiText"
    }
    ###
    proc CanvasTextEditBacksp  {w} {
        set pos [expr [$w index "EdiText" insert] -1]
        if {$pos >= 0} {
            $w dchars "EdiText" $pos
        }
    }
    ###
    proc CanvasTextDone  {w} {
        set msg [$w itemcget "EdiText" -text]
        if {[string length [string trim $msg]] == 0} {
            $w delete "EdiText"
        }
        $w dtag "EdiText"
        $w focus ""
    }
    ### A REVOIR
    proc Insert {what} {
        global S T
        set w [format "%s%s%s" .t $S(ict) .c]
        switch -exact $what {
            Scale {$w delete SCA
                set kv [array get T $S(ict),dbl,*]
                set max 0
                foreach {key value} $kv {
                    if {$value >= $max} {set max $value ; set keymax $key}
                }
                set code [string range $keymax [expr [string last "," $keymax] +1] end]
                set cood [$w coords $code]
                set leng [expr  [lrange $cood 0 0] - [lrange $cood 2 2]]
                set wgoal [expr [winfo width $w] / 10.0]
                set r [expr $wgoal / $leng]
                set dxfinal [expr $r * $max]
                set deci [string last . $dxfinal]
                set dxfinal [string range $dxfinal 0 [expr $deci +2] ]
                set lefinal [expr $r * $leng]
                set ori_x 20.0
                set ori_y 20.0
                $w create line $ori_x  $ori_y  \
                        $ori_x [expr $ori_y + 7.0] \
                        $ori_x [expr $ori_y + 3.0] \
                        [expr $ori_x + $lefinal] [expr $ori_y + 3.0] \
                        [expr $ori_x + $lefinal] [expr $ori_y + 7.0] \
                        [expr $ori_x + $lefinal] $ori_y \
                        -width 1 -fill blue -tags SCA
                $w create text [expr $ori_x + $lefinal / 2] [expr $ori_y + 10.0] \
                        -text  $dxfinal -font $T($S(ict),gfo) -fill blue -tags SCA -anchor center
                set S(und) "$w delete SCA"
            }
            Date {set s  [clock format [clock seconds] -format "%A %B %d %H:%M:%S %Z %Y"]
                $w create text  30 30 -text $s -font $S(gfo) -fill $T($S(ict),gfg) -tags "TXT"
            }
            File {set s  $T($S(ict),fil)
                $w create text 40 40 -text $s -font $S(gfo) -fill $T($S(ict),gfg) -tags "TXT"
            }
            Text {set s  $T($S(ict),fil)
                Interface::toolbar_select .treedyn.n.tab.notebook.page1.w.pt textinsert
                TBA::CanvasTextSelect $w 10 10
            }
        }
    }
    #
    proc AnnotateBuiltIn {w t x y what} {
        global S T
        switch -exact $what {
            Scale {
                #$w delete SCA
                set kv [array get T $t,dbl,*]
                # recherche d'une longueur de branche moyenne
                set dblB 0
                foreach {key value} $kv {
                    if {$value >= $dblB} {set dblB $value ; set keymax $key}
                }
                set dblA $dblB
                foreach {key value} $kv {
                    if {$value <= $dblA} {set dblA $value ; set keymin $key}
                }
                set dblmoy [expr ($dblB - $dblA) / 2]
                # longueur C du trait correspondant a la dblmoy
                set code [string range $keymax [expr [string last "," $keymax] +1] end]
                set cood [$w coords $code]
                set B [expr  [lrange $cood 0 0] - [lrange $cood 2 2]]
                set C [expr ($dblmoy * $B) / $dblB]
                #arrondir dblmoy
                set scientif [format "%e" $dblmoy]
                set exposant [string range $scientif [string first e $scientif] end]
                set prefixe [expr round([string range $scientif 0 [expr [string first e $scientif] -1]])]
                set dblmoyarrondi [format "%f" [format "%s%s" $prefixe $exposant]]
                #ajuster la longueur du trait moyen a l'arrondi
                set D [expr ($dblmoyarrondi * $C) / $dblmoy]
                # dessin
                set ori_x $x
                set ori_y $y
                set tagi [format "%s%s" TSCA [Tools::GenId]]
                $w create line $ori_x  $ori_y [expr $ori_x + $D] $ori_y \
                        -width 1 -fill $S(col) -tags "SCA T$t $tagi"
                $w create text [expr $ori_x + $D / 2] [expr $ori_y + 10.0] \
                        -text  [string trimright $dblmoyarrondi 0 ] -font $S(gfo) -fill $S(col) -tags "SCA T$t $tagi" -anchor center
                set S(und) "$w delete [list SCA && T$t]"
            }
            Scale100 {
                set co [$w bbox [list T$t && Z]]
                set x1 [lindex $co 0]
                set x2 [lindex $co 2]
                set dx [expr $x2 - $x1]
                set unit [expr $dx / 10.0]
                set tagi [format "%s%s" TSCA [Tools::GenId]]
                for {set i 0} {$i <= 10} {incr i 1} {
                    $w create line [expr $x + ($i * $unit)] [expr $y -3] \
                            [expr $x + ($i * $unit)] [expr $y +4] -width 1 -fill black -tags "SCA T$t $tagi"
                    set texto [format "%s%s" [expr 10 * $i] "%"]
                    $w create text [expr $x + ($i * $unit)] [expr $y -5] -text $texto \
                            -fill black -tags "SCA T$t $tagi" -anchor s -justify center
                }
                $w create line $x $y [expr $x + $dx] $y -width 1 -fill black -tags "SCA T$t $tagi"
            }
            Date {
                $w create text  $x $y -text [clock format [clock seconds] -format "%A %B %d %Y"] \
                        -font $S(gfo) -fill $S(col) -tags "TXT T$t"
            }
            File {
                #
                #[wm title [winfo parent $w]]
                $w create text $x $y -text $S($t,tit) -font $S(gfo) -fill $S(col) -tags "TXT T$t" -anchor w
            }
        }
    }
    ###
    proc DisplayDBL {w t} {
        global T S
        set li [$w find withtag [list T$t && DBL]]
        if {$li != ""} {
            $w delete [list T$t && DBL]
        } else  {
            $w delete [list T$t && DBL]
            set l [lrange $T($t,all_cod) 1 end]
            foreach i $l {
                if {[$w itemcget $i -state] != "hidden"} {
                    
                    set co [$w coords $i]
                    if {$co != ""} {
                        set x [lrange $co 2 2]
                        set y [lrange $co 1 1]
                        eval {$w create text} \
                                {$x $y} \
                                {-text $T($t,dbl,$i) -fill $S(col) \
                                    -font $S(gfo) -anchor nw -tags "T$t DBL"}
                    }
                }
            }
        }
    }
    ###
    proc DisplayDBLpercent {w t} {
        global T S
        # recherche plus grande longueur de branche
        set ls [lrange $T($t,all_cod) 1 end]
        set blmax 0
        foreach l $ls {
            if {$T($t,dbl,$l) > $blmax} {set blmax $T($t,dbl,$l)}
        }
        # facteur / 100
        set N [expr $blmax / 100.0]
        set li [$w find withtag [list T$t && DBL]]
        if {$li != ""} {
            $w delete [list T$t && DBL]
        } else  {
            $w delete [list T$t && DBL]
            set l [lrange $T($t,all_cod) 1 end]
            foreach i $l {
                if {[$w itemcget $i -state] != "hidden"} {
                    set co [$w coords $i]
                    if {$co != ""} {
                        set x [lrange $co 2 2]
                        set y [lrange $co 1 1]
                        set bl [format "%s%s" [expr round($T($t,dbl,$i) / $N)] %]
                        eval {$w create text} \
                                {$x $y} \
                                {-text $bl -fill $S(col) \
                                    -font $S(gfo) -anchor nw -tags "T$t DBL"}
                    }
                }
            }
        }
    }
    #
    proc NodeDBLp {w x y} {
        global S T
        set x [$w canvasx $x] ; set y [$w canvasy $y]
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            # recherche plus grande longueur de branche
            set ls [lrange $T($t,all_cod) 1 end]
            set blmax 0
            foreach l $ls {
                if {$T($t,dbl,$l) > $blmax} {set blmax $T($t,dbl,$l)}
            }
            # facteur / 100
            set N [expr $blmax / 100.0]
            set bl [format "%s%s" [expr round($T($t,dbl,$n) / $N)] %]
            $w create text $x $y -text $bl -fill $S(col) \
                    -font $S(gfo) -anchor nw -tags "T$t DBL"
        }
    }
    #
    proc NodeDBL {w x y} {
        global S T
        set x [$w canvasx $x] ; set y [$w canvasy $y]
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            $w create text $x $y -text $T($t,dbl,$n) -fill $S(col) \
                    -font $S(gfo) -anchor nw -tags "T$t DBL"
        }
    }
    #
    proc NodeDBV {w x y} {
        global S T
        set x [$w canvasx $x] ; set y [$w canvasy $y]
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if [catch {set test $T($t,dbv,$n)} res] {
                #nothing
            } else {
                $w create text $x $y -text $T($t,dbv,$n) -fill $S(col) \
                        -font $S(gfo) -anchor nw -tags "T$t DBL"
            }
        }
    }
    #
    proc NodeDBVp {w x y} {
        global S T
        set x [$w canvasx $x] ; set y [$w canvasy $y]
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if [catch {set test $T($t,dbv,$n)} res] {
                #nothing
            } else {
                set lall [lrange $T($t,all_cod) 1 end]
                # on retire les codes des ue
                set l [Tools::SousL $lall $T($t,ue_cod)]
                # recherche plus grande valeur bootstrap
                set bvmax 0
                foreach i $l {
                    if {$T($t,dbv,$i) > $bvmax} {set bvmax $T($t,dbv,$i)}
                }
                # facteur / 100
                set N [expr $bvmax / 100.0]
                if {$T($t,dbv,$n) != ""} {
                    set txt  [format "%s%s" [expr round($T($t,dbv,$n) / $N)] %]
                    $w create text $x $y -text $txt -fill $S(col) \
                            -font $S(gfo) -anchor nw -tags "T$t DBL"
                }
            }
        }
    }
    ###
    proc DisplayDBV {w t} {
        global T S
        set x [$w canvasx $x] ; set y [$w canvasy $y]
        set li [$w find withtag [list T$t && DBV]]
        if {$li != ""} {
            $w delete [list T$t && DBV]
        } else  {
            set lall [lrange $T($t,all_cod) 1 end]
            # on retire les codes des ue
            set l [Tools::SousL $lall $T($t,ue_cod)]
            $w delete [list T$t && DBV]
            foreach i $l {
                if {[$w itemcget $i -state] != "hidden"} {
                    set co [$w coords $i]
                    if {$co != ""} {
                        set x [lrange $co 0 0]
                        set y [lrange $co 1 1]
                        if {$T($t,dbv,$i) != ""} {
                            set txt $T($t,dbv,$i)
                            eval {$w create text} \
                                    {$x $y} \
                                    {-text $txt -fill $S(col) \
                                        -font $S(gfo) -anchor nw -tags "T$t DBV"}
                        }
                    }
                }
            }
        }
    }
    ###
    proc DisplayDBVseuil {w t} {
        global T S
        destroy .dbvseuil
        set wi [toplevel .dbvseuil]
        wm geometry $wi "+[winfo pointerx $w]+[winfo pointery $w]"
        wm title .dbvseuil DBV
        iwidgets::entryfield $wi.ns  -width 4   \
                -textvariable S(dbvseuil) -labeltext "Bootstrap Treshlod: " -labelpos w -fixed 30
        frame $wi.controls
        button $wi.controls.ok -text Annotate -command "Annotation::DisplayDBVseuilGO $w $t"
        button $wi.controls.quit -text Exit  -command "destroy .dbvseuil"
        pack $wi.controls.ok $wi.controls.quit -expand yes -fill x
        pack  $wi.ns $wi.controls -expand yes -fill x
    }
    proc DisplayDBVseuilGO {w t} {
        global T S
        $w delete [list T$t && DBV]
        set lall [lrange $T($t,all_cod) 1 end]
        set l [Tools::SousL $lall $T($t,ue_cod)]
        foreach i $l {
            if {[$w itemcget $i -state] != "hidden"} {
                set co [$w coords $i]
                if {$co != ""} {
                    set x [lrange $co 0 0]
                    set y [lrange $co 1 1]
                    if {$T($t,dbv,$i) != "" && $T($t,dbv,$i) >= $S(dbvseuil) } {
                        set txt $T($t,dbv,$i)
                        eval {$w create text} \
                                {$x $y} \
                                {-text $txt -fill $S(col) \
                                    -font $S(gfo) -anchor nw -tags "T$t DBV"}
                    }
                }
            }
        }
    }
    ###
    proc DisplayDBLseuil {w t} {
        global T S
        destroy .dblseuil
        set wi [toplevel .dblseuil]
        wm title .dblseuil DBL
        wm geometry $wi "+[winfo pointerx $w]+[winfo pointery $w]"
        iwidgets::entryfield $wi.ns -width 4 -textvariable S(dblseuil) \
                -labeltext "Branch Length Treshold: " -labelpos w  -fixed 30
        frame $wi.controls
        button $wi.controls.ok -text Annotate -command "Annotation::DisplayDBLseuilGO $w $t"
        button $wi.controls.quit -text Exit -command "destroy .dblseuil"
        pack $wi.controls.ok $wi.controls.quit -expand yes -fill x
        pack $wi.ns $wi.controls -expand yes -fill x
    }
    proc DisplayDBLseuilGO {w t} {
        global T S
        $w delete [list T$t && DBL]
        set l [lrange $T($t,all_cod) 1 end]
        foreach i $l {
            if {[$w itemcget $i -state] != "hidden"} {
                set co [$w coords $i]
                if {$co != ""} {
                    set x [lrange $co 2 2]
                    set y [lrange $co 1 1]
                    if {$T($t,dbl,$i) != "" && $T($t,dbl,$i) >= $S(dblseuil) } {
                        eval {$w create text} \
                                {$x $y} \
                                {-text $T($t,dbl,$i) -fill $S(col) \
                                    -font $S(gfo) -anchor nw -tags "T$t DBL"}
                    }
                }
            }
        }
        
    }
    ###
    proc DisplayDBVpercent {w t} {
        global T S
        $w delete [list T$t && DBV]
        set lall [lrange $T($t,all_cod) 1 end]
        # on retire les codes des ue
        set l [Tools::SousL $lall $T($t,ue_cod)]
        # recherche plus grande valeur bootstrap
        set bvmax 0
        foreach i $l {
            if {$T($t,dbv,$i) > $bvmax} {set bvmax $T($t,dbv,$i)}
        }
        # facteur / 100
        set N [expr $bvmax / 100.0]
        $w delete [list T$t && DBV]
        foreach i $l {
            if {[$w itemcget $i -state] != "hidden"} {
                set co [$w coords $i]
                if {$co != ""} {
                    set x [lrange $co 0 0]
                    set y [lrange $co 1 1]
                    if {$T($t,dbv,$i) != ""} {
                        set txt  [format "%s%s" [expr round($T($t,dbv,$i) / $N)] %]
                        eval {$w create text} \
                                {$x $y} \
                                {-text $txt -fill $S(col) \
                                    -font $S(gfo) -anchor nw -tags "T$t DBV"}
                    }
                    
                }
            }
        }
        
    }
    #
    proc LabelMatrix  {w t EUS tagquery} {
        global S
        set tagquery [format "%s%s%s" MA ¶ $tagquery]
        set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
        set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
        if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
        if [catch {expr $S($t,LabelMatrixBase) + $S(TabulationAnnot)} result] {
            set S($t,LabelMatrixBase) $S(TabulationAnnot)
        } else  {
            set S($t,LabelMatrixBase) $result
        }
        set x [expr $XMAX + $S($t,LabelMatrixBase)]
        foreach eu $EUS {
            set i  [$w find withtag [list T$t && EUL$eu]]
            if {$i != ""} {
                set co [$w coords $i]
                set y [lindex $co 1]
                $w create text $x $y -text + -fill $S(col) -tags "T$t $tagquery AnnotMatrix ML¶$eu"
            }
        }
        $w bind AnnotMatrix <Any-Enter> "after 500 Annotation::AnyEnterAM %W %x %y"
        $w bind AnnotMatrix <Any-Leave> "after 500 Annotation::AnyLeaveAM %W"
    }
    #
    proc  AnyEnterAM {w x y} {
        set tags [$w gettags current]
        set color [$w itemcget current -fill]
        set maq  [lindex $tags [lsearch -glob $tags MA*]]
        set maf  [lindex $tags [lsearch -glob $tags ML*]]
        set q [lindex [split $maq ¶] end]
        set ql [lindex [split $maf ¶] end]
        $w create text  [expr  $x + 15] $y -text [format "%s%s%s" $ql : $q] \
                -anchor w -tag AMi -fill $color
    }
    proc  AnyLeaveAM {w} {
        $w delete AMi
    }
    #
    proc BLLmake {w t x y titre text n} {
        global B S
        # attention  1n:nBLL
        set id [format "%s%s" $t [Tools::GenId]]
        set idtext [format "%s%s%s" BLL ¶ $id]
        set idlink [format "%s%s%s" LIN ¶ $id]
        #BLL
        set txt $text
        set txtfinal $txt
        $w create text [$w canvasx [expr $x + 30 ] ] [$w canvasy [expr $y + 30 ]]  \
                -text $txtfinal -font $S(gfo) -fill $S(col) -anchor nw \
                -tags "bullab T$t $idtext"
        # LIN [expr $x + 30 ] [expr $y + 30 ]
        $w create line  [$w canvasx $x] [$w canvasy $y] [$w canvasx [expr $x + 30 ] ] [$w canvasy [expr $y + 30 ]]  \
                -width 1 -fill $S(col) -tags "Link T$t $idlink"
        # MEM
        set B(BLLtre,$id) $t
        set B(BLLnod,$id) $n
        set B(BLLtxt,$id) $txtfinal
        set B(BLLidt,$id) $idtext
        set B(BLLidl,$id) $idlink
        set B(BLLcol,$id) $S(col)
        set B(BLLgfo,$id) $S(gfo)
        set B(BLLxxx,$id) [expr $x + 30 ]
        set B(BLLyyy,$id) [expr $y + 30 ]
        # Liste des BLL par tree
        lappend B($t,bll) $id
    }
    # idem que BLLmake mais ne cree pas les items graphiques
    # utilise dans les copy/paste et restauration
    # 2 arguments suple la couleur et la fonte
    proc BLLmake2 {w t x y titre text n col gfo} {
        global B S
        # attention  1n:nBLL
        set id [format "%s%s" $t [Tools::GenId]]
        set idtext [format "%s%s%s" BLL ¶ $id]
        set idlink [format "%s%s%s" LIN ¶ $id]
        #BLL
        set txt $text
        #set txtfinal [format "%s%s%s" $titre \n $txt]
        set txtfinal $txt
        # MEM
        set B(BLLtre,$id) $t
        set B(BLLnod,$id) $n
        set B(BLLtxt,$id) $txtfinal
        set B(BLLidt,$id) $idtext
        set B(BLLidl,$id) $idlink
        set B(BLLcol,$id) $col
        set B(BLLgfo,$id) $gfo
        set B(BLLxxx,$id) [expr $x + 30 ]
        set B(BLLyyy,$id) [expr $y + 30 ]
        # Liste des BLL par tree
        lappend B($t,bll) $id
    }
    # comme BLLmake mais ici on utilise les fontes pour illustration
    proc BLLmake3 {w t x y text n} {
        global B S
        # attention  1n:nBLL
        set id [format "%s%s" $t [Tools::GenId]]
        set idtext [format "%s%s%s" BLL ¶ $id]
        set idlink [format "%s%s%s" LIN ¶ $id]
        #BLL
        set txt $text
        set txtfinal $txt
        Illustration::drawsymbol  $w [$w canvasx [expr $x + 30 ] ] [$w canvasy [expr $y + 30 ]] \
                [list bullab T$t $idtext]
        
        
        #$w create text [$w canvasx [expr $x + 30 ] ] [$w canvasy [expr $y + 30 ]]  \
        #        -text $txtfinal -font $S(ill-fon) -fill $S(col) -anchor nw \
        #        -tags "bullab T$t $idtext"
        
        $w create line  [$w canvasx $x] [$w canvasy $y] [$w canvasx [expr $x + 30 ] ] [$w canvasy [expr $y + 30 ]]  \
                -width 1 -fill $S(col) -tags "Link T$t $idlink"
        # MEM
        set B(BLLtre,$id) $t
        set B(BLLnod,$id) $n
        set B(BLLtxt,$id) $txtfinal
        set B(BLLidt,$id) $idtext
        set B(BLLidl,$id) $idlink
        set B(BLLcol,$id) $S(col)
        set B(BLLgfo,$id) $S(ill-fon)
        set B(BLLxxx,$id) [expr $x + 30 ]
        set B(BLLyyy,$id) [expr $y + 30 ]
        # Liste des BLL par tree
        lappend B($t,bll) $id
    }
    ###
    # comme BLLmake mais ici une forme complexe type polygon
    # id est un tag unique partage par tous les items composant la structure
    proc BLLmake4 {w t x y id n} {
        global B S
        # attention  1n:nBLL
        # set id [format "%s%s" $t [Tools::GenId]]
        # set idtext [format "%s%s%s" BLL ¶ $id]
        set idlink [format "%s%s%s" LIN ¶ $id]
        $w create line  [$w canvasx $x] [$w canvasy $y] [$w canvasx [expr $x + 30 ] ] [$w canvasy [expr $y + 30 ]]  \
                -width 1 -fill $S(col) -tags "Link T$t $idlink"
        # MEM
        set B(BLLtre,$id) $t
        set B(BLLnod,$id) $n
        set B(BLLtxt,$id) -
        set B(BLLidt,$id) MOR$id
        set B(BLLidl,$id) $idlink
        set B(BLLcol,$id) $S(col)
        set B(BLLgfo,$id) $S(ill-fon)
        set B(BLLxxx,$id) [expr $x + 30 ]
        set B(BLLyyy,$id) [expr $y + 30 ]
        # Liste des BLL par tree
        lappend B($t,bll) $id
    }
    ###
    proc BLLDelete {w i} {
        global B
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BLL*]] ¶] end]
        $w delete [format "%s%s%s" BLL ¶ $id]
        $w delete [format "%s%s%s" LIN ¶ $id]
        set t $B(BLLtre,$id)
        foreach key [array names B *,$id] {
            unset B($key)
        }
        #retirer
        set index [lsearch -exact $B($t,bll) $id]
        set B($t,bll) [concat [lrange $B($t,bll) 0 [expr $index - 1]] \
                [lrange $B($t,bll) [expr $index + 1] end]]
    }
    ###
    proc BLLDelete2 {w id} {
        global B
        $w delete [format "%s%s%s" BLL ¶ $id]
        $w delete [format "%s%s%s" LIN ¶ $id]
        set t $B(BLLtre,$id)
        foreach key [array names B *,$id] {
            unset B($key)
        }
        #retirer
        set index [lsearch -exact $B($t,bll) $id]
        set B($t,bll) [concat [lrange $B($t,bll) 0 [expr $index - 1]] \
                [lrange $B($t,bll) [expr $index + 1] end]]
    }
    ###
    proc BLLUpdateColor {w i} {
        global B S
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BLL*]] ¶] end]
        $w itemconfigure [format "%s%s%s" BLL ¶ $id] -fill $S(col)
        $w itemconfigure [format "%s%s%s" LIN ¶ $id] -fill $S(col)
        set B(BLLcol,$id) $S(col)
    }
    ###
    proc BLLUpdateFont {w i} {
        global B S
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BLL*]] ¶] end]
        $w itemconfigure [format "%s%s%s" BLL ¶ $id]  -font $S(gfo)
        set B(BLLgfo,$id) $S(gfo)
    }
    ###
    proc BLLmove {w x y i} {
        global B S
        $w move $S(mov) [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags BLL*]] ¶] end]
        if {$B(BLLnod,$id) == $B(BLLtre,$id)} {
            set co_sou [$w coords [format "%s%s" $B(BLLnod,$id) C]]
            set x1 [lindex $co_sou 0]
            set y1 [expr ([lindex $co_sou 3] - [lindex $co_sou 1]) / 2.0]
        } else  {
            set co_sou [$w coords $B(BLLnod,$id)]
            set x1 [lindex $co_sou 0]
            set y1 [lindex $co_sou 1]
        }
        set co_tar [$w coords $i]
        set x2 [lindex $co_tar 0]
        set y2 [lindex $co_tar 1]
        # il peu y avoir des tags suplementaires a la liste "Link T$B(BLLtre,$id) $idlink"
        # en particulier le tag lie aux decompositions
        set tagslink [$w gettags $B(BLLidl,$id)]
        $w delete $B(BLLidl,$id)
        $w create line $x1 $y1 $x2 $y2 \
                -width 1 -fill $B(BLLcol,$id) -tags $tagslink
        set B(BLLxxx,$id) $x
        set B(BLLyyy,$id) $y
    }
    # QUERYNODE
    proc QueryNode {w t eu} {
        global S T B
        set id [format "%s%s" $t [Tools::GenId]]
        set idtext [format "%s%s%s" QYN ¶ $id]
        set co [$w bbox [list Z && T$t]]
        $w create text [lindex $co 0] [lindex $co 1]  -text $S(query)  \
                -fill $S(col) -font $S(gfo) -tags "querynode T$t $idtext" -anchor nw
        $w raise Q$t
        # restriction de result aux EU appartenant au tree target
        set leu {}
        foreach e $eu {
            if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend leu $e}
        }
        set B(QYNres,$id) $leu
        set B(QYNqry,$id) $S(query)
        set B(QYNtre,$id) $t
        set B(QYNidt,$id) $idtext
        set B(QYNcol,$id) $S(col)
        set B(QYNgfo,$id) $S(gfo)
        set B(QYNxxx,$id) 0
        set B(QYNyyy,$id) 0
        lappend B($t,qyn) $id
    }
    ### NB : pas de QueryNodeLink sur les nodes, trop de recouvrements
    proc QueryNodeLinkLeaf {id leu} {
        global B S T
        # set tags [$w gettags $i]
        # set id [lindex [split [lindex $tags [lsearch -glob $tags QYN*]] ¶] end]
        set w $S($B(QYNtre,$id),w)
        set co_sou  [$w coords [format "%s%s%s" QYN ¶ $id]]
        set x1 [lindex $co_sou 0]
        set y1 [lindex $co_sou 1]
        foreach eu $leu {
            set i2 [$w find withtag [list [format "%s%s" EU $eu] && T$B(QYNtre,$id)]]
            set co_tar  [$w coords $i2]
            set x2 [lindex $co_tar 0]
            set y2 [lindex $co_tar 1]
            set idlink [format "%s%s%s" LIN ¶ $id]
            QueryNodeLink $w $x1 $y1 $x2 $y2 $B(QYNcol,$id) "Link $idlink  T$B(QYNtre,$id)"
        }
    }
    proc QueryNodeUnLinkLeaf {id leu} {
        global B S
        set w $S($B(QYNtre,$id),w)
        set idlink [format "%s%s%s" LIN ¶ $id]
        $w delete $idlink
    }
    ###
    proc QueryNodeLink {w x1 y1 x2 y2 c tags} {
        $w create line $x1 $y1 $x2 $y2 -width 1 -fill $c -tags $tags
    }
    ###
    proc QueryNodeUpdateColor {w id} {
        global B S
        $w itemconfigure [format "%s%s%s" QYN ¶ $id] -fill $S(col)
        $w itemconfigure [format "%s%s%s" LIN ¶ $id] -fill $S(col)
        set B(QYNcol,$id) $S(col)
    }
    ###
    proc QueryNodeUpdateFont {w id} {
        global B S
        $w itemconfigure [format "%s%s%s" QYN ¶ $id] -font $S(gfo)
        set B(QYNgfo,$id) $S(gfo)
    }
    
    ### OK
    proc QueryNodeLocalisation {id} {
        global B S T
        set t $B(QYNtre,$id)
        set w $S($t,w)
        # restriction aux eus du tree target,
        # voir aussi si prise en compte des eus sous shrink
        set EUS {}
        foreach e $B(QYNres,$id) {
            if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend EUS $e}
        }
        Operation::Operation  $w $t $EUS
    }
    ###
    proc QueryNodeMove {w x y i} {
        global S T B
        $w move $S(mov) [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
        set tags [$w gettags $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags QYN*]] ¶] end]
        # delete et redraw des link
        if {[$w find withtag [format "%s%s%s" LIN ¶ $id]] != {} } {
            $w delete [format "%s%s%s" LIN ¶ $id]
            set co_sou  [$w coords $i]
            set x1 [lindex $co_sou 0]
            set y1 [lindex $co_sou 1]
            foreach eu $B(QYNres,$id) {
                set i2 [$w find withtag [list [format "%s%s" EU $eu] && T$B(QYNtre,$id)]]
                set co_tar  [$w coords $i2]
                set x2 [lindex $co_tar 0]
                set y2 [lindex $co_tar 1]
                set idlink [format "%s%s%s" LIN ¶ $id]
                QueryNodeLink $w $x1 $y1 $x2 $y2 $B(QYNcol,$id) "Link $idlink  T$B(QYNtre,$id)"
            }
        }
        set B(QYNxxx,$id) $x
        set B(QYNyyy,$id) $y
    }
    ###
    proc QueryNodeDelete {w id} {
        global B
        $w delete [format "%s%s%s" QYN ¶ $id]
        $w delete [format "%s%s%s" LIN ¶ $id]
        set t $B(QYNtre,$id)
        
        foreach key [array names B *,$id] {
            unset B($key)
        }
        #retirer
        set index [lsearch -exact $B($t,qyn) $id]
        set B($t,bll) [concat [lrange $B($t,qyn) 0 [expr $index - 1]] \
                [lrange $B($t,qyn) [expr $index + 1] end]]
    }
    ###
    proc InsertTextNode {w x y} {
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            InsertTextNodeMake $w $t $x $y $n
        }
    }
    ###
    proc InsertTextNodeMake {w t x y n} {
        global S
        #       set x [$w canvasx $x]
        #       set y [$w canvasy $y]
        set text $S(AnnotateNote)
        Annotation::BLLmake $w $t $x $y "Note :" $text $n
        $w configure -scrollregion [$w bbox all]
    }
    #
    proc InsertSymbolNode {w x y} {
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            InsertSymbolNodeMake $w $t $x $y $n
        }
    }
    ###
    proc InsertSymbolNodeMake {w t x y n} {
        global S
        #        set x [$w canvasx $x]
        #        set y [$w canvasy $y]
        set text $S(ill-car)
        Annotation::BLLmake3 $w $t $x $y $text $n
        $w configure -scrollregion [$w bbox all]
    }
    ###
    # s est soit tab- soit tab+
    # cette fonction permet d'incrementer (+) // decrementer (-)
    # la variable de tabulation pour les arbres en target
    # manuellement (afin de tab entre 2 series de requetes)
    proc AnnCTabulation {s} {
        global S T
        # A-list window/tree des arbres en target d'une session treedyn
        foreach {w t} [Selection::TreeTar] {
            switch -exact $s  {
                tab+ {
                    if [catch {expr $S($t,LabelMatrixBase) + $S(TabulationAnnot)} result] {
                        set S($t,LabelMatrixBase) $S(TabulationAnnot)
                    } else  {
                        set S($t,LabelMatrixBase) $result
                    }
                }
                tab- {
                    if [catch {expr $S($t,LabelMatrixBase) - $S(TabulationAnnot)} result] {
                        # rien
                    } else  {
                        set S($t,LabelMatrixBase) $result
                    }
                }
            }
        }
    }
    
    
    
}
################################################################################


################################################################################
# ABSTRACTION
################################################################################
namespace eval Abstraction {
    
    proc SubdivisionPanel {} {
        global S
        set w [toplevel .sb ]
        wm title .sb "Subdivision"
        wm geometry .sb "+10+120"
        wm protocol .sb WM_DELETE_WINDOW {}
        iwidgets::tabnotebook .sb.n  -width 400 -height 300 -equaltabs 0 -tabpos n
        set S(BIcol) 1 ; set S(BIrow) 1 ; set S(BIfile) ? ; set S(BItotalL) ? ; set S(BItotalN) ?
        ###
        set op0c [.sb.n add -label "Subdivision" -image IMGbigimport ]
        # labeledframe subdivision
        iwidgets::Labeledframe $op0c.in -labelpos nw -labeltext "Subdivision"
        set p [$op0c.in childsite]
        # selection d'un fichier
        button $p.b0 -text Open... -command PROTO::BIopenUser
        # label fichier courant
        label  $p.lab0 -bd 1 -textvariable S(BIfile)
        
        # seuil
        iwidgets::entryfield $p.e  -width 8 -textvariable S(BIseuil) -labeltext "Treshold:"
        # processus de subdivision du fichier courant sachant seuil
        button $p.b1 -text Extract -command PROTO::BIimport
        # label nombre total de feuilles
        label  $p.lab1 -bd 1 -textvariable S(BItotalL)
        # label nombre de sous-arbres trouves
        label  $p.lab2 -bd 1 -textvariable S(BItotalN)
        iwidgets::spinint  $p.co -labeltext "Col(s): " -range { 1 1 } -width 3 \
                -textvariable S(BIcol) -command PROTO::BIswitchRowtoCol \
                -decrement PROTO::BIswitchRowtoCol+ -increment PROTO::BIswitchRowtoCol-
        iwidgets::spinint  $p.ro -labeltext "Row(s): " -range { 1 1 } -width 3 \
                -textvariable S(BIrow) -command PROTO::BIswitchColtoRow \
                -decrement PROTO::BIswitchColtoRow+ -increment PROTO::BIswitchColtoRow-
        button $p.b2 -text Save... -command PROTO::BImatrixCanvas
        # chargement d'une decomposition
        button $p.b3 -text Load... -command PROTO::BIopenUser
        button $p.b4 -text Display... -command PROTO::BImatrixCanvas
        #
        pack $p.b0 $p.lab0 $p.e $p.b1 $p.lab1 $p.lab2 \
                $p.co $p.ro $p.ro $p.b2 $p.b3 $p.b4 -fill x -expand yes
        pack $op0c.in -fill x -expand yes -anchor nw
        pack .sb.n -expand yes -fill both
        .sb.n view "Subdivision"
    }
    # Collapse cumulatif de la selection user
    proc CollapseToolbox {w} {
        global B T
        set item [$w find withtag current]
        set tags [$w gettags $item]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set TarCodLea [Tools::NodeNoToLe $t $n]
            set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
            # ON AJOUTE
            foreach i $TarRefLea {lappend T($t,eu_collapse) $i}
            set finalleaves [Tools::SousL $T($t,ue_lab) $T($t,eu_collapse)]
            # on envoie les feuilles qu'on garde
            NewickAbstract  $w $t $finalleaves
        }
    }
    # UnCollapse cumulatif de la selection user
    proc CollapseUnToolbox {w} {
        global B T
        set item [$w find withtag current]
        set tags [$w gettags $item]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set TarCodLea [Tools::NodeNoToLe $t $n]
            set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
            # ON SOUSTRAIT
            set T($t,eu_collapse) [Tools::SousL $T($t,eu_collapse) $TarRefLea]
            set finalleaves [Tools::SousL $T($t,ue_lab) $T($t,eu_collapse)]
            # on envoie les feuilles qu'on garde
            NewickAbstract  $w $t $finalleaves
        }
    }
    # Collapse cumulatif de la selection user
    proc Collapse {w t TarRefLea} {
        global B T
        # ON AJOUTE
        foreach i $TarRefLea {lappend T($t,eu_collapse) $i}
        set finalleaves [Tools::SousL $T($t,ue_lab) $T($t,eu_collapse)]
        # on envoie les feuilles qu'on garde
        NewickAbstract  $w $t $finalleaves
    }
    # UnCollapse cumulatif de la selection user
    proc CollapseUn {w t TarRefLea} {
        global B T
        # ON SOUSTRAIT
        set T($t,eu_collapse) [Tools::SousL $T($t,eu_collapse) $TarRefLea]
        set finalleaves [Tools::SousL $T($t,ue_lab) $T($t,eu_collapse)]
        # on envoie les feuilles qu'on garde
        NewickAbstract  $w $t $finalleaves
    }
    ###
    proc ShrinkToolbox {w} {
        global B
        set item [$w find withtag current]
        set tags [$w gettags $item]
        if {[lsearch -exact $tags SHRINK] == -1} {
            set n [string trimright \
                    [lindex $tags [lsearch -glob $tags *C]] C]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$n != ""} {Shrink $w $t $n}
        } else  {
            set id [lindex [split [lindex $tags [lsearch -glob $tags SHN*]] ¶] end]
            set t $B(SHItre,$id)
            if {$id != ""} {ShrinkUn $w $t $id}
        }
    }
    ###
    proc Shrink3Toolbox {w} {
        global B
        set item [$w find withtag current]
        set tags [$w gettags $item]
        if {[lsearch -exact $tags SHRINK] == -1} {
            set n [string trimright \
                    [lindex $tags [lsearch -glob $tags *C]] C]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$n != ""} {
                set test 0
                foreach {k v} [array get B SHInod*] {
                    if {$v == $n} {set test 1}
                }
                if {$test != 1 } {Shrink3 $w $t $n} else  {
                    set id [lindex [split [lindex $tags [lsearch -glob $tags SHN*]] ¶] end]
                    if {$id != ""} {set t $B(SHItre,$id) ; ShrinkUn $w $t $id}
                }
            }
        } else  {
            set id [lindex [split [lindex $tags [lsearch -glob $tags SHN*]] ¶] end]
            if {$id != ""} {set t $B(SHItre,$id) ; ShrinkUn $w $t $id}
        }
    }
    ###
    proc Shrink3 {w t n} {
        global S T B IMGshn
        set id [format "%s%s" $t [Tools::GenId]]
        set TAG [format "%s%s%s" SHI ¶ $id]
        #set c0 [$w bbox $n]
        set c0 [$w coords $n]
        set x0 [lindex $c0 0]
        set y0 [lindex $c0 1]
        set x1 [lindex $c0 2]
        set y1 [lindex $c0 3]
        set leafs [Tools::NodeNoToLe $t $n]
        if {[llength $leafs] > 1} {
            set lxy [Figuration::NodeColorBgSubTreeContourTriangle $w $t $n]
            $w create polygon $lxy  -stipple @[file join  + stipple $S(stipple)]   \
                    -fill $S(col) -outline $S(col) -tags "SHRINK [format "%s%s%s" SHN ¶ $id] T$t"
            $w lower [format "%s%s%s" SHN ¶ $id]
            # BLL
            set pattern [format "%s%s" $n *]
            foreach idbll $B($t,bll) {
                if {[string match $pattern $B(BLLnod,$idbll)] == 1 } {
                    if {[$w itemcget $B(BLLidt,$idbll) -state] != "hidden"} {
                        $w addtag $TAG withtag $B(BLLidt,$idbll)
                        $w addtag $TAG withtag $B(BLLidl,$idbll)
                        $w itemconfigure $B(BLLidt,$idbll) -state hidden
                        $w itemconfigure $B(BLLidl,$idbll) -state hidden
                    }
                }
            }
            # leaves
            set leafs [Tools::NodeNoToLe $t $n]
            foreach i $leafs {
                set tagi [list [format "%s%s" EUL  $T($t,ctl,$i)] && T$t]
                if {[$w itemcget $tagi -state] != "hidden"} {
                    $w addtag  $TAG withtag $tagi
                    $w itemconfigure $tagi -state hidden
                }
            }
            # background leaves
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,bgl)  {
                if  {[string match $pattern $B(BGLnod,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGL ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" BGL ¶ $idi]
                        $w itemconfigure [format "%s%s%s" BGL ¶ $idi] -state hidden
                    }
                }
            }
            # arretes terminales
            set Le [Tools::NodeNoToLe $t $n]
            foreach e $Le {
                if {[$w itemcget $e -state] != "hidden"} {
                    $w addtag $TAG withtag $e
                    $w itemconfigure $e -state hidden
                }
            }
            # tree
            set lchild [Tools::NodeNoCoFaToNoCoCh2 $t $n]
            foreach i $lchild {
                if {[$w itemcget $i -state] != "hidden"} {
                    $w addtag $TAG withtag [format "%s%s" $i C]
                    $w itemconfigure [format "%s%s" $i C] -state hidden
                }
            }
            # $w itemconfigure $n -fill $S(col)
            set iverticale [$w find withtag [format "%s%s%s%s" $n C ^ $n]]
            $w addtag $TAG withtag $iverticale
            $w itemconfigure $iverticale -state hidden
            # ova (en fait que le link)
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,ova)  {
                if  {[string match $pattern $B(OVAnod1,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGS ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s"  link ¶ $idi ]
                        $w itemconfigure [format "%s%s%s"  link ¶ $idi ] -state hidden
                    }
                }
            }
            # background tree
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,bgs)  {
                if  {[string match $pattern $B(BGSnod,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGS ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" BGS ¶ $idi]
                        $w itemconfigure [format "%s%s%s" BGS ¶ $idi] -state hidden
                        
                    }
                }
            }
            # sous shrink
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,shi)  {
                if  {[string match $pattern $B(SHInod,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" SHN ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" SHN ¶ $idi]
                        $w itemconfigure [format "%s%s%s" SHN ¶ $idi] -state hidden
                        set B(SHIsta,$idi) hidden
                    }
                }
            }
            ### mem
            # lappend B($t,shi) $id
            lappend B($t,shi) $id
            set B(SHInod,$id) $n
            set B(SHItre,$id) $t
            set B(SHIcol,$id) $S(col)
            set B(SHIsta,$id) normal
            set B(SHIsti,$id) $S(stipple)
            set B(SHItyp,$id) 3
            set B(SHIsymdx,$id) -
            set B(SHIsymdy,$id) -
            set B(SHIsymty,$id) -
            # UNDO
            set S(und) "Abstraction::ShrinkUn $w $t $id"
            return $id
        }
    }
    ###
    proc Shrink4Toolbox {w} {
        global B
        set item [$w find withtag current]
        set tags [$w gettags $item]
        if {[lsearch -exact $tags SHRINK] == -1} {
            set n [string trimright \
                    [lindex $tags [lsearch -glob $tags *C]] C]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            
            if {$n != ""} {
                # attention si pointage arrete porteuse d'un node shrink4
                set test 0
                foreach {k v} [array get B SHInod*] {
                    if {$v == $n} {set test 1}
                }
                if {$test != 1 } {Shrink4 $w $t $n} else  {
                    set id [lindex [split [lindex $tags [lsearch -glob $tags SHN*]] ¶] end]
                    if {$id != ""} {set t $B(SHItre,$id) ; ShrinkUn $w $t $id}
                }
            }
        } else  {
            set id [lindex [split [lindex $tags [lsearch -glob $tags SHN*]] ¶] end]
            if {$id != ""} {set t $B(SHItre,$id) ; ShrinkUn $w $t $id}
        }
    }
    ###
    proc Shrink4 {w t n} {
        global S T B IMGshn
        set id [format "%s%s" $t [Tools::GenId]]
        set TAG [format "%s%s%s" SHI ¶ $id]
        set c0 [$w coords $n]
        set x0 [lindex $c0 0]
        set y0 [lindex $c0 1]
        set x1 [lindex $c0 2]
        set y1 [lindex $c0 3]
        set leafs [Tools::NodeNoToLe $t $n]
        if {[llength $leafs] > 1} {
            # tous les sous-shrink de type shrink ou shrink3 doivent passer en shrink4
            # retrace du contour
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,shi)  {
                if  {[string match $pattern $B(SHInod,$idi)] == 1 } {
                    if {$B(SHInod,$idi) != 4} {
                        $w delete [format "%s%s%s" SHN ¶ $idi]
                        set B(SHItyp,$idi) 4
                        set lxy [Figuration::NodeColorBgSubTreeContour $w $t $B(SHInod,$idi)]
                        set c0i [$w coords $B(SHInod,$idi)]
                        set x0i [lindex $c0i 0]
                        set y0i [lindex $c0i 1]
                        $w create polygon "$x0i $y0i $lxy $x0i $y0i"  -stipple @[file join  + stipple $B(SHIsti,$idi)]   \
                                -fill $B(SHIcol,$idi) -outline $B(SHIcol,$idi) -tags "SHRINK [format "%s%s%s" SHN ¶ $idi] T$t" \
                                -smooth 1 -splinesteps 100
                        $w lower [format "%s%s%s" SHN ¶ $idi]
                    }
                }
            }
            # shrink 4 n
            set lxy [Figuration::NodeColorBgSubTreeContour $w $t $n]
            $w create polygon "$x0 $y0 $lxy $x0 $y0"  -stipple @[file join  + stipple $S(stipple)]   \
                    -fill $S(col) -outline $S(col) -tags "SHRINK [format "%s%s%s" SHN ¶ $id] T$t" \
                    -smooth 1 -splinesteps 100
            $w lower [format "%s%s%s" SHN ¶ $id]
            # BLL
            set pattern [format "%s%s" $n *]
            foreach idbll $B($t,bll) {
                if {[string match $pattern $B(BLLnod,$idbll)] == 1 } {
                    if {[$w itemcget $B(BLLidt,$idbll) -state] != "hidden"} {
                        $w addtag $TAG withtag $B(BLLidt,$idbll)
                        $w addtag $TAG withtag $B(BLLidl,$idbll)
                        $w itemconfigure $B(BLLidt,$idbll) -state hidden
                        $w itemconfigure $B(BLLidl,$idbll) -state hidden
                    }
                }
            }
            # leaves
            set leafs [Tools::NodeNoToLe $t $n]
            foreach i $leafs {
                set tagi [list [format "%s%s" EUL  $T($t,ctl,$i)] && T$t]
                if {[$w itemcget $tagi -state] != "hidden"} {
                    $w addtag  $TAG withtag $tagi
                    $w itemconfigure $tagi -state hidden
                }
            }
            # background leaves
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,bgl)  {
                if  {[string match $pattern $B(BGLnod,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGL ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" BGL ¶ $idi]
                        $w itemconfigure [format "%s%s%s" BGL ¶ $idi] -state hidden
                    }
                }
            }
            # arretes terminales
            set Le [Tools::NodeNoToLe $t $n]
            foreach e $Le {
                if {[$w itemcget $e -state] != "hidden"} {
                    $w addtag $TAG withtag $e
                    $w itemconfigure $e -state hidden
                }
            }
            # tree
            set lchild [Tools::NodeNoCoFaToNoCoCh2 $t $n]
            foreach i $lchild {
                if {[$w itemcget $i -state] != "hidden"} {
                    $w addtag $TAG withtag [format "%s%s" $i C]
                    $w itemconfigure [format "%s%s" $i C] -state hidden
                }
            }
            ### $w itemconfigure $n -fill $S(col)
            set iverticale [$w find withtag [format "%s%s%s%s" $n C ^ $n]]
            $w addtag $TAG withtag $iverticale
            $w itemconfigure $iverticale -state hidden
            # ova (en fait que le link)
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,ova)  {
                if  {[string match $pattern $B(OVAnod1,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGS ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s"  link ¶ $idi ]
                        $w itemconfigure [format "%s%s%s"  link ¶ $idi ] -state hidden
                    }
                }
            }
            # background tree
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,bgs)  {
                if  {[string match $pattern $B(BGSnod,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGS ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" BGS ¶ $idi]
                        $w itemconfigure [format "%s%s%s" BGS ¶ $idi] -state hidden
                        
                    }
                }
            }
            ### mem & text a afficher en D3
            lappend B($t,shi) $id
            set B(SHInod,$id) $n
            set B(SHItre,$id) $t
            set B(SHIcol,$id) $S(col)
            set B(SHIsta,$id) normal
            set B(SHIsti,$id) $S(stipple)
            set B(SHItyp,$id) 4
            set B(SHIsymdx,$id) -
            set B(SHIsymdy,$id) -
            set B(SHIsymty,$id) -
            # UNDO
            set S(und) "Abstraction::ShrinkUn $w $t $id"
            return $id
        }
    }
    ###
    proc Shrink {w t n {txt user}} {
        global T S B IMGshn
        set id [format "%s%s" $t [Tools::GenId]]
        # le tag commun a tous les items qui vont passer en mode hidden
        set TAG [format "%s%s%s" SHI ¶ $id]
        if {[lsearch -exact $B($t,shi) $id] == -1} {
            # dessin
            set c0 [$w coords $n]
            set x0 [lindex $c0 2]
            set y0 [lindex $c0 3]
            Illustration::drawsymbol $w [expr $x0 +$S(symboldx)] $y0 "SHRINK [format "%s%s%s" SHN ¶ $id]  T$t"   
            # BLL
            set pattern [format "%s%s" $n *]
            foreach idbll $B($t,bll) {
                if {[string match $pattern $B(BLLnod,$idbll)] == 1 } {
                    if {[$w itemcget $B(BLLidt,$idbll) -state] != "hidden"} {
                        $w addtag $TAG withtag $B(BLLidt,$idbll)
                        $w addtag $TAG withtag $B(BLLidl,$idbll)
                        $w itemconfigure $B(BLLidt,$idbll) -state hidden
                        $w itemconfigure $B(BLLidl,$idbll) -state hidden
                    }
                }
            }
            # leaves
            set leafs [Tools::NodeNoToLe $t $n]
            foreach i $leafs {
                set tagi [list [format "%s%s" EUL  $T($t,ctl,$i)] && T$t]
                if {[$w itemcget $tagi -state] != "hidden"} {
                    $w addtag  $TAG withtag $tagi
                    $w itemconfigure $tagi -state hidden
                }
            }
            # background leaves
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,bgl)  {
                if  {[string match $pattern $B(BGLnod,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGL ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" BGL ¶ $idi]
                        $w itemconfigure [format "%s%s%s" BGL ¶ $idi] -state hidden
                    }
                }
            }
            # arretes terminales
            set Le [Tools::NodeNoToLe $t $n]
            foreach e $Le {
                if {[$w itemcget $e -state] != "hidden"} {
                    $w addtag $TAG withtag $e
                    $w itemconfigure $e -state hidden
                }
            }
            # tree
            set lchild [Tools::NodeNoCoFaToNoCoCh $t $n]
            foreach i $lchild {
                if {[$w itemcget $i -state] != "hidden"} {
                    $w addtag $TAG withtag [format "%s%s" $i C]
                    $w itemconfigure [format "%s%s" $i C] -state hidden
                }
            }
            # ova (en fait que le link)
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,ova)  {
                if  {[string match $pattern $B(OVAnod1,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGS ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s"  link ¶ $idi ]
                        $w itemconfigure [format "%s%s%s"  link ¶ $idi ] -state hidden
                        
                    }
                }
            }
            # background tree
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,bgs)  {
                if  {[string match $pattern $B(BGSnod,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" BGS ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" BGS ¶ $idi]
                        $w itemconfigure [format "%s%s%s" BGS ¶ $idi] -state hidden
                        
                    }
                }
            }
            # sous shrink
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,shi)  {
                if  {[string match $pattern $B(SHInod,$idi)] == 1 } {
                    if {[$w itemcget [format "%s%s%s" SHN ¶ $idi] -state] != "hidden"} {
                        $w addtag $TAG withtag  [format "%s%s%s" SHN ¶ $idi]
                        $w itemconfigure [format "%s%s%s" SHN ¶ $idi] -state hidden
                        set B(SHIsta,$idi) hidden
                    }
                }
            }
            ### mem & text a afficher en D3
            lappend B($t,shi) $id
            set B(SHInod,$id) $n
            set B(SHItre,$id) $t
            set B(SHIcol,$id) $S(col)
            set B(SHIsta,$id) normal
            set B(SHIsti,$id) $S(stipple)
            set B(SHItyp,$id) 0
            # le type 0 3 features sup
            set B(SHIsymdx,$id) $S(symboldx)
            set B(SHIsymdy,$id) $S(symboldy)
            set B(SHIsymty,$id) $S(symboltype)
            # UNDO
            set S(und) "Abstraction::ShrinkUn $w $t $id"
            return $id
        }
    }
    ### comme shrink mais array seuleument col argument en plus
    proc Shrink2 {w t n col stipple type symdx symdy symty} {
        global T S B IMGshn
        set id [format "%s%s" $t [Tools::GenId]]
        lappend B($t,shi) $id
        set B(SHInod,$id) $n
        set B(SHItre,$id) $t
        set B(SHIcol,$id) $col
        set B(SHIsti,$id) $stipple
        set B(SHIsta,$id) normal
        set B(SHItyp,$id) $type
        set B(SHIsymdx,$id) $symdx
        set B(SHIsymdy,$id) $symdy
        set B(SHIsymty,$id) $symty
    }
    ###
    proc ShrinkUn {w t id} {
        global B S
        if {[lsearch -exact $B($t,shi) $id] != -1} {
            set p [format "%s%s%s" SHI ¶ $id]
            set litems [$w find withtag $p]
            foreach j $litems {
                $w itemconfigure $j -state normal
                $w dtag $j $p
            }
            $w delete [format "%s%s%s" SHN ¶ $id]
            # UNDO
            set S(und) "Abstraction::Shrink $w $t $B(SHInod,$id)"
            #mise a jour array B
            set index [lsearch -exact $B($t,shi) $id]
            set B($t,shi) [concat [lrange $B($t,shi) 0 [expr $index - 1]] \
                    [lrange $B($t,shi) [expr $index + 1] end]]
            unset B(SHInod,$id)
            unset B(SHItre,$id)
            unset B(SHIcol,$id)
            unset B(SHIsta,$id)
            unset B(SHIsti,$id)
            unset B(SHItyp,$id)
            unset B(SHIsymdx,$id)
            unset B(SHIsymdy,$id)
            unset B(SHIsymty,$id)
        }
    }
    proc ShrinkUnAll {w t} {
        global B
        foreach id $B($t,shi) {
            ShrinkUn $w $t $id
        }
    }
    # unshrink sachant une liste de node
    proc ShrinkUnLN {w t ln} {
        global B
        set lnshi {}
        foreach id $B($t,shi) {
            lappend lnshi $B(SHInod,$id)
            set transit($B(SHInod,$id)) $id
        }
        foreach n $ln {
            if {[lsearch $lnshi $n] != -1} {
                ShrinkUn $w $t $transit($n)
            }
        }
        if [array exists transit] {unset transit}
    }
    ###
    proc ShrinkNodeUpdateColor {w i} {
        global B S
        set tags [$w gettags $i]
        $w itemconfigure $i -fill $S(col)
        set type   [$w type $i]
        if {$type == "polygon"} {
            $w itemconfigure $i -outline $S(col)
        }
        set id [lindex [split [lindex $tags [lsearch -glob $tags SHN*]] ¶] end]
        set B(SHIcol,$id) $S(col)
    }
    ###
    proc ShrinkNodeUpdateStipple {w i} {
        global B S
        set tags [$w gettags $i]
        $w itemconfigure $i -stipple @[file join  + stipple $S(stipple)]
        set type   [$w type $i]
        set id [lindex [split [lindex $tags [lsearch -glob $tags SHN*]] ¶] end]
        set B(SHIsti,$id) $S(stipple)
    }
    #
    proc leafShrinkToolbox {w} {
        set tags [$w gettags current]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set TarCodLea [Tools::NodeNoToLe $t $n]
            set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
            Abstraction::LeafShrink $w $t $TarRefLea
        }
    }
    #
    proc leafShrinkUnToolbox {w} {
        set tags [$w gettags current]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            set TarCodLea [Tools::NodeNoToLe $t $n]
            set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
            Abstraction::LeafUnShrink $w $t $TarRefLea
        }
    }
    #
    proc LeafShrink {w t leu} {
        global T S B
        # leaves
        foreach i $leu {
            set tagi [list [format "%s%s" EUL  $i] && T$t]
            $w itemconfigure $tagi -state hidden
        }
        # background leaves
        set ln [Operation::FindFatherNode $t $leu]
        foreach n $ln {
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,bgl)  {
                if  {[string match $pattern $B(BGLnod,$idi)] == 1 } {
                    $w itemconfigure [format "%s%s%s" BGL ¶ $idi] -state hidden
                }
            }
        }
    }
    #
    proc LeafUnShrink {w t leu} {
        global T S B
        # leaves
        foreach i $leu {
            set tagi [list [format "%s%s" EUL  $i] && T$t]
            $w itemconfigure $tagi -state normal
        }
        # background leaves
        set ln [Operation::FindFatherNode $t $leu]
        foreach n $ln {
            set pattern [format "%s%s" $n *]
            foreach idi $B($t,bgl)  {
                if  {[string match $pattern $B(BGLnod,$idi)] == 1 } {
                    $w itemconfigure [format "%s%s%s" BGL ¶ $idi] -state normal
                }
            }
        }
    }
    ### SHRINK OPEN/CLOSE NEXT LEVEL
    proc NodeOpen {{w ?}} {
        global S T
        if {$w == "?"} {set w [format "%s%s%s" .t $S(ict) .c]}
        set t [string range $w 2 [expr [string first .c $w] -1]]
        if {$T($t,currentlevel) ==  "?"} {
            set level $T($t,tot)
        } elseif {$T($t,currentlevel) ==  $T($t,tot) } {
            set level $T($t,tot)
        } else {set level $T($t,currentlevel)}
        if {$level !=  $T($t,tot)} {
            set T($t,currentlevel) [expr $level + 1]
            foreach i $T($t,cbg,$level) {
                set bg [format "%s%s" $i g]
                set bd [format "%s%s" $i d]
                foreach n [list $bg $bd] {
                    if {$S(DebugMod) == 1} {
                        puts "LEVEL: $level // NODES $T($t,cbg,$level)"
                        puts "NODE: $n"
                    }
                    set Le [TRE::NoToLe $t $n]
                    set T($t,lsk) [TRE::SousL $T($t,lsk) $Le]
                    set T($t,nsk) [TRE::SousL $T($t,nsk) $n]
                    $w delete Z
                }
            }
        }
        TRE::ArrayToCanvasRedisplay $t
    }
    #
    proc NodeClose {{w ?}} {
        global T S
        if {$w == "?"} {set w [format "%s%s%s" .t $S(ict) .c]}
        set t [string range $w 2 [expr [string first .c $w] -1]]
        if {$T($t,currentlevel) ==  "?"} {
            set level [expr $T($t,tot) - 1]
        } elseif {$T($t,currentlevel) ==  0 } {
            set level 0
        } else {set level [expr $T($t,currentlevel) - 1]}
        
        if {$T($t,currentlevel) !=  0} {
            set T($t,currentlevel) $level
            foreach i $T($t,cbg,$level) {
                set bg [format "%s%s" $i g]
                set bd [format "%s%s" $i d]
                foreach n [list $bg $bd] {
                    set tagshrink [format "%s%s" $i S]
                    set tags [$w gettags [$w find withtag $n]]
                    set c0 [$w coords $n]
                    if {$S(DebugMod) == 1} {
                        puts "LEVEL: $level // NODES $T($t,cbg,$level)"
                        puts "NODE: $n // TAGS: $tags"
                    }
                    set x0 [lindex $c0 2]
                    set y0 [lindex $c0 1]
                    set Le [TRE::NoToLe $t $n]
                    set T($t,lsk) [concat $T($t,lsk) $Le]
                    set T($t,nsk) [concat $T($t,nsk) $n]
                    foreach e $Le {$w delete $e}
                    set lchild [TRE::NoCoFaToNoCoCh $t $n]
                    foreach i $lchild {
                        $w delete [format "%s%s" $i C]
                        $w delete [format "%s%s" $i R] ;# Box
                    }
                    $w create oval [expr $x0 +2] $y0  [expr $x0 +5] [expr $y0 +3] \
                            -outline $T($t,gfg)  -fill $T($t,gbg) \
                            -tags "$tags L LH Z $tagshrink $Le SHRINK"
                }
            }
        }
    }
    ### Simplification sur la base d'une valeur seuil de bootstrap
    proc NodeOpenClose {{w ?} mode} {
        global T S
        if {$w == "?"} {set w [format "%s%s%s" .t $S(ict) .c]}
        set t [string range $w 2 [expr [string first .c $w] -1]]
        set l {}
        foreach n $T($t,all_cod) {
            if {$n != 0 && [lsearch  $T($t,ue_cod) $n] == -1} {
                if {$T($t,dbv,$n) != "?" && $T($t,dbv,$n)  != "" && $T($t,dbv,$n) <= $S(lim)} {
                    lappend l $n
                }
            }
        }
        set lsup [TRE::FaNoId {} $l]
        # CLOSE
        if {$mode == "c"} {
            foreach i $lsup {
                set n $i
                set tagshrink [format "%s%s" $i S]
                set tags [$w gettags [$w find withtag $n]]
                set c0 [$w coords $n]
                if {$c0 != ""} {
                    set x0 [lindex $c0 2]
                    set y0 [lindex $c0 1]
                    set Le [TRE::NoToLe $t $n]
                    set T($t,lsk) [concat $T($t,lsk) $Le]
                    set T($t,nsk) [concat $T($t,nsk) $n]
                    foreach e $Le {$w delete $e}
                    set lchild [TRE::NoCoFaToNoCoCh $t $n]
                    foreach i $lchild {
                        $w delete [format "%s%s" $i C]
                        $w delete [format "%s%s" $i R] ;# Box
                    }
                    $w create oval [expr $x0 +2] $y0  [expr $x0 +5] [expr $y0 +3] \
                            -outline $T($t,gfg)  -fill $T($t,gbg) \
                            -tags "$tags L LH Z $tagshrink $Le SHRINK"
                }
            }
        }
        # OPEN
        if {$mode == "o"} {
            foreach i $lsup {
                set Le [TRE::NoToLe $t $i]
                set T($t,lsk) [TRE::SousL $T($t,lsk) $Le]
                set T($t,nsk) [TRE::SousL $T($t,nsk) $i]
                $w delete Z
            }
        }
        TRE::ArrayToCanvasRedisplay $t
    }
    #### Abstraction / MARC TAUZIN
    # lab1 est la liste des feuilles que l'on veut voir
    proc NewickParsermarc2A {s t code n sx} {
        global A lab1
        if {[string match *,* $s]} {
            if {[ImportExport::Dicho $s] == 1} {
                set s [format "%s%s%s" ( $s ):0]
            }
            set tp [string last ")" $s]
            set dt [string range $s 0 $tp]
            set dx [string range $s [expr $tp + 1] end]
            if {[string compare [string range $dt 0 0] ( ] != 0 || \
                        [string compare [string range $dt end end] ) ] != 0} {
                set dt [format "%s%s%s" ( $dt )]
            }
            set id [ImportExport::BgBdx $dt]
            set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
            set bd [string range $dt 1 [expr $id - 1]]
            if {$n == 0 } {
                set repg [NewickParsermarc2A $bg $t [format "%s%s" $code g] [expr $n +1]\
                        [expr $sx + [string range $dx [expr [string last ":" $dx] + 1] end]]]
                set repd [NewickParsermarc2A $bd $t [format "%s%s" $code d] [expr $n +1]\
                        [expr $sx + [string range $dx [expr [string last ":" $dx] + 1] end]]]
            } else  {
                set repg [ NewickParsermarc2A $bg $t [format "%s%s%s" $code $n g] [expr $n +1]\
                        [expr $sx + [string range $dx [expr [string last ":" $dx] + 1] end]]]
                set repd [ NewickParsermarc2A $bd $t [format "%s%s%s" $code $n d] [expr $n +1]\
                        [expr $sx + [string range $dx [expr [string last ":" $dx] + 1] end]]]
            }
            if {[expr $repg + $repd]>0} {
                lappend A($t,cbg,$n) [format "%s%s" $code $n]
                lappend A($t,all_cod) $code
                set A($t,nwk,$code) $s
                set A($t,dbl,$code) [string range $dx [expr [string last ":" $dx] + 1] end]
                return 1
            } else  {
                return 0
            }
        } {
            set tp [string last ":" $s]
            set dt [string range $s 0 [expr $tp - 1]]
            set dx [string range $s [expr $tp + 1] end]
            if {[lsearch -exact $lab1 $dt] != -1} {
                lappend A($t,all_cod) $code
                set A($t,nwk,$code) $s
                set A($t,dbl,$code) [string range $dx [expr [string last ":" $dx] + 1] end]
                set A($t,ctl,$code) $dt
                set A($t,ltc,$dt) $code
                lappend A($t,ue_cod) $code
                lappend A($t,ue_lab) $dt
                set sx [expr $sx + $dx]
                set A($t,sox,$code) $sx
                if { $sx >= $A($t,xmax)} {set A($t,xmax) $sx}
                if {$n >= $A($t,tot)} {set A($t,tot) $n}
                return 1
            } else  {
                return 0
            }
        }
    }
    # d est la chaine newick de l'arbre complet
    # leu est la liste des feuilles que l'on veut voir
    proc NewickAbstract {w t eus} {
        global T S lab1 A
        set lab1 $eus
        set d [format "%s%s" $T($t,nwk,$t) :0]
        set A($t,xmax) 0        ;# branch length max
        set A($t,tot) 0         ;# level max
        set A($t,all_cod) {}    ;# codes nodes
        set A($t,ue_cod) {}     ;# UE - codes LISTE ORDONNEE
        set A($t,ue_lab) {}     ;# UE - labels LISTE ORDONNEE
        NewickParsermarc2A $d $t $t 0 0
        set co [$w bbox [list Z && T$t]]
        set px [ expr [lindex $co 0] +2]
        set py [lindex $co 1]
        # pb si collapse sur une seule feuille
        set wi   [expr [lindex $co 2] - [lindex $co 0] -3]
        set he   [expr [lindex $co 3] - [lindex $co 1] -2]
        $w delete T$t
        PhyNJAbstractA $t $w $px $py $wi $he
        unset A
        Figuration::RestaureT $w $t
    }
    ###
    proc PhyNJAbstractA {t w px py {largeur 200} {hauteur 200}} {
        global A S
        set y 0
        set nb [llength $A($t,ue_cod)]
        set fy [expr double($hauteur.0  / $nb) ]
        set fx [expr double($largeur.0 / $A($t,xmax))]
        set n 0
        set t3 [format "%s%s" T $t ]
        ### EU
        foreach i $A($t,ue_cod) {
            incr n
            set y [expr $n * $fy ]
            set G($i,x) [expr ($A($t,sox,$i) - $A($t,dbl,$i) )* $fx]
            set G($i,y) $y
            set t2 [format "%s%s" EU $A($t,ctl,$i) ]
            set t4 [format "%s%s" EUL $A($t,ctl,$i) ]
            set t2bis [format "%s%s" $i C]
            $w create line [expr $A($t,sox,$i) * $fx] $G($i,y) $G($i,x) $G($i,y)  \
                    -tags "$i $t2 $t3 $t2bis Z"
            $w create text [expr ($A($t,sox,$i) * $fx) + 2]  $G($i,y) \
                    -text  $A($t,ctl,$i) -anchor w   \
                    -tags " $t3 $t4 L" \
                    -font $S(fontbase) -state $S($t,display_eu)
        }
        ### NODES
        for {set i [expr $A($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            foreach b $A($t,cbg,$i) {
                set bg [format "%s%s" $b g]
                set bd [format "%s%s" $b d]
                #??????
                set j [string range $bg 0 [expr [string last $i $bg] - 1]]
                set t2 [format "%s%s" $j C]
                #marc1
                set bgy [format "%s%s" $bg ",y"]
                set bdy [format "%s%s" $bd ",y"]
                if {[array names G $bgy] == $bgy} {
                    if {[array names G $bdy] == $bdy} {
                        # nodes avec partie droite et gauche
                        set yn [expr $G($bgy) - (($G($bgy) - $G($bdy)) / 2)]
                        # Vertical
                        $w create line $G($bg,x) $G($bg,y) $G($bg,x) $G($bd,y) -tags "$t2 $t3 Z"
                        # Horizontal
                        set G($j,x) [expr $G($bg,x) - ($A($t,dbl,$j) * $fx)]
                        $w create line $G($bg,x) $yn $G($j,x) $yn  -tags "$j $t2 $t3 Z"
                        set G($j,y) $yn
                    } else  {
                        # nodes avec partie gauche
                        set yn $G($bgy)
                        # Vertical
                        $w create line $G($bg,x) $G($bg,y) $G($bg,x) [expr $G($bg,y)+4] -tags "$t2 $t3 Z"
                        # Horizontal
                        set G($j,x) [expr $G($bg,x) - ($A($t,dbl,$j) * $fx)]
                        $w create line $G($bg,x) $yn $G($j,x) $yn  -tags "$j $t2 $t3 Z"
                        set G($j,y) $yn
                    }
                } else  {
                    # nodes avec partie droite
                    set yn $G($bdy)
                    # Vertical
                    $w create line $G($bd,x) $G($bd,y) $G($bd,x) [expr $G($bd,y)-4] -tags "$t2 $t3 Z"
                    # Horizontal
                    set G($j,x) [expr $G($bd,x) - ($A($t,dbl,$j) * $fx)]
                    $w create line $G($bd,x) $yn $G($j,x) $yn  -tags "$j $t2 $t3 Z"
                    set G($j,y) $yn
                }
            }
        }
        ### ROOT
        set ch [$w coords [format "%s%s" $t g]]
        set cb [$w coords [format "%s%s" $t d]]
        if {$ch != ""} {
            if {$cb != ""} {
                set yh [lrange $ch 1 1]
                set yb [lrange $cb 3 3]
                set x [lrange $ch 2 2]
                set yn [expr $yh - (($yh - $yb) / 2)]
            } else  {
                set yh [lrange $ch 1 1]
                set yb [expr [lrange $ch 3 3]+4]
                set x [lrange $ch 2 2]
                set yn $yh
            }
        } else  {
            set yh [lrange $cb 1 1]
            set yb [expr [lrange $cb 3 3] -4]
            set x [lrange $cb 2 2]
            set yn $yb
        }
        # Vertical
        $w create line $x $yh $x $yb -tags "[format "%s%s" $t C] $t3 Z"
        $w move T$t $px $py
    }
    ### ABSTRACTION PANEL
    proc AbstractionPanel {} {
        global S abs
        set w [toplevel .abs ]
        wm title .abs "Abstraction"
        wm geometry .abs 180x600
        # a mettre en init treedyn
        set abs(nbLavailable) 0
        set abs(nbLselection) 0
        set abs(What) display
        set abs(Mode) shrink
        set abs(stringsearch) *
        # menubutton Target
        menubutton .abs.target -text "Target(s)" -menu .abs.target.m   -direction below
        set z  [menu  .abs.target.m -tearoff 0]
        $z configure -postcommand "Abstraction::AbsTarget $z"
        # label leaves total
        label .abs.labtl -bd 1 -text "Leaves"
        button .abs.up -text "Update" -command "Abstraction::AbsAddAvailableLeaves"
        # filtre leaves total
        iwidgets::entryfield .abs.filter -width 25 -textvariable abs(stringsearch) -labeltext "Filter:" -command Abstraction::AbsUpdateActionFilter
        # select all/unselect all available leaves
        frame .abs.ale
        button .abs.ale.sel -text "Select all" -command ".abs.lfa.l selection set 0 end"
        button .abs.ale.uns -text "UnSelect all" -command ".abs.lfa.l selection clear 0 end"
        pack .abs.ale.sel .abs.ale.uns -side left -fill both -expand yes
        # Nombre de feuilles availables
        label .abs.labnbtl -bd 1 -textvariable abs(nbLavailable)
        # list leaves Total (pour tree target)
        set wd [frame .abs.lfa]
        scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
        scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
        listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                -width 50 -height 5 -selectmode multiple
        grid $wd.l -row 0 -column 0 -sticky news
        grid $wd.yscroll -row 0 -column 1 -sticky ns
        grid $wd.xscroll -row 1 -column 0 -sticky ew
        grid rowconfigure $wd 0 -weight 1
        grid columnconfigure $wd 0 -weight 1
        # Add // Remove from available to selection
        frame .abs.ieb
        button .abs.ieb.add -image IMGieadd -command Abstraction::AbsAddL
        button .abs.ieb.rem -image IMGierem  -command Abstraction::AbsRemL
        pack .abs.ieb.add .abs.ieb.rem -side left -fill both -expand yes
        # label leaves selection
        label .abs.labsl -bd 1 -text "Leaves Selection"
        # bouton remise a zero de la liste selection
        button .abs.rem -text "Empty List" -command ".abs.lfb.l delete 0 end ; set abs(nbLselection) 0"
        # Nombre de feuilles en selection
        label .abs.labnbsl -bd 1 -textvariable abs(nbLselection)
        # list leaves "selection"
        set wd [frame .abs.lfb]
        scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
        scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
        listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                -width 50 -height 5 -selectmode multiple
        grid $wd.l -row 0 -column 0 -sticky news
        grid $wd.yscroll -row 0 -column 1 -sticky ns
        grid $wd.xscroll -row 1 -column 0 -sticky ew
        grid rowconfigure $wd 0 -weight 1
        grid columnconfigure $wd 0 -weight 1
        # controle mode et selection
        frame .abs.si
        iwidgets::Labeledframe .abs.si.si1 -labelpos nw -labeltext "Leaves"
        set cs1 [.abs.si.si1 childsite]
        radiobutton $cs1.display -text "Selection" -variable abs(What) -anchor w -value display
        radiobutton $cs1.hidden -text "All - Selection" -anchor w -variable abs(What) -value hidden
        pack $cs1.display $cs1.hidden -anchor w -side left -fill both -expand yes
        iwidgets::Labeledframe .abs.si.si2 -labelpos nw -labeltext "Mode"
        set cs2 [.abs.si.si2 childsite]
        radiobutton $cs2.shrink -text "Shrink" -variable abs(Mode) -value shrink -anchor w
        radiobutton $cs2.topology -text "SubTree" -variable abs(Mode) -value collapse -anchor w
        pack $cs2.shrink $cs2.topology -anchor w -side left -fill both -expand yes
        pack .abs.si.si1 .abs.si.si2 -side top -fill both -expand yes
        # control d'abstraction
        button .abs.go -text "Abstraction" -command "Abstraction::AbsGo"
        # packing final
        pack  .abs.target .abs.labtl .abs.up .abs.filter .abs.ale .abs.labnbtl .abs.lfa .abs.ieb \
                .abs.labsl .abs.rem .abs.labnbsl .abs.lfb .abs.si .abs.go -fill both -expand yes
        # bindings
        bind .abs.lfa.l <Double-Button-1> "Abstraction::AbsaddLeafMouse .abs.lfa.l %x %y"
        bind .abs.lfb.l <Double-Button-1> "Abstraction::AbsremLeafMouse .abs.lfb.l %x %y"
    }
    #
    proc AbsGo {} {
        global S abs
        if {[.abs.lfb.l get 0 end] != {}} {
            # liste de tree target
            set lkv [array get S *,tar]
            set ltreetarget {}
            foreach {k v} $lkv {
                if {$S($k) == 1} {
                    lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
                }
            }
            # feuilles en selection
            # si on est en remove, la liste des feuilles est la
            # liste des feuilles available moins la liste des feuilles en selection
            switch $abs(What) {
                display {
                    set EUS [.abs.lfb.l get 0 end]
                }
                hidden   {
                    set EUS [Tools::SousL [.abs.lfa.l get 0 end] [.abs.lfb.l get 0 end]]
                }
            }
            #
            switch $abs(Mode) {
                shrink {
                    # pour chaque tree en target identifier SHRINK
                    # des noeuds pere sachant la liste leaf en selection
                    foreach t $ltreetarget {
                        set peres  [FindFatherNode $t $EUS]
                        foreach e $peres {
                            Shrink $S($t,w) $t $e "Leaves Abstraction"
                        }
                    }
                }
                collapse {
                    # pour chaque tree en target identifier COLLAPSE
                    # des noeuds pere sachant la liste leaf en selection
                    foreach t $ltreetarget {
                        NewickAbstract  $S($t,w) $t $EUS
                    }
                }
            }
        }
    }
    #
    proc AbsTarget {m} {
        global S
        $m  delete 0 end
        $m add command -label "Select All" -command "Selection::AbsTargetSelectAll ; Abstraction::AbsAddAvailableLeaves"
        $m add command -label "UnSelect All" -command "Selection::AbsTargetUnSelectAll ; Abstraction::AbsAddAvailableLeaves"
        $m add separator
        # un menu par fenetre, avec select/unselect all par fenetre
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set ms [format "%s%s%s" $m. w [Tools::GenId]]
                $m add cascade -label [wm title .t$wi] -menu $ms
                menu $ms -tearoff 0
                $ms add command -label "Select All" -command "Selection::TreeTargetSelectAllperW $wi ; Abstraction::AbsAddAvailableLeaves"
                $ms add command -label "Unselect All" -command "Selection::TreeTargetUnSelectAllperW $wi ; Abstraction::AbsAddAvailableLeaves"
                $ms add separator
                set win [format "%s%s%s" .t $wi .c]
                foreach t $S($win,t) {
                    $ms add checkbutton -label $S($t,tit) -variable S($t,tar) \
                            -columnbreak 0 -command "Selection::ShwoTree $t ; Abstraction::AbsAddAvailableLeaves"
                }
            }
        }
    }
    # mise a jour liste des feuilles en fonction des arbres en target
    proc AbsAddAvailableLeaves {} {
        global S abs T
        # liste de tree target
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        # construction de la liste des feuilles de tous lmes arbres en selection
        # liste sans repetitions, classe par ordre alpha et respectant le filtre
        set leu {}
        if {$abs(stringsearch) != "*"} {
            foreach t $ltreetarget  {
                foreach i $T($t,ue_lab) {
                    if {[string match $abs(stringsearch) $i]} {lappend leu $i }
                }
            }
        } else  {
            foreach t $ltreetarget  {
                set leu [concat $leu $T($t,ue_lab)]
            }
        }
        if {[llength $ltreetarget] != 1} {set leu [Tools::DelRep $leu]}
        set leu [lsort -dictionary $leu]
        # remplissage listbox
        .abs.lfa.l delete 0 end
        eval {.abs.lfa.l insert end} $leu
        # reconfiguration background des feuilles de la listbox
        # pour celles deja en selection
        if {[.abs.lfb.l get 0 end] != {}} {AbsConfigBg}
        # mise ajour nb de feuille availabale
        set abs(nbLavailable) [llength [.abs.lfa.l get 0 end]]
    }
    # l'utilisateur modifie le filtre, mise a jour de la listbox des feuilles available
    # attention respect de la casse
    proc AbsUpdateActionFilter {} {
        Abstraction::AbsAddAvailableLeaves
    }
    # config bg si deja en selection
    proc AbsConfigBg {} {
        global S
        set li {}
        set lavailable [.abs.lfa.l get 0 end] ;# feuilles available
        .abs.lfa.l delete 0 end
        eval {.abs.lfa.l insert end} $lavailable
        set selectL [.abs.lfb.l get 0 end] ;# feuilles en selection
        foreach e $selectL {
            set r [lsearch $lavailable $e]
            if {$r != -1} {lappend li $r}
        }
        foreach i $li {
            .abs.lfa.l itemconfigure $i -background NavajoWhite2
        }
    }
    #
    proc AbsaddLeafMouse {listbox x y} {
        global S abs
        set leaf [$listbox get @$x,$y]
        set selectL [.abs.lfb.l get 0 end]
        if {[lsearch $selectL $leaf] == -1}  {
            .abs.lfb.l insert 0 $leaf
        }
        .abs.lfa.l selection clear @$x,$y
        AbsConfigBg
        set abs(nbLselection) [llength [.abs.lfb.l get 0 end]]
    }
    # boutton ajout de la selection leave available dans la liste selection
    proc AbsAddL {} {
        global S abs
        # mise a jour listbox fichiers selection
        # on conserve l'ordre des groupes de selection
        set li [.abs.lfa.l curselection] ;# des index
        set lsel {}
        foreach i $li {
            lappend lsel [.abs.lfa.l get $i]
            .abs.lfa.l itemconfigure $i -background NavajoWhite2
        }
        set lall2 [.abs.lfb.l get 0 end]
        .abs.lfb.l delete 0 end
        # c moche je sais
        foreach e $lsel {
            lappend lall2 $e
        }
        #
        foreach e [Tools::DelRep $lall2] {
            .abs.lfb.l insert 0 $e
        }
        # deselection des fichiers liste available
        .abs.lfa.l selection clear 0 end
        # update nb de tree total
        set abs(nbLselection) [llength $lall2]
    }
    #
    proc AbsRemL {} {
        global abs
        # attention retrait a partir de l'index le plus bat
        # le delete remet a jour les index
        set li [lsort -decreasing [.abs.lfb.l curselection]] ;# des index
        foreach i $li {
            .abs.lfb.l delete $i
        }
        # deselection des fichiers liste available
        .abs.lfa.l selection clear 0 end
        set abs(nbLselection) [llength [.abs.lfb.l get 0 end]]
        AbsConfigBg
    }
    #
    proc AbsremLeafMouse {listbox x y} {
        global S abs
        $listbox delete @$x,$y
        AbsConfigBg
        set abs(nbLselection) [llength [.abs.lfb.l get 0 end]]
    }
    ### OPTIMISATION : si un node est ok : ne pas tester ses nodes fils
    proc FindFatherNode {t SouRefLea} {
        global S T
        set L {}
        if {[llength $SouRefLea] != 1} {
            foreach TarCodNod [lsort -dictionary $T($t,all_cod)] {
                # selection des codes leaf issus de node
                set TarCodLea [Tools::NodeNoToLe $t $TarCodNod]
                # passage codes leaf -> references leaf
                set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
                # test inclusion des references leaf de TARGET avec SOURCE
                if {$S(nodefilter) == 0} {
                    set r [Tools::ListInclu $TarRefLea $SouRefLea]
                    if {$r == 1} {lappend L $TarCodNod}
                } else  {
                    set r [Tools::ListIncluSauf $TarRefLea $SouRefLea $S(nodefilter)]
                    if {$r == 1} {lappend L $TarCodNod}
                }
            }
            # meme node pere possibles
            # differents nodes peres possibles
            # -> identification des nodes peres de plus haut niveau
            set l [Tools::NodeFaNoId {} $L]
            if {$L == {}} {return {}} {return $l}
        } {
            if {[lsearch -exact $T($t,ue_lab) $SouRefLea] != -1} {return $T($t,ltc,$SouRefLea)} else {return {}}
        }
    }
}
################################################################################


################################################################################
# LOCALISATION
################################################################################
namespace eval Localisation {
    
    # Localisation SWITCH zone canvas ou tree
    proc L_Switch {w x y} {
        global T
        if {[winfo exists $w.localisation ] == 1} {destroy $w.localisation}
        set m [menu $w.localisation -tearoff 0  ]
        set i [$w find withtag current]
        # verifier pas un item
        if {$i == {}} {
            if {[$w find overlapping [expr $x -20]  [expr $y - 20] [expr $x+20] [expr $y+20] ] == {} } {
                # zone avec plusieurs arbres
                Localisation::I_Canvas $w $m
            } else {
                # zone un seul arbre
                set id [$w find closest $x $y]
                set tags [$w gettags $id]
                set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
                Localisation::I_Tree $w $m $t
            }
            tk_popup $m [winfo pointerx $w] [winfo pointery $w]
        }
    }
    ### plusieurs TREES  ==> LOCALISATION on target la liste des tree de la fenetre
    proc I_Canvas {w m } {
        global S T
        set nb [llength $S($w,t)]
        $m add command -label "Localisation: $nb Tree(s)"
        $m add separator
        if {$S(database) != ""} {
            $m add command -label "Current database: $S(database)"  -foreground blue
            Labelisation::LabelsFileSwitch $m
            $m add command -label "Annotations browser" -command "Database::dbBrowser"
        }
        $m add command -label "Load annotations..." -command "Database::LoadAnnotations"
        $m add command -label "Operation Panel" -command "Operation::OperationMenu"
        $m add separator
        MenuUE $w $m *
        if {$S(database) != ""} {
            $m add separator
            $m add command -label "Labels"
            # le symbole = indique que l'on target les tree de la fenetre courante
            MenuDB $w $m =
        }
        return $m
    }
    ### 1 TREE ==> LOCALISATION
    proc I_Tree {w m t} {
        global S db
        if {$S($t,tit) != ""} {
            $m add command -label "Localisation: $S($t,tit)"
        } else  {
            $m add command -label "Localisation"
        }
        $m add separator
        if {$S(database) != ""} {
            $m add command -label "Current database: $S(database)"  -foreground blue
            Labelisation::LabelsFileSwitch $m
            $m add command -label "Annotations browser" -command "Database::dbBrowser"
        }
        $m add command -label "Load annotations..." -command "Database::LoadAnnotations"
        $m add command -label "Operation Panel" -command "Interface::OperationPanel"
        $m add separator
        MenuUE $w $m $t
        if {$S(database) != ""} {
            $m add separator
            $m add command -label "Labels"
            MenuDB $w $m $t
        }
        return $m
    }
    ###  MenuUE MODE Localisation
    ###  MenuUE inserre une cascade EU (classees alphabetique)
    proc MenuUE {w m t} {
        global S T
        if {$t == "*"} {
            set eul {}
            foreach t $S($w,t) {
                foreach e $T($t,ue_lab) {
                    lappend eul $e
                }
            }
            set msl [format "%s%s%s%s" $m . m $t]
            $m add cascade -label "[llength $eul] Leaves" -menu $msl
            menu $msl -tearoff 0
            set L {}
            set eul [lsort -dictionary [Tools::DelRep $eul]]
            foreach i $eul {
                lappend L [string toupper [string range $i 0 0]]
            }
            set L [lsort -dictionary [Tools::DelRep $L]]
            foreach i $L {
                set ms [format "%s%s%s%s%s%s" $m . m $t . [string tolower $i]]
                $msl add cascade -label $i -menu $ms
                menu $ms -tearoff 0
                foreach r $eul {
                    if {[string toupper [string range $r 0 0]] == $i} {
                        $ms add command -label $r -command "Localisation::LocalisationEU $w $t $r"
                    }
                }
            }
        } {
            set eul [lsort -dictionary $T($t,ue_lab)]
            set msl [format "%s%s%s%s" $m . m $t]
            $m add cascade -label "[llength $eul] Leaves" -menu $msl
            menu $msl -tearoff 0
            set L {}
            foreach i $eul {
                lappend L [string toupper [string range $i 0 0]]
            }
            set L [lsort -dictionary [Tools::DelRep $L]]
            foreach i $L {
                set ms [format "%s%s%s%s%s%s" $m . m $t . [string tolower $i]]
                $msl add cascade -label $i -menu $ms
                menu $ms -tearoff 0
                foreach r $eul {
                    if {[string toupper [string range $r 0 0]] == $i} {
                        $ms add command -label $r -command "Localisation::LocalisationEU $w $t $r"
                    }
                }
            }
        }
    }
    ### Menu DB Mode Localisation
    proc MenuDB {w m t} {
        global db S
        set database $S(database)
        if {$database != ""} {
            set tags [Database::dbQueryVarAll $database]
            foreach tag $tags {
                if {[string equal -nocase $tag "eu"] != 1} {
                    set mm [format "%s%s%s" $m . [string tolower $tag]]
                    $m add cascade -label $tag -menu $mm
                    menu $mm -tearoff 1
                    set lvv {}
                    foreach val [Database::dbQueryValFromVar $database $tag] {
                        if {[llength $val] > 1} {
                            foreach ival $val {
                                if {[lsearch -exact $lvv $ival] == -1} {lappend lvv $ival}
                            }
                        } else  {
                            if {[lsearch -exact $lvv $val] == -1} {lappend lvv $val}
                        }
                    }
                    foreach e [lsort -dictionary $lvv] {
                        $mm add command -label $e -command "Localisation::LocalisationDB $w $t $database $tag $e"
                    }
                }
            }
        }
    }
    ###
    proc LocalisationEU {w t EUS } {
        Operation::Operation $w $t $EUS
    }
    ###
    proc LocalisationDB {w t database var val } {
        global S
        set S(query) [format "%s%s%s" $var " == " $val]
        set records [Database::dbQueryRecordsFromVarVal $database $var $val]
        set EUS [Database::dbQueryEusFromRecords $database $records]
        Operation::Operation $w $t $EUS
    }
}
################################################################################


################################################################################
# LABELISATION
################################################################################
namespace eval Labelisation {
    
    ### LEAF LABELISATION
    proc I_Leaf {w m t n x y} {
        global S db T
        $m add command -label [format "%s%s" "Leaf Labelisation: " $T($t,ctl,$n)]
        $m add separator
        if {$S(database) != ""} {
            $m add command -label "Current database: $S(database)"  -foreground blue
            Labelisation::LabelsFileSwitch $m
            $m add command -label "Annotations browser" -command "Database::dbBrowser"
        }
        $m add command -label "Load annotations..." -command "Database::LoadAnnotations"
        if {$S(database) != ""} {
            $m add separator
            $m add command -label "Annotations"
            MenuDBfromNode $w $m $t $n $x $y
            $m add separator
            $m add command -label "Annotate with Labels"  \
                    -command "Identification::InsertBulDBCommonTags $w $x $y $n"
        }
        return $m
    }
    ### NODE LABELISATION
    proc I_Node {w m t n x y} {
        global S db
        $m add command -label "Node Labelisation"
        $m add separator
        if {$S(database) != ""} {
            $m add command -label "Current database: $S(database)"  -foreground blue
            Labelisation::LabelsFileSwitch $m
            $m add command -label "Labels File Browser" -command "Database::dbBrowser"
        }
        $m add command -label "Load annotations..." -command "Database::LoadAnnotations"
        #$m add command -label "Operation Panel" -command "Interface::OperationPanel"
        $m add separator
        if {$S(database) == ""} {
            # Leaves Labels
            set eul [lsort -dictionary [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]]
            set msl [format "%s%s%s%s" $m . m $t]
            $m add cascade -label "[llength $eul] Leaves" -menu $msl
            menu $msl -tearoff 0
            set L {}
            foreach i $eul {
                lappend L [string toupper [string range $i 0 0]]
            }
            set L [lsort -dictionary [Tools::DelRep $L]]
            foreach i $L {
                set ms [format "%s%s%s%s%s%s" $m . m $t . [string tolower $i]]
                $msl add cascade -label $i -menu $ms
                menu $ms -tearoff 0
                foreach r $eul {
                    if {[string toupper [string range $r 0 0]] == $i} {
                        $ms add command -label $r
                    }
                }
            }
            $m add command -label "Annotate with Leaves"  \
                    -command "Identification::InsertBulUE $w $x $y $n"
            $m add separator
            $m add command -label "(no label)"
            
        } else  {
            
            # LEAVES
            set eul [lsort -dictionary [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]]
            set msl [format "%s%s%s%s" $m . m $t]
            $m add cascade -label "[llength $eul] Leaves" -menu $msl
            menu $msl -tearoff 0
            set L {}
            foreach i $eul {
                lappend L [string toupper [string range $i 0 0]]
            }
            set L [lsort -dictionary [Tools::DelRep $L]]
            foreach i $L {
                set ms [format "%s%s%s%s%s%s" $m . m $t . [string tolower $i]]
                $msl add cascade -label $i -menu $ms
                menu $ms -tearoff 0
                foreach r $eul {
                    if {[string toupper [string range $r 0 0]] == $i} {
                        $ms add command -label $r
                    }
                }
            }
            $m add command -label "Annotate with Leaves"  \
                    -command "Identification::InsertBulUE $w $x $y $n"
            
            # NODE
            $m add separator
            $m add command -label "Node Labels"
            set euls [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
            set lrecords {}
            set database $S(database)
            #liste des records
            foreach eu $euls {
                set res [Database::dbQueryRecordsFromVarVal $database EU $eu]
                if {$res != ""} {set lrecords [concat $lrecords $res] }
            }
            # affichage une cascade par variable pointant sur la liste des valeurs, toutes feuilles confondues
            if {$lrecords != ""} {
                set variables [Database::dbQueryVarAll $database]
                foreach variable $variables {
                    if {[string equal -nocase $variable "eu"] != 1} {
                        set values [Database::dbQueryVarFromRecords $database $variable $lrecords]
                        if {$values != ""} {
                            set mm [format "%s%s%s" $m . [string tolower $variable]]
                            $m add cascade -label "$variable ([llength $values])" -menu $mm
                            menu $mm -tearoff 1
                            foreach value $values {
                                set couple [format "%s%s%s" $variable = $value]
                                regsub -all " |\n" $couple "//" couple
                                # annotation avec une valeur de la variable
                                $mm add command -label "$value"
                            }
                            # pour l'instant seuleument annotation avec la liste de toutes les valeurs d'une variable
                            #-command "Identification::InsertBulDBCouple $w $t $x $y $n [list $value]"
                            
                            # annotation du node avec toutes les valeurs de la variable
                            regsub -all "\}" $values "\n" vals
                            regsub -all "\{" $vals "" vals
                            set couple [format "%s%s%s%s%s" $variable ($database) : "\n " $vals]
                            # foreach v $values {
                            # lappend couple  \n $v
                            # }
                            $mm add separator
                            $mm add command -label "Annotate"  \
                                    -command "Identification::InsertBulDBCouple $w $t $x $y $n [list $couple]"
                        }
                    }
                }
            }
            # affichage Liste Variable=Value pour les values communes a TOUTES les feuilles
            # (intersection)
            $m add separator
            $m add command -label "Share Labels"
            MenuDBfromNode $w $m $t $n $x $y
            
            #set msla [format "%s%s" $m .ma]
            #$m add cascade -label "Share Labels:" -menu $msla -font {Helvetica 8 bold}
            #menu $msla -tearoff 0
            
            
            # affichage Liste Variable=Value pour les values communes et specificiques a TOUTES les feuilles
            # (intersection et specificite)
            # $m add separator
            # set mslb [format "%s%s" $m .mb]
            # $m add cascade -label "Share & Specific Labels:" -menu $mslb -font {Helvetica 8 bold}
            # menu $mslb -tearoff 0
        }
        return $m
    }
    ###  MenuUEfromNode MODE Labelisation
    ###  MenuUEfromNode inserre une cascade EU (classees alphabetique)
    ###  d'un subtree select via un node
    proc MenuUEfromNode {w m t n} {
        global S T
        set eul [lsort -dictionary [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]]
        set msl [format "%s%s%s%s" $m . m $t]
        $m add cascade -label "[llength $eul] Leaves" -menu $msl
        menu $msl -tearoff 0
        set L {}
        foreach i $eul {
            lappend L [string toupper [string range $i 0 0]]
        }
        set L [lsort -dictionary [Tools::DelRep $L]]
        foreach i $L {
            set ms [format "%s%s%s%s%s%s" $m . m $t . [string tolower $i]]
            $msl add cascade -label $i -menu $ms
            menu $ms -tearoff 0
            foreach r $eul {
                if {[string toupper [string range $r 0 0]] == $i} {
                    $ms add command -label $r -command ""
                }
            }
        }
    }
    ### Menu DB Mode Labelisation
    ### insertion au menu m de la liste de couples variables/valeur
    ### commune aux leafs issues de nodes
    proc MenuDBfromNode {w m t n x y} {
        global db S
        # insertion ds le menu d'une liste de couple variable-valeur
        # communes aux leaf issues du node select par l'utilisateur
        set euls [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        set lrecords {}
        set database $S(database)
        if {$database != ""} {
            foreach eu $euls {
                set res [Database::dbQueryRecordsFromVarVal $database EU $eu]
                if {$res != ""} {set lrecords [concat $lrecords $res] }
            }
            # pour chaque record on reduit la A-List a une liste de var#val (concat)
            # on a donc une liste de liste, on cherche l'intersection
            if {$lrecords != ""} {
                puts IN
                upvar #0 $database X
                set ll {}
                foreach record $lrecords {
                    
                    set l {}
                    foreach {var val} $X($record) {
                        set couple [format "%s%s%s" $var = $val]
                        regsub -all " " $couple "-" couple
                        lappend l $couple
                    }
                    lappend ll $l
                }
                # travail sur les valeurs communes
                set intersection [lsort -dictionary [Tools::operatorANDll $ll]]
                if {$intersection != ""} {
                    foreach couple $intersection {
                        regsub -all " " $couple "-" couple
                        $m add command -label $couple -command "Identification::InsertBulDBCouple $w $t $x $y $n [list $couple]"
                    }
                    regsub -all " " $intersection "\n" intersection
                    $m add command -label Annotate -command "Identification::InsertBulDBCouple $w $t $x $y $n [list $intersection]"
                } else  {
                    $m add command -label (empty)
                }
                
            } else {
                $m add command -label "(no label)"
            }
        }
    }
    #
    proc LabelsFileSwitch {m} {
        global S
        set ms $m.selectlf
        $m add cascade -label "Select a Labels File" -menu $ms
        menu $ms -tearoff 0
        foreach i $S(ldatabase) {
            $ms add command -label $i -command "set S(database) $i"
        }
    }
    
}
################################################################################


################################################################################
# IDENTIFICATION
################################################################################
namespace eval Identification {
    
    # si selection d'une zone treeS ou d'une zone 1 tree => mode localisation
    # si selection node => activation du mode labelisation
    proc I_Switch {w x y} {
        global T
        if {[winfo exists $w.d3label ] == 1} {destroy $w.d3label}
        set m [menu $w.d3label -tearoff 0  ]
        set i [$w find withtag current]
        if {$i != {}}  {
            set tags [$w gettags $i]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            set n [string trimright \
                    [lindex $tags [lsearch -glob $tags *C]] C]
            if {$n == ""} {
                set name [string range \
                        [lindex $tags [lsearch -glob $tags EUL*]] 3 end]
                set n $T($t,ltc,$name)
                # identification sens LABELISATION
                Labelisation::I_Leaf $w $m $t $n $x $y
            } else  {
                # identification sens LABELISATION
                Labelisation::I_Node $w $m $t $n $x $y
            }
            tk_popup $m [winfo pointerx $w] [winfo pointery $w]
        }
    }
    #
    proc SelectUpdateAscend {t SouRefLea} {
        global S
        if {$S(nodefilter) == 0} {
            SelectUpdateAscendOriginal $t $SouRefLea
        } else  {
            SelectUpdateAscendSauf $t $SouRefLea
        }
    }
    ### OPTIMISATION : si un node est ok : ne pas tester ses nodes fils
    proc SelectUpdateAscendOriginal {t SouRefLea} {
        global S T
        set L {}
        if {[llength $SouRefLea] != 1} {
            foreach TarCodNod [lsort -dictionary $T($t,all_cod)] {
                # selection des codes leaf issus de node
                set TarCodLea [Tools::NodeNoToLe $t $TarCodNod]
                # passage codes leaf -> references leaf
                set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
                # test inclusion des references leaf de TARGET avec SOURCE
                if {$S(nodefilter) == 0} {
                    set r [Tools::ListInclu $TarRefLea $SouRefLea]
                    if {$r == 1} {lappend L $TarCodNod}
                } else  {
                    set r [Tools::ListIncluSauf $TarRefLea $SouRefLea $S(nodefilter)]
                    if {$r == 1} {lappend L $TarCodNod}
                }
            }
            # meme node pere possibles
            # differents nodes peres possibles
            # -> identification des nodes peres de plus haut niveau
            set l [Tools::NodeFaNoId {} $L]
            if {$L == {}} {return {}} {return $l}
        } {return $T($t,ltc,$SouRefLea) }
    }
    ### OPTIMISATION : si un node est ok : ne pas tester ses nodes fils
    proc SelectUpdateAscendSauf {t SouRefLea} {
        global S T
        set L {}
        # on ne prend pas en compte les codes des feuilles
        set latest [Tools::SousL $T($t,all_cod) $T($t,ue_cod)]
        if {[llength $SouRefLea] != 1} {
            foreach TarCodNod [lsort -dictionary $latest] {
                # selection des codes leaf issus de node
                set TarCodLea [Tools::NodeNoToLe $t $TarCodNod]
                # passage codes leaf -> references leaf
                set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
                # test inclusion des references leaf de TARGET avec SOURCE
                set r [Tools::ListIncluSauf $TarRefLea $SouRefLea $S(nodefilter)]
                if {$r == 1} {lappend L $TarCodNod}
            }
            # meme node pere possibles
            # differents nodes peres possibles
            # -> identification des nodes peres de plus haut niveau
            set l [Tools::NodeFaNoId {} $L]
            if {$L == {}} {return {}} {return $l}
        } {return $T($t,ltc,$SouRefLea) }
    }
    ###
    proc InitGraph {} {
        global S
        foreach key [array names S *,tar]  {
            if {$S($key) == 1} {
                set t [string range $key 0 [expr [string first , $key] - 1]]
                Figuration::NodeGraVarInit $t
            }
        }
    }
    ### Bulle Labels : UEs
    proc InsertBulUE {w x y i} {
        global S T
        set tags [$w gettags $i]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright [lindex $tags [lsearch -glob $tags *C]] C]
        if {[lsearch -exact $T($t,all_cod) $n] != -1} {
            set La {}
            set SouCodLea [Tools::NodeNoToLe $t $n]
            set UE [lsort -dictionary [Tools::NodeLeCoToRe $t $SouCodLea]]
            foreach i $UE {
                regsub -all {¶} $i " " texti
                lappend La $texti
                #lappend La [string toupper $i]
            }
            
            Annotation::BLLmake $w $t $x $y  \
                    [format "%s%s" [llength $La] " Leaves : "]\
                    [Tools::FormatText  $La] $n
            
        }
    }
    ### Bulle Labels : DB
    proc InsertBulDBCommonTags {w x y i} {
        global S T db
        set tags [$w gettags $i]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright [lindex $tags [lsearch -glob $tags *C]] C]
        set euls [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        set lrecords {}
        set database $S(database)
        if {$database != ""} {
            foreach eu $euls {
                lappend lrecords [Database::dbQueryRecordsFromVarVal $database EU $eu]
            }
            # pour chaque record on reduit la A-List a une liste de var#val (concat)
            # on a donc une liste de liste, on cherche l'intersection
            upvar #0 $database X
            set ll {}
            foreach record $lrecords {
                set l {}
                foreach {var val} $X($record) {
                    lappend l [format "%s%s%s" $var = $val]
                }
                lappend ll $l
            }
            set intersection [lsort -dictionary [Tools::operatorANDll $ll]]
            # ?
            #lappend intersection
            Annotation::BLLmake $w $t $x $y \
                    [format "%s%s" [llength $intersection] " Labels (Common, $database) : "]\
                    [Tools::FormatText  $intersection] $n
        }
    }
    ### LABEL : NODE / Intersection Variables-Modalites avec Specificite
    proc InsertBulDBSpecificTags {w x y i}  {
        global S T db
        set tags [$w gettags $i]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright [lindex $tags [lsearch -glob $tags *C]] C]
        set euls [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        set lrecords {}
        set database $S(database)
        if {$database != ""} {
            foreach eu $euls {
                lappend lrecords [dbQueryRecordsFromVarVal $database EU $eu]
            }
            # pour chaque record on reduit la A-List a une liste de var=val (concat)
            # on a donc une liste de liste, on cherche l'intersection
            upvar #0 $database X
            set ll {}
            foreach record $lrecords {
                set l {}
                foreach {var val} $X($record) {
                    lappend l [format "%s%s%s" $var = $val]
                }
                lappend ll $l
            }
            #
            set intersection [lsort -dictionary [Tools::operatorANDll $ll]]
            
            # Annotation::BLLmake $w $t $x $y \
            # [format "%s%s" [llength $intersection] " Labels (Common, $database) : "]\
            # [Tools::FormatText  $intersection] $n
        }
    }
    #
    proc InsertBulDBCouple {w t x y n couple} {
        global S
        set database $S(database)
        Annotation::BLLmake $w $t $x $y \
                $database\
                $couple $n
    }
    #
    proc InsertVarVal {w t x y n} {
        global S
        set database $S(database)
        set q $S(query)
        Annotation::BLLmake $w $t  [$w canvasx $x] [$w canvasy $y ]  \
                $database [lrange $q [expr [lsearch $q where] + 1] end] $n
    }
    proc InsertVarVal2 {w t x y n} {
        global S
        set database $S(database)
        set q $S(query)
        Annotation::BLLmake $w $t [$w canvasx $x] [$w canvasy $y ] \
                $database [lindex $q  end] $n
    }
    # panel
    proc AlternaGraphicsIdentification {} {
        global S alter
        set id [Tools::GenId]
        set wi .identification.pw.pane1.childsite.cc.select.l
        if [catch {$wi get [$wi curselection]} select] {
            tk_messageBox -message "Select is missing" -type ok; return
        } else {
            # variable
            set wi .identification.pw.pane1.childsite.cc.variable.l
            if [catch {$wi get [$wi curselection]} variable] {
                tk_messageBox -message "Variable is missing" -type ok; return
            } else {
                set S(QueryVariable$id) $variable
                # operator
                set wi .identification.pw.pane1.childsite.cc.operators.l
                if [catch {$wi get [$wi curselection]} operator] {
                    tk_messageBox -message "Operator is missing" -type ok; return
                } else {
                    
                    set S(QueryOperator$id) $operator
                    
                    # ici on tourne sur toute la liste des valeur d'une variable
                    set wi .identification.pw.pane1.childsite.cc.value.l
                    set lv [$wi get 0 end]
                    set S(MultiQueryValue$id) $lv
                    set S(MultiQueryQuery$id) "$select $variable $operator"
                    
                    toplevel .alter$id
                    wm title .alter$id AlternaGraphics
                    wm geometry .alter$id "+[winfo pointerx .alter$id]+[winfo pointery .alter$id]"
                    # message
                    label  .alter$id.lab -text "Alternagraphics"
                    # canvas d'affichage de la liste de TOUS les patterns
                    set w [frame .alter$id.canvas]
                    scrollbar $w.xsbar -orient horizontal -command "$w.c xview"
                    scrollbar $w.ysbar -orient vertical -command "$w.c yview"
                    canvas $w.c -width 100 -height 100  \
                            -xscrollcommand "$w.xsbar set" -yscrollcommand "$w.ysbar set"\
                            -highlightthickness 0
                    grid $w.c -row 0 -column 0 -sticky news
                    grid $w.xsbar -row 1 -column 0 -sticky ew
                    grid $w.ysbar -row 0 -column 1 -sticky ns
                    grid rowconfigure $w 0  -weight 1
                    grid columnconfigure $w 0 -weight 1
                    set x 40
                    set y 20
                    #liste des patterns issus de Find/History
                    #set lv [.find.history.childsite.l get 0 end]
                    foreach value $lv {
                        $w.c create text [expr $x + 30] [expr $y + 15] -fill green \
                                -text "$select $variable $operator $value" \
                                -anchor w  -tags "t $value"
                        incr y 15
                    }
                    $w.c bind t <Button-1> "Identification::AlternaGraphicsIdentificationSelUnSelOne $w.c"
                    $w.c configure -scrollregion [$w.c  bbox all]
                    # message d'aide
                    message .alter$id.msg -width 300 -text " + Clic on text values. Green: the value will be checked,\
                            Red: the value will not be checked. Also use the <Select All> or <Unselect All> buttons."
                    # menu operation
                    iwidgets::optionmenu  .alter$id.operation -labeltext "Operation: " -labelpos w \
                            -command "Identification::AlternaGraphicsIdentificationOperation .alter$id.operation"
                    foreach i {"Leaf Foreground Color" "Leaf Background Color" "Node Foreground Color" } {
                        .alter$id.operation insert end $i
                    }
                    # button select all et unselect all
                    set ww [frame .alter$id.select]
                    button $ww.selall -text "Select All" -command "Identification::AlternaGraphicsIdentificationSelectAll .alter$id.canvas.c"
                    button $ww.unsall -text "Unselect All" -command "Identification::AlternaGraphicsIdentificationUnSelectAll .alter$id.canvas.c"
                    pack  $ww.selall $ww.unsall -side left -expand yes -fill both
                    
                    # message d'information de la requete courante
                    message .alter$id.msgval -width 300 -text "" -textvariable alter(value)
                    
                    Operation::ResetAllFig+
                    Operation::ResetGraphicVariables
                    set alter(modeswitch) manual ;# ou auto
                    set alter(modeautoloop) 5 ;# number of loop to do in iterative mode
                    set alter(modeautotime) 200 ;# temps en millisecondes entre deux query
                    set alter(value) ""
                    set alter(ManualQueryList) ""
                    set alter(stop) 0
                    ### MODE MANUAL/AUTO
                    iwidgets::Labeledframe .alter$id.manual -labelpos nw -labeltext "Manual Mode"
                    set p1 [.alter$id.manual childsite]
                    iwidgets::Labeledframe .alter$id.auto -labelpos nw -labeltext "Automatic Mode"
                    set p2 [.alter$id.auto childsite]
                    
                    # mode manual
                    radiobutton $p1.mode -text "Manual mode" -variable alter(modeswitch) -value manual -command "Identification::AlternaGraphicsIdentificationManualToAuto $p1 $p2"
                    button $p1.prev -text "Previous"  -command "Identification::AlternaGraphicsIdentificationManualQueryPrev .alter$id.canvas.c $id"
                    button $p1.next -text "Next" -command "Identification::AlternaGraphicsIdentificationManualQueryNext .alter$id.canvas.c $id"
                    pack $p1.mode $p1.prev $p1.next -side top -expand yes -fill x
                    # mode automatic
                    radiobutton $p2.mode -text "Automatic mode" -variable alter(modeswitch) \
                            -value auto -command "Identification::AlternaGraphicsIdentificationAutoToManual $p1 $p2"
                    iwidgets::entryfield $p2.loop  -labeltext "Loop number" -width 5 -textvariable alter(modeautoloop) \
                            -labelpos w
                    iwidgets::entryfield $p2.time  -labeltext "Time laps (ms)" -width 5 -textvariable alter(modeautotime) \
                            -labelpos w
                    button $p2.queryprecalcul -text "Query all first"  \
                            -command "Identification::AlternaGraphicsIdentificationAutoQueryPrecalcul $p2.queryprecalcul $w.c $id"
                    button $p2.query -text "Query on the fly"   \
                            -command "Identification::AlternaGraphicsIdentificationAutoQuery  $w.c $id"
                    button $p2.stop -text Stop -command "set alter(stop) 1"
                    pack $p2.mode $p2.loop $p2.time $p2.queryprecalcul $p2.query $p2.stop -side top -expand yes -fill x
                    pack .alter$id.lab .alter$id.msg .alter$id.select  $w \
                            .alter$id.operation .alter$id.msgval .alter$id.manual .alter$id.auto \
                            -expand yes -fill x
                    # par defaut on est en mode manual donc inhibition des controls auto
                    Identification::AlternaGraphicsIdentificationManualToAuto $p1 $p2
                }
            }
        }
    }
    #
    proc AlternaGraphicsIdentificationManualQueryPrev {c id} {
        global alter
        # recuperation des valeurs en selection
        set li [$c find withtag t]
        set lvalues {}
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green"} {
                lappend lvalues $valeur
            }
        }
        set alter(ManualQueryList) $lvalues
        # on va tourner sur la liste
        if {$alter(value) != ""} {
            set ou [lsearch -exact $alter(ManualQueryList) $alter(value)]
            
            if {$ou != -1} {
                set newval [lindex $alter(ManualQueryList) [incr ou -1]]
                if {$newval != ""} {
                    set alter(value) $newval
                } else  {
                    set alter(value) [lindex $alter(ManualQueryList) end]
                }
                Operation::ResetAllFig+
                Operation::ResetGraphicVariables
                Identification::AlternaGraphicsIdentificationQuery $id $alter(value)
                update idletasks
            }
        } else  {
            set alter(value) [lindex $alter(ManualQueryList) 0]
            Operation::ResetAllFig+
            Operation::ResetGraphicVariables
            Identification::AlternaGraphicsIdentificationQuery $id $alter(value)
            update idletasks
        }
    }
    #
    proc AlternaGraphicsIdentificationManualQueryNext {c id} {
        global alter
        # recuperation des valeurs en selection
        set li [$c find withtag t]
        set lvalues {}
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green"} {
                lappend lvalues $valeur
            }
        }
        set alter(ManualQueryList) $lvalues
        # on va tourner sur la liste
        if {$alter(value) != ""} {
            set ou [lsearch -exact $alter(ManualQueryList) $alter(value)]
            if {$ou != -1} {
                set newval [lindex $alter(ManualQueryList) [incr ou]]
                if {$newval != ""} {
                    set alter(value) $newval
                } else  {
                    set alter(value) [lindex $alter(ManualQueryList) 0]
                }
                Operation::ResetAllFig+
                Operation::ResetGraphicVariables
                Identification::AlternaGraphicsIdentificationQuery $id $alter(value)
                update idletasks
            }
        } else  {
            set alter(value) [lindex $alter(ManualQueryList) 0]
            Operation::ResetAllFig+
            Operation::ResetGraphicVariables
            Identification::AlternaGraphicsIdentificationQuery $id $alter(value)
            update idletasks
        }
    }
    #
    proc AlternaGraphicsIdentificationAutoQuery {c id} {
        global alter
        # recuperation des valeurs en selection
        set li [$c find withtag t]
        set lvalues {}
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green"} {
                lappend lvalues $valeur
            }
        }
        for  {set i 1} {$i <= $alter(modeautoloop)} {incr i} {
            if {$alter(stop) == 1} {set alter(stop) 0 ; break}
            foreach val $lvalues {
                set alter(value) $val ;# pour variable d'information
                Operation::ResetAllFig+
                Operation::ResetGraphicVariables
                after $alter(modeautotime)
                Identification::AlternaGraphicsIdentificationQuery $id $val
                update idletasks
                update
            }
        }
    }
    #
    proc AlternaGraphicsIdentificationAutoQueryPrecalcul {b c id} {
        global alter Alterna S
        # recuperation des valeurs en selection
        set li [$c find withtag t]
        set lvalues {}
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green"} {
                lappend lvalues $valeur
            }
        }
        foreach val $lvalues {
            if {$alter(stop) == 1} {set alter(stop) 0 ; break}
            #remplissage tableau Alterna($id,$val) == $liste eu
            set alter(value) $val ;# pour variable d'information
            set args "[lrange $S(MultiQueryQuery$id) 1 end] $val"
            set var1 [lindex $args 0]
            set database [lindex $args 2]
            set var2 [lindex $args 4]
            set operator [lindex $args 5]
            set val2 [lindex $args 6]
            if {$operator == "##"} {
                set res1 [Database::dbQueryRecordsFromVarPatVal $database $var2 $val2]
            } elseif {$operator == "!#"} {
                set res1 [Database::dbQueryRecordsFromVarPat2Val $database $var2 $val2]
            } else {
                set res1 [Database::dbQueryRecordsFromVarOpVal $database $var2 $operator $val2]
            }
            # res2 est la liste des feuilles sur la database (pas par arbre)
            # mais on va garder comme ca
            set res2 [Database::dbQueryVarFromRecords $database $var1 $res1]
            set Alterna($id,$val) $res2
            # la lecture se fait Operation::Operation $wi $ti $Alterna($id,$val)
            $b configure -text Ok
            $b configure -command  "Identification::AlternaGraphicsIdentificationAutoQueryPrecalculGo $c $id"
        }
    }
    #
    proc AlternaGraphicsIdentificationAutoQueryPrecalculGo {c id} {
        global alter Alterna
        set li [$c find withtag t]
        set lvalues {}
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green"} {
                lappend lvalues $valeur
            }
        }
        set AlistWTtarget [Selection::TreeTar]
        if {$AlistWTtarget != {}} {
            foreach {wi ti} $AlistWTtarget {
                if {$alter(stop) == 1} {set alter(stop) 0 ; break}
                foreach val $lvalues {
                    Operation::ResetAllFig+
                    Operation::ResetGraphicVariables
                    after $alter(modeautotime)
                    Operation::Operation $wi $ti $Alterna($id,$val)
                    update idletasks
                    update
                }
            }
        } else  {
            return
        }
    }
    #
    proc AlternaGraphicsIdentificationQuery {id v} {
        global alter T S asedCon
        set q "$S(MultiQueryQuery$id) $v \n"
        set wc .identification.pw.pane2.childsite.console.t
        $wc insert prompt $q
        $wc see insert
        Database::evalCommand $wc $asedCon [Database::getCommand $wc]
    }
    #
    proc AlternaGraphicsIdentificationManualToAuto {p1 p2} {
        $p1.prev configure -state normal
        $p1.next configure -state normal
        $p2.loop configure -state disabled
        $p2.time configure -state disabled
        $p2.query configure -state disabled
        $p2.queryprecalcul configure -state disabled
        $p2.stop configure -state disabled
    }
    #
    proc AlternaGraphicsIdentificationAutoToManual {p1 p2} {
        $p1.prev configure -state normal
        $p1.next configure -state normal
        $p2.loop configure -state normal
        $p2.time configure -state normal
        $p2.query configure -state normal
        $p2.queryprecalcul configure -state normal
        $p2.stop configure -state normal
    }
    #
    proc AlternaGraphicsIdentificationSelUnSelOne {w} {
        set c [$w itemcget current -fill]
        if {$c == "green"} {set color red} {set color green}
        $w itemconfigure current -fill $color
    }
    #
    proc AlternaGraphicsIdentificationOperation {w} {
        global S
        set operation [$w get]
        switch -glob $operation {
            "Leaf Foreground Color" {set S(operation) leaffgcolor }
            "Node Foreground Color" {set S(operation) nodefgcolor }
            "Leaf Background Color" {set S(operation) leafbgcolor }
            "Node Background Color" {set S(operation) nodebgcolor }
            "Leaf Illustration (columns)" {set S(operation) LillC ; Interface::PopUp Symbol}
            "Leaf Annotation (columns)" {set S(operation) LannC ; Interface::PopUp Text}
            "Query: Leaf Annotate (columns)" {set S(DisplayVOV) 0 ;  set S(operation) qLannC}
            "Query: Node Annotate" {set S(operation) insertvarval}
        }
    }
    #
    proc AlternaGraphicsIdentificationSelectAll {w} {
        $w itemconfigure t -fill green
    }
    #
    proc AlternaGraphicsIdentificationUnSelectAll {w} {
        $w itemconfigure t -fill red
    }
}
################################################################################


################################################################################
# ORIENTATION
################################################################################

namespace eval Orientation {
    ### proc ok(sauf conformation circulaire)
    ### nb : tourne sur T$t pour l'instant
    ### le menu/submenu "orientation" du menu contextuel TREE
    ### n'apparait pas si le type de l'arbre est circulaire
    ### pour etendre Anchor aux vues circulaires : integrer la gestion des arcs
    ### donc filtrer selon le type de l'item
    proc Anchor {w t} {
        global T S
        set co [$w bbox T$t]
        set wi [expr [lindex $co 2] - [lindex $co 0]]
        set he [expr [lindex $co 3] - [lindex $co 1]]
        set items [$w find withtag T$t]
        set b [$w bbox T$t]
        set x0 [lindex $b 3]
        set x0prim [lindex $b 0]
        foreach i $items {
            set ic [$w coords $i]
            set x1 [lindex $ic 0]
            set y1 [lindex $ic 1]
            set x2 [lindex $ic 2]
            set y2 [lindex $ic 3]
            switch [$w type $i] {
                line  {
                    $w coords $i [expr $x0 + ($x0 - $x1)] $y1 [expr $x0 + ($x0 - $x2)] $y2
                }
                text {
                    $w coords $i [expr $x0 + ($x0 - $x1)] $y1
                    $w itemconfigure $i -anchor e
                }
            }
        }
        $w move T$t [expr $x0prim - $x0] 0
        Figuration::RestaureT $w $t
    }
    ###
    proc AnchorVertical {w t} {
    }
}
################################################################################


################################################################################
# CONFORMATION
################################################################################
namespace eval Conformation {
    ### pour copy d'arbre
    proc ArrToCanType {t w} {
        global S
        set co [$w bbox [list Z && T$t]]
        set px [ expr [lindex $co 0] +2]
        set py [lindex $co 1]
        set wi   [expr [lindex $co 2] - [lindex $co 0] -3]
        set he   [expr [lindex $co 3] - [lindex $co 1] -2]
        $w delete T$t
        switch -exact $S($t,type) {
            PhyNJ {set S($t,type) PhyNJ ; Conformation::PhyNJ $t $w $wi $he}
            PhyRad {set S($t,type) PhyRad ; Conformation::PhyRad $t $w $wi $he}
            PhyCir1 {set S($t,type) PhyCir1 ; Conformation::PhyCir1 $t $w $wi $he}
            PhyCir2 {set S($t,type) PhyCir2 ; Conformation::PhyCir2 $t $w $wi $he}
            ClaRec {set S($t,type) ClaRec ; Conformation::ClaRec $t $w $wi $he}
            ClaSla {set S($t,type) ClaSla ; Conformation::ClaSla $t $w $wi $he}
            ClaRad {set S($t,type) ClaRad ; Conformation::ClaRad $t $w $wi $he}
            ClaCir1 {set S($t,type) ClaCir1  ; Conformation::ClaCir1 $t $w $wi $he}
            ClaCir2 {set S($t,type) ClaCir2 ; Conformation::ClaCir2 $t $w $wi $he}
            PhyCir1 {set S($t,type) PhyCir1 ; Conformation::PhyCir1 $t $w $wi $he}
            PhyCir2 {set S($t,type) PhyCir2 ; Conformation::PhyCir2 $t $w $wi $he}
            ClaCir5 {set S($t,type) ClaCir5 ; Conformation::ClaCir5 $t $w $wi $he}
            default {set S($t,type) PhyNJ ; Conformation::PhyNJ  $t $w $wi $he}
        }
        $w move T$t $px $py
        Figuration::RestaureT $w $t
    }
    ### on force la position et la taille , par exemple pour les navigateurs
    proc ArrToCanType2 {t w {px 0} {py 0} {wi 150} {he 150}} {
        global S
        switch -exact $S($t,type) {
            PhyNJ {set S($t,type) PhyNJ ; Conformation::PhyNJ $t $w $wi $he}
            PhyRad {set S($t,type) PhyRad ; Conformation::PhyRad $t $w $wi $he}
            PhyCir1 {set S($t,type) PhyCir1 ; Conformation::PhyCir1 $t $w $wi $he}
            PhyCir2 {set S($t,type) PhyCir2 ; Conformation::PhyCir2 $t $w $wi $he}
            ClaRec {set S($t,type) ClaRec ; Conformation::ClaRec $t $w $wi $he}
            ClaSla {set S($t,type) ClaSla ; Conformation::ClaSla $t $w $wi $he}
            ClaRad {set S($t,type) ClaRad ; Conformation::ClaRad $t $w $wi $he}
            ClaCir1 {set S($t,type) ClaCir1  ; Conformation::ClaCir1 $t $w $wi $he}
            ClaCir2 {set S($t,type) ClaCir2 ; Conformation::ClaCir2 $t $w $wi $he}
            ClaCir3 {set S($t,type) ClaCir3 ; Conformation::ClaCir3 $t $w $wi $he}
            
            default {set S($t,type) PhyNJ ; Conformation::PhyNJ  $t $w  $wi $he}
        }
        $w move T$t $px $py
        # pas de variable a restaurer
    }
    ### on force la position et la taille , par exemple pour les navigateurs
    proc ArrToCanType3 {t w {px 0} {py 0} {wi 150} {he 150}} {
        global S
        $w delete T$t
        switch -exact $S($t,type) {
            PhyNJ {set S($t,type) PhyNJ ; Conformation::PhyNJ $t $w $wi $he}
            PhyRad {set S($t,type) PhyRad ; Conformation::PhyRad $t $w $wi $he}
            PhyCir1 {set S($t,type) PhyCir1 ; Conformation::PhyCir1 $t $w $wi $he}
            PhyCir2 {set S($t,type) PhyCir2 ; Conformation::PhyCir2 $t $w $wi $he}
            ClaRec {set S($t,type) ClaRec ; Conformation::ClaRec $t $w $wi $he}
            ClaSla {set S($t,type) ClaSla ; Conformation::ClaSla $t $w $wi $he}
            ClaRad {set S($t,type) ClaRad ; Conformation::ClaRad $t $w $wi $he}
            ClaCir1 {set S($t,type) ClaCir1  ; Conformation::ClaCir1 $t $w $wi $he}
            ClaCir2 {set S($t,type) ClaCir2 ; Conformation::ClaCir2 $t $w $wi $he}
            ClaCir3 {set S($t,type) ClaCir3 ; Conformation::ClaCir3 $t $w $wi $he}
            
            default {set S($t,type) PhyNJ ; Conformation::PhyNJ  $t $w  $wi $he}
        }
        $w move T$t $px $py
        # pas de variable a restaurer
    }
    ### pour changements de conformation
    proc ArrToCanSwitch {t w vers} {
        global S
        set co [$w bbox [list Z && T$t]]
        set px [lindex $co 0]
        set py [lindex $co 1]
        set wi   [expr [lindex $co 2] - [lindex $co 0]]
        set he   [expr [lindex $co 3] - [lindex $co 1]]
        $w delete T$t
        switch -exact $vers {
            PhyNJ {set S($t,type) PhyNJ ; Conformation::PhyNJ $t $w $wi $he}
            PhyRad {set S($t,type) PhyRad ; Conformation::PhyRad $t $w $wi $he}
            PhyCir1 {set S($t,type) PhyCir1 ; Conformation::PhyCir1 $t $w $wi $he}
            PhyCir2 {set S($t,type) PhyCir2 ; Conformation::PhyCir2 $t $w $wi $he}
            ClaRec {set S($t,type) ClaRec ; Conformation::ClaRec $t $w $wi $he}
            ClaSla {set S($t,type) ClaSla ; Conformation::ClaSla $t $w $wi $he}
            ClaRad {set S($t,type) ClaRad ; Conformation::ClaRad $t $w $wi $he}
            ClaCir1 {set S($t,type) ClaCir1  ; Conformation::ClaCir1 $t $w $wi $he}
            ClaCir2 {set S($t,type) ClaCir2 ; Conformation::ClaCir2 $t $w $wi $he}
            ClaCir3 {set S($t,type) ClaCir3 ; Conformation::ClaCir3 $t $w $wi $he}
            
        }
        $w move T$t $px $py
        Figuration::RestaureT $w $t
    }
    proc SwitchConfiguration {w x y configuration} {
        global S
        set id [$w find closest $x $y]
        set tags [$w gettags $id]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set co [$w bbox [list Z && T$t]]
        set px [lindex $co 0]
        set py [lindex $co 1]
        set wi   [expr [lindex $co 2] - [lindex $co 0]]
        set he   [expr [lindex $co 3] - [lindex $co 1]]
        $w delete T$t
        switch -exact $configuration {
            PhyNJ {
                set S($t,type) PhyNJ ; Conformation::PhyNJ $t $w $wi $he}
            PhyRad {set S($t,type) PhyRad ; Conformation::PhyRad $t $w $wi $he}
            PhyCir1 {set S($t,type) PhyCir1
                set S(gfo) {Helvetica 6 normal}
                if {$wi <= $he} {set taille $wi} {set taille $he}
                Conformation::PhyCir1 $t $w $taille $taille
            }
            PhyCir2 {set S($t,type) PhyCir2 ; Conformation::PhyCir2 $t $w $wi $he}
            ClaRec {set S(gfo) {Helvetica 6 normal}
                set S($t,type) ClaRec ; Conformation::ClaRec $t $w $wi $he}
            ClaSla {set S($t,type) ClaSla ; Conformation::ClaSla $t $w $wi $he}
            ClaRad {set S($t,type) ClaRad ; Conformation::ClaRad $t $w $wi $he}
            ClaCir1 {
                set S(gfo) {Helvetica 6 normal}
                if {$wi <= $he} {set taille $wi} {set taille $he}
                set S($t,type) ClaCir1  ; Conformation::ClaCir1 $t $w $taille $taille}
            ClaCir2 {
                set S(gfo) {Helvetica 6 normal}
                if {$wi <= $he} {set taille $wi} {set taille $he}
                set S($t,type) ClaCir2 ; Conformation::ClaCir2 $t $w $taille $taille}
            ClaCir3 {
                set S(gfo) {Helvetica 6 normal}
                #set avant $S($t,display_eu)
                #set S($t,display_eu) hidden
                if {$wi <= $he} {set taille $wi} {set taille $he}
                set S($t,type) ClaCir3 ; Conformation::ClaCir3 $t $w $taille $taille
                #set S($t,display_eu) $avant
            }
        }
        $w move T$t $px $py
        Figuration::RestaureT $w $t
        set S(tool) move
        bindtags $w [list $S(tool) $w Canvas . all]
    }
    ### pour changements de conformation
    proc ArrToCanSwitch2 {t w vers {px 0} {py 0} {wi 150} {he 150}} {
        global S
        switch -exact $vers {
            PhyNJ {set S($t,type) PhyNJ ; Conformation::PhyNJ $t $w $wi $he}
            PhyRad {set S($t,type) PhyRad ; Conformation::PhyRad $t $w $wi $he}
            PhyCir1 {set S($t,type) PhyCir1 ; Conformation::PhyCir1 $t $w $wi $he}
            PhyCir2 {set S($t,type) PhyCir2 ; Conformation::PhyCir2 $t $w $wi $he}
            ClaRec {set S($t,type) ClaRec ; Conformation::ClaRec $t $w $wi $he}
            ClaSla {set S($t,type) ClaSla ; Conformation::ClaSla $t $w $wi $he}
            ClaRad {set S($t,type) ClaRad ; Conformation::ClaRad $t $w $wi $he}
            ClaCir1 {set S($t,type) ClaCir1  ; Conformation::ClaCir1 $t $w $wi $he}
            ClaCir2 {set S($t,type) ClaCir2 ; Conformation::ClaCir2 $t $w $wi $he}
            ClaCir3 {set S($t,type) ClaCir3 ; Conformation::ClaCir3 $t $w $wi $he}
        }
        $w move T$t $px $py
    }
    
    #set t3 [format "%s%s" T $t ]
    
    # CODE feuille 1g1g2d3g4g5g6g7g8g
    # CODE DE GENERATION 1g1g2d3g4d5g6g7g8g9d10
    ###
    proc ClaSla {t w  {posx 0} {posy 0}  {largeur 200} {hauteur 200} } {
        global T S
        set y 0
        set dy [expr round(double($hauteur)  / [llength $T($t,ue_cod)]) ]
        set dx [expr double($largeur) / $T($t,tot)]
        ### EU
        foreach i $T($t,ue_cod) {
            incr y $dy
            set G($i,x) $largeur
            set G($i,y) $y
            $w create text $G($i,x) $G($i,y) -text $T($t,ctl,$i) -anchor w
        }
        ###
        
        
        foreach b $T($t,cbg,[expr $T($t,tot) - 1 ]) {
            set bg [format "%s%s" $b g]
            set bd [format "%s%s" $b d]
            set xG $G($bg,x)
            set yG $G($bg,y)
            set xD $G($bd,x)
            set yD $G($bd,y)
            set xp [expr ($yG - $yD)+(( $xG + $xD )/ 2.0)]
            set yp [expr ((($yD + $yG)/ 2.0)+(($xG - $xD )/ 4.0))]
            $w create line $xp $yp $xG $yG
            $w create line $xp $yp $xD $yD
            set G($b,x) $xp
            set G($b,y) $yp
        }
        
        for {set i [expr $T($t,tot) - 2 ]} {$i >= 1} {incr i -1} {
            foreach b $T($t,cbg,$i) {
                set bg [format "%s%s" $b g]
                set bd [format "%s%s" $b d]
                set xG $G($bg,x)
                set yG $G($bg,y)
                set xD $G($bd,x)
                set yD $G($bd,y)
                set xp [expr ($yG - $yD)+(( $xG + $xD )/ 2.0)]
                set yp [expr ((($yD + $yG)/ 2.0)+(($xG - $xD )/ 4.0))]
                $w create line $xp $yp $xG $yG
                $w create line $xp $yp $xD $yD
                set G($b,x) $xp
                set G($b,y) $yp
                
            }
        }
        $w configure -scrollregion [$w bbox all]
    }
    ### idem Phyrad sauf longeur de branche fixe
    proc ClaRad {t w  {largeur 200} {hauteur 200} } {
        global T S G
        set nb  [llength $T($t,ue_cod)]
        set x0 [expr $largeur/2.0]
        set y0 [expr $hauteur/2.0]
        if {$x0 <= $y0} {set R $x0} {set R $y0}
        set pi2 [expr 2 * acos(-1)]
        set f [expr $R / $T($t,xmax)]
        set dd [expr ((acos(-1)) * [expr 360.0 / $nb])/ 180.0]
        set S($t,a_uni) $dd
        set td [format "%s%s" $t d]
        set tg [format "%s%s" $t g]
        set nbg [Tools::NodeNoToLeNum $t $tg]
        set nbd [Tools::NodeNoToLeNum $t $td]
        #  $t d
        set G($td,a_amplitude) [expr $nbd * $dd]
        set G($td,a_from) 0
        set G($td,a_to) [expr $G($td,a_from) + $G($td,a_amplitude) ]
        set G($td,a) [expr $G($td,a_from) + ($G($td,a_amplitude) / 2.0)]
        #set G($td,x) [expr $T($t,dbl,$td) * $f * cos($G($td,a))]
        #set G($td,y) [expr $T($t,dbl,$td) * $f * sin($G($td,a))]
        set G($td,x) [expr 100 * $f * cos($G($td,a))]
        set G($td,y) [expr 100 * $f * sin($G($td,a))]
        # $t g
        set G($tg,a_amplitude) [expr $nbg * $dd]
        set G($tg,a_from) $G($td,a_to)
        set G($tg,a_to) [expr $G($tg,a_from) + $G($tg,a_amplitude) ]
        set G($tg,a) [expr $G($tg,a_from) + ($G($tg,a_amplitude) / 2.0)]
        # set G($tg,x) [expr $T($t,dbl,$tg) * $f * cos($G($tg,a))]
        # set G($tg,y) [expr $T($t,dbl,$tg) * $f * sin($G($tg,a))]
        set G($tg,x) [expr 100 * $f * cos($G($tg,a))]
        set G($tg,y) [expr 100 * $f * sin($G($tg,a))]
        # tags
        set tag1 [format "%s%s" $t C]
        set tag2 [format "%s%s" $t C]
        set tag11 [format "%s%s" $td C]
        set tag22 [format "%s%s" $tg C]
        # trace $td & $tg
        $w create line 0 0 $G($tg,x) $G($tg,y) -tags "$tag1 $tag11 T$t Z" -fill $S(Preference_fgc)
        $w create line 0 0 $G($td,x) $G($td,y) -tags "$tag2 $tag22 T$t Z" -fill $S(Preference_fgc)
        #
        for {set i 1} {$i < $T($t,tot)} {incr i} {
            foreach b $T($t,cbg,$i) {
                set j [string trimright $b {[0123456789]}]
                set bd [format "%s%s" $b d]
                set bg [format "%s%s" $b g]
                set nbg [Tools::NodeNoToLeNum $t $bg]
                set nbd [Tools::NodeNoToLeNum $t $bd]
                # D
                set G($bd,a_amplitude) [expr $nbd * $dd]
                set G($bd,a_from) $G($j,a_from)
                set G($bd,a_to) [expr $G($bd,a_from) + $G($bd,a_amplitude) ]
                set G($bd,a) [expr $G($bd,a_from) + ($G($bd,a_amplitude) / 2.0)]
                set gamma [expr abs($G($j,a) - $G($bd,a))]
                #set a [expr cos($gamma) * $T($t,dbl,$j)]
                #set b2 [expr sin($gamma) * $T($t,dbl,$j)]
                set a [expr cos($gamma) * 100]
                set b2 [expr sin($gamma) * 100]
                #set c [expr sqrt( abs (($T($t,dbl,$bd) * $T($t,dbl,$bd)) - ($b2 * $b2) ))]
                set c [expr sqrt( abs ((100 * 100) - ($b2 * $b2) ))]
                set L [expr $c + $a]
                set G($bd,x) [expr $G($j,x) + $f * cos($G($bd,a)) * $L]
                set G($bd,y) [expr $G($j,y) + $f * sin($G($bd,a)) * $L]
                # G
                set G($bg,a_amplitude) [expr $nbg * $dd]
                set G($bg,a_from) $G($bd,a_to)
                set G($bg,a_to) [expr $G($bg,a_from) + $G($bg,a_amplitude) ]
                set G($bg,a) [expr $G($bg,a_from) + ($G($bg,a_amplitude) / 2.0)]
                set gamma [expr abs($G($j,a) - $G($bg,a))]
                #set a [expr cos($gamma) * $T($t,dbl,$j)]
                #set b2 [expr sin($gamma) * $T($t,dbl,$j)]
                set a [expr cos($gamma) * 100]
                set b2 [expr sin($gamma) * 100]
                #set c [expr sqrt( abs( ($T($t,dbl,$bg)*$T($t,dbl,$bg)) - ($b2 * $b2) ))]
                set c [expr sqrt( abs( (100*100) - ($b2 * $b2) ))]
                set L [expr $c + $a]
                set G($bg,x) [expr $G($j,x) + $f * cos($G($bg,a)) * $L]
                set G($bg,y) [expr $G($j,y) + $f * sin($G($bg,a)) * $L]
                # tags
                set t2 [format "%s%s" $j C]
                # trace
                $w create line $G($j,x) $G($j,y) $G($bg,x) $G($bg,y) -tags "$j $t2 T$t Z" -fill $S(Preference_fgc)
                $w create line $G($j,x) $G($j,y) $G($bd,x) $G($bd,y) -tags "$j $t2 T$t Z" -fill $S(Preference_fgc)
            }
        }
        # Leaf Names
        if {$S($t,display_eu) == 1} {
            foreach i $T($t,ue_cod) {
                $w create text $G($i,x) $G($i,y) -text $T($t,ctl,$i) \
                        -tags "T$t  [format "%s%s" EUL $T($t,ctl,$i) ] N$t L"  \
                        -font $S(fontbase) -state $S($t,display_eu)
            }
        }
        # centrage et scrollregion
        $w move T$t $x0 $y0
        $w configure -scrollregion [$w bbox all]
        unset G
    }
    ### comme sans PhyNJ sans les longueurs de branches
    proc ClaRec {t w  {largeur 200} {hauteur 200}} {
        global T S
        set y 0
        set nb [llength $T($t,ue_cod)]
        set fy [expr double($hauteur)  / $nb ]
        set longeurbranche [expr double($largeur) / $T($t,tot)]
        #set fx [expr double($largeur) / $T($t,tot)]
        set n 0
        set t3 [format "%s%s" T $t ]
        ### EU
        foreach i $T($t,ue_cod) {
            incr n
            set y [expr $n * $fy ]
            # set j [string range $bg 0 [expr [string last $i $bg] - 1]]
            # chercher la profondeur de la feuille   1g1g2g
            regsub -all {g|d} $i {-} newi
            set ni3 [string range $newi 0 end-1]
            set nni [lindex [split $ni3 -] end]
            #set nni [string range $ni3 [string last $ni3 -] end-1]
            # c 2
            set G($i,x) [expr $largeur - ($longeurbranche * ($T($t,tot) - $nni)) ]
            #set G($i,x) [expr $largeur - ($longeurbranche *  $nni) ]
            set G($i,y) $y
            set t2 [format "%s%s" EU $T($t,ctl,$i) ]
            set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
            set t2bis [format "%s%s" $i C]
            $w create line $largeur $G($i,y) $G($i,x) $G($i,y)  \
                    -tags "$i $t2 $t3 $t2bis Z" -fill $S(Preference_fgc)
            regsub -all {¶} $T($t,ctl,$i) " " texto
            $w create text [expr $largeur  + 2]  $G($i,y) \
                    -text  $texto -anchor w   \
                    -tags " $t3 $t4 L" \
                    -font $S(fontbase) -state $S($t,display_eu)
        }
        ### NODES
        for {set i [expr $T($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            foreach b $T($t,cbg,$i) {
                set bg [format "%s%s" $b g]
                set bd [format "%s%s" $b d]
                set yn [expr $G($bg,y) - (($G($bg,y) - $G($bd,y)) / 2)]
                set j [string range $bg 0 [expr [string last $i $bg] - 1]]
                set t2 [format "%s%s" $j C]
                # Vertical
                $w create line $G($bg,x) $G($bg,y) $G($bg,x) $G($bd,y) -tags "$t2 $t3 Z" -fill $S(Preference_fgc)
                # Horizontal
                set G($j,x) [expr $G($bg,x) - $longeurbranche]
                $w create line $G($bg,x) $yn $G($j,x) $yn  -tags "$j $t2 $t3 Z" -fill $S(Preference_fgc)
                set G($j,y) $yn
            }
        }
        ### ROOT
        set ch [$w coords [format "%s%s" $t g]]
        set cb [$w coords [format "%s%s" $t d]]
        set yh [lrange $ch 1 1]
        set yb [lrange $cb 3 3]
        set x [lrange $ch 2 2]
        set yn [expr $yh - (($yh - $yb) / 2)]
        # Vertical
        $w create line $x $yh $x $yb -tags "[format "%s%s" $t C] $t3 Z" -fill $S(Preference_fgc)
        # scrollregion
        $w configure -scrollregion [$w bbox all]
    }
    ###
    proc PhyNJ {t w  {largeur 200} {hauteur 200}} {
        global T S
        set y 0
        set nb [llength $T($t,ue_cod)]
        set fy [expr double($hauteur)  / $nb ]
        set fx [expr double($largeur) / $T($t,xmax)]
        set n 0
        set t3 [format "%s%s" T $t ]
        ### EU
        foreach i $T($t,ue_cod) {
            incr n
            
            set y [expr $n * $fy ]
            set G($i,x) [expr ($T($t,sox,$i) - $T($t,dbl,$i) )* $fx]
            set G($i,y) $y
            set t2 [format "%s%s" EU $T($t,ctl,$i) ]
            set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
            set t2bis [format "%s%s" $i C]
            $w create line [expr $T($t,sox,$i) * $fx] $G($i,y) $G($i,x) $G($i,y)  \
                    -tags "$i $t2 $t3 $t2bis Z" -fill $S(Preference_fgc)
            regsub -all {¶} $T($t,ctl,$i) " " texto
            $w create text [expr ($T($t,sox,$i) * $fx) + 2]  $G($i,y) \
                    -text  $texto -anchor w   \
                    -tags " $t3 $t4 L" \
                    -font $S(fontbase) -state $S($t,display_eu)
        }
        ### NODES
        for {set i [expr $T($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            foreach b $T($t,cbg,$i) {
                set bg [format "%s%s" $b g]
                set bd [format "%s%s" $b d]
                #************************************************************* PB SWAP
                set yn [expr $G($bg,y) - (($G($bg,y) - $G($bd,y)) / 2)]
                #*************************************************************
                set j [string range $bg 0 [expr [string last $i $bg] - 1]]
                set t2 [format "%s%s" $j C]
                # Vertical
                $w create line $G($bg,x) $G($bg,y) $G($bg,x) $G($bd,y) -tags "$t2 $t3 Z" -fill $S(Preference_fgc)
                # Horizontal
                set G($j,x) [expr $G($bg,x) - ($T($t,dbl,$j) * $fx)]
                $w create line $G($bg,x) $yn $G($j,x) $yn  -tags "$j $t2 $t3 Z" -fill $S(Preference_fgc)
                set G($j,y) $yn
            }
        }
        ### ROOT
        set ch [$w coords [format "%s%s" $t g]]
        set cb [$w coords [format "%s%s" $t d]]
        set yh [lrange $ch 1 1]
        set yb [lrange $cb 3 3]
        set x [lrange $ch 2 2]
        set yn [expr $yh - (($yh - $yb) / 2)]
        # Vertical
        $w create line $x $yh $x $yb -tags "[format "%s%s" $t C] $t3 Z" -fill $S(Preference_fgc)
        # scrollregion
        $w configure -scrollregion [$w bbox all]
        # modif 4 mars 2003, avant pas unset G cela cachait un bug
        
        unset G
    }
    ### PhyRad descendant
    proc PhyRad {t w {largeur 200} {hauteur 200} } {
        global T S G
        set nb  [llength $T($t,ue_cod)]
        set x0 [expr $largeur/2.0]
        set y0 [expr $hauteur/2.0]
        if {$x0 <= $y0} {set R $x0} {set R $y0}
        set pi2 [expr 2 * acos(-1)]
        set f [expr $R / $T($t,xmax)]
        set dd [expr ((acos(-1)) * [expr 360.0 / $nb])/ 180.0]
        set S($t,a_uni) $dd
        set td [format "%s%s" $t d]
        set tg [format "%s%s" $t g]
        set nbg [Tools::NodeNoToLeNum $t $tg]
        set nbd [Tools::NodeNoToLeNum $t $td]
        #  $t d
        set G($td,a_amplitude) [expr $nbd * $dd]
        #set G($td,a_from) 0 modification pour la rotation
        set G($td,a_from) $S($t,a_ori)
        set G($td,a_to) [expr $G($td,a_from) + $G($td,a_amplitude) ]
        #set G($td,a) [expr $G($td,a_from) + ($G($td,a_amplitude) / 2.0)]
        set G($td,a) [expr ($G($td,a_from) + ($G($td,a_amplitude) / 2.0)) + $S($t,a_ori)]
        set G($td,x) [expr $T($t,dbl,$td) * $f * cos($G($td,a))]
        set G($td,y) [expr $T($t,dbl,$td) * $f * sin($G($td,a))]
        # $t g
        set G($tg,a_amplitude) [expr $nbg * $dd]
        set G($tg,a_from) $G($td,a_to)
        set G($tg,a_to) [expr $G($tg,a_from) + $G($tg,a_amplitude) ]
        #set G($tg,a) [expr $G($tg,a_from) + ($G($tg,a_amplitude) / 2.0)]
        set G($tg,a) [expr ($G($tg,a_from) + ($G($tg,a_amplitude) / 2.0)) + $S($t,a_ori)]
        set G($tg,x) [expr $T($t,dbl,$tg) * $f * cos($G($tg,a))]
        set G($tg,y) [expr $T($t,dbl,$tg) * $f * sin($G($tg,a))]
        # tags
        set tag1 [format "%s%s" $t C]
        set tag2 [format "%s%s" $t C]
        set tag11 [format "%s%s" $tg C]
        set tag22 [format "%s%s" $td C]
        # trace $td & $tg
        $w create line 0 0 $G($tg,x) $G($tg,y) -tags "$tag1 $tag11  T$t Z" -fill $S(Preference_fgc)
        $w create line 0 0 $G($td,x) $G($td,y) -tags "$tag2 $tag22  T$t Z" -fill $S(Preference_fgc)
        #
        for {set i 1} {$i < $T($t,tot)} {incr i} {
            foreach b $T($t,cbg,$i) {
                set j [string trimright $b {[0123456789]}]
                set bd [format "%s%s" $b d]
                set bg [format "%s%s" $b g]
                set nbg [Tools::NodeNoToLeNum $t $bg]
                set nbd [Tools::NodeNoToLeNum $t $bd]
                # D
                set G($bd,a_amplitude) [expr $nbd * $dd]
                set G($bd,a_from) $G($j,a_from)
                set G($bd,a_to) [expr $G($bd,a_from) + $G($bd,a_amplitude) ]
                set G($bd,a) [expr $G($bd,a_from) + ($G($bd,a_amplitude) / 2.0)]
                set gamma [expr abs($G($j,a) - $G($bd,a))]
                set a [expr cos($gamma) * $T($t,dbl,$j)]
                set b2 [expr sin($gamma) * $T($t,dbl,$j)]
                set c [expr sqrt( abs (($T($t,dbl,$bd) * $T($t,dbl,$bd)) - ($b2 * $b2) ))]
                set L [expr $c + $a]
                set G($bd,x) [expr $G($j,x) + $f * cos($G($bd,a)) * $L]
                set G($bd,y) [expr $G($j,y) + $f * sin($G($bd,a)) * $L]
                # G
                set G($bg,a_amplitude) [expr $nbg * $dd]
                set G($bg,a_from) $G($bd,a_to)
                set G($bg,a_to) [expr $G($bg,a_from) + $G($bg,a_amplitude) ]
                set G($bg,a) [expr $G($bg,a_from) + ($G($bg,a_amplitude) / 2.0)]
                set gamma [expr abs($G($j,a) - $G($bg,a))]
                set a [expr cos($gamma) * $T($t,dbl,$j)]
                set b2 [expr sin($gamma) * $T($t,dbl,$j)]
                set c [expr sqrt( abs( ($T($t,dbl,$bg)*$T($t,dbl,$bg)) - ($b2 * $b2) ))]
                set L [expr $c + $a]
                set G($bg,x) [expr $G($j,x) + $f * cos($G($bg,a)) * $L]
                set G($bg,y) [expr $G($j,y) + $f * sin($G($bg,a)) * $L]
                # tags
                set t2 [format "%s%s" $j C]
                # trace
                $w create line $G($j,x) $G($j,y) $G($bg,x) $G($bg,y) \
                        -tags "[format "%s%s" $bg C] $bg T$t Z" -fill $S(Preference_fgc)
                $w create line $G($j,x) $G($j,y) $G($bd,x) $G($bd,y) \
                        -tags "[format "%s%s" $bd C] $bd T$t Z" -fill $S(Preference_fgc)
            }
        }
        # Leaf Names
        #if {$S($t,display_eu) == 1} {
        foreach i $T($t,ue_cod) {
            regsub -all {¶} $T($t,ctl,$i) " " texto
            $w create text $G($i,x) $G($i,y) -text $texto \
                    -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ]  L"  \
                    -font $S(fontbase) -state $S($t,display_eu)
        }
        #}
        # ajout tag des arretes terminales (eu)
        foreach i $T($t,ue_cod) {
            set t2 [format "%s%s" EU $T($t,ctl,$i)]
            $w addtag $t2 withtag [list $i && T$t]
            $w addtag Z withtag [list $i && T$t]
        }
        # centrage et scrollregion
        $w move T$t $x0 $y0
        $w configure -scrollregion [$w bbox all]
        unset G
    }
    ###
    proc PhyNJfXY {t w  fx fy} {
        global T S
        set y 0
        set nb [llength $T($t,ue_cod)]
        set n 0
        set t3 [format "%s%s" T $t ]
        ### EU
        foreach i $T($t,ue_cod) {
            incr n
            set y [expr $n * $fy ]
            set t2 [format "%s%s" EU $T($t,ctl,$i) ]
            set t2bis [format "%s%s" $i C]
            set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
            set G($i,x) [expr ($T($t,sox,$i) - $T($t,dbl,$i) )* $fx]
            set G($i,y) $y
            $w create line [expr $T($t,sox,$i) * $fx] $G($i,y) $G($i,x) $G($i,y)  \
                    -tags "$i $t2 $t3 $t2bis Z" -fill $S(Preference_fgc)
            regsub -all {¶} $T($t,ctl,$i) " " texto
            $w create text [expr ($T($t,sox,$i) * $fx) + 2]  $G($i,y) \
                    -text  $texto -anchor w   \
                    -tags "$t4 $t3 $t2bis S3" \
                    -font $S(gfo) -state $S($t,display_eu)
        }
        ### NODES
        for {set i [expr $T($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            foreach b $T($t,cbg,$i) {
                set bg [format "%s%s" $b g]
                set bd [format "%s%s" $b d]
                set yn [expr $G($bg,y) - (($G($bg,y) - $G($bd,y)) / 2)]
                set j [string range $bg 0 [expr [string last $i $bg] - 1]]
                set t2 [format "%s%s" $j C]
                # Vertical
                $w create line $G($bg,x) $G($bg,y) $G($bg,x) $G($bd,y) -tags "$t2 $t3 Z" -fill $S(Preference_fgc)
                # Horizontal
                set G($j,x) [expr $G($bg,x) - ($T($t,dbl,$j) * $fx)]
                $w create line $G($bg,x) $yn $G($j,x) $yn  -tags "$j $t2 $t3 Z" -fill $S(Preference_fgc)
                set G($j,y) $yn
            }
        }
        ### ROOT
        set ch [$w coords [format "%s%s" $t g]]
        set cb [$w coords [format "%s%s" $t d]]
        set yh [lrange $ch 1 1]
        set yb [lrange $cb 3 3]
        set x [lrange $ch 2 2]
        set yn [expr $yh - (($yh - $yb) / 2)]
        # Vertical
        $w create line $x $yh $x $yb -tags "[format "%s%s" $t C] $t3 Z" -fill $S(Preference_fgc)
        #scrollregion
        $w configure -scrollregion [$w bbox all]
    }
    #
    proc displayeuRadial {w t} {
        global T S
        set co [$w bbox [list Z && T$t]]
        set largeur   [expr [lindex $co 2] - [lindex $co 0] -3]
        set hauteur   [expr [lindex $co 3] - [lindex $co 1] -2]
        set basedegre [expr 360.0 / [llength $T($t,ue_cod)]]
        set dd [expr ((acos(-1)) * $basedegre)/ 180.0 ]
        set S($t,a_uni) $dd
        set xcenter [expr double($largeur)/2]
        set ycenter [expr double($hauteur)/2]
        if {$xcenter <= $ycenter} {set D $xcenter} {set D $ycenter}
        set R [expr $D / 2] ;# en faire une variable user ?
        set step [expr ($D - $R) / $T($t,tot) ]
        set n 0
        ### EU
        foreach i $T($t,ue_cod) {
            set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
            set x [expr ($R * cos($G($i,a))) ]
            set y [expr ($R * sin($G($i,a))) + $ycenter]
            set angledegre [expr ($G($i,a) * 360) / 6.283185]
            set G($i,x) $x
            set G($i,y) $y
            set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
            # retrait leaf initial
            $w delete $t4
            set ls [split $T($t,ctl,$i) {}]
            if {$angledegre >= 90 && $angledegre < 270} {
                set an e
                set b [expr 3 * [llength $ls]]
                foreach s $ls {
                    set x [expr (($R + $b) * cos($G($i,a))) + $xcenter]
                    set y [expr (($R + $b) * sin($G($i,a))) + $ycenter]
                    $w create text $x $y \
                            -text  $s -anchor $an   \
                            -tags "T$t $t4 L" \
                            -font $S(fontbase) -state $S($t,display_eu)
                    incr b -3
                }
            } else {
                set an w
                set b 0
                foreach s $ls {
                    set x [expr (($R + $b) * cos($G($i,a))) + $xcenter]
                    set y [expr (($R + $b) * sin($G($i,a))) + $ycenter]
                    $w create text $x $y \
                            -text  $s -anchor $an   \
                            -tags "T$t $t4 L" \
                            -font $S(fontbase) -state $S($t,display_eu)
                    incr b 3
                }
            }
            incr n
        }
    }
    # retoucher afin de tourner ds le sens trigonometrique
    proc ClaCir1 {t w {largeur 200} {hauteur 200}} {
        global T S
        set basedegre [expr 360.0 / [llength $T($t,ue_cod)]]
        set dd [expr ((acos(-1)) * $basedegre)/ 180.0 ]
        set S($t,a_uni) $dd
        set xcenter [expr double($largeur)/2]
        set ycenter [expr double($hauteur)/2]
        #if {$xcenter <= $ycenter} {set D $xcenter} {set D $ycenter}
        
        
        if {$xcenter <= $ycenter} {set D $ycenter} {set D $xcenter}
        set R [expr $D / 2] ;# en faire une variable user ?
        set step [expr $R / $T($t,tot) ]
        #set step [expr ($D - $R) / $T($t,tot) ]
        set n 0
        ### EU
        foreach i $T($t,ue_cod) {
            #incr n
            set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
            set x [expr ($R * cos($G($i,a)))]
            set y [expr ($R * sin($G($i,a)))]
            # orientation des feuilles
            set angledegre [expr ($G($i,a) * 360) / 6.283185]
            if {$angledegre >= 90 && $angledegre < 270} {
                set an e
                
            } else {
                set an w
            }
            set G($i,x) $x
            set G($i,y) $y
            set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
            # feuilles en radial
            regsub -all {¶} $T($t,ctl,$i) " " texto
            set ls [split $texto {}]
            set an center ;# anchor
            set ju center ;# justification
            if {$angledegre >= 90 && $angledegre < 270} {
                set b [expr 6 * [llength $ls]]
                foreach s $ls {
                    set x [expr (($R + $b) * cos($G($i,a))) ]
                    set y [expr (($R + $b) * sin($G($i,a))) ]
                    $w create text $x $y \
                            -text  $s -anchor $an -justify $ju \
                            -tags "T$t $t4 L" \
                            -font $S(gfo) -state $S($t,display_eu)
                    incr b -6
                }
            } else {
                set b 2
                foreach s $ls {
                    set x [expr (($R + $b) * cos($G($i,a))) ]
                    set y [expr (($R + $b) * sin($G($i,a))) ]
                    $w create text $x $y \
                            -text  $s -anchor $an  -justify $ju  \
                            -tags "T$t $t4 L" \
                            -font $S(gfo) -state $S($t,display_eu)
                    incr b 6
                }
            }
            incr n
        }
        ### NODES
        set step [expr $R / $T($t,tot)]
        for {set i [expr $T($t,tot) - 1 ]  } {$i >= 1} {incr i -1} {
            # rho le rayon du cercle du niveau i
            set rho [expr $R - ($step * ($T($t,tot) - $i))]
            # set rho [expr $rho + $step]
            foreach b $T($t,cbg,$i) {
                set j [string trimright $b {[0123456789]}]
                #
                set bg [format "%s%s" $b g]
                set x2g [expr $rho * cos($G($bg,a)) ]
                set y2g [expr $rho * sin($G($bg,a)) ]
                #$w create line  $G($bg,x) $G($bg,y) $x2g $y2g -tags "[format "%s%s" $bg C] $bg T$t Z"
                $w create line $x2g $y2g  $G($bg,x) $G($bg,y) -tags "[format "%s%s" $bg C] $bg T$t Z" \
                        -fill $S(Preference_fgc)
                #
                set bd [format "%s%s" $b d]
                set x2d [expr ($rho * cos($G($bd,a))) ]
                set y2d [expr ($rho * sin($G($bd,a))) ]
                #$w create line $G($bd,x) $G($bd,y) $x2d $y2d  -tags "[format "%s%s" $bd C] $bd T$t Z"
                $w create line $x2d $y2d $G($bd,x) $G($bd,y)  -tags "[format "%s%s" $bd C] $bd T$t Z" \
                        -fill $S(Preference_fgc)
                #
                set G($j,a) [expr ($G($bg,a) + $G($bd,a)) / 2.0  ]
                set G($j,x) [expr ($rho * cos($G($j,a))) ]
                set G($j,y) [expr ($rho * sin($G($j,a))) ]
                #
                set ad [expr (180.0 * $G($bd,a)) / acos(-1)]
                set ag [expr (180.0 * $G($bg,a)) / acos(-1)]
                $w create arc [expr 0 - $rho] $rho $rho [expr 0 - $rho]    \
                        -start -$ad -extent [expr $ad - $ag] -style arc  \
                        -tags "[format "%s%s" $j C] T$t Z" -outline $S(Preference_fgc)
            }
        }
        # ROOT
        set rho [expr $R - ($step * $T($t,tot)) ]
        set j $t
        set t2 [format "%s%s" $j C]
        #
        set bg [format "%s%s" $t g]
        set x2g [expr ($rho * cos($G($bg,a)))]
        set y2g [expr ($rho * sin($G($bg,a)))]
        #$w create line  $G($bg,x) $G($bg,y) $x2g $y2g -tags "[format "%s%s" $bg C] $bg T$t Z"
        $w create line  $x2g $y2g  $G($bg,x) $G($bg,y) -tags "[format "%s%s" $bg C] $bg T$t Z" \
                -fill $S(Preference_fgc)
        #
        set bd [format "%s%s" $t d]
        set x2d [expr ($rho * cos($G($bd,a)))]
        set y2d [expr ($rho * sin($G($bd,a)))]
        #$w create line $G($bd,x) $G($bd,y) $x2d $y2d  -tags "[format "%s%s" $bd C] $bd T$t Z"
        $w create line  $x2d $y2d $G($bd,x) $G($bd,y)  -tags "[format "%s%s" $bd C] $bd T$t Z" \
                -fill $S(Preference_fgc)
        #
        set G($j,a) [expr ($G($bg,a) + $G($bd,a)) / 2.0  ]
        set G($j,x) [expr ($rho * cos($G($j,a)))]
        set G($j,y) [expr ($rho * sin($G($j,a)))]
        #
        set ad [expr (180.0 * $G($bd,a)) / acos(-1)]
        set ag [expr (180.0 * $G($bg,a)) / acos(-1)]
        $w create arc [expr 0 - $rho]  $rho $rho [expr 0 - $rho]  \
                -start -$ad -extent [expr $ad - $ag] -style arc  \
                -tags "[format "%s%s" $j C] T$t Z" -outline $S(Preference_fgc)
        # ajout tag des arretes terminales (eu)
        foreach i $T($t,ue_cod) {
            set t2 [format "%s%s" EU $T($t,ctl,$i)]
            #voir si possible en une ligne
            $w addtag $t2 withtag [list $i && T$t]
            $w addtag Z withtag [list $i && T$t]
        }
        # translation
        $w move T$t $xcenter $ycenter
        $w configure -scrollregion [$w bbox all]
        unset G
    }
    ### ArrayToCanvasCirculaire
    proc ClaCir1ORI {t w {largeur 200} {hauteur 200}} {
        global T S
        set basedegre [expr 360.0 / [llength $T($t,ue_cod)]]
        set dd [expr ((acos(-1)) * $basedegre)/ 180.0]
        set S($t,a_uni) $dd
        set xcenter [expr double($largeur)/2]
        set ycenter [expr double($hauteur)/2]
        if {$xcenter <= $ycenter} {set R $ycenter} {set R $xcenter}
        #if {$xcenter <= $ycenter} {set R $xcenter} {set R $ycenter}
        set n 0
        ### EU
        foreach i $T($t,ue_cod) {
            incr n
            set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
            set x [expr ($R * cos($G($i,a)))]
            set y [expr ($R * sin($G($i,a)))]
            set G($i,x) $x
            set G($i,y) $y
            $w create text $x $y \
                    -text  $T($t,ctl,$i) -anchor w   \
                    -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ] L" \
                    -font $S(fontbase) -state $S($t,display_eu)
        }
        ### NODES
        set step [expr $R / $T($t,tot) ]
        for {set i [expr $T($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            set rho [expr $R - ($step * ($T($t,tot) - $i))]
            foreach b $T($t,cbg,$i) {
                #
                set j [string trimright $b {[0123456789]}]
                set t2 [format "%s%s" $j C]
                #
                set bg [format "%s%s" $b g]
                set x2g [expr $rho * cos($G($bg,a))]
                set y2g [expr $rho * sin($G($bg,a))]
                #-tags "[format "%s%s" $bg C] $bg T$t Z"
                $w create line  $G($bg,x) $G($bg,y) $x2g $y2g -tags "$j $t2 T$t Z" -fill $S(Preference_fgc)
                #
                set bd [format "%s%s" $b d]
                set x2d [expr $rho * cos($G($bd,a))]
                set y2d [expr $rho * sin($G($bd,a))]
                $w create line $G($bd,x) $G($bd,y) $x2d $y2d  -tags "$j $t2 T$t Z" -fill $S(Preference_fgc)
                #
                set G($j,a) [expr ($G($bg,a) + $G($bd,a)) / 2.0  ]
                set G($j,x) [expr $rho * cos($G($j,a))]
                set G($j,y) [expr $rho * sin($G($j,a))]
                #
                set ad [expr (180.0 * $G($bd,a)) / acos(-1)]
                set ag [expr (180.0 * $G($bg,a)) / acos(-1)]
                $w create arc -$rho $rho $rho -$rho \
                        -start -$ad -extent [expr $ad - $ag] -style arc  \
                        -tags "$t2 T$t Z" -outline $S(Preference_fgc)
            }
        }
        
        # ROOT
        set rho [expr $R - ($step * $T($t,tot)) ]
        set j $t
        set t2 [format "%s%s" $j C]
        #
        set bg [format "%s%s" $t g]
        set x2g [expr $rho * cos($G($bg,a))]
        set y2g [expr $rho * sin($G($bg,a))]
        #$w create line  $G($bg,x) $G($bg,y) $x2g $y2g -tags "[format "%s%s" $bg C] $bg T$t Z"
        $w create line  $x2g $y2g  $G($bg,x) $G($bg,y) -tags "[format "%s%s" $bg C] $bg T$t Z" \
                -fill $S(Preference_fgc)
        #
        set bd [format "%s%s" $t d]
        set x2d [expr $rho * cos($G($bd,a))]
        set y2d [expr $rho * sin($G($bd,a))]
        #$w create line $G($bd,x) $G($bd,y) $x2d $y2d  -tags "[format "%s%s" $bd C] $bd T$t Z"
        $w create line  $x2d $y2d $G($bd,x) $G($bd,y)  -tags "[format "%s%s" $bd C] $bd T$t Z" \
                -fill $S(Preference_fgc)
        #
        set G($j,a) [expr ($G($bg,a) + $G($bd,a)) / 2.0  ]
        set G($j,x) [expr $rho * cos($G($j,a))]
        set G($j,y) [expr $rho * sin($G($j,a))]
        #
        set ad [expr (180.0 * $G($bd,a)) / acos(-1)]
        set ag [expr (180.0 * $G($bg,a)) / acos(-1)]
        $w create arc [expr 0 -$rho]  $rho $rho [expr 0 -$rho] \
                -start -$ad -extent [expr $ad - $ag] -style arc  \
                -tags "[format "%s%s" $j C] T$t Z" -outline $S(Preference_fgc)
        
        #translation
        $w move T$t $xcenter $ycenter
        $w configure -scrollregion [$w bbox all]
        unset G
    }
    ### ArrayToCanvasCirculaire
    proc PhyCir1 {t w {largeur 200} {hauteur 200}} {
        global T S
        set basedegre [expr 360.0 / [llength $T($t,ue_cod)]]
        # passage radians
        set dd [expr ((acos(-1)) * $basedegre)/ 180.0]
        set S($t,a_uni) $dd
        #rayon du cercle primaire
        set xcenter [expr double($largeur)/2]
        set ycenter [expr double($hauteur)/2]
        if {$xcenter <= $ycenter} {set R $xcenter} {set R $ycenter}
        #if {$xcenter < $ycenter} {set R $ycenter} {set R $xcenter}
        set n 0
        # facteur de zoom
        set f [expr double($R / $T($t,xmax))]
        ### EU
        foreach i $T($t,ue_cod) {
            # incr n
            set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
            set x1 [expr ($T($t,sox,$i)* $f) * cos($G($i,a))]
            set y1 [expr ($T($t,sox,$i)* $f) * sin($G($i,a))]
            set x2 [expr ((($T($t,sox,$i) - $T($t,dbl,$i) )* $f) * cos($G($i,a)))]
            set y2 [expr ((($T($t,sox,$i) - $T($t,dbl,$i) )* $f) * sin($G($i,a)))]
            set G($i,x) $x2
            set G($i,y) $y2
            $w create line $x2 $y2 $x1 $y1  \
                    -tags "$i [format "%s%s" EU $T($t,ctl,$i) ] [format "%s%s" $i C] T$t Z" -fill $S(Preference_fgc)
            # feuilles en radial
            
            regsub -all {¶} $T($t,ctl,$i) " " texto
            #set ls [split $T($t,ctl,$i) {}]
            set ls [split $texto {}]
            set an center ;# anchor
            set ju center ;# justification
            set angledegre [expr ($G($i,a) * 360) / 6.283185]
            if {$angledegre >= 90 && $angledegre < 270} {
                set b [expr 6 * [llength $ls]]
                foreach s $ls {
                    # SPLIT + LEAVES
                    # COK
                    set xbis [expr $x1 + ($b * cos($G($i,a)))]
                    set ybis [expr $y1 + ($b * sin($G($i,a)))]
                    $w create text $xbis $ybis \
                            -text  $s -anchor $an -justify $ju    \
                            -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ] L" \
                            -font $S(gfo)  -state $S($t,display_eu)
                    incr b -6
                }
            } else {
                set b 2
                foreach s $ls {
                    # SPLIT + LEAVES
                    # COK
                    set xbis [expr $x1 + ($b * cos($G($i,a)))]
                    set ybis [expr $y1 + ($b * sin($G($i,a)))]
                    $w create text $xbis $ybis \
                            -text  $s -anchor $an -justify $ju    \
                            -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ] L" \
                            -font $S(gfo) -state $S($t,display_eu)
                    incr b 6
                }
            }
            incr n
        }
        ### NODES
        for {set i [expr $T($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            foreach b $T($t,cbg,$i) {
                set bg [format "%s%s" $b g] ;# code bras gauche precedent (un niveau de profondeur plus loin)
                set bd [format "%s%s" $b d] ;# code bras droit precedent (un niveau de profondeur plus loin)
                set j [string trimright $b {[0123456789]}] ;# code bras gauche ou droit
                set t2 [format "%s%s" $j C]
                set ad [expr (180.0 * $G($bd,a)) / acos(-1)]
                set ag [expr (180.0 * $G($bg,a)) / acos(-1)]
                set G($j,a) [expr ($G($bg,a) + $G($bd,a)) / 2.0  ]
                set rho [expr $G($bg,x) / cos($G($bg,a))]
                set x1 [expr $rho * cos($G($j,a))]
                set y1 [expr $rho * sin($G($j,a))]
                set x2 [expr $x1 - ($T($t,dbl,$j) * $f * cos($G($j,a)))]
                set y2 [expr $y1 - ($T($t,dbl,$j) * $f * sin($G($j,a)))]
                set G($j,x) $x2
                set G($j,y) $y2
                $w create arc [expr 0 -$rho] $rho $rho [expr 0 -$rho] \
                        -start -$ad -extent [expr $ad - $ag] -style arc  \
                        -tags "$t2 T$t Z" -outline $S(Preference_fgc)
                $w create line $x1 $y1 $x2 $y2  \
                        -tags "$j $t2 T$t Z" -fill $S(Preference_fgc)
            }
        }
        # root
        #$w create line $xcenter $ycenter $xcenter $ycenter \
        #        -tags "[format "%s%s" $t C] T$t Z" -fill $S(Preference_fgc)
        
        #translation
        $w move T$t $xcenter $ycenter
        $w configure -scrollregion [$w bbox all]
        $w create line $xcenter $ycenter $xcenter $ycenter \
                -tags "[format "%s%s" $t C] T$t Z" -fill $S(Preference_fgc)
        unset G
    }
    # procedure de gestion des types d'affichage
    # actuellement comme si corrdonnes de l'arbre en 0 et taille 400 (largeur et hauteur)
    proc PhyCirc1DisplayLeaves {w t mode} {
        global T S
        set basedegre [expr 360.0 / [llength $T($t,ue_cod)]]
        set dd [expr ((acos(-1)) * $basedegre)/ 180.0]
        set S($t,a_uni) $dd
        set co [$w bbox [list Z && T$t]]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co 2]
        set y2 [lindex $co 3]
        set xcenter [expr abs(($x2 - $x1)) /2.0]
        set ycenter [expr abs(($y2 - $y1)) /2.0]
        if {$xcenter <= $ycenter} {set R $xcenter} {set R $ycenter}
        set n 0
        set f [expr double($R / $T($t,xmax))]
        switch -exact $mode {
            Lleaves1  {
                # SPLIT + COLUMNS
                foreach i $T($t,ue_cod) {
                    set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
                    set x1 [expr ($T($t,sox,$i)* $f) * cos($G($i,a))]
                    set y1 [expr ($T($t,sox,$i)* $f) * sin($G($i,a))]
                    set x2 [expr ((($T($t,sox,$i) - $T($t,dbl,$i) )* $f) * cos($G($i,a)))]
                    set y2 [expr ((($T($t,sox,$i) - $T($t,dbl,$i) )* $f) * sin($G($i,a)))]
                    set G($i,x) $x2
                    set G($i,y) $y2
                    set ls [split $T($t,ctl,$i) {}]
                    set an center
                    set ju center
                    set angledegre [expr ($G($i,a) * 360) / 6.283185]
                    if {$angledegre >= 90 && $angledegre < 270} {
                        set b [expr 6 * [llength $ls]]
                        foreach s $ls {
                            set x [expr (($R + $b) * cos($G($i,a))) ]
                            set y [expr (($R + $b) * sin($G($i,a))) ]
                            $w create text $x $y \
                                    -text  $s -anchor $an -justify $ju    \
                                    -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ] L" \
                                    -font $S(gfo) -state $S($t,display_eu)
                            incr b -6
                        }
                    } else {
                        set b 2
                        foreach s $ls {
                            set x [expr (($R + $b) * cos($G($i,a))) ]
                            set y [expr (($R + $b) * sin($G($i,a))) ]
                            $w create text $x $y \
                                    -text  $s -anchor $an -justify $ju    \
                                    -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ] L" \
                                    -font $S(gfo) -state $S($t,display_eu)
                            incr b 6
                        }
                    }
                    incr n
                }
            }
            Lleaves2  {
                # SPLIT + LEAVES
                foreach i $T($t,ue_cod) {
                    set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
                    set x1 [expr ($T($t,sox,$i)* $f) * cos($G($i,a))]
                    set y1 [expr ($T($t,sox,$i)* $f) * sin($G($i,a))]
                    set x2 [expr ((($T($t,sox,$i) - $T($t,dbl,$i) )* $f) * cos($G($i,a)))]
                    set y2 [expr ((($T($t,sox,$i) - $T($t,dbl,$i) )* $f) * sin($G($i,a)))]
                    set G($i,x) $x2
                    set G($i,y) $y2
                    set ls [split $T($t,ctl,$i) {}]
                    set an center
                    set ju center
                    set angledegre [expr ($G($i,a) * 360) / 6.283185]
                    if {$angledegre >= 90 && $angledegre < 270} {
                        set b [expr 6 * [llength $ls]]
                        foreach s $ls {
                            set xbis [expr $x1 + ($b * cos($G($i,a)))]
                            set ybis [expr $y1 + ($b * sin($G($i,a)))]
                            $w create text $xbis $ybis \
                                    -text  $s -anchor $an -justify $ju    \
                                    -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ] L" \
                                    -font $S(gfo) -state $S($t,display_eu)
                            incr b -6
                        }
                    } else {
                        set b 2
                        foreach s $ls {
                            set xbis [expr $x1 + ($b * cos($G($i,a)))]
                            set ybis [expr $y1 + ($b * sin($G($i,a)))]
                            $w create text $xbis $ybis \
                                    -text  $s -anchor $an -justify $ju    \
                                    -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ] L" \
                                    -font $S(gfo) -state $S($t,display_eu)
                            incr b 6
                        }
                    }
                    incr n
                }
            }
        }
    }
    ### ArrayToCanvasCirculaire
    proc PhyCir2 {t w {largeur 200} {hauteur 200}} {
        global T S
        set basedegre [expr 360.0 / [llength $T($t,ue_cod)]]
        set dd [expr ((acos(-1)) * $basedegre)/ 180.0]
        set S($t,a_uni) $dd
        set xcenter [expr double($largeur)/2]
        set ycenter [expr double($hauteur)/2]
        if {$xcenter <= $ycenter} {set R $xcenter} {set R $ycenter}
        set n 0
        set f [expr double($R / $T($t,xmax))]
        ### EU
        
        foreach i $T($t,ue_cod) {
            incr n
            set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
            set x1 [expr ($T($t,sox,$i)* $f) * cos($G($i,a))]
            set y1 [expr ($T($t,sox,$i)* $f) * sin($G($i,a))]
            set x2 [expr ((($T($t,sox,$i) - $T($t,dbl,$i) )* $f) * cos($G($i,a)))]
            set y2 [expr ((($T($t,sox,$i) - $T($t,dbl,$i) )* $f) * sin($G($i,a)))]
            $w create line $x1 $y1 $x2 $y2 \
                    -tags "$i [format "%s%s" EU $T($t,ctl,$i) ] [format "%s%s" $i C] T$t Z" -fill $S(Preference_fgc)
            $w create text $x1 $y1 \
                    -text  $T($t,ctl,$i) -anchor w   \
                    -tags "T$t [format "%s%s" EUL $T($t,ctl,$i) ] L" \
                    -font $S(fontbase) -state $S($t,display_eu)
            set G($i,x) $x2
            set G($i,y) $y2
        }
        ### NODES
        for {set i [expr $T($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            foreach b $T($t,cbg,$i) {
                set bg [format "%s%s" $b g] ;# code bras gauche precedent (un niveau de profondeur plus loin)
                set bd [format "%s%s" $b d] ;# code bras droit precedent (un niveau de profondeur plus loin)
                set j [string trimright $b {[0123456789]}] ;# code bras gauche ou droit
                set t2 [format "%s%s" $j C]
                set ad [expr (180.0 * $G($bd,a)) / acos(-1)]
                set ag [expr (180.0 * $G($bg,a)) / acos(-1)]
                set G($j,a) [expr ($G($bg,a) + $G($bd,a)) / 2.0  ]
                set rho [expr $G($bg,x) / cos($G($bg,a))]
                set x1 [expr $rho * cos($G($j,a))]
                set y1 [expr $rho * sin($G($j,a))]
                set x2 [expr $x1 - ($T($t,dbl,$j) * $f * cos($G($j,a)))]
                set y2 [expr $y1 - ($T($t,dbl,$j) * $f * sin($G($j,a)))]
                set G($j,x) $x2
                set G($j,y) $y2
                $w create line $G($bg,x) $G($bg,y) $x2 $y2 \
                        -tags "$j $t2 T$t Z T$t Z" -fill $S(Preference_fgc)
                $w create line $G($bd,x) $G($bd,y) $x2 $y2 \
                        -tags "$j $t2 T$t Z T$t Z" -fill $S(Preference_fgc)
            }
        }
        #translation
        $w move T$t $xcenter $ycenter
        $w configure -scrollregion [$w bbox all]
        unset G
    }
    ### ClaCir3 interne le meme que le 1 sauf step est de signe oppose
    # circulaire interne
    proc ClaCir3 {t w {largeur 200} {hauteur 200}} {
        global T S
        set basedegre [expr 360.0 / [llength $T($t,ue_cod)]]
        set dd [expr ((acos(-1)) * $basedegre)/ 180.0 ]
        set S($t,a_uni) $dd
        set xcenter [expr double($largeur)/2]
        set ycenter [expr double($hauteur)/2]
        if {$xcenter <= $ycenter} {set D $xcenter} {set D $ycenter}
        set R [expr $D / 2]
        set step [expr $R / $T($t,tot) ]
        set n 0
        ### EU
        
        foreach i $T($t,ue_cod) {
            #incr n
            set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
            set x [expr ($R * cos($G($i,a)))]
            set y [expr ($R * sin($G($i,a)))]
            # orientation
            set angledegre [expr ($G($i,a) * 360) / 6.283185]
            if {$angledegre >= 90 && $angledegre < 270} {
                set an w
            } else {
                set an e
            }
            set G($i,x) $x
            set G($i,y) $y
            set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
            set rho [expr $R / $T($t,tot) ]
            set rho -$rho
            regsub -all {¶} $T($t,ctl,$i) " " texto
            set ls [split $texto {}]
            set an center ;# anchor
            set ju center ;# justification
            #-state $S($t,display_eu)
            if {$angledegre >= 90 && $angledegre < 270} {
                set b [expr 6 * [llength $ls]]
                foreach s $ls {
                    set x [expr (($R - $b) * cos($G($i,a))) ]
                    set y [expr (($R - $b) * sin($G($i,a))) ]
                    $w create text $x $y \
                            -text  $s -anchor $an -justify $ju \
                            -tags "T$t $t4 L" \
                            -font $S(gfo) -state hidden
                    incr b -6
                }
            } else {
                set b 2
                
                foreach s $ls {
                    set x [expr (($R + $b) * cos($G($i,a))) ]
                    set y [expr (($R + $b) * sin($G($i,a))) ]
                    $w create text $x $y \
                            -text  $s -anchor $an  -justify $ju  \
                            -tags "T$t $t4 L" \
                            -font $S(gfo) -state hidden
                    incr b -6
                }
            }
            incr n
        }
        
        ### NODES
        set step [expr $R / $T($t,tot) ]
        set step -$step
        for {set i [expr $T($t,tot) - 1 ] } {$i >= 1} {incr i -1} {
            set rho [expr $R - ($step * ($T($t,tot) - $i))]
            #set rho [expr $rho + $step]
            foreach b $T($t,cbg,$i) {
                set j [string trimright $b {[0123456789]}]
                #
                set bg [format "%s%s" $b g]
                set x2g [expr $rho * cos($G($bg,a)) ]
                set y2g [expr $rho * sin($G($bg,a)) ]
                #$w create line  $G($bg,x) $G($bg,y) $x2g $y2g -tags "[format "%s%s" $bg C] $bg T$t Z"
                $w create line $x2g $y2g  $G($bg,x) $G($bg,y) -tags "[format "%s%s" $bg C] $bg T$t Z" \
                        -fill $S(Preference_fgc)
                #
                set bd [format "%s%s" $b d]
                set x2d [expr $rho * cos($G($bd,a)) ]
                set y2d [expr $rho * sin($G($bd,a)) ]
                #$w create line $G($bd,x) $G($bd,y) $x2d $y2d  -tags "[format "%s%s" $bd C] $bd T$t Z"
                $w create line $x2d $y2d $G($bd,x) $G($bd,y)   -tags "[format "%s%s" $bd C] $bd T$t Z" \
                        -fill $S(Preference_fgc)
                #
                set G($j,a) [expr ($G($bg,a) + $G($bd,a)) / 2.0  ]
                set G($j,x) [expr $rho * cos($G($j,a)) ]
                set G($j,y) [expr $rho * sin($G($j,a)) ]
                #
                set ad [expr (180.0 * $G($bd,a)) / acos(-1)]
                set ag [expr (180.0 * $G($bg,a)) / acos(-1)]
                $w create arc -$rho $rho $rho -$rho \
                        -start -$ad -extent [expr $ad - $ag] -style arc  \
                        -tags "[format "%s%s" $j C] T$t Z" -outline $S(Preference_fgc)
            }
        }
        # ROOT
        set rho [expr $R - ($step * $T($t,tot)) ]
        set j $t
        set t2 [format "%s%s" $j C]
        #
        set bg [format "%s%s" $t g]
        set x2g [expr $rho * cos($G($bg,a))]
        set y2g [expr $rho * sin($G($bg,a))]
        #$w create line  $G($bg,x) $G($bg,y) $x2g $y2g -tags "[format "%s%s" $bg C] $bg T$t Z"
        $w create line  $x2g $y2g  $G($bg,x) $G($bg,y) -tags "[format "%s%s" $bg C] $bg T$t Z" \
                -fill $S(Preference_fgc)
        #
        set bd [format "%s%s" $t d]
        set x2d [expr $rho * cos($G($bd,a))]
        set y2d [expr $rho * sin($G($bd,a))]
        #$w create line $G($bd,x) $G($bd,y) $x2d $y2d  -tags "[format "%s%s" $bd C] $bd T$t Z"
        $w create line  $x2d $y2d $G($bd,x) $G($bd,y)  -tags "[format "%s%s" $bd C] $bd T$t Z" \
                -fill $S(Preference_fgc)
        #
        set G($j,a) [expr ($G($bg,a) + $G($bd,a)) / 2.0  ]
        set G($j,x) [expr $rho * cos($G($j,a))]
        set G($j,y) [expr $rho * sin($G($j,a))]
        #
        set ad [expr (180.0 * $G($bd,a)) / acos(-1)]
        set ag [expr (180.0 * $G($bg,a)) / acos(-1)]
        $w create arc -$rho $rho $rho -$rho \
                -start -$ad -extent [expr $ad - $ag] -style arc  \
                -tags "[format "%s%s" $j C] T$t Z" -outline $S(Preference_fgc)
        # ajout tag des arretes terminales (eu)
        foreach i $T($t,ue_cod) {
            set t2 [format "%s%s" EU $T($t,ctl,$i)]
            #voir si possible en une ligne
            $w addtag $t2 withtag [list $i && T$t]
            $w addtag Z withtag [list $i && T$t]
        }
        # translation
        $w move T$t $xcenter $ycenter
        $w configure -scrollregion [$w bbox all]
        unset G
    }
    
    ###
    proc Rotation {w x y sens} {
        global S
        set id [$w find closest $x $y]
        set tags [$w gettags $id]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        # NB l'event B1release met S(rotation) a 0
        set S(rotation) 1
        set co [$w bbox [list Z && T$t]]
        set px [ expr [lindex $co 0] +2]
        set py [lindex $co 1]
        set wi   [expr [lindex $co 2] - [lindex $co 0] -3]
        set he   [expr [lindex $co 3] - [lindex $co 1] -2]
        if {$sens == "+"} {
            Rotation+ $w $t $px $py $wi $he
        } elseif {$sens == "-"} {
            Rotation- $w $t $px $py $wi $he
        }
    }
    ###
    proc Rotation+ {w t px py wi he } {
        global S
        set S($t,a_ori) [expr $S($t,a_ori) + $S($t,a_uni)]
        if {$S(rotation)} {
            $w delete T$t
            Conformation::$S($t,type) $t $w $wi $he
            $w move T$t $px $py
            Figuration::RestaureT $w $t
            update idletasks
            after 10 "Conformation::Rotation+ $w $t $px $py $wi $he"
        }
    }
    ###
    proc Rotation- {w t px py wi he } {
        global S
        set S($t,a_ori) [expr $S($t,a_ori) - $S($t,a_uni)]
        if {$S(rotation)} {
            $w delete T$t
            eval Conformation::$S($t,type) $t $w $wi $he
            $w move T$t $px $py
            Figuration::RestaureT $w $t
            update idletasks
            after 100 "Conformation::Rotation- $w $t $px $py $wi $he"
        }
    }
    ### ArrayToCanvasCirculaire (Stage de Alex Guez)
    proc ClaCir2 {t w {largeur 800} {hauteur 600} } {
        global T C S
        set basedegre [expr 360.0 / [llength $T($t,ue_cod)]]
        set dd [expr ((acos(-1)) * $basedegre)/ 180.0 ]
        
        set C(xcenter) [expr double($largeur)/2]
        set C(ycenter) [expr double($hauteur)/2]
        set xcenter $C(xcenter)
        set ycenter $C(ycenter)
        if {$xcenter <= $ycenter} {set D $ycenter} {set D $xcenter}
        if {$C(xcenter) <= $C(ycenter)} {set C(r) $C(ycenter)} {set C(r) $C(xcenter)}
        set a_ref [expr 360.0/ [llength $T($t,ue_cod)]]
        set n 0
        
        set R [expr $D / 2] ;# en faire une variable user ?
        set step [expr $R / $T($t,tot) ]
        #set step [expr ($D - $R) / $T($t,tot) ]
        set n 0
        # foreach i $T($t,ue_cod) {
        # set C(angle,$i) [expr ($n*$a_ref) ] ;# degres
        # set C(rayon,$i) $C(r)
        # #incr n
        # set G($i,a) [expr ($n * $dd) + $S($t,a_ori)]
        # set x [expr ($R * cos($G($i,a)))]
        # set y [expr ($R * sin($G($i,a)))]
        # # orientation des feuilles
        # set angledegre [expr ($G($i,a) * 360) / 6.283185]
        # if {$angledegre >= 90 && $angledegre < 270} {
        # set an e
        #
        # } else {
        # set an w
        # }
        # set G($i,x) $x
        # set G($i,y) $y
        # set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
        # # feuilles en radial
        # set ls [split $T($t,ctl,$i) {}]
        # set an center ;# anchor
        # set ju center ;# justification
        # if {$angledegre >= 90 && $angledegre < 270} {
        # set b [expr 6 * [llength $ls]]
        # foreach s $ls {
        # set x [expr (($R + $b) * cos($G($i,a))) ]
        # set y [expr (($R + $b) * sin($G($i,a))) ]
        # $w create text $x $y \
        # -text  $s -anchor $an -justify $ju \
        # -tags "T$t $t4 L"  \
        # -font $S(gfo) -state $S($t,display_eu)
        # incr b -6
        # }
        # } else {
        # set b 2
        # foreach s $ls {
        # set x [expr (($R + $b) * cos($G($i,a))) ]
        # set y [expr (($R + $b) * sin($G($i,a))) ]
        # $w create text $x $y \
        # -text  $s -anchor $an  -justify $ju  \
        # -tags "T$t $t4 L" \
        # -font $S(gfo) -state $S($t,display_eu)
        # incr b 6
        # }
        # }
        # incr n
        # }
        Circulaire $w $T($t,ue_cod) 0 $t
        unset C
        # ajout tag des arretes terminales (eu)
        foreach i $T($t,ue_cod) {
            set t2 [format "%s%s" EU $T($t,ctl,$i)]
            $w addtag $t2 withtag [list $i && T$t]
        }
    }
    # set rho [expr $R / $T($t,tot) ]
    # set rho -$rho
    ### ? r est une cste
    # set C(rayon,$e) $r
    proc Circulaire {w liste p t} {
        global T C S
        set new_liste {}
        set n 0
        set attente 0
        set fait_partie_d1_couple 0
        set t3 [format "%s%s" T $t ]
        foreach e $liste {
            set noeudnp1 [lindex $liste [expr $n+1]]
            #set noeudnp1 [lindex $liste $n]
            #c le noeud n + 1
            if {[string length $e] == [string length $noeudnp1] & [string compare $noeudnp1 [string trimright [string range $e 0 end-1] {[0123456789]}]] == 1} {
                set pere [string trimright [string range $e 0 end-1] {[0123456789]}]
                #c le noeud pere
                set C(angle,$pere) [expr 0.5 * ($C(angle,$e)+$C(angle,$noeudnp1))]
                set rayon1 $C(rayon,$e)
                set rayon2 $C(rayon,$noeudnp1)
                if {$rayon1 < $rayon2} {
                    set C(rayon,$pere) [expr $rayon1 - $C(r)/$T($t,tot)]
                } {
                    set C(rayon,$pere) [expr $rayon2 - $C(r)/$T($t,tot)]
                }
                set angrad [expr $C(angle,$e) * 2 * acos(-1) / 360.0]
                set x1 [expr $C(xcenter) + ($C(rayon,$e) * cos($angrad))]
                set y1 [expr $C(ycenter) - ($C(rayon,$e) * sin($angrad))]
                set x11 [expr $C(xcenter) + [expr $C(rayon,$pere) / $C(rayon,$e)] * ($x1 - $C(xcenter)) ]
                set y11 [expr $C(ycenter) + [expr $C(rayon,$pere) / $C(rayon,$e)] * ($y1 - $C(ycenter)) ]
                set no   [string range $e 0 end-1]
                set t1 [format "%s%s" $no g ] ;# =e
                set t2 [format "%s%s%s" $no g C]
                $w create line $x1 $y1 $x11 $y11 -tags "$t1 $t2 $t3 Z" -fill $S(Preference_fgc)
                #il y a possibilite de calculer x1' et y1' sans faire un rappel sur x1,y1,T(xcenter),T(ycenter)
                set x2 [expr $C(xcenter) + $C(rayon,$noeudnp1) * cos([expr $C(angle,$noeudnp1) * 2 * acos(-1) / 360.])]
                set y2 [expr $C(ycenter) - $C(rayon,$noeudnp1) * sin([expr $C(angle,$noeudnp1) * 2 * acos(-1) / 360.])]
                set x21 [expr $C(xcenter) + [expr $C(rayon,$pere) / $C(rayon,$noeudnp1)] * ($x2 - $C(xcenter)) ]
                set y21 [expr $C(ycenter) + [expr $C(rayon,$pere) / $C(rayon,$noeudnp1)] * ($y2 - $C(ycenter)) ]
                set t1 $noeudnp1
                set t2 [format "%s%s" $noeudnp1  C]
                $w create line $x2 $y2 $x21 $y21 -tags "$t1 $t2 $t3 Z" -fill $S(Preference_fgc)
                set t2 [format "%s%s" $pere C]
                $w create arc [expr $C(xcenter) - $C(rayon,$pere)] [expr $C(ycenter) - $C(rayon,$pere)] \
                        [expr $C(xcenter) + $C(rayon,$pere)] [expr $C(ycenter) + $C(rayon,$pere)] \
                        -style arc -extent [expr $C(angle,$noeudnp1) - $C(angle,$e)] -start $C(angle,$e) \
                        -tags "[format "%s%s" $pere  C] $t3 Z" -outline $S(Preference_fgc)
                lappend new_liste $pere
                set fait_partie_d1_couple 1
            } {
                if {$fait_partie_d1_couple == 1} {
                    set noeudnp2 [lindex $liste [expr $n+2]]
                    if {[string length $noeudnp2]==[string length $noeudnp1] & [string compare $noeudnp1 [string range $noeudnp2 0 end-2]] == 1} {
                    } {if {$noeudnp1 != {}} {
                            lappend new_liste $noeudnp1
                        }
                    }
                    set fait_partie_d1_couple 0
                } {
                    if {[lindex $new_liste end] != $e} {
                        if {$e !={}} {
                            lappend new_liste $e
                        }
                    }
                }
            }
            incr n
        }
        set C($p) $new_liste
        if {$new_liste != {}} {Circulaire $w $new_liste [expr $p+1] $t}
    }
    ### renvoie une chaine newick a partir d'un fichier nexus
    proc NexusToNewick {s} {
        
        # un petit regexp pour  recuperer dans blaa la liste des feuilles 1 BLSK, 2 SHSFH, 3 SGGSS
        regexp {Translate(.+?);} $s bla blaa
        # un petit foreach pour ranger dans une liste $l les nom des feuilles {BLSK SHSFH SGGSS}
        foreach e $blaa {
            if {[regexp {^[0-9]+$} $e ] ==0} {
                regexp {[^,]+} $e e1
                lappend l $e1
            }
        }
        # un petit regexp de nouveau pour recuperer dans blaa1 l'arbre en format ((1:346.34,2:56.6):876.9,3:1.9)
        regexp {;[^(]+([^;]+);(E|e)nd;} $s bla1 blaa1
        
        # initialisation de la variable qui va contenir le resultat final
        set Nick {}
        set i 0
        # un petit regsub pour spliter $blaa1 de la forme ((1,2),3) pour la forme ( ( 1 , 2 ) , 3 )
        # pour traiter blaa1 comme une liste avec un foreach
        # Tout d'abord l'arbre a t'il des longueur de feuilles ou faut-il en mettre?
        if [regexp : $blaa1] {
            regsub -all {(\(|,|\)|:)} $blaa1 { & } blaa1
            # un petit foreach pour remplacer dans l'expression $blaa1 les chiffres par le nom
            # des feuilles stocke dans $l
            foreach e $blaa1 {
                if {[regexp {^[0-9]+$} $e] & [lindex $blaa1 [expr $i+1]] == ":"} {
                    set Nick $Nick[lindex $l [expr $e -1]]
                } elseif [string equal $e ")"] {
                    set Nick $Nick)
                } {
                    set Nick $Nick$e
                }
                incr i
            }
        } {
            regsub -all {(\(|,|\))} $blaa1 { & } blaa1
            # un petit foreach pour remplacer dans l'expression $blaa1 les chiffres par le nom
            # des feuilles stocke dans $l
            foreach e $blaa1 {
                if [regexp {^[0-9]+$} $e] {
                    set Nick $Nick[lindex $l [expr $e -1]]:1.0
                } elseif [string equal $e ")"] {
                    set Nick $Nick):1.0
                } {
                    set Nick $Nick$e
                }
            }
            
        }
        # et c'est fini
        return $Nick
    }
    # Stage de Alex Guez
    ###
    proc Swap {w {t ?} {n ?}} {
        global S
        if {$n == "?" } {
            set tags [$w gettags [$w find withtag current]]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            set n [string trimright [lindex $tags [lsearch -glob $tags *C]] C]
        }
        #
        if {$t != "" && $n != ""} {
            SwapOperation $w $t $n
            Figuration::RedrawT $w $t
            Navigation::FitToContents $w
        }
    }
    ###
    proc SwapOperation {w {t ?} {n ?}} {
        global T S B
        if {$n == $t} {
            set gen $t
            set sg [format "%s%s" $gen g]
            set sd [format "%s%s" $gen d]
        }  else  {
            set gen [expr [llength [split $n {g d}]] - 1]
            set sg [format "%s%s%s" $n $gen g]
            set sd [format "%s%s%s" $n $gen d]
        }
        set NoCoFaToNoCoCh [Tools::NodeNoCoFaToNoCoCh  $t $n]
        set SouCodLeaALL $T($t,ue_cod)
        set SouRefLeaALL $T($t,ue_lab)
        set SouCodLeaG [Tools::NodeNoToLe $t $sg]
        set SouRefLeaG [Tools::NodeLeCoToRe $t $SouCodLeaG]
        set SouCodLeaD [Tools::NodeNoToLe $t $sd]
        set SouRefLeaD [Tools::NodeLeCoToRe $t $SouCodLeaD]
        ### T ARRAY MAJ T(t,xxx,from n)
        # ne pas utiliser l'option -all avec les regsub, car 0g* matche 10g*
        set pg [format "%s%s" $sg *]
        set pd [format "%s%s" $sd *]
        set kvg [array get T $t,*,$pg]
        set kvd [array get T $t,*,$pd]
        foreach {key value} $kvd {unset T($key)}
        foreach {key value} $kvg {unset T($key)}
        foreach {key value} $kvg {
            regsub $sg $key $sd keyswi ; set T($keyswi) $value
        }
        foreach {key value} $kvd {
            regsub $sd $key $sg keyswi ; set T($keyswi) $value
        }
        ### T ARRAY MAJ T(t,ltc,*)
        foreach codeleaf $SouCodLeaG nameleaf $SouRefLeaG {
            regsub  $sg $T($t,ltc,$nameleaf) \
                    $sd T($t,ltc,$nameleaf)
        }
        foreach codeleaf $SouCodLeaD nameleaf $SouRefLeaD {
            regsub  $sd $T($t,ltc,$nameleaf) \
                    $sg T($t,ltc,$nameleaf)
        }
        # si clic racine et si indice arbre 2 et arbre,tot =2 ca plante
        for {set i 0} {$i < $T($t,tot)} {incr i} {
            set codegene $T($t,cbg,$i)
            set T($t,cbg,$i) {}
            #puts "SWAP DEDANS iteration codegene= $codegene"
            
            foreach e $codegene {
                switch -glob $e \
                        $pg {regsub $sg $e $sd e ; lappend T($t,cbg,$i) $e} \
                        $pd {regsub $sd $e $sg e ; lappend T($t,cbg,$i) $e} \
                        default {lappend T($t,cbg,$i) $e}
            }
            puts "SWAP T($t,cbg,$i) $T($t,cbg,$i)"
        }
        
        ### T ARRAY MAJ T(t,all_cod)
        set codall $T($t,all_cod)
        set T($t,all_cod) {}
        foreach e $codall {
            switch -glob $e \
                    $pg {regsub $sg $e $sd e ; lappend T($t,all_cod) $e} \
                    $pd {regsub $sd $e $sg e ; lappend T($t,all_cod) $e} \
                    default {lappend T($t,all_cod) $e}
        }
        # B ARRAY MAJ B(BLLnod,$id)
        set lkv [array get B BLLnod,*]
        foreach {key value} $lkv {
            switch -glob $value \
                    $pg {regsub $sg $value $sd value ; set B($key) $value} \
                    $pd {regsub $sd $value $sg value ; set B($key) $value} \
                    default {set B($key) $value}
        }
        # B ARRAY MAJ B(SHInod,$id)
        set lkv [array get B SHInod,*]
        foreach {key value} $lkv {
            switch -glob $value \
                    $pg {regsub $sg $value $sd value ; set B($key) $value} \
                    $pd {regsub $sd $value $sg value ; set B($key) $value} \
                    default {set B($key) $value}
        }
        # B ARRAY MAJ B(OVAnod,$id)
        set lkv [array get B OVAnod*,*]
        foreach {key value} $lkv {
            switch -glob $value \
                    $pg {regsub $sg $value $sd value ; set B($key) $value} \
                    $pd {regsub $sd $value $sg value ; set B($key) $value} \
                    default {set B($key) $value}
        }
        # B ARRAY MAJ B(BGSnod,$id)
        set lkv [array get B BGSnod*,*]
        foreach {key value} $lkv {
            switch -glob $value \
                    $pg {regsub $sg $value $sd value ; set B($key) $value} \
                    $pd {regsub $sd $value $sg value ; set B($key) $value} \
                    default {set B($key) $value}
        }
        # B ARRAY MAJ B(BGSnod,$id)
        set lkv [array get B BGLnod*,*]
        foreach {key value} $lkv {
            switch -glob $value \
                    $pg {regsub $sg $value $sd value ; set B($key) $value} \
                    $pd {regsub $sd $value $sg value ; set B($key) $value} \
                    default {set B($key) $value}
        }
        # B ARRAY MAJ B(CONnod,$id)
        # ATTENTION value est une liste de node le switch ne passe pas si le node
        # en question n'est pas en debut de liste, on passe tous les elements de value
        # en revue
        set lkv [array get B CONnod,*]
        foreach {key value} $lkv {
            foreach v $value {
                switch -glob $v \
                        $pg {regsub $sg $value $sd value ; set B($key) $value} \
                        $pd {regsub $sd $value $sg value ; set B($key) $value} \
                        default {set B($key) $value}
            }
            
        }
        set lkv [array get B CONnod,*]
        ### T ARRAY MAJ T(t,ue_cod)
        ### T ARRAY MAJ T(t,ue_lab)
        ### ATTENTION LISTES ORDONNEES
        set esup [lrange $SouRefLeaG 0 0]
        set einf [lrange $SouRefLeaD end end]
        set isup [lsearch $SouRefLeaALL $esup]
        set iinf [lsearch $SouRefLeaALL $einf]
        set T($t,ue_lab) [join [lreplace $SouRefLeaALL $isup $iinf $SouRefLeaD $SouRefLeaG]]
        unset T($t,ue_cod)
        foreach ref $T($t,ue_lab) {
            lappend T($t,ue_cod) $T($t,ltc,$ref)
        }
    }
    ### OUTGROUP
    proc Outgroup {w mode {tsource ?} {n ?}} {
        global T S B
        if {$tsource == "?"} {
            set id [$w find withtag current]
            set tags [$w gettags $id]
            set tsource [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            set n [string trimright [lindex $tags [lsearch -glob $tags *C]] C]
        }
        if {$n != "" && $n != $tsource} {
            set co [$w bbox [list Z && T$tsource]]
            set px [lindex $co 0]
            set py [lindex $co 1]
            set wi   [expr [lindex $co 2] - [lindex $co 0]]
            set he   [expr [lindex $co 3] - [lindex $co 1]]
            set t [expr [lrange  [lsort  -integer -increasing $S(ilt)] end end] + 1]
            lappend S(ilt) $t
            set T($t,nwk) [NewickReBuild $tsource $n]
            ImportExport::TreeInit $t
            if {[catch [ImportExport::NewickParser_Root $t $T($t,nwk)] result] != 0} {
                ImpotExport::UpdateArrayCanvas $w $t
                Interface::TreeDynMessage "Error"
            }  else {
                set w2 [ImportExport::NewCanvas]
                set S($t,w) $w2
                set S($t,tit) $S($tsource,tit)
                set S($t,type) $S($tsource,type)
                lappend S($w2,t) $t
                Conformation::ArrToCanType2 $t $w2 0 0 $wi $he
                ImportExport::NodeBind $w2 $t
                Operation::TreeViewerPanelUpdate
            }
        }
    }
    #
    proc NewickReBuild {t n} {
        global T
        # 50%
        set bl [expr 0.5 * $T($t,dbl,$n)]
        if [catch {set test $T($t,dbv,$n)} res] {
            set bv ""
        } else {
            set np [Tools::NodeParentNode $t $n]
            set bv $T($t,dbv,$np)
        }
        # noeud pointe garde bv et bl/2 (50%)
        set id [string last ":" $T($t,nwk,$n)]
        set nwkn [format "%s%s%s" [string range $T($t,nwk,$n) 0 [expr $id - 1]] ":" $bl]
        # brother node
        set bn [Tools::NodeBrotherNode $n]
        set nwkbn $T($t,nwk,$bn)
        ###
        #set T(newick)  [format "%s%s%s%s%s%s%s%s%s%s%s" "(" $nwkn  ",(" $nwkbn "," xxx ")" $bv ":" $bl ");"]
        set T(newick)  [format "%s%s%s%s%s%s%s%s%s%s" "(" $nwkn  ",(" $nwkbn "," xxx ")"  ":" $bl ");"]
        NewickReBuildRec $t $n
        return $T(newick)
    }
    ###
    # d   {NewickInsertFinal $t [format "%s%s" $t g]}
    # g   {NewickInsertFinal $t [format "%s%s" $t d]}
    # d1d {NewickInsertFinal $t [format "%s%s" $t g]}
    # d1g {NewickInsertFinal $t [format "%s%s" $t g]}
    # g1d {NewickInsertFinal $t [format "%s%s" $t d]}
    # g1g {NewickInsertFinal $t [format "%s%s" $t d]}
    proc NewickReBuildRec {t n} {
        global T
        set nn [string trimleft $n $t]
        switch -exact $nn {
            d1d {NewickInsertFinal $t [format "%s%s" $t g]}
            d1g {NewickInsertFinal $t [format "%s%s" $t g]}
            g1d {NewickInsertFinal $t [format "%s%s" $t d]}
            g1g {NewickInsertFinal $t [format "%s%s" $t d]}
            default {
                set pn [Tools::NodeParentNode $t $n]
                set bn [Tools::NodeBrotherNode $pn]
                NewickInsert $t $bn $pn
                NewickReBuildRec $t $pn
            }
        }
    }
    ###
    proc NewickInsert {t n no} {
        global T
        
        if [catch {set test $T($t,dbv,$no)} res] {
            set bv ""
        } else {
            set np [Tools::NodeParentNode $t $n]
            set bv $T($t,dbv,$no)
        }
        set ns [format "%s%s%s%s%s%s%s%s" ( xxx , $T($t,nwk,$n) ) $bv : $T($t,dbl,$no) ]
        regsub "xxx" $T(newick) $ns T(newick)
    }
    ###
    proc NewickInsertFinal {t n} {
        global T
        set bl [expr $T($t,dbl,[format "%s%s" $t g]) + $T($t,dbl,[format "%s%s" $t d])]
        set id [string last ":" $T($t,nwk,$n)]
        #set id [string last ")" $T($t,nwk,$n)]
        set nwkn [format "%s%s%s" [string range $T($t,nwk,$n) 0 [expr $id - 1]] ":" $bl]
        
        puts $T($t,nwk,$n)
        puts $nwkn
        regsub "xxx" $T(newick) $nwkn T(newick)
    }
    ###
    proc NewickReBuildInit {t n} {
        global T
        set bn [Tools::NodeBrotherNode $n]
        set bnd1 [expr 0.8 * $T($t,dbl,$bn)]
        set bnd2 [expr 0.2 * $T($t,dbl,$bn)]
        set tp2 [string last ":" $T($t,nwk,$bn)]
        set nwk [string range $T($t,nwk,$bn) 0 [expr $tp2 - 1]]
        if {[array exists T($t,dbv,$n)] == 0} {
            set T(newick) [format "%s%s%s%s%s%s%s%s%s%s%s" \
                    "((" "xxx" "," $nwk ":" $bnd1 "):" $bnd2 "," $T($t,nwk,$n) ")" ]
        } else {
            set T(newick) [format "%s%s%s%s%s%s%s%s%s%s%s%s%s" \
                    "((" "xxx" "," $nwk ":" $bnd1 ")" $T($t,dbv,$n) ":" $bnd2 "," $T($t,nwk,$n) ")" ]
        }
    }
    ### LADDER
    proc Ladder {w t in m} {
        global T S
        set pg [format "%s%s%s" $in * g ]
        set espaceg [array get T $t,dbl,$pg ]
        set lcode {}
        foreach {k v} $espaceg {
            set codeg [string range $k [expr [string last "," $k] + 1] end]
            set longcodeg [string length $codeg]
            #set coded [format "%s%s" [string range $codeg 0 [expr $longcodeg - 2] ] d]
            set coded [format "%s%s" [string trimright $codeg g] d]
            set nbchildd [Tools::NodeNoToLeNum $t $coded]
            set nbchildg [Tools::NodeNoToLeNum $t $codeg]
            set cmd [list $nbchildd $m $nbchildg]
            if $cmd  {
                set level [expr [regsub -all d $coded d pwet] + [regsub -all g $coded g pwet] -1]
                set longpattern [string length [format "%s%s" $level d]]
                set coco [string range  $coded 0 [expr [string length $coded] - $longpattern -1 ] ]
                if {$coco != ""} {lappend lcode $coco}
            }
        }
        set LCODE [lsort -command LengthCompar $lcode]
        foreach code $LCODE {
            SwapOperation $w $t $code
        }
        Figuration::RedrawT $w $t
    }
    ###
    proc LengthCompar {c1 c2} {
        if {[string length $c1] >= [string length $c2]} {
            return 0
        } {
            return 1
        }
    }
    ###
    proc LaddUp {w} {
        set id [$w find withtag current]
        set tags [$w gettags $id]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            Ladder $w $t $n >
        }
    }
    ###
    proc LaddDown {w} {
        set id [$w find withtag current]
        set tags [$w gettags $id]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            Ladder $w $t $n <
        }
    }
}
################################################################################


################################################################################
# DECOMPOSITION
################################################################################
namespace eval Decomposition {
    # la decomposition ne construit pas de nouvel arbre
    # elle insere simplement une translation  et un link
    # sur tous les items lies au node select et a ses descendants (et leurs items)
    # le sous arbre se comporte a l'identique de son arbre de rattachement
    # excepte 2 choses : le move et le zoom
    # TAG est le tag commun a tous les items qui vont passer en translation
    # on ne cumule pas les TAG ds le cas de decomposition multiple
    # voir fiche selon decomposition ascendante ou descandante
    proc SubTree {w x y} {
        global S T B
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        
        if {$n != ""} {
            set t [string range \
                    [lindex $tags [lsearch -glob $tags T*]] 1 end]
            # determiner le mode ascendant ou descandant
            # car cela a un impact sur l'affection de TAG
            set pattern [format "%s%s" $n *]
            set lnod {}
            foreach idi $B($t,ova) {
                lappend lnod $B(OVAnod1,$idi)
            }
            if {[lsearch -glob $lnod $pattern] == -1} {
                set mode descendant
            } else  {
                set mode ascendant
            }
            set id [Tools::GenId]
            set TAG [format "%s%s%s" TD ¶ $id]
            switch $mode {
                "ascendant" {SubTreeAscendant $w $t $n $id $TAG}
                "descendant" {SubTreeDescendant $w $t $n $id $TAG}
            }
            lappend B($t,ova)  $id
            set B(OVAtrx,$id) $x ;# en vu des chgts de conformation
            set B(OVAtry,$id) $y ;# en vu des chgts de conformation
            set B(OVAtre,$id) $t ;# en vu des chgts de conformation
            #set B(OVAtrw,$id) $w ;# en vu des chgts de conformation
            #set B(OVAtrh,$id) $h ;# en vu des chgts de conformation
            set B(OVAnod1,$id) [Tools::NodeParentNode $t $n]  ;# en vu des maj link (zoom et move)
            set B(OVAnod2,$id) $n ;# en vu des maj link (zoom et move)
            
            ### passage en mode MOVE
            set S(mox) $x
            set S(moy) $y
            set S(mov) $TAG
            set S(tool) move
            bindtags $w [list $S(tool) $w Canvas . all]
            bind move <B1-Motion> {Navigation::MoveTT %W %x %y}
        }
    }
    ### deletion d'une decomposition, reintegration du subtree
    proc UnSubTree {w t td} {
        global B
        set id [lindex [split $td ¶] end]
        # reintegration graphique
        set cot [$w coords [format "%s%s%s"  link ¶ $id ]]
        $w move [format "%s%s%s" TD ¶ $id] \
                [expr [lindex $cot 2] - [lindex $cot 0]] [expr [lindex $cot 3] -[lindex $cot 1]]
        #suppresion du link
        $w delete [format "%s%s%s"  link ¶ $id ]
        #detagage
        DeTag $w $id
        #deletion varaibles
        foreach key [array names B *,$id] {
            unset B($key)
        }
        #retirer
        set index [lsearch -exact $B($t,ova) $id]
        set B($t,ova) [concat [lrange $B($t,ova) 0 [expr $index - 1]] \
                [lrange $B($t,ova) [expr $index + 1] end]]
        # on retrace pour mise a l'echelle au cas ou il y est eu des zoom sur le tree a reintegrer
        # et mise a jour graphique
        Figuration::RedrawT $w $t
        
    }
    ### creation array uniquement
    proc SubTree2 {t x y n} {
        global B
        set id [Tools::GenId]
        set B(OVAtrx,$id) $x
        set B(OVAtry,$id) $y
        set B(OVAtre,$id) $t
        #set B(OVAtrw,$id) $w
        #set B(OVAtrh,$id) $h
        set B(OVAnod1,$id) [Tools::NodeParentNode $t $n]
        set B(OVAnod2,$id) $n
        lappend B($t,ova)  $id
    }
    ### ajouter le TAG aux items n'en ayant pas
    ### et si le tag existe ne pas le remplacer
    proc SubTreeAscendant {w t n id TAG } {
        global S T B
        
        # leafs et leur background
        set leafs [Tools::NodeNoToLe $t $n]
        foreach i $leafs {
            set tagi1 [list [format "%s%s" EUL  $T($t,ctl,$i)] && T$t]
            set tags [$w gettags $tagi1]
            if {[lsearch -glob $tags TD*] == -1} {
                $w addtag  $TAG withtag $tagi1
            }
        }
        # background leafs
        set pattern [format "%s%s" $n *]
        foreach idi $B($t,bgl)  {
            if  {[string match $pattern $B(BGLnod,$idi)] == 1 } {
                set itag [format "%s%s%s" BGL ¶ $idi]
                set tags [$w gettags $itag]
                if {[lsearch -glob $tags TD*] == -1} {
                    $w addtag $TAG withtag  $itag
                }
            }
        }
        # arretes terminales
        set Le [Tools::NodeNoToLe $t $n]
        foreach e $Le {
            set tags [$w gettags $e]
            if {[lsearch -glob $tags TD*] == -1} {
                $w addtag $TAG withtag $e
            }
        }
        # tree
        set lchild [Tools::NodeNoCoFaToNoCoCh $t $n]
        foreach i $lchild {
            set itag [format "%s%s" $i C]
            set tags [$w gettags $itag]
            if {[lsearch -glob $tags TD*] == -1} {
                $w addtag $TAG withtag $itag
            }
        }
        # background tree
        set pattern [format "%s%s" $n *]
        foreach idi $B($t,bgs)  {
            if  {[string match $pattern $B(BGSnod,$idi)] == 1 } {
                set itag [format "%s%s%s" BGS ¶ $idi]
                set tags [$w gettags $itag]
                if {[lsearch -glob $tags TD*] == -1} {
                    $w addtag $TAG withtag  $itag
                }
            }
        }
        # sous shrink
        set pattern [format "%s%s" $n *]
        foreach idi $B($t,shi)  {
            if  {[string match $pattern $B(SHInod,$idi)] == 1 } {
                set itag [format "%s%s%s" SHN ¶ $idi]
                set tags [$w gettags $itag]
                if {[lsearch -glob $tags TD*] == -1} {
                    $w addtag $TAG withtag  $itag
                }
            }
        }
        #bll
        set pattern [format "%s%s" $n *]
        foreach idbll $B($t,bll) {
            if {[string match $pattern $B(BLLnod,$idbll)] == 1 } {
                set tags [$w gettags $B(BLLidt,$idbll)]
                if {[lsearch -glob $tags TD*] == -1} {
                    $w addtag $TAG withtag $B(BLLidt,$idbll)
                }
                if {[lsearch -glob $tags TD*] == -1} {
                    $w addtag $TAG withtag $B(BLLidl,$idbll)
                }
            }
        }
    }
    ### remplacer l'ancien TAG par le nouveau
    proc SubTreeDescendant {w t n id TAG} {
        global S T B
        # leafs et leur background
        set leafs [Tools::NodeNoToLe $t $n]
        foreach i $leafs {
            set tagi1 [list [format "%s%s" EUL  $T($t,ctl,$i)] && T$t]
            set tags [$w gettags $tagi1]
            $w dtag $tagi1 [lindex $tags [lsearch -glob $tags TD*]]
            $w addtag  $TAG withtag $tagi1
        }
        # background leaves
        set pattern [format "%s%s" $n *]
        foreach idb $B($t,bgl) {
            if {[string match $pattern $B(BGLnod,$idb)] == 1 } {
                set spectag [format "%s%s%s" BGL ¶ $idb]
                set tags [$w gettags $spectag]
                $w dtag $spectag [lindex $tags [lsearch -glob $tags TD*]]
                $w addtag $TAG withtag $spectag
            }
        }
        # arretes terminales
        set Le [Tools::NodeNoToLe $t $n]
        foreach e $Le {
            set tags [$w gettags $e]
            $w dtag $e [lindex $tags [lsearch -glob $tags TD*]]
            $w addtag $TAG withtag $e
        }
        # tree
        set lchild [Tools::NodeNoCoFaToNoCoCh $t $n]
        foreach i $lchild {
            set itag [format "%s%s" $i C]
            set tags [$w gettags $itag]
            $w dtag $itag [lindex $tags [lsearch -glob $tags TD*]]
            $w addtag $TAG withtag $itag
        }
        # background tree
        set pattern [format "%s%s" $n *]
        foreach idb $B($t,bgs) {
            if {[string match $pattern $B(BGSnod,$idb)] == 1 } {
                set spectag [format "%s%s%s" BGS ¶ $idb]
                set tags [$w gettags $spectag]
                $w dtag $spectag [lindex $tags [lsearch -glob $tags TD*]]
                $w addtag $TAG withtag $spectag
            }
        }
        # sous shrink
        set pattern [format "%s%s" $n *]
        foreach idi $B($t,shi)  {
            if  {[string match $pattern $B(SHInod,$idi)] == 1 } {
                set itag [format "%s%s%s" SHN ¶ $idi]
                set tags [$w gettags $itag]
                $w dtag $itag [lindex $tags [lsearch -glob $tags TD*]]
                $w addtag $TAG withtag  $itag
            }
        }
        # BLL
        set pattern [format "%s%s" $n *]
        foreach idbll $B($t,bll) {
            if {[string match $pattern $B(BLLnod,$idbll)] == 1 } {
                set tags [$w gettags $B(BLLidt,$idbll)]
                $w dtag $B(BLLidt,$idbll) [lindex $tags [lsearch -glob $tags TD*]]
                $w addtag $TAG withtag $B(BLLidt,$idbll)
                set tags [$w gettags $B(BLLidl,$idbll)]
                $w dtag $B(BLLidl,$idbll) [lindex $tags [lsearch -glob $tags TD*]]
                $w addtag $TAG withtag $B(BLLidl,$idbll)
            }
        }
    }
    proc UpdateLink {w t} {
        global B S T
        foreach id $B($t,ova) {
            set x1 0 ; set y1 0 ; set x2 0 ; set y1 0
            # cote arbre extrait
            set cot1 [$w coords $B(OVAnod2,$id)]
            set x1 [lindex $cot1 2]
            set y1 [lindex $cot1 3]
            #cote arbre source
            set item [$w find withtag [list [format "%s%s" $B(OVAnod1,$id) C]  && ! $B(OVAnod1,$id) ] ]
            
            switch [$w type $item] {
                line  {
                    # representation NJ
                    set cot2 [$w coords $item]
                    set bras [string range $B(OVAnod2,$id) end end]
                    switch $bras {
                        d {
                            set x2 [lindex $cot2 2]
                            set y2 [lindex $cot2 3]}
                        g {
                            set x2 [lindex $cot2 0]
                            set y2 [lindex $cot2 1]}
                    }
                }
                arc {
                    # les representations circulaire
                    set cot1 [$w coords $B(OVAnod1,$id)]
                    set x2 [lindex $cot1 0]
                    set y2 [lindex $cot1 1]
                }
                default {
                    # cas de la representation radiale
                    set cot1 [$w coords [Tools::NodeParentNode $t $B(OVAnod1,$id)]]
                    set x2 [lindex $cot1 2]
                    set y2 [lindex $cot1 3]
                }
            }
            #
            #set tagslink [$w gettags [format "%s%s%s"  link ¶ $id ]]
            $w delete [format "%s%s%s"  link ¶ $id ]
            if {$x1 != 0 && $y1 != 0 && $x2 != 0 && $y1 != 0} {
                $w create line  $x1 $y1 $x2 $y2  -fill grey50 -dash {2 2} \
                        -tags "[format "%s%s%s"  link ¶ $id ] T$t "
            }
            
        }
    }
    # ReTag met a jour le TAG necessaire au move/zoom sur le groupe d'items concerne
    # necessaire si par exemple bll ou shrink apres une decomposition
    proc ReTag {w t} {
        global B
        set lnodlid {}
        foreach id $B($t,ova) {
            lappend lnodlid $B(OVAnod2,$id)
            set decomp($B(OVAnod2,$id)) $id
        }
        foreach n [lsort -increasing $lnodlid] {
            set id $decomp($n)
            set TAG [format "%s%s%s" TD ¶ $id]
            Decomposition::SubTreeDescendant $w $t  $n $id $TAG
        }
        if [array exists decomp] {unset decomp}
    }
    proc DeTag {w id} {
        set TAG [format "%s%s%s" TD ¶ $id ]
        foreach i [$w find withtag $TAG] {
            $w dtag $i $TAG
        }
    }
    
}
################################################################################


################################################################################
# SELECTION
################################################################################
namespace eval Selection {
    ###
    proc MenuTreeTarget {m} {
        global S
        $m  delete 0 end
        $m add command -label "Select All" -command "Selection::TreeTargetSelectAll"
        $m add command -label "UnSelect All" -command "Selection::TreeTargetUnSelectAll"
        $m add separator
        # un menu par fenetre, avec select/unselect all par fenetre
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set ms [format "%s%s%s" $m. w [Tools::GenId]]
                $m add cascade -label [wm title .t$wi] -menu $ms
                menu $ms -tearoff 0
                $ms add command -label "Select All" -command "Selection::TreeTargetSelectAllperW $wi"
                $ms add command -label "Unselect All" -command "Selection::TreeTargetUnSelectAllperW $wi"
                $ms add separator
                set win [format "%s%s%s" .t $wi .c]
                foreach t $S($win,t) {
                    $ms add checkbutton -label $S($t,tit) -variable S($t,tar) \
                            -columnbreak 0 -command "Selection::ShwoTree $t"
                }
            }
        }
    }
    #
    proc TreeTargetSelectAll {} {
        global S
        set l {}
        foreach key [array names S *,w] {
            foreach t $S($S($key),t) {
                if {[lsearch -exact $l $t] == -1} {lappend l $t}
            }
        }
        foreach t $l  {
            set S($t,tar) 1
        }
    }
    #
    proc TreeTargetUnSelectAll {} {
        global S
        set l {}
        foreach key [array names S *,w] {
            foreach t $S($S($key),t) {
                if {[lsearch -exact $l $t] == -1} {lappend l $t}
            }
        }
        foreach t $l  {
            set S($t,tar) 0
        }
    }
    #
    proc TreeTargetSelectAllperW {w} {
        global S
        set l {}
        set win [format "%s%s%s" .t $w .c]
        foreach t $S($win,t) {
            if {[lsearch -exact $l $t] == -1} {lappend l $t}
        }
        foreach t $l  {
            set S($t,tar) 1
        }
    }
    #
    proc TreeTargetUnSelectAllperW {w} {
        global S
        set l {}
        set win [format "%s%s%s" .t $w .c]
        foreach t $S($win,t) {
            if {[lsearch -exact $l $t] == -1} {lappend l $t}
        }
        foreach t $l  {
            set S($t,tar) 0
        }
    }
    #
    proc TreeTargetSelectAllperW2 {w} {
        global S
        set l {}
        
        foreach t $S($w,t) {
            if {[lsearch -exact $l $t] == -1} {lappend l $t}
        }
        foreach t $l  {
            set S($t,tar) 1
        }
    }
    #
    proc TreeTargetUnSelectAllperW2 {w} {
        global S
        set l {}
        
        foreach t $S($w,t) {
            if {[lsearch -exact $l $t] == -1} {lappend l $t}
        }
        foreach t $l  {
            set S($t,tar) 0
        }
    }
    proc TreeTargetSwitch {wi} {
        global S
        set w [format "%s%s%s" .t $wi .c]
        set nbtree [llength $S($w,t)]
        set nbtarget 0
        foreach t $S($w,t) {
            incr nbtarget $S($t,tar)
        }
        if {[expr $nbtarget.0 / $nbtree.0] >= 0.5} {
            # il y a plus de tree en target que pas en target : on desecl
            Selection::TreeTargetUnSelectAllperW $wi
        } else  {
            Selection::TreeTargetSelectAllperW $wi
        }
    }
    #
    proc ShwoTree {t} {
        global S T
        set w $S($t,w)
        
        for  {set i 0} {$i <= 3} {incr i} {
            after 100
            $w create rectangle [$w bbox T$t] -tag SHOW
            update
            after 100
            $w delete SHOW
            update
        }
    }
    # retourne la A-liste $windows $tree de tous les tree d'une session treedyn
    proc TreeAll {} {
        global S
        set l {}
        foreach key [array names S *,w] {
            foreach t $S($S($key),t) {
                if {[lsearch -exact $l $t] == -1} {lappend l $S($t,w) $t}
            }
        }
        return $l
    }
    # retourne la A-liste $windows $tree pour tous les tree en target d'une session treedyn
    proc TreeTar {} {
        global S
        set l {}
        foreach key [array names S *,tar]  {
            if {$S($key) == 1} {
                set t [string range $key 0 [expr [string first , $key] - 1]]
                if {$t != 0} {
                    if {[lsearch -exact $l $t] == -1} {lappend l $S($t,w) $t}
                }
            }
        }
        return $l
    }
}
################################################################################


############################################################################
# Navigator
############################################################################
namespace eval Navigator {
    proc HyberbolicLeavesPanel {} {
        global S
        destroy .hyperlist
        set w [toplevel .hyperlist]
        wm title $w "Hyperlist"
        set f [frame $w.control]
        # tree target
        menubutton $f.target -text "Tree(s)" -menu $f.target.m  -direction below
        set z  [menu  $f.target.m -tearoff 0]
        $z configure -postcommand "Navigator::TreeTarget $z"
        # find pattern
        set S(hpattern) *
        iwidgets::entryfield $f.etext -width 25 -textvariable S(hpattern) -labeltext "Pattern:" -command  Navigator::FindPattern
        pack  $f.target $f.etext -side left
        #CANVAS
        set wc [frame $w.c]
        scrollbar $wc.xsbar -orient horizontal -command "$wc.c xview" -width 5
        scrollbar $wc.ysbar -orient vertical -command "$wc.c yview" -width 5
        canvas $wc.c -width 100 -height 100  \
                -xscrollcommand "$wc.xsbar set" -yscrollcommand "$wc.ysbar set"\
                -highlightthickness 0
        grid $wc.c -row 0 -column 0 -sticky news
        grid $wc.xsbar -row 1 -column 0 -sticky ew
        grid $wc.ysbar -row 0 -column 1 -sticky ns
        grid rowconfigure $wc 0  -weight 1
        grid columnconfigure $wc 0 -weight 1
        
        # PACK
        
        grid $f -row 0 -column 0
        grid $wc -row 1 -column 0 -sticky news
        grid rowconfigure $w 1  -weight 1
        grid columnconfigure $w 0 -weight 1
    }
    proc TreeTarget {m} {
        global S
        $m  delete 0 end
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set win [format "%s%s%s" .t $wi .c]
                foreach t $S($win,t) {
                    $m add command -label $S($t,tit)  \
                            -columnbreak 0 -command "Navigator::MakeHyperbolicLists $win $t"
                }
            }
        }
    }
    proc FindPattern {} {
    }
    proc MakeHyperbolicLists {tw t} {
        set w .hyperlist.c.c
        $w delete all
        # liste des feuilles ORDRE TREE
        global NBelt T
        set y 10
        set tagi 1
        set NBelt 0
        foreach i $T($t,ue_cod) {
            $w create text 10 $y -text $T($t,ctl,$i) -tags "h$tagi $i $T($t,ctl,$i) Hyperbolic" -font {Helvetica 2 normal} -anchor w
            incr y 3
            incr tagi 1
            incr NBelt
        }
        # liste des feuilles ORDRE ALPHA
        global NBelt T
        set y 10
        set tagi 1
        set NBelt 0
        foreach i [lsort -dictionary  $T($t,ue_lab)]  {
            $w create text 100 $y -text $i -tags "y$tagi  $T($t,ltc,$i) $i Hyperbolic2" -font {Helvetica 2 normal} -anchor w
            incr y 3
            incr tagi 1
            incr NBelt
        }
        
        $w bind Hyperbolic <Any-Enter> "Navigator::Up %W %x %y"
        $w bind Hyperbolic <Any-Leave> "Navigator::Cl %W %x %y"
        $w bind Hyperbolic2 <Any-Enter> "Navigator::Up2 %W %x %y"
        $w bind Hyperbolic2 <Any-Leave> "Navigator::Cl2 %W %x %y"
        $w bind Hyperbolic <Button-1> "Navigator::TransToTree $tw $t"
        $w bind Hyperbolic2 <Button-1> "Navigator::TransToTree $tw $t"
        $w configure -scrollregion [$w  bbox all]
    }
    proc TransToTree {wt t} {
        global T
        set w .hyperlist.c.c
        set tag [lindex [$w gettags current] 1]
        $wt itemconfigure [format "%s%s" $tag C] -fill red
        update
    }
    proc Up {w x y} {
        global NBelt
        set tag [string range [lindex [$w gettags current] 0] 1 end]
        set tag2 [lindex [$w gettags current] 1]
        $w itemconfigure $tag2 -fill red
        # central
        $w itemconfigure current -font {Helvetica 11} -fill blue
        # rang -1 RETRAIT de 10
        $w itemconfigure h[expr $tag - 1] -font {Helvetica 10}
        $w move h[expr $tag - 1] 0 -10
        # rang +1
        $w itemconfigure h[expr $tag + 1] -font {Helvetica 10}
        $w move h[expr $tag + 1] 0 +10
        # rang -2 RETRAIT relatif de 8, donc RETRAIT absolu de 18
        $w itemconfigure h[expr $tag - 2] -font {Helvetica 8}
        $w move h[expr $tag - 2] 0 -18
        # rang +2
        $w itemconfigure h[expr $tag + 2] -font {Helvetica 8}
        $w move h[expr $tag + 2] 0 +18
        # rang -3 RETRAIT relatif de 6, donc RETRAIT absolu de 24
        $w itemconfigure h[expr $tag - 3] -font {Helvetica 6}
        $w move h[expr $tag - 3] 0 -24
        # rang +3
        $w itemconfigure h[expr $tag + 3] -font {Helvetica 6}
        $w move h[expr $tag + 3] 0 +24
        # Tous les autres en amont de current
        for  {set i 0 } {$i <= [expr $tag - 4]} {incr i} {
            $w move  h$i 0  -30
            $w itemconfigure h$i -font {Helvetica 2} -fill black
        }
        # Tous les autres en aval de current
        for  {set i [expr $tag + 4]} {$i <= $NBelt} {incr i} {
            $w move   h$i 0 +30
            $w itemconfigure h$i -font {Helvetica 2} -fill black
        }
        update
    }
    proc Cl {w x y} {
        global NBelt
        set tag [string range [lindex [$w gettags current] 0] 1 end]
        set tag2 [lindex [$w gettags current] 1]
        $w itemconfigure $tag2 -fill black
        # central
        $w itemconfigure current -font {Helvetica 2} -fill black
        # rang -1
        $w itemconfigure h[expr $tag - 1] -font {Helvetica 2}
        $w move h[expr $tag - 1] 0 +10
        # rang +1
        $w itemconfigure h[expr $tag + 1] -font {Helvetica 2}
        $w move h[expr $tag + 1] 0 -10
        # rang -2
        $w itemconfigure h[expr $tag - 2] -font {Helvetica 2}
        $w move h[expr $tag - 2] 0 +18
        # rang +2
        $w itemconfigure h[expr $tag + 2] -font {Helvetica 2}
        $w move h[expr $tag + 2] 0 -18
        # rang -3
        $w itemconfigure h[expr $tag - 3] -font {Helvetica 2}
        $w move h[expr $tag - 3] 0 +24
        # rang +3
        $w itemconfigure h[expr $tag + 3] -font {Helvetica 2}
        $w move h[expr $tag + 3] 0 -24
        # Tous les autres en amont de current
        for  {set i 0 } {$i <= [expr $tag - 4]} {incr i} {
            $w move  h$i 0  +30
            $w itemconfigure h$i -font {Helvetica 2} -fill black
        }
        # Tous les autres en aval de current
        for  {set i [expr $tag + 4]} {$i <= $NBelt} {incr i} {
            $w move        h$i 0 -30
            $w itemconfigure h$i -font {Helvetica 2} -fill black
        }
        update
    }
    proc Up2 {w x y} {
        global NBelt
        set tag [string range [lindex [$w gettags current] 0] 1 end]
        set tag2 [lindex [$w gettags current] 2]
        $w itemconfigure $tag2 -fill red
        # central
        $w itemconfigure current -font {Helvetica 11} -fill blue
        # rang -1 RETRAIT de 10
        $w itemconfigure y[expr $tag - 1] -font {Helvetica 10}
        $w move y[expr $tag - 1] 0 -10
        # rang +1
        $w itemconfigure y[expr $tag + 1] -font {Helvetica 10}
        $w move y[expr $tag + 1] 0 +10
        # rang -2 RETRAIT relatif de 8, donc RETRAIT absolu de 18
        $w itemconfigure y[expr $tag - 2] -font {Helvetica 8}
        $w move y[expr $tag - 2] 0 -18
        # rang +2
        $w itemconfigure y[expr $tag + 2] -font {Helvetica 8}
        $w move y[expr $tag + 2] 0 +18
        # rang -3 RETRAIT relatif de 6, donc RETRAIT absolu de 24
        $w itemconfigure y[expr $tag - 3] -font {Helvetica 6}
        $w move y[expr $tag - 3] 0 -24
        # rang +3
        $w itemconfigure y[expr $tag + 3] -font {Helvetica 6}
        $w move y[expr $tag + 3] 0 +24
        # Tous les autres en amont de current
        for  {set i 0 } {$i <= [expr $tag - 4]} {incr i} {
            $w move  y$i 0  -30
            $w itemconfigure y$i -font {Helvetica 2} -fill black
        }
        # Tous les autres en aval de current
        for  {set i [expr $tag + 4]} {$i <= $NBelt} {incr i} {
            $w move   y$i 0 +30
            $w itemconfigure y$i -font {Helvetica 2} -fill black
        }
        update
    }
    proc Cl2 {w x y} {
        global NBelt
        set tag [string range [lindex [$w gettags current] 0] 1 end]
        set tag2 [lindex [$w gettags current] 2]
        $w itemconfigure $tag2 -fill black
        # central
        $w itemconfigure current -font {Helvetica 2} -fill black
        # rang -1
        $w itemconfigure y[expr $tag - 1] -font {Helvetica 2}
        $w move y[expr $tag - 1] 0 +10
        # rang +1
        $w itemconfigure y[expr $tag + 1] -font {Helvetica 2}
        $w move y[expr $tag + 1] 0 -10
        # rang -2
        $w itemconfigure y[expr $tag - 2] -font {Helvetica 2}
        $w move y[expr $tag - 2] 0 +18
        # rang +2
        $w itemconfigure y[expr $tag + 2] -font {Helvetica 2}
        $w move y[expr $tag + 2] 0 -18
        # rang -3
        $w itemconfigure y[expr $tag - 3] -font {Helvetica 2}
        $w move y[expr $tag - 3] 0 +24
        # rang +3
        $w itemconfigure y[expr $tag + 3] -font {Helvetica 2}
        $w move y[expr $tag + 3] 0 -24
        # Tous les autres en amont de current
        for  {set i 0 } {$i <= [expr $tag - 4]} {incr i} {
            $w move  y$i 0  +30
            $w itemconfigure y$i -font {Helvetica 2} -fill black
        }
        # Tous les autres en aval de current
        for  {set i [expr $tag + 4]} {$i <= $NBelt} {incr i} {
            $w move        y$i 0 -30
            $w itemconfigure y$i -font {Helvetica 2} -fill black
        }
        update
    }
}
############################################################################



############################################################################
# DATABASE query langage implementation + browser interface
############################################################################
namespace eval Database {
    
    
    # proc db de Richard Suchenwirth
    # db name -- declare a database (no harm if repeated)
    # name -- returns all defined keys in no particular order
    # name {} -- clears the whole database
    # name key -- returns all item/value pairs associated with key
    # name key "" -- removes entry key from database
    # name key item -- returns the value for item of key
    # name key item value... -- sets item of key to value
    proc db {database args} {
        upvar #0 $database db
        global asedCon
        set key "" ;# in case args is empty
        foreach {- key item value} $args break
        set exists [info exists db($key)]
        set res {}
        switch [llength $args] {
            0 {
                array set db {} ;# force to be an array
                ##interp alias {} $database {} db $database -
                interp alias {} $database {} Database::db $database -
                $asedCon alias  $database Database::db $database -
                set res $database
            }
            1 {set res [array names db]}
            2 {
                if {$key != ""} {
                    if {$exists} {set res $db($key)}
                } else {array unset db }
            }
            3 {if {$item != ""} {
                    if {$exists} {
                        set t $db($key)
                        if {!([set pos [lsearch $t $item]]%2)} {
                            set res [lindex $t [incr pos]]
                        }
                    }
                } elseif {$exists} {unset db($key)}
            }
            4 {
                if {$exists} {
                    if {!([set pos [lsearch $db($key) $item]]%2)} {
                        if {$value != ""} {
                            set db($key) [lreplace $db($key) [incr pos] $pos $value]
                        } else {set db($key) [lreplace $db($key) $pos [incr pos]]}
                    } elseif {$value != ""} {
                        lappend db($key) $item $value
                    }
                } elseif {$value != ""} {set db($key) [list $item $value]}
                set res $value ;# to be returned
            }
            default {
                if {[llength $args]%2} {error "non-paired item/value list"}
                foreach {item value} [lrange $args 2 end] {
                    db $database - $key $item $value
                }
            }
        }
        # set res BIZARE !!! return $res ???
    }
    # procedure generale de chargement d'annotations
    proc LoadAnnotations {} {
        global S
        set filtre {}
        lappend filtre [list {TreeDyn Label File} .txt]
        set typelist {
            {"TreeDyn Labels Files" {".tlf"} }
            {"All Files" {*}}
        }
        set filename [tk_getOpenFile -initialdir $S(userDIR)  -defaultextension "tlf" \
                -filetypes $typelist -title "Load TreeDyn Labels File..."]
        if {$filename != ""} {
            set S(userDIR) [file dirname $filename]
            if [catch {open $filename r} fid] {
                puts stderr "Error Opening File"
            } else {
                
                set currentfile [Tools::PathCut2 $filename]
                set S(fullpath,$currentfile) $filename
                # on ecrase si existe deja
                if {[lsearch $S(ldatabase) $currentfile] != -1 } {
                    upvar #0 $currentfile X
                    array unset X
                } else  {
                    lappend S(ldatabase) $currentfile
                }
                Database::db $currentfile
                while {[eof $fid] != 1} {
                    set id [incr S(lastid)]
                    gets $fid data
                    # modif
                    regsub -all " " [lindex $data 0] "¶" sans
                    set datasans [lreplace $data 0 0 $sans]
                    eval $currentfile [concat $id EU $datasans]
                    
                    
                    #eval $currentfile [concat $id EU $data]
                }
                close $fid
                set S(database) $currentfile
                LoadAnnotationsUpdateInterf
            }
        }
    }
    proc LoadAnnotationsUpdateInterf {} {
        # panel identification
        Database::dbBrowserUpdate
        # panel annotation
        Annotation::AnnotationPanelUpdate
        # HTML export panel
        ImportExport::HTMLexportUpdateLabels
    }
    #
    proc dbSave {} {
        global f S
        set database $S(database)
        upvar #0 $database X
        set typelist {
            {"TreeDyn Labels Files" {".tlf"} }
            {"All Files" {*}}
        }
        set file [tk_getSaveFile -initialdir $S(userDIR)  -defaultextension ".tlf" \
                -filetypes $typelist -title "Save as TLF file..."]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        if {$file != ""} {
            set cmd {
                set fid [open $file w]
                foreach {k v} [array get X] {
                    foreach {var val} $v {
                        if {$var == "EU"} {
                            puts -nonewline $fid "$val "
                        } else  {
                            puts -nonewline $fid "$var \{$val\} "
                        }
                    }
                    puts $fid "\n"
                }
                close $fid
            }
            if {[catch $cmd err] != 0} {Interface::TreeDynMessage "Error"}
        }
    }
    ### OK extraire la liste de tous les enregistrements
    proc dbQueryRecordsAll {database} {
        upvar #0 $database X
        return [array names X]
    }
    ### OK extraire la liste des variables d'une database
    proc dbQueryVarAll {database} {
        upvar #0 $database X
        set l {}
        foreach record [array names X] {
            foreach {key value} $X($record) {
                if {[lsearch -exact $l $key] == -1} {lappend l $key}
            }
        }
        return $l
    }
    ### OK extraire la liste des EUs sachant une liste de records
    proc dbQueryEusFromRecords {database lid} {
        upvar #0 $database X
        set l {}
        foreach record $lid {
            set t $X($record)
            if {!([set pos [lsearch $t EU]]%2)} {
                # lappend l [lindex $t [incr pos]]
                # modif au cas ou plusieurs records pour la meme eu
                set val [lindex $t [incr pos]]
                if {[lsearch -exact $l $val] == -1} {lappend l $val}
            }
        }
        return $l
    }
    ###
    proc dbQueryVarFromRecords {database var lid} {
        upvar #0 $database X
        set l {}
        foreach record $lid {
            set t $X($record)
            if {!([set pos [lsearch $t $var]]%2)} {
                # lappend l [lindex $t [incr pos]]
                # modif au cas ou plusieurs records pour la meme eu
                set val [lindex $t [incr pos]]
                if {[lsearch -exact $l $val] == -1} {lappend l $val}
            }
        }
        return $l
    }
    ### OK extraire la liste des val sachant une var
    proc dbQueryValFromVar {database var} {
        upvar #0 $database X
        set l {}
        foreach record [array names X] {
            set t $X($record)
            if {!([set pos [lsearch $t $var]]%2)} {
                set val [lindex $t [incr pos]]
                if {[lsearch -exact $l $val] == -1} {lappend l $val}
            }
        }
        return $l
    }
    ### OK extraire la liste des Records verifiant un couple variable valeur
    ### EGALITE
    proc dbQueryRecordsFromVarVal {database var val} {
        upvar #0 $database X
        set l {}
        foreach record [array names X] {
            set t $X($record)
            if {!([set pos [lsearch $t $var]]%2)} {
                set valquery [lindex $t [incr pos]]
                if {[lsearch -exact $valquery $val] != -1} {
                    lappend l $record
                }
            }
        }
        return $l
    }
    ### OK extraire la liste des Records verifiant l'operator sur un couple variable valeur
    proc dbQueryRecordsFromVarOpVal {database var operator val} {
        upvar #0 $database X
        set l {}
        foreach record [array names X] {
            set t $X($record)
            if {!([set pos [lsearch $t $var]]%2)} {
                set valquery [lindex $t [incr pos]]
                set a [format "%s%s%s" \" $val \"]
                set b [format "%s%s%s" \" $valquery \"]
                if [expr $b $operator $a ] {
                    lappend l $record
                }
            }
        }
        return $l
    }
    ### OK extraire la liste des Records verifiant l'operator ## sur un couple variable valeur
    ### l'operator ## est utilise pour un pattern matching
    ### permet de traiter des listes
    proc dbQueryRecordsFromVarPatVal {database var val} {
        upvar #0 $database X
        set l {}
        regsub -all " " $val "" val
        foreach record [array names X] {
            set t $X($record)
            if {!([set pos [lsearch $t $var]]%2)} {
                set valquery [lindex $t [incr pos]]
                # attention le pattern
                # if {[lsearch -exact $valquery $val] != -1} {
                # lappend l $record
                # }
                foreach v $valquery {
                    if [string match -nocase $val $v ] {
                        lappend l $record
                    }
                }
            }
        }
        return $l
    }
    ### l'inverse de dbQueryRecordsFromVarPatVal
    ### permet de traiter des cas comme select les eu qui ne contiennent pas
    ### telle valeur (val) pour telle variable
    ### les listes sont possibles
    proc dbQueryRecordsFromVarPat2Val {database var val} {
        upvar #0 $database X
        set l {}
        regsub -all " " $val "" val
        foreach record [array names X] {
            set t $X($record)
            if {!([set pos [lsearch $t $var]]%2)} {
                set valquery [lindex $t [incr pos]]
                # attention doit etre verifier sur tous les elements de la liste
                set presence 0
                foreach v $valquery {
                    if {[string match -nocase $val $v ]} {
                        set presence 1
                    }
                }
                if {$presence == 0} {lappend l $record}
            }
        }
        return $l
    }
    
    ### OK extraire la liste des eus verifiant un couple variable valeur
    proc dbQueryEusFromVarVal {database var val} {
        upvar #0 $database X
        set l {}
        foreach record [array names X] {
            set t $X($record)
            if {!([set pos [lsearch $t $var]]%2)} {
                set valquery [lindex $t [incr pos]]
                if {$val == $valquery} {
                    lappend l $record
                }
            }
        }
        set eus [dbQueryEusFromRecords $database $l]
        return $eus
    }
    
    ### SELECT $var1 FROM $database WHERE $var2 $operator $val2 AND/OR ...
    ### SELECT + ResAndOr : cool :)
    proc Select {args} {
        
        global S T
        regsub -all "\}|\{|and|or" $args "" nb
        switch [llength $nb] {
            0 { set help " select <var> from <table>\n\
                        select <var> from <table> where <var> <operator> <val>\n\
                        available operators : == ; != ; > ; < ; >= ; <= \n\
                        the operators ## (include) and !# (do not include) can be used with pattern matching\n\
                        ... where <var1> == <val1> <and|or> <var2> == <val2>\n\
                        ... where {<var1> == <val1> or <var2> == <val2>} and <var3> == <val3>\n "
                return $help
            }
            3 {
                set var [lindex $args 0]
                set database [lindex $args 2]
                set res [Database::dbQueryValFromVar $database $var]
                if {[lsearch -exact $S(history) $args] == -1} {lappend S(history) $args}
                return $res
            }
            7 {
                ### SELECT $var1 FROM $database WHERE $var2 $operator $val2
                set var1 [lindex $args 0]
                set database [lindex $args 2]
                set var2 [lindex $args 4]
                set operator [lindex $args 5]
                set val2 [lindex $args 6]
                # ajout pour scripting
                set S(query) [format "%s%s%s" $var2 $operator $val2]
                
                if {$operator == "##"} {
                    set res1 [Database::dbQueryRecordsFromVarPatVal $database $var2 $val2]
                } elseif {$operator == "!#"} {
                    set res1 [Database::dbQueryRecordsFromVarPat2Val $database $var2 $val2]
                } else {
                    set res1 [Database::dbQueryRecordsFromVarOpVal $database $var2 $operator $val2]
                }
                set res2 [Database::dbQueryVarFromRecords $database $var1 $res1]
                
                # allumage
                if {$S(loc) == 1} {
                    if {[lsearch -exact $S(history) $args] == -1} {lappend S(history) $args}
                }
                if {$var1 == "EU" && $S(loc) == 1} {
                    #message info
                    set S(msgindent2) "[llength $res2] matching leaves"
                    #allumage matrice
                    
                    Database::LocalisationMatrix $res2
                    #allumage tree
                    set final ""
                    # MODIF
                    set AlistWTtarget [Selection::TreeTar]
                    if {$AlistWTtarget != {}} {
                        foreach {wi ti} $AlistWTtarget {
                            Operation::Operation $wi $ti $res2
                            set leu {}
                            foreach e $res2 {
                                if {[lsearch -exact $T($ti,ue_lab) $e] != -1} {lappend leu $e}
                            }
                            append final "\n_________________\n $S($ti,tit), [llength $leu] matching leaves:\n $leu \n"
                        }
                        return $final
                    } else  {
                        append final "\n [llength $res2] matching leaves:\n [lsort -dictionary $res2]"
                        return $final
                    }
                }
                return "\n [lsort -dictionary $res2]"
            }
            default {
                if {[lsearch -exact $args and] != -1 || [lsearch -exact $args or] != -1} {
                    ########### PHASE 1 resolution des couples $var $op $val
                    set S(loc) 0
                    set var1 [lindex $args 0]
                    set database [lindex $args 2]
                    set where [lsearch -exact $args where]
                    set queries [lrange $args [expr $where + 1] end]
                    regsub -all "\}|\{| and | or " $queries " " Alistqueries
                    set i 0
                    set lq $queries
                    global q
                    foreach {var op val} $Alistqueries {
                        incr i
                        if {$op == "##"} {
                            set res1 [Database::dbQueryRecordsFromVarPatVal $database $var $val]
                        } elseif {$op == "!#"} {
                            set res1 [Database::dbQueryRecordsFromVarPat2Val $database $var $val]
                        } else {
                            set res1 [Database::dbQueryRecordsFromVarOpVal $database $var $op $val]
                        }
                        #puts ------------------$res1
                        set q($i) $res1
                        # je remplace le triplet var op val par l'indice ds array q
                        # qui contient le resultat de ce triplet
                        regsub -all {\+} "$var $op $val" {\+} vov
                        regsub $vov $lq $i lq
                        #regsub "$var $op $val" $lq $i lq
                    }
                    
                    regsub -all {\*} $lq "" lq
                    ########### PHASE 2
                    # resolution des operateurs AND , OR avec ordre de priorite selon {}
                    # ... where $q1 AND {{$q2 OR $q3} AND $q4}
                    # ou q est est une liste resulat d'un triplet(var op val)
                    
                    set finalrecords [lsort -dictionary [ResAndOr $lq]]
                    set res2 [Database::dbQueryVarFromRecords $database $var1 $finalrecords]
                    set S(loc) 1
                    if {[lsearch -exact $S(history) $args] == -1} {lappend S(history) $args}
                    if {$var1 == "EU" && $S(loc) == 1} {
                        #message info
                        set S(msgindent2) "[llength $res2] matching leaves"
                        #allumage matrice
                        Database::LocalisationMatrix $res2
                        #allumage tree
                        set final ""
                        # MODIF
                        set AlistWTtarget [Selection::TreeTar]
                        if {$AlistWTtarget != {}} {
                            foreach {wi ti} $AlistWTtarget {
                                Operation::Operation $wi $ti $res2
                                set leu {}
                                foreach e $res2 {
                                    if {[lsearch -exact $T($ti,ue_lab) $e] != -1} {lappend leu $e}
                                }
                                append final "\n $S($ti,tit), [llength $leu] matching leaves:\n [lsort -dictionary $leu] \n"
                            }
                            return $final
                        } else  {
                            append final "\n [llength $res2] matching leaves:\n [lsort -dictionary $res2]"
                            return $final
                        }
                    }
                    return "\n [lsort -dictionary $res2]"
                    
                } else  {
                    return "?"
                }
            }
        }
    }
    
    ### SELECT $var1 FROM $database WHERE $var2 $operator $val2 AND/OR ...
    ### SELECT + ResAndOr : cool :)
    proc SelectORI {args} {
        
        global S T
        regsub -all "\}|\{|and|or" $args "" nb
        switch [llength $nb] {
            0 { set help " select <var> from <table>\n\
                        select <var> from <table> where <var> <operator> <val>\n\
                        available operators : == ; != ; > ; < ; >= ; <= \n\
                        the operators ## (include) and !# (do not include) can be used with pattern matching\n\
                        ... where <var1> == <val1> <and|or> <var2> == <val2>\n\
                        ... where {<var1> == <val1> or <var2> == <val2>} and <var3> == <val3>\n "
                return $help
            }
            3 {
                set var [lindex $args 0]
                set database [lindex $args 2]
                set res [Database::dbQueryValFromVar $database $var]
                if {[lsearch -exact $S(history) $args] == -1} {lappend S(history) $args}
                return $res
            }
            7 {
                ### SELECT $var1 FROM $database WHERE $var2 $operator $val2
                set var1 [lindex $args 0]
                set database [lindex $args 2]
                set var2 [lindex $args 4]
                set operator [lindex $args 5]
                set val2 [lindex $args 6]
                # ajout pour scripting
                set S(query) [format "%s%s%s" $var2 $operator $val2]
                
                if {$operator == "##"} {
                    set res1 [Database::dbQueryRecordsFromVarPatVal $database $var2 $val2]
                } elseif {$operator == "!#"} {
                    set res1 [Database::dbQueryRecordsFromVarPat2Val $database $var2 $val2]
                } else {
                    set res1 [Database::dbQueryRecordsFromVarOpVal $database $var2 $operator $val2]
                }
                set res2 [Database::dbQueryVarFromRecords $database $var1 $res1]
                # allumage
                if {$S(loc) == 1} {
                    if {[lsearch -exact $S(history) $args] == -1} {lappend S(history) $args}
                }
                if {$var1 == "EU" && $S(loc) == 1} {
                    #message info
                    set S(msgindent2) "[llength $res2] matching leaves"
                    #allumage matrice
                    Database::LocalisationMatrix $res2
                    #allumage tree
                    set final ""
                    # MODIF
                    set AlistWTtarget [Selection::TreeTar]
                    if {$AlistWTtarget != {}} {
                        foreach {wi ti} $AlistWTtarget {
                            Operation::Operation $wi $ti $res2
                            set leu {}
                            foreach e $res2 {
                                if {[lsearch -exact $T($ti,ue_lab) $e] != -1} {lappend leu $e}
                            }
                            append final "\n_________________\n $S($ti,tit), [llength $leu] matching leaves:\n $leu \n"
                        }
                        return $final
                    } else  {
                        append final "[llength $res2] matching leaves:\n [lsort -dictionary $res2]"
                        return $final
                    }
                }
                return [lsort -dictionary $res2]
            }
            default {
                if {[lsearch -exact $args and] != -1 || [lsearch -exact $args or] != -1} {
                    # select va etre appel iteratif on desactive l'allumage si var EU
                    set S(loc) 0
                    ########### PHASE 1 resolution des couples $var $op $val
                    set var1 [lindex $args 0]
                    set where [lsearch -exact $args where]
                    set base [lrange $args 0 $where]
                    set queries [lrange $args [expr $where + 1] end]
                    # puts "TOP AVANT $queries"
                    # attention bien garder les espaces sur and et or
                    regsub -all "\}|\{| and | or " $queries " " Alistqueries
                    #puts "TOP APRES $Alistqueries"
                    set i 0
                    set lq $queries
                    global q
                    # ok Naissance == 1964  Naissance == 1965
                    # return $Alistqueries
                    foreach {var op val} $Alistqueries {
                        # ok return "$var $op $val" Naissance == 1964
                        # ok return "$base" EU from llall where
                        set basebase $base
                        set b [lappend basebase $var $op $val]
                        # ok return "$b" EU from llall where Naissance == 1964
                        incr i
                        # ATTENTION ici on va tourner dans l'interpreteur maitre
                        # afin d'eviter les retours console (associe au slave) des resultats intermediaires
                        set q($i) [eval {Database::Select} $b]
                        # ok return $q($i) 3 25 83 85 110 113
                        # je remplace le triplet var op val par l'indice ds array q qui contient le resultat de ce triplet
                        
                        #cette requete pose pb car val se retrouve plusieurs fois
                        #select EU from datatlf where Family_Kremer ## africanum or Family_Kremer ## africanum-tub-like
                        # ce qui donnait pour lq au premier passage 1 or 1-tub-like
                        # pour resoudre je remplace "regsub -all "$var $op $val" $lq $i lq" par
                        regsub "$var $op $val" $lq $i lq
                        
                        #regsub -all "$var $op $val" $lq $i lq
                        
                        
                        #puts "LQ $lq"
                        #regsub -expanded "$var $op $val" $lq $i lq
                        #set id1 [lsearch -exact $lq $var]
                        #set id2 [lsearch -exact $lq $val]
                        
                        #set lq [lreplace $lq $id1 $id2 $i]
                    }
                    # ok return "$q(1) ---- $q(2)---- $lq" 3 25 83 85 110 113 ---- 5 5' 17 19 59 103 145---- 1 and 2
                    regsub -all {\*} $lq "" lq
                    ########### PHASE 2
                    # resolution des operateurs AND , OR avec ordre de priorite selon {}
                    # ... where $q1 AND {{$q2 OR $q3} AND $q4}
                    # ou q est est une liste resulat d'un triplet(var op val)
                    # et voila
                    set res2 [lsort -dictionary [ResAndOr $lq]]
                    # on reactive l'allumage
                    set S(loc) 1
                    # on allume si EU
                    if {[lsearch -exact $S(history) $args] == -1} {lappend S(history) $args}
                    if {$var1 == "EU"} {
                        #message info
                        set S(msgindent2) "[llength $res2] matching leaves"
                        #allumage matrice
                        Database::LocalisationMatrix $res2
                        #allumage tree
                        set final ""
                        foreach key [array names S *,tar]  {
                            if {$S($key) == 1} {
                                set t [string range $key 0 [expr [string first , $key] - 1]]
                                Operation::Operation $S($t,w) $t $res2
                                set leu {}
                                foreach e $res2 {
                                    if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend leu $e}
                                }
                                append final "$S($t,tit)=> [llength $leu] matching leaves: $leu \n"
                            }
                        }
                        return $final
                    }
                    return [lsort -dictionary $res2]
                } else  {
                    return "?"
                }
            }
        }
    }
    # recurssif
    # query est de la forme {{1 and 2} or 3}
    # ou 1 2 3 sont des indices du array q
    proc ResAndOr {query} {
        global q
        set arg1 [lindex $query 0]
        set op [lindex $query 1]
        set arg2 [lindex $query 2]
        if {[llength $arg1] != 1 } {
            set l1 [ResAndOr $arg1]
        } else  {
            set l1 $q($arg1)
        }
        if {[llength $arg2] != 1 } {
            set l2 [ResAndOr $arg2]
        } else  {
            set l2 $q($arg2)
        }
        if {$op == "and"} {
            return [Tools::operatorAND $l1 $l2]
        }
        if {$op == "or"} {
            return [Tools::operatorOR $l1 $l2]
        }
    }
    ###
    proc LocalisationMatrix {EUS} {
        global f
        if {[winfo exists .identification.pw.pane0.childsite.ma.t] == 1 } {
            # attention la ligne 0 contient le nom des variables
            set nbrows [expr [lindex  [.identification.pw.pane0.childsite.ma.t configure -rows] end] - 1]
            for  {set i 1} {$i <= $nbrows} {incr i} {
                .identification.pw.pane0.childsite.ma.t  tag configure $f($i,0) -background grey75
            }
            foreach eu $EUS {
                .identification.pw.pane0.childsite.ma.t tag configure $eu -background LightGoldenrodYellow
            }
        }
    }
    ###
    proc NodeFilterPanel {} {
        global S
        eval destroy .nodefilter
        set w [toplevel .nodefilter]
        wm title $w "Node Filter"
        # NODE FILTER // tolerance
        set S(nodefilter) 0
        iwidgets::entryfield .nodefilter.ns -width 4 -textvariable S(nodefilter) \
                -labeltext     "Missing Leaves / Node :" -labelpos w -validate numeric -fixed 30
        # NODE FILTER // nb de leafs
        set S(nodefilterNB) np
        iwidgets::entryfield .nodefilter.nn  -width 4 -textvariable S(nodefilterNB) \
                -labeltext "Minimun Leaves / Node :" -labelpos w -validate numeric  -fixed 30
        # PACK
        pack .nodefilter.ns -fill x -expand yes
        pack .nodefilter.nn -fill x -expand yes
    }
    ###
    # button Fetch plus tard pour dl via http un fichier de label
    # set fe $wcontrols.f
    # button $fe -text Fetch -command "Database::dbLoad"
    # button Quit
    # VOIR POUR BOUTTON Delete d'un fichier de label
    # VOIR POUR BOUTTON Initialisation de la database
    # au prompt treedyn identification faire un alias Help vers interp aliases
    # Liaisons entre la representation matricielle (selection d'un ligne, d'une col) et les representations graphiques
    # par exemple selection d'un colonne et le mode localisation ne considere plus que cette variable
    # commande permettant d'avoir le domaine de valeur de chaque variable
    proc dbBrowser {} {
        global S f
        # initialisation de l'allumage (voir select)
        set S(loc) 1
        # initalisation de l'historique des requetes
        set S(history) {}
        set S(matrix-font-family) Helvetica
        set S(matrix-font-size) 8
        if [interp exists treedyn] {interp delete treedyn}
        set w [toplevel .identification]
        wm title $w "Identification"
        wm geometry .identification 600x600
        wm protocol .identification WM_DELETE_WINDOW {Database::dbQuitIdentification}
        # TOOLBOX les outils de l'identification
        set wcontrols [frame .identification.c ]
        # FIND
        set S(stringsearch) ?
        iwidgets::entryfield $wcontrols.es -labeltext "Find:" -labelpos w  -width 7 -command Database::FindSearch
        # menubutton treetarget Target
        menubutton $wcontrols.target -text "Target(s)" -menu $wcontrols.target.m -relief groove -indicatoron 1  -direction below
        set z  [menu  $wcontrols.target.m -tearoff 0]
        $z configure -postcommand "Database::TreeTarget $z"
        # font matrice + text bulles labels
        menubutton $wcontrols.font -text "Font" -menu $wcontrols.font.m -indicatoron 1 -relief groove  -direction below
        set mf [menu  $wcontrols.font.m -tearoff 0]
        set fct Database::FontMatrix
        $mf add radio -label "Courier" -variable S(matrix-font-family) -value Courier -command  $fct
        $mf add radio -label "Helvetica" -variable S(matrix-font-family) -value Helvetica -command  $fct
        $mf add radio -label "Times" -variable S(matrix-font-family) -value Times -command  $fct
        $mf add separator
        $mf add radio -label "6" -variable S(matrix-font-size) -value 6 -command  $fct
        $mf add radio -label "7" -variable S(matrix-font-size) -value 7 -command  $fct
        $mf add radio -label "8" -variable S(matrix-font-size) -value 8 -command  $fct
        $mf add radio -label "9" -variable S(matrix-font-size) -value 9 -command  $fct
        $mf add radio -label "10" -variable S(matrix-font-size) -value 10 -command  $fct
        $mf add radio -label "11" -variable S(matrix-font-size) -value 11 -command  $fct
        $mf add radio -label "12" -variable S(matrix-font-size) -value 12 -command  $fct
        # ADD/DELETE ROWS/COLUMNS
        menubutton $wcontrols.rc -text "+" -menu $wcontrols.rc.m -indicatoron 1  -direction below -relief groove
        set mrc [menu  $wcontrols.rc.m -tearoff 0]
        $mrc add command -label "Add a Row"     -command  Database::AddRow
        $mrc add command -label "Add a Column"  -command  Database::AddColumn
        $mrc add separator
        $mrc add command -label "Update" -command  "Database::dbUpdate"
        # boutton quit
        button $wcontrols.q -text Quit -command Database::QuitIdentification -relief groove
        # MENU Fichier de Label(s)
        set m $wcontrols.m
        iwidgets::optionmenu $m  \
                -command "Database::SelectLabel $m ; \
                Database::dbBrowserFill .identification.pw.pane0.childsite.ma ; \
                Database::BuiltMakeQuery"
        foreach lf $S(ldatabase) {$m insert end $lf}
        
        # Menufile
        menubutton $wcontrols.file -text "File" -menu $wcontrols.file.m  -indicatoron 1 -relief groove
        set mfi [menu  $wcontrols.file.m -tearoff 0]
        $mfi add command -label "Load annotations..." -command  "Database::LoadAnnotations"
        $mfi add separator
        $mfi add command -label "Save As..." -command  "Database::dbSave"
        $mfi add separator
        $mfi add command -label "Update database" -command  "Database::dbUpdate"
        # $mfi add separator
        # $mfi add command -label "Remove" -command  "Database::dbCloseIdentificationFile"
        # $mfi add command -label "Remove All" -command  "Database::dbCloseAllIdentificationFile"
        $mfi add separator
        $mfi add command -label "Quit" -command  "Database::dbQuitIdentification"
        
        ### operations
        set mo [Operation::MenuOperation $wcontrols ]
        ###
        menubutton $wcontrols.reset -text "Reset" -menu $wcontrols.reset.m  -indicatoron 1 -relief groove
        set mc [menu  $wcontrols.reset.m -tearoff 0 ]
        $mc add check -label "Automatic Reset" -variable S(AutoReset)
        $mc add separator
        $mc add command -label  "Reset" -command {Operation::ResetGraphicVariables}
        $mc add separator
        $mc add command -label  "Graphical Variables to Reset:" -command ""
        $mc add check -label  "Leaf Foreground Color" -variable S(OpResetLFgC)
        $mc add check -label  "Leaf Background Color" -variable S(OpResetLBgC)
        $mc add check -label  "Leaf Font" -variable S(OpResetLF)
        $mc add check -label  "Node Foreground Color" -variable S(OpResetNFgC)
        $mc add check -label  "Node Background Color" -variable S(OpResetNBgC)
        $mc add check -label  "Node Line (Width)" -variable S(OpResetNLW)
        $mc add check -label  "Node Line (Dash)" -variable S(OpResetNLD)
        $mc add command -label  "Select All" -command "Operation::ResetAllFig+"
        $mc add command -label  "UnSelect All" -command "Operation::ResetAllFig-"
        
        # PACK
        pack   $wcontrols.file  $m  $wcontrols.target  \
                $mo $wcontrols.reset $wcontrols.es \
                $wcontrols.font $wcontrols.rc -side left -fill both -expand yes
        # PANED WINDOW
        iwidgets::panedwindow .identification.pw  -width 300 -height 200
        ########## MATRIX
        .identification.pw add "top"
        set pane [.identification.pw childsite "top"]
        # affichage du nombre col et row du fichier de labels
        set S(msgindent1) ?
        frame $pane.pinfo
        label $pane.pinfo.m1 -textvariable S(msgindent1) -anchor w
        # affichage du nombre d'elts trouves
        set S(msgindent2) ""
        label $pane.pinfo.m2 -textvariable S(msgindent2) -anchor e
        pack $pane.pinfo.m1  $pane.pinfo.m2  -expand 1 -fill x -side left
        pack $pane.pinfo -fill x -expand 0
        # matrice / edit labels
        if [array exists f] {unset f}
        set f {}
        frame $pane.ma
        pack $pane.ma  -fill both -expand yes
        
        ########## LISTBOX
        .identification.pw add "middle"
        set pane [.identification.pw childsite "middle"]
        global conWindow
        global asedCon
        set cc [frame $pane.cc]
        # constructeur de requetes SELECT
        set wlb [frame $cc.select]
        Interface::Lbs $wlb Select 25 5 pwet
        # constructeur de requetes VARIABLE
        set wlb [frame $cc.variable]
        Interface::Lbs $wlb Variable 15 5 pwet
        set wl .identification.pw.pane1.childsite.cc.variable.l
        bind $wl <ButtonRelease> "Database::BuiltAddValueConsole $wl %x %y"
        # constructeur de requetes OPERATORS
        set wlb [frame $cc.operators]
        Interface::Lbs $wlb Operator 7 5 pwet
        $wlb.l insert end  == != > < >= <= ## !#
        # AND OR
        # constructeur de requetes VALUE sachant VARIABLE
        set wlb [frame $cc.value]
        Interface::Lbs $wlb Value 15 5 pwet
        set ccc [frame $cc.ctl]
        # insert la selection
        menubutton $ccc.insert -text "Insert"  -indicatoron 1 \
                -menu $ccc.insert.m -relief groove -direction below
        set z  [menu  $ccc.insert.m -tearoff 0]
        $z configure -postcommand "Database::MenuInsert $z"
        
        
        #button $ccc.insert -text "Insert" -command Database::QueryGoInsert
        # button constructeur de requetes, GO
        button $ccc.goquery -text "Query" -command Database::QueryGo
        button $ccc.goquerym -text "Variable Query" -command Database::QueryGoMultiple
        button $ccc.script -text "Script" -command "Interface::PopUpPanel ScriptingPanel"
        button $ccc.alter -text "Alternagraphics" -command "Identification::AlternaGraphicsIdentification"
        # menubutton historique des requetes
        menubutton $ccc.history -text "History" -menu $ccc.history.m -indicatoron 1 -relief groove
        set z  [menu  $ccc.history.m -tearoff 0]
        $z configure -postcommand "Database::MenuHistory $z"
        #PACK $cc.targetree
        pack  $cc.select $cc.variable $cc.operators $cc.value $ccc  \
                -side left -fill both -expand yes
        #pack    $ccc.goquery $ccc.goquery2  $ccc.connector $ccc.history -fill both -expand yes -side top
        pack  $ccc.insert  $ccc.goquery  $ccc.goquerym $ccc.alter $ccc.script $ccc.history -fill both -expand yes -side top
        pack $cc -anchor w -fill both -expand yes
        ########## CONSOLE
        .identification.pw add "bottom"
        set pane [.identification.pw childsite "bottom"]
        # console de requete
        set wc [frame $pane.console]
        set conWindow $wc
        set asedCon [interp create treedyn]
        Database::consoleInit $wc
        $asedCon alias  db "Database::db"
        pack $wc  -fill both -expand yes
        
        .identification.pw fraction 40 30 30
        
        pack $wcontrols -fill x
        pack .identification.pw -fill both -expand yes
        
        Database::SelectLabel $m
        Database::dbBrowserFill .identification.pw.pane0.childsite.ma
        Database::BuiltMakeQuery
        
    }
    ###
    proc MenuInsert {m} {
        global S
        $m  delete 0 end
        $m add command  -label "Select VARIABLE from DATABASE where VARIABLE OPERATOR VALUE" \
                -command "Database::InsertQuery"
        $m add command  -label "VARIABLE OPERATOR VALUE" \
                -command "Database::InsertVOV"
        $m add command  -label "AND connector" \
                -command "Database::InsertText and"
        $m add command  -label "OR connector" \
                -command "Database::InsertText or"
        $m add command  -label "{}" \
                -command "Database::InsertAcc"
    }
    proc InsertQuery {} {
        set wi .identification.pw.pane1.childsite.cc.select.l
        if [catch {$wi get [$wi curselection]} select] {
            set select ?
        }
        set wi .identification.pw.pane1.childsite.cc.variable.l
        if [catch {$wi get [$wi curselection]} variable] {
            set variable ?
        }
        set wi .identification.pw.pane1.childsite.cc.operators.l
        if [catch {$wi get [$wi curselection]} operator] {
            set operator ?
        }
        set wi .identification.pw.pane1.childsite.cc.value.l
        if [catch {$wi get [$wi curselection]} value] {
            set value ?
        }
        set q " $select $variable $operator $value"
        set wc .identification.pw.pane2.childsite.console.t
        $wc mark set insert prompt
        $wc delete prompt end
        set command $q
        $wc insert prompt $command
        $wc see insert
    }
    proc InsertVOV {} {
        set wi .identification.pw.pane1.childsite.cc.variable.l
        if [catch {$wi get [$wi curselection]} variable] {
            set variable ?
        }
        set wi .identification.pw.pane1.childsite.cc.operators.l
        if [catch {$wi get [$wi curselection]} operator] {
            set operator ?
        }
        set wi .identification.pw.pane1.childsite.cc.value.l
        if [catch {$wi get [$wi curselection]} value] {
            set value ?
        }
        set q " $variable $operator $value"
        set wc .identification.pw.pane2.childsite.console.t
        #$wc mark set insert prompt
        #$wc delete prompt end
        set command $q
        #$wc insert prompt $command
        $wc insert end $command
        $wc see insert
    }
    proc InsertText {text} {
        set q " $text"
        set wc .identification.pw.pane2.childsite.console.t
        #$wc mark set insert prompt
        #$wc delete prompt end
        set command $q
        #$wc insert prompt $command
        $wc insert end $command
        $wc see insert
    }
    proc InsertAcc {} {
        set wc .identification.pw.pane2.childsite.console.t
        #$wc mark set insert prompt
        #$wc delete prompt end
        #set command $q
        #$wc insert prompt $command
        $wc insert end " \{\}"
        $wc see insert
    }
    
    #
    proc TreeTarget {m} {
        global S
        $m  delete 0 end
        $m add command -label "Select All" -command "Selection::TreeTargetSelectAll"
        $m add command -label "UnSelect All" -command "Selection::TreeTargetUnSelectAll"
        $m add separator
        # un menu par fenetre, avec select/unselect all par fenetre
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set ms [format "%s%s%s" $m. w [Tools::GenId]]
                $m add cascade -label [wm title .t$wi] -menu $ms
                menu $ms -tearoff 0
                $ms add command -label "Select All" -command "Selection::TreeTargetSelectAllperW $wi"
                $ms add command -label "Unselect All" -command "Selection::TreeTargetUnSelectAllperW $wi"
                $ms add separator
                set win [format "%s%s%s" .t $wi .c]
                foreach t $S($win,t) {
                    $ms add checkbutton -label $S($t,tit) -variable S($t,tar) \
                            -columnbreak 0 -command "Selection::ShwoTree $t"
                }
            }
        }
    }
    proc dbBrowserUpdate {} {
        global S
        set m .identification.c.m
        if {[winfo exists .identification] == "1"} {
            # mise a jour du menu des fichiers de labels
            $m delete 0 end
            foreach lf $S(ldatabase) {$m insert end $lf}
            $m select end
            Database::SelectLabel $m
            Database::dbBrowserFill .identification.pw.pane0.childsite.ma
            Database::BuiltMakeQuery
        }
    }
    #
    proc  SelectLabel {w} {
        global S
        set select [$w get]
        switch -exact $select {
            "?" {puts Default}
            default {set S(database) $select}
        }
        .identification.pw.pane1.childsite.cc.value.l delete 0 end
        
    }
    #
    proc dbQuitIdentification {} {
        set choix [tk_messageBox -type okcancel -default ok  \
                -message "Exit Labels Browser ?" -icon question]
        if {$choix == "ok"} {
            eval destroy .identification
        }
    }
    #
    proc dbCloseIdentificationFile {} {
        global S
        set database $S(database)
        set choix [tk_messageBox -type okcancel -default ok  \
                -message "Remove $database ?" -icon question]
        if {$choix == "ok"} {
            # menage interne
            upvar #0 $database X
            unset X
            set index [lsearch -exact $S(ldatabase) $database]
            set S(ldatabase) [concat [lrange $S(ldatabase) 0 [expr $index - 1]] \
                    [lrange $S(ldatabase) [expr $index + 1] end]]
            set S(database) [lindex $S(ldatabase) 0]
            .identification.c.m delete $database
            .identification.c.m select $S(database)
            # init interface
            Database::SelectLabel $S(database)
            Database::dbBrowserFill .identification.pw.pane0.childsite.ma
            Database::BuiltMakeQuery
        }
    }
    #
    proc dbCloseAllIdentificationFile {} {
        global S
        set choix [tk_messageBox -type okcancel -default ok  \
                -message "Remove All Labels Files ?" -icon question]
        if {$choix == "ok"} {
            set currentselection $S(database)
            if {$currentselection != ""} {
                foreach database [.identification.c.m get 0 end] {
                    upvar #0 $database X
                    unset X
                }
            }
            global f
            unset f
        }
    }
    #
    proc BuiltMakeQuery {} {
        BuiltAddSelectConsole
        BuiltAddVariableConsole
    }
    #
    proc BuiltAddSelectConsole {} {
        global db
        set database [.identification.c.m  get]
        if {$database != ""} {
            set m .identification.pw.pane1.childsite.cc.select.l
            $m delete 0 end
            set tags [dbQueryVarAll $database]
            foreach tag [lsort -dictionary $tags] {
                set st "select $tag from $database where"
                $m insert end $st
            }
        }
    }
    #
    proc BuiltAddVariableConsole {} {
        global db
        set database [.identification.c.m  get]
        if {$database != ""} {
            set m .identification.pw.pane1.childsite.cc.variable.l
            $m delete 0 end
            set tags [dbQueryVarAll $database]
            foreach tag [lsort -dictionary $tags] {
                # correction finalement on place EU en variable aussi
                $m insert end $tag
            }
        }
    }
    #
    proc BuiltAddValueConsole {w x y} {
        global db
        set database [.identification.c.m  get]
        if {$database != ""} {
            set wv .identification.pw.pane1.childsite.cc.value.l
            $wv delete 0 end
            set variable [$w get @$x,$y]
            if {$variable != ""} {
                set ll {}
                foreach tag [dbQueryValFromVar $database $variable] {
                    # si variable multivaluee
                    foreach tagi $tag {
                        if {[lsearch -exact $ll $tagi] == -1} {lappend ll $tagi}
                    }
                }
                foreach tagi [lsort -dictionary $ll] {
                    $wv insert end $tagi
                }
            }
        }
    }
    #
    proc QueryGo {} {
        global asedCon
        set wi .identification.pw.pane1.childsite.cc.select.l
        if [catch {$wi get [$wi curselection]} select] {
            tk_messageBox -message "Select is missing" -type ok; return
        } else {
            set wi .identification.pw.pane1.childsite.cc.variable.l
            if [catch {$wi get [$wi curselection]} variable] {
                tk_messageBox -message "Variable is missing" -type ok; return
            } else {
                set wi .identification.pw.pane1.childsite.cc.operators.l
                if [catch {$wi get [$wi curselection]} operator] {
                    tk_messageBox -message "Operator is missing" -type ok; return
                } else {
                    set wi .identification.pw.pane1.childsite.cc.value.l
                    if [catch {$wi get [$wi curselection]} value] {
                        tk_messageBox -message "Value is missing" -type ok; return
                    } else {
                        set q "$select $variable $operator $value"
                        set wc .identification.pw.pane2.childsite.console.t
                        $wc mark set insert prompt
                        $wc delete prompt end
                        set command $q
                        $wc insert prompt $command
                        $wc see insert
                        Database::evalCommand $wc $asedCon [Database::getCommand $wc]
                    }
                }
            }
        }
    }
    ###
    proc QueryGoInsert {} {
        set wi .identification.pw.pane1.childsite.cc.select.l
        if [catch {$wi get [$wi curselection]} select] {
            set select ?
        }
        set wi .identification.pw.pane1.childsite.cc.variable.l
        if [catch {$wi get [$wi curselection]} variable] {
            set variable ?
        }
        set wi .identification.pw.pane1.childsite.cc.operators.l
        if [catch {$wi get [$wi curselection]} operator] {
            set operator ?
        }
        set wi .identification.pw.pane1.childsite.cc.value.l
        if [catch {$wi get [$wi curselection]} value] {
            set value ?
        }
        set q "$select $variable $operator $value"
        set wc .identification.pw.pane2.childsite.console.t
        $wc mark set insert prompt
        $wc delete prompt end
        set command $q
        $wc insert prompt $command
        $wc see insert
    }
    # travail en automatique sur le domaine d'une variable
    # verifier que l'on est sur EU
    proc QueryGoMultiple {} {
        global  S asedCon
        #set S(MultiQueryValue) ""
        #destroy .multiquery
        set wi .identification.pw.pane1.childsite.cc.select.l
        # select
        set id [Tools::GenId]
        if [catch {$wi get [$wi curselection]} select] {
            tk_messageBox -message "Select is missing" -type ok; return
        } else {
            # variable
            set wi .identification.pw.pane1.childsite.cc.variable.l
            if [catch {$wi get [$wi curselection]} variable] {
                tk_messageBox -message "Variable is missing" -type ok; return
            } else {
                set S(QueryVariable$id) $variable
                # operator
                set wi .identification.pw.pane1.childsite.cc.operators.l
                if [catch {$wi get [$wi curselection]} operator] {
                    tk_messageBox -message "Operator is missing" -type ok; return
                } else {
                    set S(QueryOperator$id) $operator
                    # ici on tourne sur toute la liste des valeur d'une variable
                    set wi .identification.pw.pane1.childsite.cc.value.l
                    set lv [$wi get 0 end]
                    set S(MultiQueryValue$id) $lv
                    # set increment [expr 100 / [llength $lv]]
                    # interface panel
                    toplevel .multiquery$id
                    wm title .multiquery$id "$select $variable $operator"
                    wm geometry .multiquery$id "+[winfo pointerx .multiquery$id]+[winfo pointery .multiquery$id]"
                    set S(MultiQueryQuery$id) "$select $variable $operator"
                    
                    # canvas d'affichage de la legende
                    set w [frame .multiquery$id.canvas]
                    scrollbar $w.xsbar -orient horizontal -command "$w.c xview"
                    scrollbar $w.ysbar -orient vertical -command "$w.c yview"
                    canvas $w.c -width 100 -height 100  \
                            -xscrollcommand "$w.xsbar set" -yscrollcommand "$w.ysbar set"\
                            -highlightthickness 0
                    grid $w.c -row 0 -column 0 -sticky news
                    grid $w.xsbar -row 1 -column 0 -sticky ew
                    grid $w.ysbar -row 0 -column 1 -sticky ns
                    grid rowconfigure $w 0  -weight 1
                    grid columnconfigure $w 0 -weight 1
                    set x 40
                    set y 20
                    foreach value $lv {
                        $w.c create rectangle [expr $x + 10] [expr $y + 10] [expr $x + 20] [expr $y + 20] \
                                -fill [randomColor] -tags "q $value"
                        $w.c create text [expr $x + 30] [expr $y + 15] \
                                -text $value -anchor w -font {Helvetica 7 normal} -tags "t $value"
                        incr y 15
                    }
                    $w.c bind q <Button-1> "Database::MultiQueryUpdateColor $w.c"
                    $w.c bind t <Button-1> "Database::MultiQuerySelUnSelOne $w.c"
                    $w.c configure -scrollregion [$w.c  bbox all]
                    # Help
                    label .multiquery$id.msg  -background azure1 -anchor w -justify left \
                            -text " + Clic on text values. Green: the value will be checked,\n\
                            Red: the value will not be checked. Also use the <Select All>\n\
                            or <Unselect All> buttons.\n\n\
                            + Clic on the colored box for setting a new color.\n\
                            The new color must be selected using the Parameters Panel.\n\
                            Use the <Random Colors> or <Progressive Colors>\n\
                            buttons for a global setting."
                    # redraw color
                    set ww1 [frame .multiquery$id.colors]
                    button $ww1.c1 -text "Random Colors" -command "Database::MultiQueryLegendColorRandom $w.c [list $lv]"
                    button $ww1.c2 -text "Progressive Colors" -command "Database::MultiQueryLegendColorProgressive $w.c [list $lv]"
                    button $ww1.c4 -text "Greys" -command "Database::MultiQueryLegendGreyProgressive $w.c [list $lv]"
                    button $ww1.c3 -text "Current Color" -command "Database::MultiQueryLegendColorOne $w.c [list $lv]"
                    pack  $ww1.c1 $ww1.c2 $ww1.c4 $ww1.c3 -side left -expand yes -fill both
                    # menu operation
                    iwidgets::optionmenu  .multiquery$id.operation -labeltext "Operation: " -labelpos w \
                            -command "Database::MultiQueryOperation .multiquery$id.operation"
                    foreach i {"Leaf Foreground Color" "Leaf Background Color" \
                                "Node Foreground Color" "Node Background Color" \
                                "Leaf Illustration (columns)" "Leaf Annotation (columns)" \
                                "Query: Node Annotate" \
                                "Query: Leaf Annotate (columns)"} {
                        .multiquery$id.operation insert end $i
                    }
                    # Select all et unselect all
                    set ww [frame .multiquery$id.select]
                    button $ww.selall -text "Select All" -command "Database::MultiQuerySelectAll .multiquery$id.canvas.c"
                    button $ww.unsall -text "Unselect All" -command "Database::MultiQueryUnSelectAll .multiquery$id.canvas.c"
                    pack  $ww.selall $ww.unsall -side left -expand yes -fill both
                    # Legend
                    set wleg [frame .multiquery$id.legend ]
                    checkbutton $wleg.l1 -text "Legend" -variable S(MultiQueryLegend$id)
                    menubutton $wleg.opt  -text "Options" -menu $wleg.opt.m
                    set mc [menu  $wleg.opt.m -tearoff 0]
                    $mc add check  -label "Labels File" -variable S(LegendLabels)
                    $mc add check  -label "Variable" -variable S(LegendVariable)
                    $mc add check  -label "Operator" -variable S(LegendOperator)
                    $mc add check  -label "Operation" -variable S(LegendOperation)
                    $mc add check  -label "Boxes/Illustrations" -variable S(LegendBox)
                    $mc add check  -label "Frame" -variable S(LegendCadre)
                    pack  $wleg.l1  $wleg.opt -side left -expand yes -fill x
                    set wop [frame $w.wop ]
                    menubutton $wop.loca -text "Operation: " -menu $wop.loca.m
                    set mc [menu  $wop.loca.m -tearoff 0]
                    $mc add radio -label "Leaf Foreground Color" -variable S(operation) \
                            -value leaffgcolor -command {set S(operationName) "Leaf Foreground Color"}
                    # Query
                    button .multiquery$id.query -text Query   \
                            -command "Database::MultiQueryOperation .multiquery$id.operation ; Database::MultiQueryGo $id"
                    # Quit
                    button .multiquery$id.quit -text Cancel -command "destroy .multiquery$id"
                    # button Make script
                    button .multiquery$id.maketds -text "Save (script)" -command "Database::MakeTDSpanel $id"
                    pack .multiquery$id.msg -expand 1 -fill x
                    pack   .multiquery$id.select  $w \
                            $ww1 .multiquery$id.operation  .multiquery$id.legend \
                            .multiquery$id.maketds .multiquery$id.query .multiquery$id.quit\
                            -expand yes -fill x
                    MultiQuerySelectAll .multiquery$id.canvas.c
                }
            }
        }
    }
    #
    # TDS : fichier script a generer
    # TLF : fichier annotation
    # NWK : fichier arbre
    # variable : la variable a traiter
    # lv : la liste des valeurs de variable a traiter
    # operateur : l'operateur Ã  utiliser
    # operation : l'operation graphique
    proc MakeTDSpanel {id } {
        global S
        destroy .maketds
        set S(makeTDStargetfile) [format "%s%s" $S(userDIR)  /?.tds]
        set S(makeTDSloadtree) 1
        set S(makeTDSloadlabels) 1
        set S(makeTDSquery) $S(MultiQueryQuery$id)
        set S(makeTDSvalues) {} ;# lvalues est une A-list valeur couleur
        set S(makeTDSoperation) [.multiquery$id.operation get]
        # recuperation valeurs en selection
        set c .multiquery$id.canvas.c
        set li [$c find withtag t]
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green3"} {
                set ii [$c find withtag [list q && $valeur]]
                set couleur [$c itemcget $ii -fill]
                lappend S(makeTDSvalues) $valeur $couleur
            }
        }
        toplevel .maketds -relief groove -bd 2
        iwidgets::entryfield .maketds.tar -textvariable S(makeTDStargetfile) -labeltext "Script File: " -labelpos w
        checkbutton .maketds.loadtree -variable S(makeTDSloadtree) -text "Tree(s) file"
        checkbutton .maketds.loadlabels -variable S(makeTDSloadlabels) -text "Annotations file"
        iwidgets::entryfield .maketds.operation  -textvariable S(makeTDSoperation) -labeltext "Operation" -labelpos w
        iwidgets::entryfield .maketds.query -textvariable S(makeTDSquery) -labeltext "Query" -labelpos w
        # GO
        button .maketds.go -text Make -command Database::MakeTDSgo
        # PACK
        pack   .maketds.tar .maketds.loadtree .maketds.loadlabels \
                .maketds.query .maketds.operation .maketds.go \
                -expand true -fill x -side top -anchor w
        
    }
    proc MakeTDSgo {} {
        global S
        if [catch {open $S(makeTDStargetfile) w} fid] {
            # "Error Opening File"
        } else {
            ### SELECT EU FROM $database WHERE $variable $operator
            set database [lindex $S(makeTDSquery) 3]
            set variable [lindex $S(makeTDSquery) 5]
            set operator [lindex $S(makeTDSquery) 6]
            puts $fid "#TreeDyn Script [clock format [clock seconds] -format "%A %B %d %Y"]"
            # chargement des fichiers tree par le script
            if {$S(makeTDSloadtree) == 1} {
                puts $fid "loadlabel $S(fullpath,$database)"
            }
            # chargement du fichier annotation par le script
            if {$S(makeTDSloadlabels) == 1} {
                #liste des fenetre en target
                set lwi {}
                foreach key [array names S *,tar]  {
                    if {$S($key) == 1} {
                        set ti [string range $key 0 [expr [string first , $key] - 1]]
                        if {$ti != 0} {
                            if {[lsearch -exact $lwi  $S($ti,w)] == -1} {lappend lwi $S($ti,w)}
                        }
                    }
                }
                foreach wi $lwi {
                    puts $fid "loadtree $S($wi,filefullpath)"
                }
            }
            # operation
            switch -glob $S(makeTDSoperation) {
                "Leaf Foreground Color" {
                    puts $fid "operation leaffgcolor"
                    foreach {v c} $S(makeTDSvalues) {
                        puts $fid "color $c"
                        puts $fid "ID EU from $database where $variable $operator $v"
                    }
                }
                "Node Foreground Color" {
                    puts $fid "operation nodefgcolor"
                    foreach {v c} $S(makeTDSvalues) {
                        puts $fid "color $c"
                        puts $fid "ID EU from $database where $variable $operator $v"
                    }
                }
                "Leaf Background Color" {
                    puts $fid "operation leafbgcolor"
                    foreach {v c} $S(makeTDSvalues) {
                        puts $fid "color $c"
                        puts $fid "ID EU from $database where $variable $operator $v"
                    }
                }
                "Node Background Color" {
                    puts $fid "operation nodebgcolor"
                    foreach {v c} $S(makeTDSvalues) {
                        puts $fid "color $c"
                        puts $fid "ID EU from $database where $variable $operator $v"
                    }
                }
                
                
                
            }
            close $fid
        }
    }
    
    # tabulationla valeur de wname est le path a declarer comme fenetre
    proc OperationTabulation {wname} {
        set wtag [frame $wname]
        checkbutton $wtag.tab -variable S(illustration-tabulation) -text Tabulation
        button $wtag.tab- -command "Illustration::IllCTabulation tab-" -text -
        button $wtag.tab+ -command "Illustration::IllCTabulation tab+" -text +
        button $wtag.tabpreview -command "" -text Preview
        bind  $wtag.tabpreview  <ButtonPress-1> "Operation::IllCTabulationPreviewOn %W"
        bind  $wtag.tabpreview  <ButtonRelease-1> "Operation::IllCTabulationPreviewOff %W"
        pack $wtag.tab $wtag.tab- $wtag.tab+ $wtag.tabpreview -side left -expand yes -fill both
    }
    proc MultiQueryLegendColorRandom {w lv} {
        set x 40
        set y 20
        $w delete q
        foreach value $lv {
            set color [randomColor]
            $w create rectangle [expr $x + 10] [expr $y + 10] [expr $x + 20] [expr $y + 20] \
                    -fill $color -tags "q $value"
            incr y 15
        }
    }
    #
    proc MultiQueryLegendColorOne {w lv} {
        global S
        set x 40
        set y 20
        $w delete q
        foreach value $lv {
            set color $S(col)
            $w create rectangle [expr $x + 10] [expr $y + 10] [expr $x + 20] [expr $y + 20] \
                    -fill $color -tags "q $value"
            incr y 15
        }
    }
    #
    proc MultiQueryLegendGreyProgressive {w lv} {
        set x 40
        set y 20
        $w delete q
        set incrb [expr 1.0 / [llength $lv] ]
        set b 0
        foreach value $lv {
            set color [Operation::ColorPanel_hsb2rgb 0 0 $b]
            $w create rectangle [expr $x + 10] [expr $y + 10] [expr $x + 20] [expr $y + 20] \
                    -fill $color -tags "q $value"
            incr y 15
            set b [expr $b + $incrb]
        }
    }
    #
    #set nb [llength $lv]
    #set increment [expr round((100.0 / $nb) + 0.5)]
    #set n 0
    #set color [percent2rgb $n]
    #set color [Operation::ColorPanel_hsb2rgb $hue 1 1]
    proc MultiQueryLegendColorProgressive {w lv} {
        set x 40
        set y 20
        $w delete q
        set nb [llength $lv]
        if {$nb <= 7} {
            
            #set incrhue [expr 6.28 / $nb]
            set incrhue 1
            set hue 0
            foreach value $lv {
                set color [Operation::ColorPanel_hsb2rgb $hue 1 1]
                $w create rectangle [expr $x + 10] [expr $y + 10] [expr $x + 20] [expr $y + 20] \
                        -fill $color -tags "q $value"
                incr y 15
                set hue [expr $hue + $incrhue]
            }
        } elseif {$nb > 7 && $nb <= 14} {
            set lcolor {}
            # saturation
            foreach s {1.0 0.5}  {
                # hue
                foreach h {0 1 2 3 4 5 6} {
                    lappend lcolor [Operation::ColorPanel_hsb2rgb $h $s 1  ]
                }
            }
            set indexcolor 0
            foreach value $lv  {
                set color [lindex $lcolor $indexcolor ]
                $w create rectangle [expr $x + 10] [expr $y + 10] [expr $x + 20] [expr $y + 20] \
                        -fill $color -tags "q $value"
                incr y 15
                incr indexcolor
            }
        }  elseif {$nb > 14 && $nb <= 42} {
            set lcolor {}
            # brigthness
            foreach b {1.0 0.7 0.4} {
                # saturation
                foreach s {1.0 0.5}  {
                    # hue
                    foreach h {0 1 2 3 4 5 6} {
                        lappend lcolor [Operation::ColorPanel_hsb2rgb $h $s $b]
                    }
                }
            }
            set indexcolor 0
            foreach value $lv  {
                set color [lindex $lcolor $indexcolor ]
                $w create rectangle [expr $x + 10] [expr $y + 10] [expr $x + 20] [expr $y + 20] \
                        -fill $color -tags "q $value"
                incr y 15
                incr indexcolor
            }
        } elseif {$nb > 42 && $nb <= 78} {
            set lcolor {}
            # brigthness
            foreach b {1.0 0.7 0.4} {
                # saturation
                foreach s {1.0 0.5}  {
                    # hue
                    foreach h {0 0.5 1 1.5 2 2.5 3 3.5 4 4.5 5 5.5 6}  {
                        lappend lcolor [Operation::ColorPanel_hsb2rgb $h $s $b]
                    }
                }
            }
            set indexcolor 0
            foreach value $lv  {
                set color [lindex $lcolor $indexcolor ]
                $w create rectangle [expr $x + 10] [expr $y + 10] [expr $x + 20] [expr $y + 20] \
                        -fill $color -tags "q $value"
                incr y 15
                incr indexcolor
            }
        }
    }
    #
    proc MultiQueryOperation {w} {
        global S
        set operation [$w get]
        switch -glob $operation {
            "Leaf Foreground Color" {set S(operation) leaffgcolor }
            "Node Foreground Color" {set S(operation) nodefgcolor }
            "Leaf Background Color" {set S(operation) leafbgcolor }
            "Node Background Color" {set S(operation) nodebgcolor }
            "Leaf Illustration (columns)" {set S(operation) LillC ; Interface::PopUp Symbol}
            "Leaf Annotation (columns)" {set S(operation) LannC ; Interface::PopUp Text}
            "Query: Leaf Annotate (columns)" {set S(DisplayVOV) 0 ;  set S(operation) qLannC}
            "Query: Node Annotate" {set S(operation) insertvarval}
        }
        #"Query: Leaf Annotate (Variable Operator Value)" {set S(DisplayVOV) 1 ; set S(operation) qLannC}
    }
    #
    proc MultiQueryUpdateColor {w} {
        global S
        $w itemconfigure current -fill $S(col)
    }
    #
    proc MultiQuerySelectAll {w} {
        $w itemconfigure t -fill green3
    }
    #
    proc MultiQueryUnSelectAll {w} {
        $w itemconfigure t -fill red
    }
    # switch green to red or red to green
    proc MultiQuerySelUnSelOne {w} {
        set c [$w itemcget current -fill]
        if {$c == "green3"} {set color red} {set color green3}
        $w itemconfigure current -fill $color
    }
    #"Query: Leaf Annotate (columns)" {set S(operation) qLannC}
    #"Query: Node Annotate" {set S(operation) insertvarval}
    # d3 legend supprimer
    proc MultiQueryGo {id} {
        global S
        # par defaut l'operation est leaffgcolor
        if {[lsearch {leaffgcolor	nodefgcolor	leafbgcolor \
                        nodebgcolor LillC LannC qLannC insertvarval} $S(operation)] ==  -1} {
            set S(operation) leaffgcolor
        }
        # recuperation des valeur en selection
        set c .multiquery$id.canvas.c
        set li [$c find withtag t]
        set lvalues {} ;# lvalues est une A-list valeur couleur
        foreach i $li {
            set color [$c itemcget $i -fill]
            set valeur [lindex [$c gettags $i] end]
            if {$color == "green3"} {
                set ii [$c find withtag [list q && $valeur]]
                set couleur [$c itemcget $ii -fill]
                lappend lvalues $valeur $couleur
            }
        }
        # query
        # $wc mark set insert prompt
        # $wc delete prompt end
        global asedCon
        set transcolor $S(col)
        foreach {v c} $lvalues {
            set S(col) $c
            set q "$S(MultiQueryQuery$id) $v \n"
            set wc .identification.pw.pane2.childsite.console.t
            $wc insert prompt $q
            $wc see insert
            Database::evalCommand $wc $asedCon [Database::getCommand $wc]
        }
        set S(col) $transcolor
        # LEGENDE
        if {$S(MultiQueryLegend$id) == 1} {
            #liste des fenetre en target
            set lwi {}
            foreach key [array names S *,tar]  {
                if {$S($key) == 1} {
                    set ti [string range $key 0 [expr [string first , $key] - 1]]
                    if {$ti != 0} {
                        if {[lsearch -exact $lwi  $S($ti,w)] == -1} {lappend lwi $S($ti,w)}
                    }
                }
            }
            foreach w $lwi {
                set x 10
                set y 10
                set tagi [format "%s%s" LE [Tools::GenId]]
                
                if {$S(LegendLabels) == 1} {
                    incr y 10
                    set LabelsL "Labels: [lindex    $S(MultiQueryQuery$id) 3 ]"
                    $w create text $x $y   \
                            -text "$LabelsL" \
                            -anchor w  -tags "Legend txt $tagi"
                    
                }
                if {$S(LegendVariable) == 1} {
                    incr y 10
                    set VariableL "Variable: [lindex  $S(MultiQueryQuery$id) 5 ]"
                    $w create text $x $y   \
                            -text "$VariableL" \
                            -anchor w  -tags "Legend txt $tagi"
                    
                }
                if {$S(LegendOperator) == 1} {
                    incr y 10
                    set OperatorL "Operator:[lindex  $S(MultiQueryQuery$id) 6 ]"
                    $w create text $x $y   \
                            -text "$OperatorL" \
                            -anchor w  -tags "Legend txt $tagi"
                    
                }
                if {$S(LegendOperation) == 1} {
                    incr y 10
                    switch -exact $S(operation) {
                        leaffgcolor	{set texto "Leaf Foreground Color"}
                        nodefgcolor	{set texto "Node Foreground Color"}
                        leafbgcolor {set texto "Leaf Background Color"}
                        nodebgcolor	{set texto "Node Background Color"}
                        LillC {set texto "Leaf Illustration"}
                        LannC {set texto "Leaf Annotation"}
                        qLannC {set texto "Query Leaf Annotation "}
                        insertvarval {set texto "Query Node Annotation"}
                    }
                    $w create text $x $y  -text "Operation: $texto" \
                            -anchor w  -tags "Legend txt $tagi"
                }
                if {$S(LegendBox) == 1} {
                    foreach {v c} $lvalues {
                        if {$S(operation) == "LillC"} {
                            set illtxt [concat " " $S(ill-car) ]
                            set illfon $S(ill-fon)
                            $w create text $x [expr $y + 10] -fill $c -anchor w \
                                    -text $illtxt -font $illfon  -tags "Legend txt $tagi"
                            $w create text [expr $x + 20] [expr $y + 10] \
                                    -text $v -anchor w  -tags "Legend txt $tagi"
                        } else  {
                            $w create rectangle $x  [expr $y + 10] [expr $x + 10] [expr $y + 20] \
                                    -fill $c -tags "Legend $tagi"
                            $w create text [expr $x + 20] [expr $y + 16] \
                                    -text $v -anchor w  -tags "Legend txt $tagi"
                        }
                        incr y 15
                    }
                } else  {
                    foreach {v c} $lvalues {
                        $w create text $x [expr $y + 10] -fill $c \
                                -text $v -anchor w  -tags "Legend txt $tagi"
                        incr y 15
                    }
                }
                if {$S(LegendCadre) == 1} {
                    set co [$w bbox $tagi]
                    set x1 [lindex $co 0] ; set y1 [lindex $co 1] ; set x2 [lindex $co 2] ; set y2 [lindex $co 3]
                    set idc [$w create rectangle [expr $x1 -2 ] [expr $y1 -2 ] [expr $x2 +2 ] [expr $y2 +2 ] \
                            -tag "Legend $tagi" -fill white -outline grey -width 1]
                    $w lower $idc
                }
                Navigation::FitToContents $w
            }
        }
    }
    
    # Percent to color: The following routine produces a color
    # from an integer between 0 and 100, where 0 is red, 50 is yellow,
    # and 100 is green (useful e.g. for painting progress bars):
    proc percent2rgb {n} {
        # map 0..100 to a red-yellow-green sequence
        set n     [expr {$n < 0? 0: $n > 100? 100: $n}]
        set red   [expr {$n > 75? 60 - ($n * 15 / 25) : 15}]
        set green [expr {$n < 50? $n * 15 / 50 : 15}]
        format    "#%01x%01x0" $red $green
    }
    #presented this simple beauty in the Tcl chatroom on 2002-12-18:
    proc randomColor {} {format #%06x [expr {int(rand() * 0xFFFFFF)}]}
    #
    proc QueryGoVarOpVal {} {
        global asedCon
        set wi .identification.pw.pane1.childsite.cc.variable.l
        if [catch {$wi get [$wi curselection]} variable] {
            tk_messageBox -message "Variable is missing" -type ok; return
        } else {
            set wi .identification.pw.pane1.childsite.cc.operators.l
            if [catch {$wi get [$wi curselection]} operator] {
                tk_messageBox -message "Operator is missing" -type ok; return
            } else {
                set wi .identification.pw.pane1.childsite.cc.value.l
                if [catch {$wi get [$wi curselection]} value] {
                    tk_messageBox -message "Value is missing" -type ok; return
                } else {
                    set q " $variable $operator $value"
                    set wc .identification.pw.pane2.childsite.console.t
                    # $wc mark set insert prompt
                    # $wc delete prompt end
                    $wc insert prompt $q
                    $wc see insert
                }
            }
        }
    }
    #
    proc AddConnector {c} {
        set wc .identification.pw.pane2.childsite.console.t
        $wc mark set insert prompt
        $wc delete prompt end
        $wc insert prompt $c
        $wc see insert
    }
    #
    proc AddRow {} {
        # construire la ligne du tableur
        .identification.pw.pane0.childsite.ma.t insert rows end 1
        # remplir la table f
        global f
        set NBvariables [expr [llength [array names f 0,*]] -1]
        set NBrecords [expr [llength [array names f *,0]] -1]
        set row [expr $NBrecords + 1]
        for  {set col 1} {$col <= $NBvariables} {incr col} {
            set f($row,$col) -
        }
        set f($row,0) ?
        # mise a jour
        dbUpdate
    }
    #
    proc AddConsole {s} {
        global window
        puts $s
    }
    #
    proc AddColumn {} {
        # construire la colonne du tableur
        .identification.pw.pane0.childsite.ma.t insert cols end 1
        # remplir la table f
        global f
        set NBvariables [expr [llength [array names f 0,*]] -1]
        set NBrecords [expr [llength [array names f *,0]] -1]
        set col [expr $NBvariables + 1]
        for  {set row 1} {$row <= $NBrecords} {incr row} {
            set f($row,$col) -
        }
        set f(0,$col) ?
        # mise a jour
        dbUpdate
    }
    ###
    proc FontMatrix {} {
        global S
        set font [list $S(matrix-font-family) $S(matrix-font-size)]
        .identification.pw.pane0.childsite.ma.t configure -font $font
    }
    ###
    proc FindSearch {} {
        global S T f
        set pattern [.identification.c.es get]
        # attention premiere ligne 0, le nom des variables (indice de ligne = 0)
        set nbrows [expr [lindex  [.identification.pw.pane0.childsite.ma.t configure -rows] end] -1]
        set eu {}
        for  {set i 1} {$i <= $nbrows} {incr i} {
            if {[string match $pattern $f($i,0)]}  {lappend eu $f($i,0) }
        }
        Database::LocalisationMatrix $eu
        set S(msgindent2) "[llength $eu] matching leaves"
    }
    ###
    proc MenuHistory {m} {
        global S  asedCon conWindow
        $m  delete 0 end
        set i 0
        foreach query $S(history)  {
            incr i
            # ici on est dans l'interpreteur maitre
            $m add command  -label "$i > $query" \
                    -command "set S(query) \"$query\" ; eval {Database::Select} $query"
        }
    }
    ###
    proc MenuTreeInit {m} {
        global S
        $m  delete 0 end
        set l {}
        # pour chaque fenetre ayant un ou plusieurs tree
        foreach key [array names S *,w] {
            # pour chaque tree de la fenetre
            foreach t $S($S($key),t) {
                if {[lsearch -exact $l $t] == -1} {lappend l $t}
            }
        }
        foreach t $l  {
            $m add checkbutton -label $S($t,tit) -variable S($t,init)
        }
    }
    ###
    proc dbBrowserFill {w} {
        global f S
        set database $S(database)
        
        if {$database != ""} {
            
            upvar #0 $database X
            # init
            if {[winfo exists $w.t] == 1} {destroy $w.t $w.sy $w.sx}
            catch {unset f}
            
            # unset f
            # remplissage row 0 col j
            set variables [dbQueryVarAll $database]
            set records [lsort -dictionary [dbQueryRecordsAll $database]]
            set j -1
            foreach variable $variables {
                incr j
                set f(0,$j) $variable
            }
            # remplissage i,j
            set NBvariables [llength $variables]
            set NBrecords [llength $records]
            set S(msgindent1) "$NBrecords records * [expr $NBvariables -1] columns"
            set row 0 ; set col -1
            foreach record $records {
                incr row ; set col -1
                foreach variable $variables {
                    incr col
                    set data [$database $record $variable]
                    if {$data == ""} {set data -}
                    regsub -all " " $data "\n" data
                    set f($row,$col) $data
                }
            }
            # construction Tktable
            set ta [table $w.t -rows [expr $NBrecords + 1] -cols $NBvariables -variable f  \
                    -yscrollcommand "$w.sy set"  -xscrollcommand  "$w.sx set " \
                    -titlerows 1 -titlecols 0 \
                    -height 10 -rowheight 1 -selectmode extended -bd 1\
                    -colstretch unset -rowstretch last  ]
            #-browsecommand {Database::dbUpdate}]
            #-browsecommand {Database::LocalisationMatrixUser %S}]
            
            $ta tag config title -bg grey60 -relief groove
            #
            for  {set i 1} {$i <= $row} {incr i} {
                $ta tag row $f($i,0) $i
            }
            scrollbar $w.sy -command [list $w.t yview]
            scrollbar $w.sx -command [list $w.t xview] -orient horizontal
            # GRID
            grid $w.t -row 0 -column 0 -sticky news
            grid $w.sx -row 1 -column 0 -sticky ew
            grid $w.sy -row 0 -column 1 -sticky ns
            grid rowconfigure $w 0  -weight 1
            grid columnconfigure $w 0 -weight 1
        }
    }
    # mise a jour database suite MAJ user sur array f
    # de f vers database
    proc dbUpdate {} {
        global f S
        set NBvariables [expr [llength [array names f 0,*]] -1]
        set NBrecords [expr [llength [array names f *,0]] -1]
        set database $S(database)
        upvar #0 $database X
        #on delete X
        unset X
        #et on reconstruit
        db $database
        for  {set row 1} {$row <= $NBrecords} {incr row} {
            set data {}
            append data " \{$f($row,0)\}"
            for  {set col 1} {$col <= $NBvariables} {incr col} {
                # on construit la A-List Var Val
                append data " $f(0,$col) \{[split $f($row,$col)]\}"
            }
            set id [incr S(lastid)]
            eval $database [concat $id EU $data]
        }
        BuiltAddVariableConsole
    }
    # pour l'instant on ne traite que les $rows,0
    # pour ca on utilise pas $f($s) directement
    proc LocalisationMatrixUser {s} {
        global f S T
        set row [string range $s 0 [expr [string first , $s] - 1]]
        set indice [format "%s%s%s" $row , 0]
    }
    #
    proc flashWin {win delay} {
        set color [$win cget -bg]
        $win configure -bg red
        update
        after $delay
        $win configure -bg $color
        update
    }
    #
    proc reset {} {
        global asedCon
        interp eval $asedCon {
            if {[lsearch [package names] Tk] != -1} {
                foreach child [winfo children .] {
                    if {[winfo exists $child]} {destroy $child}
                }
                wm withdraw .
            }
        }
    }
    #
    proc conPuts {var {tag output} {win {}} {flash 0} {see 1}} {
        global prompt
        global conWindow
        if {$win == {}} {
            #set win $conWindow
            set win $conWindow.t
        }
        $win mark gravity prompt right
        $win insert end $var $tag
        if {[string index $var [expr [string length $var]-1]] != "\n"} {
            $win insert end "\n"
        }
        set prompt "TreeDyn Identification"
        $win insert end "$prompt % " prompt
        $win mark gravity prompt left
        if $see {$win see insert}
        update
        if $flash {
            flashWin $win $flash
        }
        return
    }
    #
    proc consolePuts {args} {
        global prompt
        global conWindow
        global errorInfo
        
        set argcounter [llength $args]
        if {[llength $args] > 3} {
            conPuts [list [tr "invalid arguments"] error]
        }
        set newline "\n"
        if {[string match "-nonewline" [lindex $args 0]]} {
            set newline ""
            set args [lreplace $args 0 0]
        }
        if {[llength $args] == 1} {
            set chan stdout
            set string [lindex $args 0]$newline
        } else {
            set chan [lindex $args 0]
            set string [lindex $args 1]$newline
        }
        if [regexp (stdout|stderr) $chan] {
            eval conPuts [list $string]
        } else {
            puts -nonewline $chan $string
        }
    }
    #
    proc SetValues {_code _result _errorInfo} {
        global code result errorInfo
        set code $_code
        set result $_result
        set errorInfo $_errorInfo
    }
    # proc evalCommand
    # executes commands within a seperate interpreter
    # runs also windows commands via exec
    proc evalCommand {window Interp command} {
        global errorInfo
        global env
        global code
        global result
        global prompt
        global historyIndex
        global tcl_platform
        global buffer
        set historyIndex 0
        if {$command != {} && $command != "\n"} {
            if {$command == "reset\n"} {
                set buffer ""
                conPuts [tr "current command canceled !"] error
                return
            } elseif {$command == "cls\n"} {
                $window delete 1.0 end-1c
                $window insert end "$prompt % " prompt
                $window mark set prompt insert
                $window mark gravity prompt left
                return
            }
            append buffer $command
            if {[info complete $buffer]} {
                set evalCommand $buffer
                set buffer ""
                history add $evalCommand
                interp eval $Interp set evalCommand [list $evalCommand]
                if {[info commands [lindex $evalCommand 0]] == "puts"} {
                    eval regsub "puts " $evalCommand "" evalCommand
                    eval [list consolePuts $evalCommand]
                    return
                }
                interp eval $Interp {
                    set code [catch "eval [list $evalCommand]" result]
                    setValues $code $result $errorInfo
                }
                update idletasks
                if {!$code} {
                    if {$result != {}} {
                        eval [list conPuts $result]
                    } else  {
                        set prompt "TreeDyn Identification"
                        $window mark gravity prompt right
                        $window insert end "$prompt % " prompt
                        $window mark gravity prompt left
                        $window see insert
                    }
                } else  {
                    if {[info commands [lindex $evalCommand 0]] != ""} {
                        eval [list conPuts $errorInfo error]
                    } else  {
                        if {$tcl_platform(platform) == "windows"} {
                            set comspec [file split $env(COMSPEC)]
                            set temp ""
                            foreach item $comspec {
                                set temp [file join $temp $item]
                            }
                            set execComspec [concat $temp /c $evalCommand]
                        } else {
                            set execComspec $evalCommand
                        }
                        set code [catch {eval exec $execComspec} result]
                        #conPuts "code:$code - result:$result"
                        conPuts "\n"
                        if {!$code} {
                            if {$result != {}} {
                                eval [list conPuts $result output]
                            } else  {
                                set prompt "TreeDyn Identification"
                                $window mark gravity prompt right
                                $window insert end "$prompt % " prompt
                                $window mark gravity prompt left
                                $window see insert
                            }
                        } else  {
                            #eval [list conPuts $errorInfo error]
                            eval [list conPuts ?]
                        }
                    }
                }
            }
        } else  {
            set prompt "TreeDyn Identification"
            $window mark gravity prompt right
            $window insert end "$prompt % " prompt
            $window mark gravity prompt left
            $window see insert
        }
        set prompt "TreeDyn Identification"
    }
    #
    proc getCommand {window} {
        global prompt S
        set command [$window get prompt end-1c]
        $window mark set prompt insert
        set S(query) [lrange $command [expr [lsearch $command where] + 1] end]
        return $command
    }
    proc searchHistory {direction} {
        global historyIndex
        switch $direction {
            backwards {
                if {$historyIndex > -20} {
                    set command [history event $historyIndex]
                    incr historyIndex -1
                    return $command
                } else  {
                    return {}
                }
            }
            forwards {
                if {$historyIndex < -1} {
                    incr historyIndex
                    set command [history event [expr $historyIndex+1]]
                    return $command
                } else  {
                    return {}
                }
            }
            default {tk_messageBox -message [tr "Internal Error"] -type ok; return}
        }
    }
    #
    proc onKeyPressed {win} {
        if {[$win compare insert < prompt]} {
            $win mark set insert prompt
            $win see insert
        }
    }
    #
    proc onButtonPressed {win} {
    }
    #
    proc onKeyHome {win} {
        $win mark set insert prompt
    }
    #
    proc onKeyUp {win} {
        if {[$win compare insert >= prompt]} {
            $win mark set insert prompt
            $win delete prompt end
            set command [searchHistory backwards]
            $win insert prompt $command
            $win see insert
        } else  {
            $win mark set insert "insert - 1line"
        }
    }
    #
    proc onKeyDown {win} {
        if {[$win compare insert >= prompt]} {
            $win mark set insert prompt
            $win delete prompt end
            set command [searchHistory forwards]
            $win insert prompt $command
            $win see insert
        } else  {
            $win mark set insert "insert + 1line"
        }
    }
    #
    proc onKeyLeft {win} {
        if {[$win compare insert >= prompt]} {
            set curPos [lindex [split [$win index insert] "."] 1]
            set promptPos [lindex [split [$win index prompt] "."] 1]
            if {$curPos <= $promptPos} {
                return {}
            } else  {
                $win mark set insert insert-1c
            }
        } else  {
            $win mark set insert "insert -1c"
        }
    }
    #
    proc onKeyRight {win} {
        $win mark set insert "insert +1c"
    }
    #
    proc onKeyBackSpace {win} {
        
        if {[$win compare insert <= prompt]} {
            return {}
        }  else  {
            $win delete insert-1c
        }
    }
    #
    proc treedynaliases {} {
        set help " select <var> from <table>\n\
                select <var> from <table> where <var> <operator> <val>\n\
                available operators : == ; != ; > ; < ; >= ; <= \n\
                the operators ## (include) and !# (do not include) can be used with pattern matching\n\
                ... where <var1> == <val1> <and|or> <var2> == <val2>\n\
                ... where {<var1> == <val1> or <var2> == <val2>} and <var3> == <val3>\n "
        return $help
    }
    ###
    proc consoleInit {win {width 60} {height 10}} {
        global asedCon
        global prompt
        global window
        global historyIndex
        set historyIndex 0
        set window $win
        set prompt "TreeDyn Identification"
        if {$window == "."} {
            set window ""
        }
        $asedCon alias setValues Database::SetValues
        $asedCon alias exit Database::reset
        $asedCon alias puts Database::consolePuts
        $asedCon alias  db "Database::db"
        $asedCon alias dbdomainvar "Database::dbQueryValFromVar"
        $asedCon alias dbvarval "Database::dbQueryRecordsFromVarVal"
        $asedCon alias ? "Database::treedynaliases"
        $asedCon alias select  "Database::Select"
        $asedCon alias ss   "Database::dbQueryRecordsFromVarOpVal"
        scrollbar $window.ysbar -orient vertical -command "$window.t yview"
        text $window.t -width $width -height $height   \
                -yscrollcommand "$window.ysbar set"  -highlightthickness 0
        grid $window.t -row 0 -column 0 -sticky news
        grid $window.ysbar -row 0 -column 1 -sticky ns
        grid rowconfigure $window 0  -weight 1
        grid columnconfigure $window 0 -weight 1
        $window.t tag configure output -foreground SeaGreen4
        $window.t tag configure prompt -foreground blue
        $window.t tag configure error -foreground grey
        $window.t insert end "$prompt % " prompt
        $window.t mark set prompt insert
        $window.t mark gravity prompt left
        bind $window.t <KeyPress-Return> {%W mark set insert "prompt lineend"}
        bind $window.t <KeyRelease-Return> {Database::evalCommand %W $asedCon [Database::getCommand %W];break}
        bind $window.t <Key-Up> {Database::onKeyUp %W ; break}
        bind $window.t <Key-Down> {Database::onKeyDown %W ; break}
        bind $window.t <Key-Left> {Database::onKeyLeft %W ; break}
        bind $window.t <Key-Right> {Database::onKeyRight %W ; break}
        bind $window.t <Key-BackSpace> {Database::onKeyBackSpace %W;break}
        bind $window.t <Key-Home> {Database::onKeyHome %W ;break}
        bind $window.t <Control-c> {set dummy nothing}
        bind $window.t <KeyPress> {Database::onKeyPressed %W}
        return $window.t
    }
    #
    proc LoadTransitionFile {} {
        global S asedCon
        set filtre {}
        lappend filtre [list {TreeDyn Label File} .txt]
        set typelist {
            {"TreeDyn Labels Files" {".tlf"} }
            {"All Files" {*}}
        }
        set filename [tk_getOpenFile -initialdir $S(userDIR)  -defaultextension "tlf" \
                -filetypes $typelist -title "Load TreeDyn Transition File..."]
        if {$filename != ""} {set S(userDIR) [file dirname $filename]}
        if [catch {open $filename r} fid] {
            Interface::TreeDynMessage "Error Opening File"
        } else {
            set currentfile [Tools::PathCut2 $filename]
            if [interp exists treedyn] {interp delete treedyn}
            set asedCon [interp create treedyn]
            $asedCon alias db "Database::db"
            Database::db $currentfile
            while {[eof $fid] != 1} {
                set id [incr S(lastid)]
                gets $fid data
                eval $currentfile [concat $id EU $data]
            }
            close $fid
        }
        set S(database) $currentfile
    }
    
}
################################################################################


################################################################################
# OPERATION
################################################################################
namespace eval Operation {
    
    proc MenuOperation {w} {
        set wop [frame $w.wop ]
        menubutton $wop.loca -text "Operation: " -menu $wop.loca.m -relief groove  -indicatoron 1
        set mc [menu  $wop.loca.m -tearoff 0 -relief groove]
        $mc add radio -label "Console Only (no graphic operation)" \
                -variable S(operation) -value console -command {set S(operationName) "Console Only"} ;# OK
        $mc add separator
        
        $mc add radio -label  "Query: Canvas Annotate" -variable S(operation) \
                -value querynode -command {set S(operationName) "Query: Canvas Annotate"}
        $mc add separator
        $mc add radio -label "Leaf Foreground Color" -variable S(operation) \
                -value leaffgcolor -command {set S(operationName) "Leaf Foreground Color"}
        $mc add radio -label "Leaf Background Color" -variable S(operation) \
                -value leafbgcolor -command {set S(operationName) "Leaf Background Color"}
        $mc add radio -label "Leaf Font" -variable S(operation) \
                -value leaffontglob -command {set S(operationName) "Leaf Font"}
        $mc add radio -label  "Leaf Illustration (leaves)" -variable S(operation) \
                -value LillL -command {set S(operationName) "Leaf Illustration" ; Interface::PopUp Symbol}
        $mc add radio -label  "Leaf Illustration Symbol (columns)" -variable S(operation) \
                -value LillC -command {set S(operationName) "Leaf Illustration" ; Interface::PopUp Symbol}
        $mc add radio -label  "Leaf Illustration Polygon (columns)" -variable S(operation) \
                -value LillCpolygon -command {set S(operationName) "Leaf Illustration"}
        $mc add radio -label  "Leaf Annotate (leaves, user's text)" -variable S(operation) \
                -value LannL -command {set S(operationName) "Leaf Annotate" ; Interface::PopUp Text}
        $mc add radio -label  "Leaf Annotate (leaves, value)" -variable S(operation) \
                -value qLannL -command {set S(operationName) "Query: Leaf Annotate"}
        $mc add radio -label  "Leaf Annotate (columns, user's text)" -variable S(operation) \
                -value LannC -command {set S(operationName) "Leaf Annotate" ; Interface::PopUp Text}
        $mc add radio -label  "Leaf Annotate (columns, value)" -variable S(operation) \
                -value qLannC -command {set S(DisplayVOV) 0 ; \
                    set S(operationName) "Query: Leaf Annotate" ; Operation::TabPanelQueryAnnotate}
        $mc add radio -label "Leaf Hide" -variable S(operation) \
                -value leafshrink -command {set S(operationName) "Leaf Hide"}
        $mc add radio -label "Leaf Display" -variable S(operation) \
                -value leafunshrink -command {set S(operationName) "Leaf Display"}
        $mc add separator
        $mc add radio -label "Node Foreground Color" -variable S(operation) \
                -value nodefgcolor -command {set S(operationName) "Node Foreground Color"}
        $mc add radio -label "Node Background Color" -variable S(operation) \
                -value nodebgcolor -command {set S(operationName) "Node Background Color"}
        $mc add radio -label "Node Width Line +" -variable S(operation) \
                -value widthline+ -command {set S(operationName) "Node Width Line +"}
        $mc add radio -label "Node Width Line -" -variable S(operation) \
                -value widthline- -command {set S(operationName) "Node Width Line -"}
        $mc add radio -label "Node Dash Line On" -variable S(operation) \
                -value nodedashOn -command {set S(operationName) "Node Dash Line On"}
        $mc add radio -label "Node Dash Line Off" -variable S(operation) \
                -value nodedashOff -command {set S(operationName) "Node Dash Line Off"}
        $mc add radio -label "Node Illustration" -variable S(operation) \
                -value nodeillustration -command {set S(operationName) "Node Illustration" ;  Interface::PopUp Symbol }
        $mc add radio -label "Node Illustration (link)" -variable S(operation) \
                -value symbolnode -command {set S(operationName) "Node Illustration (link)" ;  Interface::PopUp Symbol }
        $mc add radio -label  "Node Annotate (user's text)" -variable S(operation) \
                -value nodeannotate -command {set S(operationName) "Node Annotate" ;  Interface::PopUp Text}
        $mc add radio -label  "Node Annotate (variable-value)" -variable S(operation) \
                -value insertvarval -command {set S(operationName) "Query: Node Annotate"}
        $mc add radio -label  "Node Annotate (value)" -variable S(operation) \
                -value insertvarval2 -command {set S(operationName) "Query: Node Annotate2"}
        $mc add radio -label "Node Shrink" -variable S(operation) \
                -value shrink -command {set S(operationName) "Node Shrink"}
                $mc add radio -label "Node Shrink II" -variable S(operation) \
                        -value shrink3 -command {set S(operationName) "Node Shrink II"}
                $mc add radio -label "Node Shrink III" -variable S(operation) \
                        -value shrink4 -command {set S(operationName) "Node Shrink III"}
        $mc add radio -label "Node UnShrink" -variable S(operation) \
                -value unshrink -command {set S(operationName) "Node UnShrink"}
        $mc add radio -label "Node Collapse" -variable S(operation) \
                -value collapse -command {set S(operationName) "Node Collapse"}
        $mc add radio -label "Node UnCollapse" -variable S(operation) \
                -value uncollapse -command {set S(operationName) "Node UnCollapse"}
        $mc add radio -label "Node Network" -variable S(operation) \
                -value nodenetwork -command {set S(operationName) "Node Network"}
        $mc add radio -label "Node Extract" -variable S(operation) \
                -value nodeextract -command {set S(operationName) "Node Extract"}
        message $wop.msg -width 200 -textvariable S(operationName)
        pack $wop.loca $wop.msg -side left -expand yes -fill x
        return $wop
    }
    #
    proc MenuOperation2 {w} {
        set wop [frame $w.wop]
        menubutton $wop.loca  -text "Operation: " -menu $wop.loca.m  -relief groove -indicatoron 1
        set mc [menu  $wop.loca.m -tearoff 0]
        $mc add radio -label "Leaf Foreground Color" -variable S(operation) \
                -value leaffgcolor -command {set S(operationName) "Leaf Foreground Color"}
        $mc add radio -label "Leaf Background Color" -variable S(operation) \
                -value leafbgcolor -command {set S(operationName) "Leaf Background Color"}
        $mc add radio -label "Leaf Font" -variable S(operation) \
                -value leaffontglob -command {set S(operationName) "Leaf Font"}
        $mc add radio -label  "Leaf Illustration (leaves)" -variable S(operation) \
                -value LillL -command {set S(operationName) "Leaf Illustration" ; Interface::PopUp Symbol}
        $mc add radio -label  "Leaf Illustration (columns)" -variable S(operation) \
                -value LillC -command {set S(operationName) "Leaf Illustration" ; Interface::PopUp Symbol}
        $mc add radio -label  "Leaf Annotate (leaves)" -variable S(operation) \
                -value LannL -command {set S(operationName) "Leaf Annotate" ; Interface::PopUp Text}
        $mc add radio -label  "Leaf Annotate (columns)" -variable S(operation) \
                -value LannC -command {set S(operationName) "Leaf Annotate" ; Interface::PopUp Text}
        $mc add radio -label "Leaf Hide" -variable S(operation) \
                -value leafshrink -command {set S(operationName) "Leaf Hide"}
        $mc add radio -label "Leaf Display" -variable S(operation) \
                -value leafunshrink -command {set S(operationName) "Leaf Display"}
        $mc add separator
        $mc add radio -label "Node Foreground Color" -variable S(operation) \
                -value nodefgcolor -command {set S(operationName) "Node Foreground Color"}
        $mc add radio -label "Node Background Color" -variable S(operation) \
                -value nodebgcolor -command {set S(operationName) "Node Background Color"}
        $mc add radio -label "Node Width Line +" -variable S(operation) \
                -value widthline+ -command {set S(operationName) "Node Width Line +"}
        $mc add radio -label "Node Width Line -" -variable S(operation) \
                -value widthline- -command {set S(operationName) "Node Width Line -"}
        $mc add radio -label "Node Dash Line On" -variable S(operation) \
                -value nodedashOn -command {set S(operationName) "Node Dash Line On"}
        $mc add radio -label "Node Dash Line Off" -variable S(operation) \
                -value nodedashOff -command {set S(operationName) "Node Dash Line Off"}
        $mc add radio -label "Node Illustration" -variable S(operation) \
                -value nodeillustration -command {set S(operationName) "Node Illustration" ;  Interface::PopUp Symbol }
        $mc add radio -label "Node Illustration (link)" -variable S(operation) \
                -value symbolnode -command {set S(operationName) "Node Illustration (link)" ;  Interface::PopUp Symbol }
                $mc add radio -label  "Node Annotate" -variable S(operation) \
                        -value nodeannotate -command {set S(operationName) "Node Annotate" ;  Interface::PopUp Text}
                $mc add radio -label "Node Shrink" -variable S(operation) \
                        -value shrink -command {set S(operationName) "Node Shrink"}
                $mc add radio -label "Node Shrink II" -variable S(operation) \
                        -value shrink3 -command {set S(operationName) "Node Shrink II"}
                $mc add radio -label "Node Shrink III" -variable S(operation) \
                        -value shrink4 -command {set S(operationName) "Node Shrink III"}
        $mc add radio -label "Node UnShrink" -variable S(operation) \
                -value unshrink -command {set S(operationName) "Node UnShrink"}
        $mc add radio -label "Node Collapse" -variable S(operation) \
                -value collapse -command {set S(operationName) "Node Collapse"}
        $mc add radio -label "Node UnCollapse" -variable S(operation) \
                -value uncollapse -command {set S(operationName) "Node UnCollapse"}
        $mc add radio -label "Node Network" -variable S(operation) \
                -value nodenetwork -command {set S(operationName) "Node Network"}
        $mc add radio -label "Node Extract" -variable S(operation) \
                -value nodeextract -command {set S(operationName) "Node Extract"}
        message $wop.msg -width 200 -textvariable S(operationName)
        pack $wop.loca $wop.msg -side left -expand yes -fill x
        return $wop
    }
    # panel annotation utilisateur
    proc AnnotatePanel {w} {
        global S
        # fenetre de controls : tabulation + tools + font/color
        set contr [frame $w.ctls ]
        # controles de tabulation
        Database::OperationTabulation $contr.tab
        # toolbox
        
        eval {iwidgets::toolbar} $contr.t
        $contr.t add radiobutton  movematrix -overrelief sunken\
                -variable S(tool) -value movematrix \
                -image TIMmovematrix
        $contr.t add radiobutton  movecol -overrelief sunken\
                -variable S(tool) -value movecol \
                -image TIMmovecol
        $contr.t add radiobutton  annfgcol -overrelief sunken\
                -variable S(tool) -value annfgcol \
                -image TIMannfgcol
        $contr.t add radiobutton  annfgrow -overrelief sunken\
                -variable S(tool) -value annfgrow -overrelief sunken\
                -image TIMannfgrow
        $contr.t add radiobutton  annfocol -overrelief sunken\
                -variable S(tool) -value annfocol \
                -image TIMannfocol
        $contr.t add radiobutton  annforow -overrelief sunken\
                -variable S(tool) -value annforow \
                -image TIMannforow
        $contr.t add radiobutton  annanchw -overrelief sunken\
                -variable S(tool) -value annanchw \
                -image TIMannanchw
        $contr.t add radiobutton  annanche -overrelief sunken\
                -variable S(tool) -value annanche \
                -image TIMannanche
        # texteditor
        set ww [frame $w.edit]
        text $ww.e  -yscrollcommand "$ww.sy set" -width 20 -height 15
        $ww.e insert end $S(AnnotateNote)
        bind $ww.e <Any-Leave> "Operation::AnnotatePanelUpdate $ww.e"
        scrollbar $ww.sy -orient vert -command "$ww.e yview"
        grid $ww.e -row 0 -column 0 -sticky news
        grid $ww.sy -row 0 -column 1 -sticky ns
        grid rowconfigure $w.edit 0 -weight 1
        grid columnconfigure $w.edit 0 -weight 1
        # PACK controls
        pack $contr.tab $contr.t  -side left -expand yes -fill x
        pack $contr $ww -side top -expand yes -fill both
    }
    # panel pour la tabulation avec l'operation query: annotate panel
    proc TabPanelQueryAnnotate {} {
        global S
        if {[winfo exists .tabpanelqueryannot] == 1} {
            wm deiconify .tabpanelqueryannot
        } else  {
            set w .tabpanelqueryannot
            toplevel $w -relief raised -borderwidth 2
            wm geometry $w "+[winfo pointerx $w]+[winfo pointery $w]"
            wm title .tabpanelqueryannot "Annotation"
            Database::OperationTabulation .tabpanelqueryannot.tab
            pack .tabpanelqueryannot.tab
        }
    }
    #
    proc AnnotatePanelUpdate {editor} {
        global S
        set s [$editor get 0.0 end]
        regsub -all {\n} $s " " s
        set S(AnnotateNote) $s
    }
   
    proc AnnotHTTPpanel {} {
            global S 
            destroy .annothttp
            set S(annoturllist) [list \
            "http://pbil.univ-lyon1.fr/cgi-bin/acnuc-search-ac?db=GenBank&query=" \
            "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=Nucleotide&cmd=search&val=" \
            ]
            set S(annoturl) "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=Nucleotide&cmd=search&val="
            set f [toplevel .annothttp]
            wm title $f "URLs Annotation"
            
            # URL menu
            menubutton $f.urlselect -text "URLs"  -menu $f.urlselect.m  -direction below
            set z  [menu  $f.urlselect.m -tearoff 0]
            $z configure -postcommand "Operation::AnnotHTTPpanelmenu $z"
            
            # URL current/entry
            entry $f.urlcurrent -width 80 -textvariable S(annoturl)
           
            # PACK 
            pack $f.urlselect $f.urlcurrent -side left -fill x -expand yes
    }
    proc AnnotHTTPpanelmenu {m} {
            global S
            $m  delete 0 end
            foreach url $S(annoturllist)  {
                $m add command -label "$url" -command "set S(annoturl)  $url"
            }
    }
    proc AnnotHTTPgo {w x y} {
            global S env tcl_platform
            set annotation [lindex [$w itemconfigure current -text] end]
            set url "$S(annoturl)$annotation"
            #puts $url
            #exec [file join $env(COMSPEC)] << "start $url \n exit"
            #exec [file join $env(COMSPEC)] << "start \"\" \"$url\" \n exit"
            switch $tcl_platform(platform) {
                "unix" {catch { exec mozilla  $url &} err}
                "windows" {catch {eval exec "{C:/program files/internet explorer/iexplore.exe}" $url &} err}
            }
          
    }
    #
    proc OperationMenu {} {
        global S
        if {[winfo exists .operationmenu] == 1} {
            wm deiconify .operationmenu
        } else  {
            set w .operationmenu
            destroy $w
            toplevel $w -relief raised -borderwidth 2
            wm geometry $w "+[winfo pointerx $w]+[winfo pointery $w]"
            wm title .operationmenu "Operation"
            set ww [frame $w.op]
            set wi [Operation::MenuOperation2 $ww]
            pack $ww -expand yes -fill x
            pack $wi -expand yes -fill x
        }
    }
    #
    proc IllustrationPanel  {{w ?}} {
        global S
        
        Database::OperationTabulation $w.tabul
        
        # menu type symbol
        menubutton $w.type  -text "Type" -menu $w.type.m  -relief groove -indicatoron 1
        set mc [menu  $w.type.m -tearoff 0]
        $mc add command -label "Square/Rectangle"  \
                -command "set S(symboltype) 01 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        $mc add command -label "Circle/Oval"  \
                -command "set S(symboltype) 02 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        $mc add command -label "Diamond"  \
                -command "set S(symboltype) 03 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        $mc add command -label "Triangle right"  \
                -command "set S(symboltype) 04 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        $mc add command -label "Triangle left"  \
                -command "set S(symboltype) 05 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        $mc add command -label "Triangle bottom"  \
                -command "set S(symboltype) 06 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        $mc add command -label "Triangle top"  \
                -command "set S(symboltype) 07 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        $mc add command -label "checkboxe Off"  \
                -command "set S(symboltype) 08 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        $mc add command -label "checkboxe On"  \
                -command "set S(symboltype) 09 ; $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        
        # taille
        
        
        iwidgets::entryfield $w.sx -width 5  -textvariable S(symboldx)  \
                -labelimage TVwidth -labelpos w -validate numeric -fixed 30 \
                -command "$w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        iwidgets::entryfield $w.sy -width 5  -textvariable S(symboldy)  \
                -labelimage TVheigth -labelpos w -validate numeric -fixed 30 \
                -command "$w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}"
        
        # canvas
        canvas $w.c -background white
        #GRID
        grid $w.tabul -row 0 -column 0 -columnspan 3
        grid $w.type -row 1 -column 0
        grid $w.sx -row 1 -column 1
        grid $w.sy -row 1 -column 2
        grid $w.c -row 2 -column 0 -columnspan 3
        
        $w.c delete all ;  Illustration::drawsymbol $w.c 100 100 {}
    }
    #
    proc IllustrationPanelORI  {{w ?}} {
        global S
        # controls
        set w1 $w.controls
        frame $w1
        # panel tabulation
        Database::OperationTabulation $w1.tabul
        # toolbox
        set wtools [frame $w1.tools]
        eval {iwidgets::toolbar} $w1.t
        $w1.t add radiobutton  movematrix -overrelief sunken\
                -variable S(tool) -value movematrix \
                -image TIMmovematrix
        $w1.t add radiobutton  movecol -overrelief sunken\
                -variable S(tool) -value movecol \
                -image TIMmovecol
        $w1.t add radiobutton  annfgcol -overrelief sunken\
                -variable S(tool) -value annfgcol \
                -image TIMannfgcol
        $w1.t add radiobutton  annfgrow -overrelief sunken\
                -variable S(tool) -value annfgrow -overrelief sunken\
                -image TIMannfgrow
        $w1.t add radiobutton  annfocol -overrelief sunken\
                -variable S(tool) -value annfocol \
                -image TIMannfocol
        $w1.t add radiobutton  annforow -overrelief sunken\
                -variable S(tool) -value annforow \
                -image TIMannforow
        $w1.t add radiobutton  annanchw -overrelief sunken\
                -variable S(tool) -value annanchw \
                -image TIMannanchw
        $w1.t add radiobutton  annanche -overrelief sunken\
                -variable S(tool) -value annanche \
                -image TIMannanche
        iwidgets::menubar $w.menu   \
                -helpvariable S(topmessage) -menubuttons {
                    menubutton file -text "Family" -menu {
                        options -tearoff false
                        radiobutton marlett -variable S(ill-family) -value Marlett -label "Marlett" \
                                -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton mtextra -variable S(ill-family) -value {MT Extra} -label "MT Extra" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton symbol -variable S(ill-family) -value Symbol -label "Symbol" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton webdings -variable S(ill-family) -value Webdings -label "Webdings" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton wingdings -variable S(ill-family) -value Wingdings -label "Wingdings" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton wingdings2 -variable S(ill-family) -value {Wingdings 2} -label "Wingdings 2" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton wingdings3 -variable S(ill-family) -value {Wingdings 3} -label "Wingdings 3" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
            }
            menubutton weight -text "Weight" -menu {
                options -tearoff false
                radiobutton normal  -variable S(ill-weight) -value normal -label "Normal" \
                        -command "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton bold  -variable S(ill-weight) -value bold -label "Bold" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
            }
            menubutton size -text "Size" -menu {
                options -tearoff false
                radiobutton s6 -variable S(ill-size) -value 6 -label "6" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s7 -variable S(ill-size) -value 7 -label "7" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s8 -variable S(ill-size) -value 8 -label "8" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s9 -variable S(ill-size) -value 9 -label "9" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s10 -variable S(ill-size) -value 10 -label "10" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s11 -variable S(ill-size) -value 11 -label "11" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s12 -variable S(ill-size) -value 12 -label "12" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s14 -variable S(ill-size) -value 14 -label "14" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s15 -variable S(ill-size) -value 16 -label "16" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s18 -variable S(ill-size) -value 18 -label "18" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s20 -variable S(ill-size) -value 20 -label "20" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s28 -variable S(ill-size) -value 28 -label "28" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton s36 -variable S(ill-size) -value 36 -label "36" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
            }
            
            menubutton slant -text "Slant" -menu {
                options -tearoff false
                radiobutton roman -variable S(ill-slant) -value roman -label "Roman" \
                        -command  "Operation::apgClavierVirtuel $w.clavier"
                radiobutton italic -variable S(ill-slant) -value italic -label "Italic" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
            }
            menubutton underline -text "Underline" -menu {
                options -tearoff false
                radiobutton Utrue -variable S(ill-underline) -value 1 -label "Yes" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton Ufalse -variable S(ill-underline) -value 0 -label "No" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
            }
            menubutton overstrike -text "Overstrike" -menu {
                options -tearoff false
                radiobutton Otrue -variable S(ill-overstrike) -value 1 -label "Yes" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
                radiobutton Ofalse -variable S(ill-overstrike) -value 0 -label "No" \
                        -command  "Operation::apgClavierVirtuel $w.clavier ; pack $w.clavier"
            }
        }
        # clavier virtuel
        frame $w.clavier
        apgClavierVirtuel $w.clavier
        
        # PACK
        pack $w1.tabul $w1.t -side left -expand yes -fill x
        pack $w1 $w.menu $w.clavier -expand yes -fill both
        
    }
    proc IllCTabulationPreviewOn {w} {
        global S
        foreach {w t} [Selection::TreeTar] {
            if [catch {expr $S($t,LabelMatrixBase) + 0} result] {
                set S($t,LabelMatrixBase) $S(TabulationAnnot)
            } else  {
                # tabulation entre colonnes
                # possiblite de rester sur la meme colonne
                if {$S(illustration-tabulation) == 1} {
                    set S($t,LabelMatrixBase) $result
                }
            }
            switch -exact $S($t,type) {
                PhyNJ - ClaSla - ClaRec {
                    # recherche x
                    if {$S(illustration-tabulation) == 1} {
                        set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                        set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                        set XMAX3 [lindex [$w bbox [list T$t && AnnotMatrix]] 2]
                        if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                        if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
                        set x [expr $XMAX + $S($t,LabelMatrixBase)]
                    } else  {
                        set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                        set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                        if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                        set x [expr $XMAX + $S($t,LabelMatrixBase)]
                    }
                    # VOIR ensuite pour y
                    $w create line $x 0 $x 1000 -fill grey -tags "TABpreview"
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    set d $S($t,LabelMatrixBase)
                    #set co [$w bbox [list Z && T$t]]
                    set co [$w bbox [list L && T$t]]
                    set x1 [lindex $co 0]
                    set y1 [lindex $co 1]
                    set x2 [lindex $co 2]
                    set y2 [lindex $co 3]
                    $w create oval [expr $x1 - $d] [expr $y1 - $d] \
                            [expr $x2 + $d] [expr $y2 + $d] \
                            -outline grey -tags "TABpreview"
                }
                ClaCir1 - ClaCir2 - ClaCir3 {
                    set d $S($t,LabelMatrixBase)
                    set co [$w bbox [list Z && T$t]]
                    set x1 [lindex $co 0]
                    set y1 [lindex $co 1]
                    set x2 [lindex $co 2]
                    set y2 [lindex $co 3]
                    
                    
                    
                    $w create oval [expr $x1 - $d] [expr $y1 - $d] \
                            [expr $x2 + $d] [expr $y2 + $d] \
                            -outline grey -tags "TABpreview"
                }
            }
        }
    }
    #
    proc IllCTabulationPreviewOff {w} {
        foreach {wi t} [Selection::TreeTar] {
            $wi delete TABpreview
        }
    }
    #
    proc apgM3 {w} {
        if {[winfo exists .apg.move.d3menu ] == 1} {destroy .apg.move.d3menu}
        set m [menu .apg.move.d3menu -tearoff 0]
        $m add command -label Exit -command "destroy .apg"
        tk_popup $m [winfo pointerx $w] [winfo pointery $w]
    }
    proc apgMoveMotion {w x y} {
        global S
        wm geometry .apg "+[winfo pointerx .apg]+[winfo pointery .apg]"
    }
    proc apgClavierVirtuel {w} {
        global S
        set fo [list $S(ill-family) $S(ill-size) $S(ill-weight) $S(ill-slant)]
        if {$S(ill-overstrike) == 1} {lappend fo overstrike}
        if {$S(ill-underline) == 1} {lappend fo underline}
        destroy $w
        
        iwidgets::scrolledframe $w -width 500 -height 300
        set win [$w childsite]
        set listWingding [list "ABCDEFGHIJKLMNOPQRSTUVWXYZ" \
                "abcdefghijklmnopqrstuvwxyz" \
                "0123456789!@#$%^&*()_+-=[]" \
                "{}.;:\"'`~,<>/?\|"]
        set c 0 ; set r 0
        foreach lc $listWingding  {
            set c 0
            foreach ca [split $lc {}] {
                set wii [format "%s%s%s%s"  $win .c $r $c]
                radiobutton $wii -text $ca -font $fo -indicatoron 0 -variable S(ill-car) -value $ca -command "set S(ill-fon) [list $fo]"
                grid $wii -row $r -column $c
                incr c
            }
            incr r
        }
    }
    proc ColorFontPanel {} {
        global S
        set w [toplevel .cf]
        wm geometry .cf "+[winfo pointerx $w]+[winfo pointery $w]"
        wm title .cf "Parameters panel"
        iwidgets::tabnotebook .cf.n  -width 450 -height 370 -equaltabs 0
        # COLOR PANEL
        set op4 [.cf.n add -label "Color" -tabpos e  ]
        iwidgets::Labeledframe $op4.color -labelpos nw -labeltext "Color"
        set win [$op4.color childsite]
        ColorPanel $win
        pack $op4.color -expand true -fill both
        pack $win -expand true -fill both
        # FONT PANEL
        set op5 [.cf.n add -label "Font" -tabpos e  ]
        iwidgets::Labeledframe $op5.font -labelpos nw -labeltext "Font"
        set win [$op5.font childsite]
        FontPanel $win
        pack $op5.font  -expand yes -fill both
        pack $win
        
        # STIPPLE PANEL
        set op6 [.cf.n add -label "Stipple" -tabpos e  ]
        iwidgets::Labeledframe $op6.sti -labelpos nw -labeltext "Stipple"
        set win [$op6.sti childsite]
        Interface::StipplePanel $win
        pack $op6.sti  -expand yes -fill both
        pack $win
        
        # Symbol PANEL
        set op7 [.cf.n add -label "Symbol" -tabpos e  ]
        iwidgets::Labeledframe $op7.sym -labelpos nw -labeltext "Symbol"
        set win [$op7.sym childsite]
        Operation::IllustrationPanel $win
        pack $op7.sym  -expand yes -fill both
        pack $win
        
        # Text PANEL
        set op8 [.cf.n add -label "Text" -tabpos e  ]
        iwidgets::Labeledframe $op8.txt -labelpos nw -labeltext "Text"
        set win [$op8.txt childsite]
        Operation::AnnotatePanel $win
        pack $op8.txt  -expand yes -fill both
        pack $win
        
        # PACK
        pack .cf.n -fill both -expand yes -anchor nw
        .cf.n view "Color"
    }
    proc ResetAllFig+ {} {
        global S
        set S(OpResetLFgC) 1
        set S(OpResetLBgC) 1
        set S(OpResetLF) 1
        set S(OpResetNFgC) 1
        set S(OpResetNBgC) 1
        set S(OpResetNLW) 1
        set S(OpResetNLD) 1
        set S(OpResetNUS) 1
        set S(OpResetNUC) 1
        set S(OpResetAL) 1
        set S(OpResetAN) 1
        set S(OpResetAC) 1
    }
    #
    proc ResetAllFig- {} {
        global S
        set S(OpResetLFgC) 0
        set S(OpResetLBgC) 0
        set S(OpResetLF) 0
        set S(OpResetNFgC) 0
        set S(OpResetNBgC) 0
        set S(OpResetNLW) 0
        set S(OpResetNLD) 0
        set S(OpResetNUS) 0
        set S(OpResetNUC) 0
        set S(OpResetAL) 0
        set S(OpResetAN) 0
        set S(OpResetAC) 0
    }
    #
    proc ResetGraphicVariables {} {
        global S T
        # cette fonction travaille sur la liste des trees en target
        foreach key [array names S *,tar]  {
            if {$S($key) == 1} {
                set t [string range $key 0 [expr [string first , $key] - 1]]
                set w $S($t,w)
                # t va etre reset sur une, plusieurs, ou toutes les variables graphiques
                # ...voir optimisation...
                # Leaf Foreground Color
                if {$S(OpResetLFgC) == 1} {Figuration::GraVarInitFgLeaf $w $t}
                # Leaf Background Color
                if {$S(OpResetLBgC) == 1} {Figuration::GraVarInitBgLeaf $w $t}
                # Leaf Font
                if {$S(OpResetLF) == 1}   {Figuration::GraVarInitFont $w $t}
                # Node Foreground Color
                if {$S(OpResetNFgC) == 1} {Figuration::GraVarInitFgTree $w $t}
                # Node Background Color
                if {$S(OpResetNBgC) == 1} {Figuration::GraVarInitBgSubTree $w $t}
                # Node Line Witdh
                if {$S(OpResetNLW) == 1}  {Figuration::GraVarInitLineWidth $w $t}
                # Node Line Dash
                if {$S(OpResetNLD) == 1}  {Figuration::GraVarInitLineDash $w $t}
                # Node Unshrink
                if {$S(OpResetNUS) == 1}  {}
                # Node UnCollapse
                if {$S(OpResetNUC) == 1}  {}
                # Remove Annotation Leaf
                if {$S(OpResetAL) == 1}  {}
                # Remove Annotation Node
                if {$S(OpResetAN) == 1}  {}
                # Remove Annotation Canvas
                if {$S(OpResetAC) == 1}  {}
            }
        }
    }
    proc TreeViewerPanelUpdate {} {
        global S
        if {[winfo exists .treeviewer] == 1} {
            TreeViewerMenu .treeviewer.c.m
            set last [lindex $S(ilw) end]
            if {$last} {
                Operation::TreeDocu $last
                .treeviewer.c configure -text [file tail [wm title .t$last]]
            }
        }
    }
    # tree viewer
    proc TreeViewerPanel {} {
        global S T
        set w .treeviewer
        if {[winfo exists $w] != 1} {
            toplevel $w
            wm geometry $w "180x300+[winfo pointerx $w]+[winfo pointery $w]"
            wm title .treeviewer "Tree panel"
            menubutton .treeviewer.c -text "Tree(s)"  -menu .treeviewer.c.m -indicatoron 1
            set z2  [menu  .treeviewer.c.m -tearoff 0]
            $z2 configure -postcommand "Operation::TreeViewerMenu $z2"
            pack .treeviewer.c -expand yes -fill x
        }
        TreeViewerMenu .treeviewer.c.m
        set last [lindex $S(ilw) end]
        if {$last} {
            Operation::TreeDocu $last
            .treeviewer.c configure -text [file tail [wm title .t$last]]
        }
    }
    proc TreeViewerMenu {m} {
        global S
        $m  delete 0 end
        $m add command  -label "Select All" -command "Selection::TreeTargetSelectAll"
        $m add command  -label "UnSelect All" -command "Selection::TreeTargetUnSelectAll"
        $m add separator
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                $m add command -label [file tail [wm title .t$wi]] -foreground blue  \
                        -command ".treeviewer.c configure -text [file tail [wm title .t$wi]] ; Operation::TreeDocu $wi"
            }
        }
    }
    #
    proc TreeDocu {wi} {
        global T S
        destroy .treeviewer.d
        frame .treeviewer.d
        raise .t$wi
        if {$wi != 0 && [winfo exists .t$wi] == 1} {
            set www [format "%s%s%s" .t $wi .c]
            set ci [frame .treeviewer.d.c ]
            pack $ci -expand yes -fill both -side left
            ### Fit to contents
            #button $ci.fi -text "Fit to contents" -command "Navigation::FitToContents $www"
            #button $ci.fi2 -text "Fit to Window" -command "Navigation::FitToWindowMultiple $www"
            ### Reorganise row x column + taille
            set p [frame $ci.spi]
            set n [llength $S($www,t)]
            label $p.col -text "Col: " -image TVcolumns
            label $p.rol -text "Row: " -image TVrows
            spinbox  $p.co -from 1 -to $n -width 2 -increment 1  \
                    -command "Navigation::spinCol2 $www $p.ro $p.co"
            spinbox  $p.ro -from 1 -to $n -increment 1  -width 2   \
                    -command "Navigation::spinRow2 $www $p.ro $p.co "
            if {$S($www,BIcol) == "?"} {set S($www,BIcol) 1}
            if {$S($www,BIrow) == "?"} {set S($www,BIrow) $n}
            $p.co set $S($www,BIcol)
            $p.ro set $S($www,BIrow)
            button $p.ok -text Ok -command "Navigation::Reorganize $www"
            # taille
            iwidgets::entryfield $p.ns -width 5  -textvariable S(newH)  \
                    -labelimage TVheigth -labelpos w -validate numeric -fixed 30 -command Navigation::ResizeAuto
            iwidgets::entryfield $p.nn -width 5  -textvariable S(newW)  \
                    -labelimage TVwidth -labelpos w -validate numeric  -fixed 30 -command Navigation::ResizeAuto
            button $p.ok2 -text Ok -command "Navigation::ResizeAllGo $www"
            #
            grid $p.col -row 0 -column 0
            grid $p.co  -row 0 -column 1
            grid $p.rol -row 1 -column 0
            grid $p.ro  -row 1 -column 1
            
            grid $p.ok  -row 0 -column 2 -rowspan 2 -sticky news
            grid $p.ns  -row 0 -column 3
            grid $p.nn  -row 1 -column 3
            grid $p.ok2 -row 0 -column 4 -rowspan 2 -sticky news
            ### treelist target
            set tar [frame $ci.tar ]
            
            button $tar.bs -text "Select/Unselect All" -command "Selection::TreeTargetSwitch $wi"
            pack $tar.bs -expand yes -fill x
            iwidgets::scrolledframe $tar.sf -height 200 -labeltext "" -hscrollmode none -sbwidth 2
            set win [$tar.sf childsite]
            
            foreach t $S($www,t) {
                frame $win.f$t
                checkbutton $win.f$t.c -text " $S($t,tit)" -variable S($t,tar) -command "Selection::ShwoTree $t"
                label $win.f$t.l -text "[llength $T($t,ue_cod)] leaves"
                pack $win.f$t.c $win.f$t.l -side left -anchor w
                pack $win.f$t
                
            }
            pack   $ci.spi $ci.tar $tar.sf -side top -expand true -fill both
        }
        pack .treeviewer.d -expand true -fill both
    }
    #
    proc UpdateTargetPanel {win} {
        global S T
        destroy $win
        frame $win
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set www [format "%s%s%s" .t $wi .c]
                set ci [frame $win.c$wi]
                label $ci.l -text "[wm title [format "%s%s" .t $wi]]:"
                button $ci.bs -text "+" -command "Selection::TreeTargetSelectAllperW $wi"
                button $ci.bu -text "-" -command "Selection::TreeTargetUnSelectAllperW $wi"
                pack $ci.l $ci.bs $ci.bu -side left -expand yes -fill x
                pack $ci -expand yes -fill both
                foreach t $S($www,t) {
                    frame $win.f$t
                    checkbutton $win.f$t.c -text " $S($t,tit)" -variable S($t,tar) \
                            -command "Selection::ShwoTree $t"  \
                            label $win.f$t.l -text "[llength $T($t,ue_cod)] leaves"
                    pack $win.f$t.c $win.f$t.l -side left -anchor w
                    pack $win.f$t
                }
            }
        }
        pack $win
    }
    ### OPTIMISATION : si un node est ok : ne pas tester ses nodes fils
    proc FindFatherNode {t SouRefLea} {
        global S T
        set L {}
        # on ne prend pas en compte les codes des feuilles
        # set latest [Tools::SousL $T($t,all_cod) $T($t,ue_cod)]
        # on prend en compte les codes des feuilles
        set latest $T($t,all_cod)
        
        
        if {[llength $SouRefLea] != 1} {
            foreach TarCodNod [lsort -dictionary $latest] {
                # selection des codes leaf issus de node
                set TarCodLea [Tools::NodeNoToLe $t $TarCodNod]
                # passage codes leaf -> references leaf
                set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
                # test inclusion des references leaf de TARGET avec SOURCE
                set r [Tools::ListIncluSauf $TarRefLea $SouRefLea $S(nodefilter)]
                if {$r == 1} {lappend L $TarCodNod}
            }
            # meme node pere possibles
            # differents nodes peres possibles
            # -> identification des nodes peres de plus haut niveau
            set l [Tools::NodeFaNoId {} $L]
            if {$L == {}} {return {}} {return $l}
        } {return $T($t,ltc,$SouRefLea) }
    }
    # operation switch en fonction target, si $t :
    # * : on opere sur la liste des tree en target (panel operation)
    # = : on opere sur la liste des tree de la fenetre en argument
    # finalement on traite $t comme une liste de tree, pouvant se restreindre a un seul elt
    proc Operation {w t EUS} {
        global S
        switch -exact $t {
            \* {
                foreach key [array names S *,tar]  {
                    if {$S($key) == 1} {
                        set ti [string range $key 0 [expr [string first , $key] - 1]]
                        if {$ti != 0} {
                            set wi $S($ti,w)
                            Operation::OperationAction $wi $ti $EUS
                        }
                    }
                }
            }
            =  {
                foreach ti $S($w,t) {
                    Operation::OperationAction $w $ti $EUS
                }
            }
            default {
                foreach ti $t {
                    Operation::OperationAction $w $ti $EUS
                }
            }
        }
    }
    proc OperationAction {w t EUS} {
        global T S
        # Reset Automatic ?
        if {$S(AutoReset)== 1} {Operation::ResetGraphicVariables}
        
        switch $S(operation) {
            leafbgcolor {
                set leu {}
                foreach e $EUS {
                    if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend leu $e}
                }
                Figuration::EUColorBgLeaf $t $leu $S(col)
            }
            leaffgcolor {
                set leu {}
                foreach e $EUS {
                    if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend leu $e}
                }
                Figuration::EUColorFgLeaf $t $leu $S(col)
            }
            leaffontglob {
                set leu {}
                foreach e $EUS {
                    if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend leu $e}
                }
                Figuration::FontSetGlobalEU $t $leu $S(gfo)
            }
            leafshrink {
                set leu {}
                foreach e $EUS {
                    if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend leu $e}
                }
                Abstraction::LeafShrink $w $t $leu
            }
            leafunshrink {
                set leu {}
                foreach e $EUS {
                    if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend leu $e}
                }
                Abstraction::LeafUnShrink $w $t $leu
            }
            qLannL {
                Annotation::qLannL $w $t $EUS
            }
            qLannC {
                Annotation::qLannC $w $t $EUS
            }
            LannL {
                Annotation::LannL $w $t $EUS
            }
            LannC {
                Annotation::LannC $w $t $EUS
            }
            LillL {
                Illustration::LillL $w $t $EUS
            }
            LillC {
                Illustration::LillC $w $t $EUS
            }
            LillCpolygon {
                Illustration::LillCpolygon $w $t $EUS
            }
            nodefgcolor {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Figuration::NodeColorFgTree $t $e $S(col)}
            }
            nodebgcolor {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Figuration::NodeColorBgSubTree $t $e}
                Figuration::RestaureBGSall $w $t
            }
            insertvarval {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {
                    set co [$w coords $e]
                    set x [lindex $co 0]
                    set y [lindex $co 1]
                    Identification::InsertVarVal $w $t $x $y $e
                }
            }
            insertvarval2 {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {
                    set co [$w coords $e]
                    set x [lindex $co 0]
                    set y [lindex $co 1]
                    Identification::InsertVarVal2 $w $t $x $y $e
                }
            }
            nodeannotate {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {
                    set co [$w bbox $e]
                    set x [lindex $co 0]
                    set y [lindex $co 1]
                    Annotation::BLLmake $w $t $x $y "" $S(AnnotateNote) $e
                }
            }
            nodeillustration {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {
                    set co [$w coords $e]
                    set x [lindex $co 0]
                    set y [lindex $co 1]
                    Illustration::drawsymbol  $w [$w canvasx [expr $x + 30 ] ] [$w canvasy [expr $y + 30 ]] [list T$t]
                    
                    #set item [$w create text [$w canvasx [expr $x + 30 ] ] [$w canvasy [expr $y + 30 ]]  \
                    #        -text $S(ill-car) -font $S(ill-fon) -fill $S(col) -anchor center \
                    #        -tags "T$t"]
                    
                    #set item [$w create image $x $y -image $S(imgillu) -tags  T$t]
                    #$w raise $item
                    #update
                }
            }
            shrink {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Abstraction::Shrink $w $t $e ""}
            }
            shrink3 {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Abstraction::Shrink3 $w $t $e }
            }
            shrink4 {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Abstraction::Shrink4 $w $t $e }
            }
            unshrink {
                set peres  [FindFatherNode $t $EUS]
                Abstraction::ShrinkUnLN $w $t $peres
            }
            collapse {Abstraction::Collapse $w $t $EUS}
            uncollapse {Abstraction::CollapseUn $w $t $EUS}
            widthline+ {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Figuration::NodeLineWidth $t $e +}
            }
            widthline- {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Figuration::NodeLineWidth $t $e -}
            }
            nodedashOn {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Figuration::NodeLineDash $t $e 1}
            }
            nodedashOff {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {Figuration::NodeLineDash $t $e 0}
            }
            nodenetwork {
                set lkv {}
                set peres  [FindFatherNode $t $EUS]
                foreach ni $peres {
                    lappend lkv $t $ni
                }
                Reflection::NodeNetworkBuild $w $lkv " "
            }
            querynode {Annotation::QueryNode $w $t $EUS}
            nodeextract {
                set peres  [FindFatherNode $t $EUS]
                PROTO::NodeExtract $t $peres
            }
            symbolnode {
                set peres  [FindFatherNode $t $EUS]
                foreach e $peres {
                    set co [$w coords $e]
                    set x [lindex $co 0]
                    set y [lindex $co 1]
                    Annotation::InsertSymbolNodeMake $w $t $x $y $e
                }
            }
        }
    }
    ###
    proc MenuTreeInit {m} {
        global S
        $m  delete 0 end
        set l {}
        # pour chaque fenetre ayant un ou plusieurs tree
        foreach key [array names S *,w] {
            # pour chaque tree de la fenetre
            foreach t $S($S($key),t) {
                if {[lsearch -exact $l $t] == -1} {lappend l $t}
            }
        }
        foreach t $l  {
            $m add checkbutton -label $S($t,tit) -variable S($t,init)
        }
    }
    ### Color Panel
    proc ColorPanel {winwin} {
        global  S colors_wheel
        set l1 [list    snow1  snow3 seashell1 seashell3 \
                AntiqueWhite1 AntiqueWhite3 bisque1 bisque3 \
                PeachPuff1 PeachPuff3 NavajoWhite1 NavajoWhite3 \
                LemonChiffon1 LemonChiffon3 cornsilk1 cornsilk3 \
                ivory1 ivory3 honeydew1 honeydew3 \
                LavenderBlush1 LavenderBlush3 MistyRose1 MistyRose3 \
                azure1 azure3 SlateBlue1 SlateBlue3 \
                RoyalBlue1 RoyalBlue3 blue1 blue3 \
                DodgerBlue1 DodgerBlue3 SteelBlue1 SteelBlue3 \
                DeepSkyBlue1 DeepSkyBlue3 SkyBlue1 SkyBlue3 ]
        set l2 [list    LightSkyBlue1 LightSkyBlue3 SlateGray1 SlateGray3 \
                LightSteelBlue1 LightSteelBlue3 LightBlue1 LightBlue3 \
                LightCyan1 LightCyan3 PaleTurquoise1 PaleTurquoise3 \
                CadetBlue1 CadetBlue3 turquoise1 turquoise3 \
                cyan1 cyan3 DarkSlateGray1 DarkSlateGray3 \
                aquamarine1 aquamarine3 DarkSeaGreen1 DarkSeaGreen3 \
                SeaGreen1 SeaGreen3 PaleGreen1 PaleGreen3 \
                SpringGreen1 SpringGreen3 green1 green3 \
                chartreuse1 chartreuse3 OliveDrab1 OliveDrab3 \
                DarkOliveGreen1 DarkOliveGreen3 khaki1 khaki3 ]
        set l3 [list    LightGoldenrod1 LightGoldenrod3 LightYellow1 LightYellow3 \
                yellow1 yellow3 gold1 gold3 \
                goldenrod1 goldenrod3 DarkGoldenrod1 DarkGoldenrod3 \
                RosyBrown1 RosyBrown3 IndianRed1 IndianRed3 \
                sienna1 sienna3 burlywood1 burlywood3 \
                wheat1 wheat3 tan1 tan3 \
                chocolate1 chocolate3 firebrick1 firebrick3 \
                brown1 brown3 salmon1 salmon3 \
                LightSalmon1 LightSalmon3 orange1 orange3 \
                DarkOrange1 DarkOrange3 coral1 coral3 ]
        set l4 [list    tomato1 tomato3 OrangeRed1 OrangeRed3 \
                red1 red3 DeepPink1 DeepPink3 \
                HotPink1 HotPink3 pink1 pink3 \
                LightPink1 LightPink3 PaleVioletRed1 PaleVioletRed3 \
                maroon1 maroon3 VioletRed1 VioletRed3 \
                magenta1 magenta3 orchid1 orchid3 \
                plum1 plum3 MediumOrchid1 MediumOrchid3 \
                DarkOrchid1 DarkOrchid3 purple1 purple3 \
                MediumPurple1 MediumPurple3 thistle1 thistle3 \
                white gray75 gray50 black ]
        
        
        foreach li {l1 l2 l3 l4 } {
            set ww [frame $winwin.$li ]
            upvar 0 $li l
            foreach c $l {
                set c [string tolower $c]
                radiobutton $ww.$c -background $c -selectcolor $c \
                        -indicatoron 0 -variable S(col) -value $c  \
                        -command "set S(col) $c ; $winwin.sample configure -background $c"
                pack $ww.$c -fill both -expand true -side left
            }
            pack $ww -side top
        }
        
        
        # BY NAME
        set ww [frame $winwin.f ]
        frame $ww.rc  -borderwidth 5
        Lbs2 $ww.rc "Color by Names" 30 7 S(col)
        bind $ww.rc.l <Double-Button-1>  "Operation::ColorListSelect $winwin"
        set lcolor {gray60 gray70 gray80 gray85 gray90 gray95 \
                    snow1 snow2 snow3 snow4 seashell1 seashell2 \
                    seashell3 seashell4 AntiqueWhite1 AntiqueWhite2 AntiqueWhite3 \
                    AntiqueWhite4 bisque1 bisque2 bisque3 bisque4 PeachPuff1 \
                    PeachPuff2 PeachPuff3 PeachPuff4 NavajoWhite1 NavajoWhite2 \
                    NavajoWhite3 NavajoWhite4 LemonChiffon1 LemonChiffon2 \
                    LemonChiffon3 LemonChiffon4 cornsilk1 cornsilk2 cornsilk3 \
                    cornsilk4 ivory1 ivory2 ivory3 ivory4 honeydew1 honeydew2 \
                    honeydew3 honeydew4 LavenderBlush1 LavenderBlush2 \
                    LavenderBlush3 LavenderBlush4 MistyRose1 MistyRose2 \
                    MistyRose3 MistyRose4 azure1 azure2 azure3 azure4 \
                    SlateBlue1 SlateBlue2 SlateBlue3 SlateBlue4 RoyalBlue1 \
                    RoyalBlue2 RoyalBlue3 RoyalBlue4 blue1 blue2 blue3 blue4 \
                    DodgerBlue1 DodgerBlue2 DodgerBlue3 DodgerBlue4 SteelBlue1 \
                    SteelBlue2 SteelBlue3 SteelBlue4 DeepSkyBlue1 DeepSkyBlue2 \
                    DeepSkyBlue3 DeepSkyBlue4 SkyBlue1 SkyBlue2 SkyBlue3 \
                    SkyBlue4 LightSkyBlue1 LightSkyBlue2 LightSkyBlue3 \
                    LightSkyBlue4 SlateGray1 SlateGray2 SlateGray3 SlateGray4 \
                    LightSteelBlue1 LightSteelBlue2 LightSteelBlue3 \
                    LightSteelBlue4 LightBlue1 LightBlue2 LightBlue3 \
                    LightBlue4 LightCyan1 LightCyan2 LightCyan3 LightCyan4 \
                    PaleTurquoise1 PaleTurquoise2 PaleTurquoise3 PaleTurquoise4 \
                    CadetBlue1 CadetBlue2 CadetBlue3 CadetBlue4 turquoise1 \
                    turquoise2 turquoise3 turquoise4 cyan1 cyan2 cyan3 cyan4 \
                    DarkSlateGray1 DarkSlateGray2 DarkSlateGray3 \
                    DarkSlateGray4 aquamarine1 aquamarine2 aquamarine3 \
                    aquamarine4 DarkSeaGreen1 DarkSeaGreen2 DarkSeaGreen3 \
                    DarkSeaGreen4 SeaGreen1 SeaGreen2 SeaGreen3 SeaGreen4 \
                    PaleGreen1 PaleGreen2 PaleGreen3 PaleGreen4 SpringGreen1 \
                    SpringGreen2 SpringGreen3 SpringGreen4 green1 green2 \
                    green3 green4 chartreuse1 chartreuse2 chartreuse3 \
                    chartreuse4 OliveDrab1 OliveDrab2 OliveDrab3 OliveDrab4 \
                    DarkOliveGreen1 DarkOliveGreen2 DarkOliveGreen3 \
                    DarkOliveGreen4 khaki1 khaki2 khaki3 khaki4 \
                    LightGoldenrod1 LightGoldenrod2 LightGoldenrod3 \
                    LightGoldenrod4 LightYellow1 LightYellow2 LightYellow3 \
                    LightYellow4 yellow1 yellow2 yellow3 yellow4 gold1 gold2 \
                    gold3 gold4 goldenrod1 goldenrod2 goldenrod3 goldenrod4 \
                    DarkGoldenrod1 DarkGoldenrod2 DarkGoldenrod3 DarkGoldenrod4 \
                    RosyBrown1 RosyBrown2 RosyBrown3 RosyBrown4 IndianRed1 \
                    IndianRed2 IndianRed3 IndianRed4 sienna1 sienna2 sienna3 \
                    sienna4 burlywood1 burlywood2 burlywood3 burlywood4 wheat1 \
                    wheat2 wheat3 wheat4 tan1 tan2 tan3 tan4 chocolate1 \
                    chocolate2 chocolate3 chocolate4 firebrick1 firebrick2 \
                    firebrick3 firebrick4 brown1 brown2 brown3 brown4 salmon1 \
                    salmon2 salmon3 salmon4 LightSalmon1 LightSalmon2 \
                    LightSalmon3 LightSalmon4 orange1 orange2 orange3 orange4 \
                    DarkOrange1 DarkOrange2 DarkOrange3 DarkOrange4 coral1 \
                    coral2 coral3 coral4 tomato1 tomato2 tomato3 tomato4 \
                    OrangeRed1 OrangeRed2 OrangeRed3 OrangeRed4 red1 red2 red3 \
                    red4 DeepPink1 DeepPink2 DeepPink3 DeepPink4 HotPink1 \
                    HotPink2 HotPink3 HotPink4 pink1 pink2 pink3 pink4 \
                    LightPink1 LightPink2 LightPink3 LightPink4 PaleVioletRed1 \
                    PaleVioletRed2 PaleVioletRed3 PaleVioletRed4 maroon1 \
                    maroon2 maroon3 maroon4 VioletRed1 VioletRed2 VioletRed3 \
                    VioletRed4 magenta1 magenta2 magenta3 magenta4 orchid1 \
                    orchid2 orchid3 orchid4 plum1 plum2 plum3 plum4 \
                    MediumOrchid1 MediumOrchid2 MediumOrchid3 MediumOrchid4 \
                    DarkOrchid1 DarkOrchid2 DarkOrchid3 DarkOrchid4 purple1 \
                    purple2 purple3 purple4 MediumPurple1 MediumPurple2 \
                    MediumPurple3 MediumPurple4 thistle1 thistle2 thistle3 \
                    thistle4}
        foreach color [lsort -ascii  $lcolor] {
            $ww.rc.l insert end $color
            $ww.rc.l itemconfigure end -background $color
        }
        frame $winwin.sample -background $S(col)  -relief groove -borderwidth 2 -height 30
        set c [canvas $ww.dial ]
        $c create image 0 0 -anchor nw -image colors_wheel
        $c create oval 0 0 0 0 -fill black -tags hsval
        $c create line 0 0 0 0 -width 4 -fill black -tags bval
        $c configure -width [image width colors_wheel] -height [image height colors_wheel]
        $c bind hsval <B1-Motion> "Operation::ColorPanel_set_hs $winwin %x %y"
        $c bind bval <B1-Motion>   "Operation::ColorPanel_set_b $winwin %y"
        set S($winwin-hue) 0
        set S($winwin-saturation) 0
        set S($winwin-brightness) 1
        
        pack $ww.dial $ww.rc -side left -expand false
        
        
        pack $ww -expand true -fill both
        pack $winwin.sample -expand yes -fill x
        ColorPanel_refresh $winwin
        set S(col) red
        $winwin.sample configure -background $S(col)
    }
    proc ColorListSelect {winwin} {
        global S
        set S(col) [$winwin.f.rc.l get [$winwin.f.rc.l curselection]]
        $winwin.sample configure -background $S(col)
    }
    ###
    proc ColorPanel_set_b {win y} {
        global S
        set bright [expr (145-$y)/140.0]
        if {$bright < 0} {
            set bright 0
        } elseif {$bright > 1} {
            set bright 1
        }
        set S($win-brightness) $bright
        ColorPanel_refresh $win
    }
    ###
    proc ColorPanel_set_hs {win x y} {
        global S
        set hs [ColorPanel_xy2hs $x $y]
        set hue [lindex $hs 0]
        set sat [lindex $hs 1]
        if {$sat > 1} {set sat 1}
        set S($win-hue) $hue
        set S($win-saturation) $sat
        ColorPanel_refresh $win
    }
    ###
    proc ColorPanel_refresh {win} {
        global S
        set angle $S($win-hue)
        set length $S($win-saturation)
        set x0 [expr 75 + cos($angle)*$length*70]
        set y0 [expr 75 - sin($angle)*$length*70]
        $win.f.dial coords hsval [expr $x0-4] [expr $y0-4] [expr $x0+4] [expr $y0+4]
        set bright $S($win-brightness)
        set y0 [expr 145-$bright*140]
        $win.f.dial coords bval 154 $y0 176 $y0
        set S(col)  [ColorPanel_get $win]
        $win.sample configure -background $S(col)
        
    }
    ###
    proc ColorPanel_get {win} {
        global S
        set h $S($win-hue)
        set s $S($win-saturation)
        set v $S($win-brightness)
        return [ColorPanel_hsb2rgb $h $s $v]
    }
    ###
    proc ColorPanel_xy2hs {x0 y0} {
        set wd 150
        set ht 150
        set margin 5
        set x [expr $x0 - $wd/2]
        set y [expr $ht/2 - $y0]
        if {$x != 0} {
            set angle [expr atan($y/double($x))]
            if {$x < 0} {
                set angle [expr $angle+3.14159]
            } elseif {$y < 0} {
                set angle [expr $angle+6.28318]
            }
            set dx [expr 0.5*cos($angle)*($wd-2*$margin)]
            set dy [expr 0.5*sin($angle)*($ht-2*$margin)]
            set len [expr sqrt($dx*$dx+$dy*$dy)]
            set hue [expr $angle/3.14159*180]
            set sat [expr sqrt($x*$x+$y*$y)/$len]
        } elseif {$y > 0} {
            set hue 90
            set len [expr 0.5*($ht-2*$margin)]
            set sat [expr $y/$len]
        } else {
            set hue 270
            set len [expr 0.5*($ht-2*$margin)]
            set sat [expr -$y/$len]
        }
        set hue [expr $hue*3.14159/180.0]
        return [list $hue $sat]
    }
    ###
    proc ColorPanel_hsb2rgb {h s v} {
        
        if {$s == 0} {
            set v [expr round(65535*$v)]
            set r $v
            set g $v
            set b $v
        } else {
            if {$h >= 6.28318} {set h [expr $h-6.28318]}
            set h [expr $h/1.0472]
            set f [expr $h-floor($h)]
            set p [expr round(65535*$v*(1.0-$s))]
            set q [expr round(65535*$v*(1.0-$s*$f))]
            set t [expr round(65535*$v*(1.0-$s*(1.0-$f)))]
            set v [expr round(65535*$v)]
            switch [expr int($h)] {
                0 {set r $v; set g $t; set b $p}
                1 {set r $q; set g $v; set b $p}
                2 {set r $p; set g $v; set b $t}
                3 {set r $p; set g $q; set b $v}
                4 {set r $t; set g $p; set b $v}
                5 {set r $v; set g $p; set b $q}
            }
        }
        return [format "#%.4x%.4x%.4x" $r $g $b]
    }
    ###
    proc Lbs2 {w titre wi he var} {
        global S
        #label $w.lab -bd 1 -text $titre -width $wi
        scrollbar $w.yscroll -bd 1 -command "$w.l yview"
        scrollbar $w.xscroll -bd 1 -orient horizontal -command "$w.l xview "
        listbox  $w.l  -xscroll "$w.xscroll set" -yscroll "$w.yscroll set"  \
                -selectmode browse -width $wi -height $he -exportselection 0
        #grid $w.lab -row 0 -column 0
        grid $w.l -row 1 -column 0 -sticky news
        grid $w.yscroll -row 1 -column 1 -sticky ns
        grid $w.xscroll -row 2 -column 0 -sticky ew
        grid rowconfigure $w 1 -weight 1
        grid columnconfigure $w 0 -weight 1
        return $w
    }
    # outil de toolbox mode n:1 fonctionne sur l'operation du panel operation
    # et sur un seul tree (nb l'outil n:n est la transition)
    ### Font Panel
    proc FontPanel {w} {
        global  S
        iwidgets::menubar $w.m1   \
                -helpvariable S(topmessage) -menubuttons {
                    menubutton file -text "Family" -menu {
                        options -tearoff false
                    }
            menubutton weight -text "Weight" -menu {
                options -tearoff false
                radiobutton normal  -variable S(-weight) -value normal -label "Normal" \
                        -helpstr "Weight Font" -command "Operation::FontPanel_FontSwitch $w"
                radiobutton bold  -variable S(-weight) -value bold -label "Bold" \
                        -helpstr "Weight Font" -command  "Operation::FontPanel_FontSwitch $w"
            }
            menubutton size -text "Size" -menu {
                options -tearoff false
                radiobutton s4 -variable S(-size) -value 4 -label "4" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s5 -variable S(-size) -value 5 -label "5" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s6 -variable S(-size) -value 6 -label "6" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s7 -variable S(-size) -value 7 -label "7" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s8 -variable S(-size) -value 8 -label "8" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s9 -variable S(-size) -value 9 -label "9" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s10 -variable S(-size) -value 10 -label "10" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s11 -variable S(-size) -value 11 -label "11" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s12 -variable S(-size) -value 12 -label "12" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s14 -variable S(-size) -value 14 -label "14" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s15 -variable S(-size) -value 16 -label "16" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s16 -variable S(-size) -value 18 -label "18" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s17 -variable S(-size) -value 20 -label "20" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s18 -variable S(-size) -value 28 -label "28" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton s19 -variable S(-size) -value 36 -label "36" \
                        -helpstr "Size Font" -command  "Operation::FontPanel_FontSwitch $w"
                
            }
            
            menubutton slant -text "Slant" -menu {
                options -tearoff false
                radiobutton roman -variable S(-slant) -value roman -label "Roman" \
                        -helpstr "Slant Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton italic -variable S(-slant) -value italic -label "Italic" \
                        -helpstr "Slant Font" -command  "Operation::FontPanel_FontSwitch $w"
            }
            menubutton underline -text "Underline" -menu {
                options -tearoff false
                radiobutton Utrue -variable S(-underline) -value 1 -label "Yes" \
                        -helpstr "Underline Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton Ufalse -variable S(-underline) -value 0 -label "No" \
                        -helpstr "Underline Font" -command  "Operation::FontPanel_FontSwitch $w"
            }
            menubutton overstrike -text "Overstrike" -menu {
                options -tearoff false
                radiobutton Otrue -variable S(-overstrike) -value 1 -label "Yes" \
                        -helpstr "Overstrike Font" -command  "Operation::FontPanel_FontSwitch $w"
                radiobutton Ofalse -variable S(-overstrike) -value 0 -label "No" \
                        -helpstr "Overstrike Font" -command  "Operation::FontPanel_FontSwitch $w"
            }
        }
        foreach ff [font families] {
            set name [format "%s%s%s" .file. t [Tools::GenId]]
            $w.m1 add radiobutton $name -label $ff -variable S(-family) -value $ff\
                    -helpstr "Family Font" -command  "Operation::FontPanel_FontSwitch $w"
        }
        message $w.msg -aspect 1000  -font $S(gfo) \
                -text "ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                \nabcdefghijklmnopqrstuvwxyz\
                \n0123456789\
                \n!@#$%^&*()_+-=[]{};\
                \n:\"'` ~,.<>/?\\|"
        pack $w.m1  -expand yes -fill x
        pack $w.msg  -expand yes -fill x
    }
    proc FontPanel_FontSwitch {w} {
        global S
        set S(gfo) [list -family $S(-family) \
                -weight $S(-weight) \
                -size $S(-size) \
                -slant $S(-slant) \
                -underline $S(-underline) \
                -overstrike $S(-overstrike)]
        $w.msg configure  -font $S(gfo)
    }
}



################################################################################
# SCRIPTING
################################################################################
namespace eval Scripting {
    
    
    proc ScriptingPanel {} {
        global S tds
        if [interp exists tds] {interp delete tds}
        set w [toplevel .tds ]
        wm title $w "Scripting"
        wm protocol .tds WM_DELETE_WINDOW {}
        set wc [frame .tds.console]
        set tds [interp create tds]
        consoleInit .tds.console
        iwidgets::menubar .tds.m  -menubuttons {
            menubutton file -text "File" -menu {
                command open -label "Open script..."  -helpstr "Open File(s)"   \
                        -command {Scripting::OpenScriptCAP}
                separator sep2
                command exit -label "Exit"  -helpstr "Exit application"  -command {destroy .tds}
            }
        }
        grid .tds.m -row 0 -column 0 -sticky ew
        grid .tds.console -row 1 -column 0 -sticky news
        grid columnconfigure .tds 0 -weight 1
        grid rowconfigure .tds 1 -weight 1
        set S(ScriptingLegend) 0
    }
    proc help {} {
        conPuts "ID AN font color operation loadtree loadlabel"
    }
    proc ID {args} {
        global S
        if {$args == "?"} {
            conPuts "ID EU from <database> where <variable> <operator> <value>"
        } else  {
            eval Database::Select $args
            conPuts $args
            set ltreetarget {} ; set lwindowtarget {}
            foreach {w t} [Selection::TreeTar] {
                lappend ltreetarget $t
                lappend lwindowtarget $w
            }
            set  lwindowtarget [Tools::DelRep $lwindowtarget]
            
            if {$S(ScriptingLegend)} {
                # legende MODIF si symbol
                if {$S(operation) == "LillC"} {
                    foreach wi $lwindowtarget {
                        set co [$wi bbox Legend]
                        if {$co == ""} {
                            set x 0 ; set y 0
                        } else  {
                            set x 0 ; set y [lindex $co end]
                        }
                        $wi create text $x  [expr $y + 9]  \
                                -text $S(ill-car) -font $S(ill-fon) -fill $S(col) -anchor nw -tags "Legend $S(ScriptingLegendTAG)"
                        $wi create text [expr $x + 15] [expr $y + 10] \
                                -text [lindex $args end] -anchor nw  -tags "Legend txt $S(ScriptingLegendTAG)"
                    }
                    incr y 15
                } else  {
                    foreach wi $lwindowtarget {
                        set co [$wi bbox Legend]
                        if {$co == ""} {
                            set x 0 ; set y 0
                        } else  {
                            set x 0 ; set y [lindex $co end]
                        }
                        $wi create rectangle $x  [expr $y + 7] [expr $x + 7] [expr $y + 14] \
                                -fill $S(col) -tags "Legend $S(ScriptingLegendTAG)" -stipple @[file join  + stipple $S(stipple)]
                        $wi create text [expr $x + 11] [expr $y + 11] \
                                -text [lindex $args end] -anchor w  -tags "Legend txt $S(ScriptingLegendTAG)"
                    }
                    incr y 10
                }
            }
        }
    }
    proc font  {args} {
        if {$args == "?"} {
            conPuts "font color"
        } else  {
            global S
            eval set S(gfo) $args
            conPuts $args
        }
        
    }
    proc tabulation {args} {
        global S
        switch  -exact [lindex $args 0] {
            + {Illustration::IllCTabulationSet tab+ [lindex $args 1]}
            - {Illustration::IllCTabulationSet tab- [lindex $args 1]}
            = {Illustration::IllCTabulationSet tab= [lindex $args 1]}
            auto {set S(TabulationAnnot) [lindex $args 1] ; set S(illustration-tabulation) 1}
            manual {set S(illustration-tabulation) 0}
        }
        conPuts $args
    }
    proc stipple {args} {
        global S
        switch  -exact [lindex $args 0] {
            0 { set S(stipple) z.xbm}
            1 { set S(stipple) a.xbm}
            2 { set S(stipple) b.xbm}
            3 { set S(stipple) c.xbm}
            4 { set S(stipple) d.xbm}
            5 { set S(stipple) e.xbm}
            6 { set S(stipple) f.xbm}
            7 { set S(stipple) g.xbm}
            8 { set S(stipple) h.xbm}
            9 { set S(stipple) i.xbm}
            10 { set S(stipple) j.xbm}
            11 { set S(stipple) k.xbm}
            12 { set S(stipple) l.xbm}
            13 { set S(stipple) m.xbm}
        }
        conPuts [lindex $args 0]
    }
    proc shape {args} {
        global S
        switch  -exact [lindex $args 0] {
            1 { set S(defaultshape) 1}
            2 { set S(defaultshape) 2}
            3 { set S(defaultshape) 3}
            4 { set S(defaultshape) 4}
            5 { set S(defaultshape) 5}
        }
        conPuts $args
    }
    proc symbol  {args} {
        if {$args == "?"} {
            conPuts "symbol type"
        } else  {
            global S
            switch  $args {
                1 { set S(ill-fon) {Wingdings 8 normal} ; set S(ill-car) l}
                2 { set S(ill-fon) {Wingdings 8 normal} ; set S(ill-car) u}
                3 { set S(ill-fon) {Wingdings 8 normal} ; set S(ill-car) n}
                00 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) i}
                01 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) j}
                02 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) k}
                03 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) l}
                04 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) m}
                05 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) n}
                06 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) o}
                07 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) p}
                08 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) q}
                09 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) r}
                10 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) t}
                11 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) u}
                12 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) v}
                13 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) w}
                14 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) x}
                15 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) y}
                16 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) z}
                17 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) "\{"}
                18 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) "\|"}
                19 { set S(ill-fon) {{Wingdings 2} 11 normal} ; set S(ill-car) "\}"}
            }
            conPuts $args
        }
    }
    proc color  {args} {
        global S
        eval set S(col) $args
        conPuts $args
    }
    proc  legend {args} {
        global S
        switch  -exact $args {
            on {
                set S(ScriptingLegend) 1
                set tagi [format "%s%s" LE [Tools::GenId]]
                set S(ScriptingLegendTAG) $tagi
            }
            off {
                set S(ScriptingLegend) 0
            }
            
        }
        conPuts $args
    }
    #
    proc operation  {command} {
        global S
        # lx == feuille
        # nx == node
        # cx == canvas
        switch -exact $command {
            l01 {
                # leaf foreground color
                set S(operation) leaffgcolor
                conPuts "leaf foreground color"
            }
            l02 {
                # leaf background color
                set S(operation) leafbgcolor
                conPuts "leaf background color"
            }
            l03 {
                # leaf font
                set S(operation) leaffontglob
                conPuts "leaf font"
            }
            l04 {
                # leaf illustration juxtaposition
                set S(operation) LillL
                conPuts "leaf illustration juxtaposition"
            }
            l05 {
                # leaf illustration column
                set S(operation) LillC
                conPuts "leaf illustration column"
            }
            l06 {
                # leaf annotation juxtaposition
                set S(operation) LannL
                conPuts "leaf annotation juxtaposition"
            }
            l07 {
                # leaf annotation column
                set S(operation) LannC
                conPuts "leaf annotation column"
            }
            l08 {
                # leaf state hidden
                set S(operation) leafshrink
                conPuts "leaf state hidden"
            }
            l09 {
                # leaf state normal
                set S(operation) leafunshrink
                conPuts "leaf state normal"
            }
            n00 {
                # node foreground color
                set S(operation) nodefgcolor
                conPuts "node foreground color"
            }
            n01 {
                # node background color
                set S(operation) nodebgcolor
                conPuts "node background color"
            }
            n02 {
                # node line width +
                set S(operation) widthline+
                conPuts "node line width +"
            }
            n03 {
                # node line width -
                set S(operation) widthline-
                conPuts "node line width -"
            }
            n04 {
                # node dash on
                set S(operation) nodedashOn
                conPuts "node dash on"
            }
            n05 {
                # node dash off
                set S(operation) nodedashOff
                conPuts "node dash off"
            }
            n06 {
                # node illustration surimposition
                set S(operation) nodeillustration
                conPuts "nodeillustration"
            }
            n07 {
                # node illustration link
                set S(operation)
                conPuts "node illustration link"
            }
            n08 {
                # node annotate user's text
                set S(operation) nodeannotate
                conPuts "node annotate user's text"
            }
            n09 {
                # node annotate variable-value
                set S(operation) insertvarval
                conPuts "node annotate variable-value"
            }
            n10 {
                # node annotate value
                set S(operation) insertvarval2
                conPuts "node annotate value"
            }
            n11 {
                # node shrink
                set S(operation) shrink
                conPuts "node shrink"
            }
            n12 {
                # node unshrink
                set S(operation) unshrinnk
                conPuts "node unshrink"
            }
            n13 {
                # node network
                set S(operation) nodenetwork
                conPuts "node network"
            }
            n14 {
                # node extract, collection
                set S(operation) nodeextract
                conPuts "node extract, collection"
            }
            c00 {
                # canvas query node
                set S(operation) querynode
                conPuts "canvas query node"
            }
        }
    }
    proc find {command} {
        global S T
        set S(query) $command
        set ltreetarget {} ; set lwindowtarget {}
        foreach {w t} [Selection::TreeTar] {
            lappend ltreetarget $t
            lappend lwindowtarget $w
        }
        set  lwindowtarget [Tools::DelRep $lwindowtarget]
        foreach {w t} [Selection::TreeTar]  {
            set leu {}
            foreach i $T($t,ue_lab) {
                if {[string match -nocase $command $i]} {lappend leu $i }
            }
            Operation::Operation $w $t $leu
            if {$S(ScriptingLegend)} {
                # legende MODIF si symbol
                if {$S(operation) == "LillC"} {
                    foreach wi $lwindowtarget {
                        set co [$wi bbox Legend]
                        if {$co == ""} {
                            set x 0 ; set y 0
                        } else  {
                            set x 0 ; set y [lindex $co end]
                        }
                        $wi create text $x  [expr $y + 9]  \
                                -text $S(ill-car) -font $S(ill-fon) -fill $S(col) -anchor nw -tags "Legend $S(ScriptingLegendTAG)"
                        $wi create text [expr $x + 15] [expr $y + 10] \
                                -text $command -anchor nw  -tags "Legend txt $S(ScriptingLegendTAG)"
                    }
                    incr y 15
                } else  {
                    foreach wi $lwindowtarget {
                        set co [$wi bbox Legend]
                        if {$co == ""} {
                            set x 0 ; set y 0
                        } else  {
                            set x 0 ; set y [lindex $co end]
                        }
                        $wi create rectangle $x  [expr $y + 7] [expr $x + 7] [expr $y + 14] \
                                -fill $S(col) -tags "Legend $S(ScriptingLegendTAG)" -stipple @[file join  + stipple $S(stipple)]
                        $wi create text [expr $x + 11] [expr $y + 11] \
                                -text $command -anchor w  -tags "Legend txt $S(ScriptingLegendTAG)"
                    }
                    incr y 10
                }
            }
        }
        conPuts $command
    }
    proc operationp  {args} {
        global S
        set var [lindex $args 0]
        set val [lindex $args 1]
        eval set S($var) $val
        conPuts $args
    }
    proc loadtree  {args} {
        eval ImportExport::MIimport $args
        conPuts $args
    }
    proc loadlabel  {args} {
        global S
        if [catch {open $args  r} fidlabels] {
            conPuts "Error Opening File"
        } else {
            set currentfile [Tools::PathCut2 $args]
            # on ecrase si existe deja
            if {[lsearch $S(ldatabase) $currentfile] != -1 } {
                upvar #0 $currentfile X
                array unset X
            } else  {
                set S(database) $currentfile
                lappend S(ldatabase) $currentfile
                conPuts $args
            }
            Database::db $currentfile
            while {[eof $fidlabels] != 1} {
                set id [incr S(lastid)]
                gets $fidlabels data
                eval $currentfile [concat $id EU $data]
            }
            close $fidlabels
        }
        Database::LoadAnnotationsUpdateInterf
    }
    proc AN {args} {
        if {$args == "?"} {
            conPuts "AN LeavesReplace {<database> {<variable(s)>}} <option(s)>"
            conPuts "AN LeavesAdd {<database> {<variable(s)>}} <option(s)>"
            conPuts "AN Columns {<database> <variable(s)>} <option(s)>"
            conPuts "Options: {?prefix <string>? ?suffix <string>? ?exposant <value>?}"
        } else  {
            global ann S
            set arg2s $args
            
            set ann(ann-fgfiguration) asleaf
            set ann(ann-fofiguration) asleaf
            set ann(ann-prefix) " "
            set ann(ann-suffix) ""
            set ann(ann-exposant) 0
            set lkv [array get S *,tar]
            set ltreetarget {}
            foreach {k v} $lkv {
                if {$S($k) == 1} {
                    lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
                }
            }
            conPuts $args
            # LeavesAdd {Vibrio_ezurae {Accession}} {prefix "{" suffix "}"}
            set mode [lindex $args 0]
            set fct [format "%s%s" Annotation::ANGo $mode] ;# la fonction d'annotation
            set var [lindex $args 1] ;# database liste_de_variables
            set lv [lindex $var 1] ;# liste de variables
            set args [lindex $args 2] ;# options
            if {$args != ""} {
                foreach {option value} $args {
                    set ann(ann-$option) $value
                }
            }
            
            eval $fct $lv $ltreetarget
            set ann(ann-prefix) " "
            set ann(ann-suffix) ""
            set ann(ann-exposant) 0
            conPuts $arg2s
        }
    }
    proc OpenScriptCAP {} {
        global S T tds
        lappend filtre [list {TreeDyn Label File} .txt]
        set typelist {
            {"TreeDyn Script" {".tds"} }
            {"All Files" {*}}
        }
        set filename [tk_getOpenFile -initialdir $S(userDIR)  -defaultextension "tds" \
                -filetypes $typelist -title "Load TreeDyn Script..."]
        if {$filename != ""} {set S(userDIR) [file dirname $filename]}
        OpenScript $filename
    }
    
    proc OpenScript {filename} {
        global S T tds
        catch {open $filename r} fid
        set ltreetarget {} ; set lwindowtarget {}
        foreach {w t} [Selection::TreeTar] {
            lappend ltreetarget $t
            lappend lwindowtarget $w
        }
        set  lwindowtarget [Tools::DelRep $lwindowtarget]
        # valeur par defaut
        set S(ScriptingLegend) 0
        while {[eof $fid] != 1} {
            gets $fid raw
            set type [lindex $raw 0]
            set command [lrange $raw 1 end]
            conPuts $raw
            switch -exact $type {
                AN {
                    global ann
                    set ann(ann-fgfiguration) asuser
                    set ann(ann-fofiguration) asuser
                    set ann(ann-prefix) " "
                    set ann(ann-suffix) ""
                    set ann(ann-exposant) 0
                    set mode [lindex $command 0]
                    set fct [format "%s%s" Annotation::ANGo $mode] ;# la fonction d'annotation
                    set var [lindex $command 1] ;# database liste_de_variables
                    set S(database) [lindex $var 0]
                    set lv [lindex $var 1] ;# liste de variables
                    set args [lindex $command 2] ;# options
                    if {$args != ""} {
                        foreach {option value} $args {
                            set ann(ann-$option) $value
                        }
                    }
                    eval $fct $lv [list $ltreetarget]
                    set ann(ann-prefix) " "
                    set ann(ann-suffix) ""
                    set ann(ann-exposant) 0
                }
                ANmatrix {
                    global ann
                    set S(database) [lindex $command 0]
                    set ann(binmatPadding) 6
                    set ann(binmatHeight) 4
                    set ann(binmatWidth) 4
                    set ann(binmatColor0) white
                    set ann(binmatColor1) black
                    set ann(binmatOutline) 1
                    set ann(binmatColumnsNumber) 0
                    Annotation::MatrixAnnotateGoGo [lindex $command 1] $ltreetarget
                }
                find {
                    set S(query) $command
                    foreach {w t} [Selection::TreeTar]  {
                        set leu {}
                        foreach i $T($t,ue_lab) {
                            if {[string match -nocase $command $i]} {lappend leu $i }
                        }
                        Operation::Operation $w $t $leu
                        if {$S(ScriptingLegend)} {
                            # legende MODIF si symbol
                            if {$S(operation) == "LillC"} {
                                foreach wi $lwindowtarget {
                                    set co [$wi bbox Legend]
                                    if {$co == ""} {
                                        set x 0 ; set y 0
                                    } else  {
                                        set x 0 ; set y [lindex $co end]
                                    }
                                    $wi create text $x  [expr $y + 9]  \
                                            -text $S(ill-car) -font $S(ill-fon) -fill $S(col) -anchor nw -tags "Legend $S(ScriptingLegendTAG)"
                                    $wi create text [expr $x + 15] [expr $y + 10] \
                                            -text $command -anchor nw  -tags "Legend txt $S(ScriptingLegendTAG)"
                                }
                                incr y 15
                            } else  {
                                foreach wi $lwindowtarget {
                                    set co [$wi bbox Legend]
                                    if {$co == ""} {
                                        set x 0 ; set y 0
                                    } else  {
                                        set x 0 ; set y [lindex $co end]
                                    }
                                    $wi create rectangle $x  [expr $y + 7] [expr $x + 7] [expr $y + 14] \
                                            -fill $S(col) -tags "Legend $S(ScriptingLegendTAG)" -stipple @[file join  + stipple $S(stipple)]
                                    $wi create text [expr $x + 11] [expr $y + 11] \
                                            -text $command -anchor w  -tags "Legend txt $S(ScriptingLegendTAG)"
                                }
                                incr y 10
                            }
                        }
                    }
                }
                ID {
                    eval Database::Select $command
                    if {$S(ScriptingLegend)} {
                        # legende MODIF si symbol
                        if {$S(operation) == "LillC"} {
                            foreach wi $lwindowtarget {
                                set co [$wi bbox Legend]
                                if {$co == ""} {
                                    set x 0 ; set y 0
                                } else  {
                                    set x 0 ; set y [lindex $co end]
                                }
                                $wi create text $x  [expr $y + 9]  \
                                        -text $S(ill-car) -font $S(ill-fon) -fill $S(col) -anchor nw -tags "Legend $S(ScriptingLegendTAG)"
                                $wi create text [expr $x + 15] [expr $y + 10] \
                                        -text [lindex $command end] -anchor nw  -tags "Legend txt $S(ScriptingLegendTAG)"
                            }
                            incr y 15
                        } else  {
                            foreach wi $lwindowtarget {
                                set co [$wi bbox Legend]
                                if {$co == ""} {
                                    set x 0 ; set y 0
                                } else  {
                                    set x 0 ; set y [lindex $co end]
                                }
                                $wi create rectangle $x  [expr $y + 7] [expr $x + 7] [expr $y + 14] \
                                        -fill $S(col) -tags "Legend $S(ScriptingLegendTAG)" -stipple @[file join  + stipple $S(stipple)]
                                $wi create text [expr $x + 11] [expr $y + 11] \
                                        -text [lindex $command end] -anchor w  -tags "Legend txt $S(ScriptingLegendTAG)"
                            }
                            incr y 10
                        }
                    }
                }
                localisation {
                    #ID EU from sample04 where key3 == valeur
                    # localisation labels variable operator {liste valeur}
                    set lab [lindex $command 0]
                    set var [lindex $command 1]
                    set ope [lindex $command 2]
                    foreach val [lindex $command 3] {
                        set com [concat  EU from $lab where $var $ope $val]
                        conPuts "localisation $lab $var $ope $val"
                        eval Database::Select $com
                        if {$S(ScriptingLegend)} {
                            # legende MODIF si symbol
                            if {$S(operation) == "LillC"} {
                                foreach wi $lwindowtarget {
                                    set co [$wi bbox Legend]
                                    if {$co == ""} {
                                        set x 0 ; set y 0
                                    } else  {
                                        set x 0 ; set y [lindex $co end]
                                    }
                                    $wi create text $x  [expr $y + 9]  \
                                            -text $S(ill-car) -font $S(ill-fon) -fill $S(col) -anchor nw -tags "Legend $S(ScriptingLegendTAG)"
                                    $wi create text [expr $x + 15] [expr $y + 10] \
                                            -text [lindex $com end] -anchor nw  -tags "Legend txt $S(ScriptingLegendTAG)"
                                }
                                incr y 15
                            } else  {
                                foreach wi $lwindowtarget {
                                    set co [$wi bbox Legend]
                                    if {$co == ""} {
                                        set x 0 ; set y 0
                                    } else  {
                                        set x 0 ; set y [lindex $co end]
                                    }
                                    $wi create rectangle $x  [expr $y + 7] [expr $x + 7] [expr $y + 14] \
                                            -fill $S(col) -tags "Legend $S(ScriptingLegendTAG)" -stipple @[file join  + stipple $S(stipple)]
                                    $wi create text [expr $x + 11] [expr $y + 11] \
                                            -text [lindex $com end] -anchor w  -tags "Legend txt $S(ScriptingLegendTAG)"
                                }
                                incr y 10
                            }
                        }
                    }
                }
                font {
                    eval set S(gfo) $command
                }
                legend {
                    switch  -exact $command {
                        on {
                            set S(ScriptingLegend) 1
                            set tagi [format "%s%s" LE [Tools::GenId]]
                            set S(ScriptingLegendTAG) $tagi
                        }
                        off {
                            set S(ScriptingLegend) 0
                        }
                        
                    }
                }
                text {
                    set S(AnnotateNote) $command
                }
                symbol {
                    set S(symboltype) [lindex $command 0]
                    set S(symboldx) [lindex $command 1]
                    set S(symboldy) [lindex $command 2]
                    
                   
                    # 01 Square/Rectangle
                    # 02 Circle/Oval
                    # 03 Diamond
                    # 04 Triangle right
                    # 05 Triangle left
                    # 06 Triangle bottom
                    # 07 Triangle top
                    # 08 checkboxe Off
                    # 09 checkboxe On
                    
################################################################################
#                     switch  -exact [lindex $command 0] {
#                         0 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 0}
#                         1 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 1}
#                         2 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 2}
#                         3 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 3}
#                         4 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 4}
#                         5 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 5}
#                         6 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 6}
#                         7 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 7}
#                         8 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 8}
#                         9 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) 9}
#                         00 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) i}
#                         01 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) j}
#                         02 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) k}
#                         03 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) l}
#                         04 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) m}
#                         05 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) n}
#                         06 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) o}
#                         07 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) p}
#                         08 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) q}
#                         09 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) r}
#                         10 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) t}
#                         11 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) u}
#                         12 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) v}
#                         13 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) w}
#                         14 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) x}
#                         15 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) y}
#                         16 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) z}
#                         17 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) "\{"}
#                         18 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) "\|"}
#                         19 { set S(ill-fon) [list {Wingdings 2} $s normal] ; set S(ill-car) "\}"}
#                         21 { set S(ill-fon) [list Wingdings $s normal] ; set S(ill-car) l}
#                         22 { set S(ill-fon) [list Wingdings $s normal] ; set S(ill-car) u}
#                         23 { set S(ill-fon) [list Wingdings $s normal] ; set S(ill-car) n}
#                         30 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) |}
#                         31 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) +}
#                         32 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) =}
#                         33 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) -}
#                         34 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) x}
#                         35 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) o}
#                         36 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) ~}
#                         37 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) !}
#                         38 { set S(ill-fon) [list Helvetica $s normal] ; set S(ill-car) *}
#                     }
################################################################################
                }
                tabulation {
                    switch  -exact [lindex $command 0] {
                        + {Illustration::IllCTabulationSet tab+ [lindex $command 1]}
                        - {Illustration::IllCTabulationSet tab- [lindex $command 1]}
                        = {Illustration::IllCTabulationSet tab= [lindex $command 1]}
                        auto {set S(TabulationAnnot) [lindex $command 1] ; set S(illustration-tabulation) 1}
                        manual {set S(illustration-tabulation) 0}
                    }
                }
                color {
                    eval set S(col) $command
                    
                }
                stipple {
                    switch  -exact [lindex $command 0] {
                        0 { set S(stipple) z.xbm}
                        1 { set S(stipple) a.xbm}
                        2 { set S(stipple) b.xbm}
                        3 { set S(stipple) c.xbm}
                        4 { set S(stipple) d.xbm}
                        5 { set S(stipple) e.xbm}
                        6 { set S(stipple) f.xbm}
                        7 { set S(stipple) g.xbm}
                        8 { set S(stipple) h.xbm}
                        9 { set S(stipple) i.xbm}
                        10 { set S(stipple) j.xbm}
                        11 { set S(stipple) k.xbm}
                        12 { set S(stipple) l.xbm}
                        13 { set S(stipple) m.xbm}
                    }
                }
                rowcolumn {
                    set row [lindex $command 0]
                    set column [lindex $command 1]
                    foreach wi $lwindowtarget {Navigation::Reorganize $wi $column $row}
                }
                size {
                    set S(newW) [lindex $command 0]
                    set S(newH) [lindex $command 1]
                    foreach wi $lwindowtarget {Navigation::ResizeAllGo $wi}
                }
                
                shape {
                    switch  -exact [lindex $command 0] {
                        1 { set S(defaultshape) 1}
                        2 { set S(defaultshape) 2}
                        3 { set S(defaultshape) 3}
                        4 { set S(defaultshape) 4}
                        5 { set S(defaultshape) 5}
                    }
                }
                operation {
                    
                    # lx == feuille
                    # nx == node
                    # cx == canvas
                    switch  $command {
                        
                        l01 {
                            # leaf foreground color
                            eval set S(operation) leaffgcolor}
                        l02 {
                            # leaf background color
                            eval set S(operation) leafbgcolor}
                        l03 {
                            # leaf font
                            eval set S(operation) leaffontglob}
                        l04 {
                            # leaf illustration juxtaposition
                            eval set S(operation) LillL}
                        l05 {
                            # leaf illustration column
                            eval set S(operation) LillC}
                        l06 {
                            # leaf annotation juxtaposition
                            eval set S(operation) LannL}
                        l07 {
                            # leaf annotation column
                            eval set S(operation) LannC}
                        l08 {
                            # leaf state hidden
                            eval set S(operation) leafshrink}
                        l09 {
                            # leaf state normal
                            eval set S(operation) leafunshrink}
                        
                        n00 {
                            # node foreground color
                            eval set S(operation) nodefgcolor}
                        n01 {
                            # node background color
                            eval set S(operation) nodebgcolor}
                        n02 {
                            # node line width +
                            eval set S(operation) widthline+}
                        n03 {
                            # node line width -
                            eval set S(operation) widthline-}
                        n04 {
                            # node dash on
                            eval set S(operation) nodedashOn}
                        n05 {
                            # node dash off
                            eval set S(operation) nodedashOff}
                        n06 {
                            # node illustration surimposition
                            eval set S(operation) nodeillustration}
                        n07 {
                            # node illustration link
                            eval set S(operation) symbolnode}
                        n08 {
                            # node annotate user's text
                            eval set S(operation) nodeannotate}
                        n09 {
                            # node annotate variable-value
                            eval set S(operation) insertvarval}
                        n10 {
                            # node annotate value
                            eval set S(operation) insertvarval2}
                        n11 {
                            # node shrink
                            eval set S(operation) shrink}
                        n12 {
                            # node unshrink
                            eval set S(operation) unshrinnk}
                        n13 {
                            # node network
                            eval set S(operation) nodenetwork}
                        n14 {
                            # node extract, collection
                            eval set S(operation) nodeextract}
                        n15 {
                            # node shrink
                            eval set S(operation) shrink3}
                        n16 {
                            # node shrink
                            eval set S(operation) shrink4}
                        c00 {
                            # canvas query node
                            eval set S(operation) querynode}
                    }
                }
                operationp {
                    foreach {variable value} $command {
                        eval  set S($variable) $value
                    }
                }
                loadtree {
                    eval ImportExport::MIimport $command
                }
                loadlabel {
                    if [catch {open $command  r} fidlabels] {
                        #puts "Error Opening File"
                    } else {
                        set currentfile [Tools::PathCut2 $command]
                        # on ecrase si existe deja
                        if {[lsearch $S(ldatabase) $currentfile] != -1 } {
                            upvar #0 $currentfile X
                            array unset X
                        } else  {
                            set S(database) $currentfile
                            lappend S(ldatabase) $currentfile
                        }
                        Database::db $currentfile
                        while {[eof $fidlabels] != 1} {
                            set id [incr S(lastid)]
                            gets $fidlabels data
                            eval $currentfile [concat $id EU $data]
                        }
                        close $fidlabels
                    }
                    Database::LoadAnnotationsUpdateInterf
                }
            }
        }
        close $fid
    }
    #
    proc consoleInit {win {width 60} {height 10}} {
        global tds
        set window $win
        set prompt "TreeDyn Scripting"
        if {$window == "."} {
            set window ""
        }
        $tds alias setValues Scripting::SetValues
        $tds alias exit Scripting::reset
        $tds alias puts Scripting::consolePuts
        $tds alias ? Scripting::help
        $tds alias help Scripting::help
        $tds alias ID Scripting::ID
        $tds alias AN Scripting::AN
        $tds alias font Scripting::font
        $tds alias loadtree Scripting::loadtree
        $tds alias loadlabel Scripting::loadlabel
        $tds alias color Scripting::color
        $tds alias operation Scripting::operation
        $tds alias operationp Scripting::operationp
        $tds alias legend Scripting::legend
        $tds alias stipple Scripting::stipple
        $tds alias shape Scripting::shape
        $tds alias tabulation Scripting::tabulation
        $tds alias symbol Scripting::symbol
        $tds alias find Scripting::find
        scrollbar $window.ysbar -orient vertical -command "$window.t yview"
        text $window.t -yscrollcommand "$window.ysbar set"  -highlightthickness 0
        grid $window.t -row 0 -column 0 -sticky news
        grid $window.ysbar -row 0 -column 1 -sticky ns
        grid rowconfigure $window 0  -weight 1
        grid columnconfigure $window 0 -weight 1
        $window.t tag configure output -foreground SeaGreen4
        $window.t tag configure prompt -foreground blue
        $window.t tag configure error -foreground grey
        $window.t insert end "$prompt % " prompt
        $window.t mark set prompt insert
        $window.t mark gravity prompt left
        bind $window.t <KeyPress-Return> {%W mark set insert "prompt lineend"}
        bind $window.t <KeyRelease-Return> {Scripting::evalCommand %W $tds [Scripting::getCommand %W];break}
        bind $window.t <Key-Up> {Scripting::onKeyUp %W ; break}
        bind $window.t <Key-Down> {Scripting::onKeyDown %W ; break}
        bind $window.t <Key-Left> {Scripting::onKeyLeft %W ; break}
        bind $window.t <Key-Right> {Scripting::onKeyRight %W ; break}
        bind $window.t <Key-BackSpace> {Scripting::onKeyBackSpace %W;break}
        bind $window.t <Key-Home> {Scripting::onKeyHome %W ;break}
        bind $window.t <KeyPress> {Scripting::onKeyPressed %W}
        return $window.t
    }
    proc evalCommand {window Interp command} {
        global errorInfo
        global env
        global code
        global result
        global prompt
        global historyIndex
        global tcl_platform
        global buffer
        set historyIndex 0
        if {$command != {} && $command != "\n"} {
            if {$command == "reset\n"} {
                set buffer ""
                conPuts [tr "current command canceled !"] error
                return
            } elseif {$command == "cls\n"} {
                $window delete 1.0 end-1c
                $window insert end "$prompt % " prompt
                $window mark set prompt insert
                $window mark gravity prompt left
                return
            }
            append buffer $command
            if {[info complete $buffer]} {
                set evalCommand $buffer
                set buffer ""
                history add $evalCommand
                interp eval $Interp set evalCommand [list $evalCommand]
                if {[info commands [lindex $evalCommand 0]] == "puts"} {
                    eval regsub "puts " $evalCommand "" evalCommand
                    eval [list consolePuts $evalCommand]
                    return
                }
                interp eval $Interp {
                    set code [catch "eval [list $evalCommand]" result]
                    setValues $code $result $errorInfo
                }
                update idletasks
                if {!$code} {
                    if {$result != {}} {
                        eval [list conPuts $result]
                    } else  {
                        set prompt "TreeDyn Scripting"
                        $window mark gravity prompt right
                        $window insert end "$prompt % " prompt
                        $window mark gravity prompt left
                        $window see insert
                    }
                } else  {
                    if {[info commands [lindex $evalCommand 0]] != ""} {
                        eval [list conPuts $errorInfo error]
                    } else  {
                        if {$tcl_platform(platform) == "windows"} {
                            set comspec [file split $env(COMSPEC)]
                            set temp ""
                            foreach item $comspec {
                                set temp [file join $temp $item]
                            }
                            set execComspec [concat $temp /c $evalCommand]
                        } else {
                            set execComspec $evalCommand
                        }
                        set code [catch {eval exec $execComspec} result]
                        #conPuts "code:$code - result:$result"
                        conPuts "\n"
                        if {!$code} {
                            if {$result != {}} {
                                eval [list conPuts $result output]
                            } else  {
                                set prompt "TreeDyn Scripting"
                                $window mark gravity prompt right
                                $window insert end "$prompt % " prompt
                                $window mark gravity prompt left
                                $window see insert
                            }
                        } else  {
                            #eval [list conPuts $errorInfo error]
                            eval [list conPuts ?]
                        }
                    }
                }
            }
        } else  {
            set prompt "TreeDyn Scripting"
            $window mark gravity prompt right
            $window insert end "$prompt % " prompt
            $window mark gravity prompt left
            $window see insert
        }
        set prompt "TreeDyn Scripting"
    }
    #
    proc reset {} {
        global tds
        interp eval $tds {
            if {[lsearch [package names] Tk] != -1} {
                foreach child [winfo children .] {
                    if {[winfo exists $child]} {destroy $child}
                }
                wm withdraw .
            }
        }
    }
    #
    proc conPuts {var {tag output} {win {}} {flash 0} {see 1}} {
        global prompt
        if {$win == {}} {
            
            if {[winfo exists .tds]} {
                set win .tds.console.t
                $win mark gravity prompt right
                $win insert end $var $tag
                if {[string index $var [expr [string length $var]-1]] != "\n"} {
                    $win insert end "\n"
                }
                set prompt "TreeDyn Scripting"
                #$win insert end "$prompt % " prompt
                $win mark gravity prompt left
                if $see {$win see insert}
                update
                if $flash {
                    flashWin $win $flash
                }
                return
            }
        }
    }
    #
    proc consolePuts {args} {
        global prompt
        global errorInfo
        
        set argcounter [llength $args]
        if {[llength $args] > 3} {
            conPuts [list [tr "invalid arguments"] error]
        }
        set newline "\n"
        if {[string match "-nonewline" [lindex $args 0]]} {
            set newline ""
            set args [lreplace $args 0 0]
        }
        if {[llength $args] == 1} {
            set chan stdout
            set string [lindex $args 0]$newline
        } else {
            set chan [lindex $args 0]
            set string [lindex $args 1]$newline
        }
        if [regexp (stdout|stderr) $chan] {
            eval conPuts [list $string]
        } else {
            puts -nonewline $chan $string
        }
    }
    #
    proc SetValues {_code _result _errorInfo} {
        global code result errorInfo
        set code $_code
        set result $_result
        set errorInfo $_errorInfo
    }
    #
    proc getCommand {window} {
        global prompt S
        set command [$window get prompt end-1c]
        $window mark set prompt insert
        return $command
        
    }
    proc searchHistory {direction} {
        global historyIndex
        switch $direction {
            backwards {
                if {$historyIndex > -20} {
                    set command [history event $historyIndex]
                    incr historyIndex -1
                    return $command
                } else  {
                    return {}
                }
            }
            forwards {
                if {$historyIndex < -1} {
                    incr historyIndex
                    set command [history event [expr $historyIndex+1]]
                    return $command
                } else  {
                    return {}
                }
            }
            default {tk_messageBox -message [tr "Internal Error"] -type ok; return}
        }
    }
    #
    proc onKeyPressed {win} {
        if {[$win compare insert < prompt]} {
            $win mark set insert prompt
            $win see insert
        }
    }
    #
    proc onButtonPressed {win} {
    }
    #
    proc onKeyHome {win} {
        $win mark set insert prompt
    }
    #
    proc onKeyUp {win} {
        if {[$win compare insert >= prompt]} {
            $win mark set insert prompt
            $win delete prompt end
            set command [searchHistory backwards]
            $win insert prompt $command
            $win see insert
        } else  {
            $win mark set insert "insert - 1line"
        }
    }
    #
    proc onKeyDown {win} {
        if {[$win compare insert >= prompt]} {
            $win mark set insert prompt
            $win delete prompt end
            set command [searchHistory forwards]
            $win insert prompt $command
            $win see insert
        } else  {
            $win mark set insert "insert + 1line"
        }
    }
    #
    proc onKeyLeft {win} {
        if {[$win compare insert >= prompt]} {
            set curPos [lindex [split [$win index insert] "."] 1]
            set promptPos [lindex [split [$win index prompt] "."] 1]
            if {$curPos <= $promptPos} {
                return {}
            } else  {
                $win mark set insert insert-1c
            }
        } else  {
            $win mark set insert "insert -1c"
        }
    }
    #
    proc onKeyRight {win} {
        $win mark set insert "insert +1c"
    }
    #
    proc onKeyBackSpace {win} {
        
        if {[$win compare insert <= prompt]} {
            return {}
        }  else  {
            $win delete insert-1c
        }
    }
    # TDS : fichier script a generer
    # TLF : fichier annotation
    # NWK : fichier arbre
    # variable : la variable a traiter
    # lv : la liste des valeurs de variable a traiter
    # operateur : l'operateur Ã  utiliser
    # operation : l'operation graphique
    proc ScriptGenIDcolor {TDS TLF NWK variable lv operateur operation } {
        if [catch {open $TDS w} fid] {
            # "Error Opening File"
        } else {
            set incrhue [expr 6.28 / [length $lv])]
            set hue $incrhue
            puts $fid "#TreeDyn Script"
            puts $fid "loadtree $NWK"
            puts $fid "loadlabel $TLF"
            puts $fid "operation $operation"
            foreach v $lv {
                set color [Operation::ColorPanel_hsb2rgb $hue 1 1]
                puts $fid "color $color"
                puts $fid "ID EU from $TLF where $variable $operator $v"
                set hue [expr $hue + $incrhue]
            }
            close $fid
        }
    }
    
}
################################################################################


################################################################################
# ICONOGRAPHIE
################################################################################
namespace eval Iconographie {
    proc MakeIconographie {} {
        global S
        set S(stidir) [file join [file dirname [info script]] +/stipple/]
        
        image create photo STIz -file [file join [file dirname [info script]] +/stipple/z.xbm]
        image create photo STIa -file [file join [file dirname [info script]] +/stipple/a.xbm]
        image create photo STIb -file [file join [file dirname [info script]] +/stipple/b.xbm]
        image create photo STIc -file [file join [file dirname [info script]] +/stipple/c.xbm]
        image create photo STIe -file [file join [file dirname [info script]] +/stipple/e.xbm]
        image create photo STIf -file [file join [file dirname [info script]] +/stipple/f.xbm]
        image create photo STIl -file [file join [file dirname [info script]] +/stipple/l.xbm]
        image create photo STIm -file [file join [file dirname [info script]] +/stipple/m.xbm]
        image create photo STIg -file [file join [file dirname [info script]] +/stipple/g.xbm]
        image create photo STIh -file [file join [file dirname [info script]] +/stipple/h.xbm]
        image create photo STIi -file [file join [file dirname [info script]] +/stipple/i.xbm]
        image create photo STIj -file [file join [file dirname [info script]] +/stipple/j.xbm]
        image create photo STIk -file [file join [file dirname [info script]] +/stipple/k.xbm]
        
        image create photo IMGieadd -file [file join [file dirname [info script]] +/icon/ieadd.gif]
        image create photo IMGhelp -file [file join [file dirname [info script]] +/icon/help.gif]
        image create photo IMGieadd -file [file join [file dirname [info script]] +/icon/ieadd.gif]
        image create photo IMGierem -file [file join [file dirname [info script]] +/icon/ierem.gif]
        
        image create photo IMGhelp -file [file join [file dirname [info script]] +/icon/help.gif]
        image create photo IMGshn -file [file join [file dirname [info script]] +/icon/ticon.gif]
        image create photo TIMconfcircext2 -file [file join [file dirname [info script]] +/icon/confcircext2.gif]
        #PB
        image create photo TIMcongruence -file [file join [file dirname [info script]] +/icon/congruence.gif]
        image create photo TIMleafillustrationC -file [file join [file dirname [info script]] +/icon/leafillustrationC.gif]
        image create photo TIMannfgcol -file [file join [file dirname [info script]] +/icon/annfgcol.gif]
        image create photo TIMannfgrow -file [file join [file dirname [info script]] +/icon/annfgrow.gif]
        image create photo TIMdelete -file [file join [file dirname [info script]] +/icon/delete.gif]
        image create photo TIMconfrect -file [file join [file dirname [info script]] +/icon/confrect.gif]
        
        
        
        image create photo TIMstcopypaste -data {
            R0lGODlhEAAQAPcAAP//////zP//mf//Zv//M///AP/M///MzP/Mmf/MZv/M
            M//MAP+Z//+ZzP+Zmf+ZZv+ZM/+ZAP9m//9mzP9mmf9mZv9mM/9mAP8z//8z
            zP8zmf8zZv8zM/8zAP8A//8AzP8Amf8AZv8AM/8AAMz//8z/zMz/mcz/Zsz/
            M8z/AMzM/8zMzMzMmczMZszMM8zMAMyZ/8yZzMyZmcyZZsyZM8yZAMxm/8xm
            zMxmmcxmZsxmM8xmAMwz/8wzzMwzmcwzZswzM8wzAMwA/8wAzMwAmcwAZswA
            M8wAAJn//5n/zJn/mZn/Zpn/M5n/AJnM/5nMzJnMmZnMZpnMM5nMAJmZ/5mZ
            zJmZmZmZZpmZM5mZAJlm/5lmzJlmmZlmZplmM5lmAJkz/5kzzJkzmZkzZpkz
            M5kzAJkA/5kAzJkAmZkAZpkAM5kAAGb//2b/zGb/mWb/Zmb/M2b/AGbM/2bM
            zGbMmWbMZmbMM2bMAGaZ/2aZzGaZmWaZZmaZM2aZAGZm/2ZmzGZmmWZmZmZm
            M2ZmAGYz/2YzzGYzmWYzZmYzM2YzAGYA/2YAzGYAmWYAZmYAM2YAADP//zP/
            zDP/mTP/ZjP/MzP/ADPM/zPMzDPMmTPMZjPMMzPMADOZ/zOZzDOZmTOZZjOZ
            MzOZADNm/zNmzDNmmTNmZjNmMzNmADMz/zMzzDMzmTMzZjMzMzMzADMA/zMA
            zDMAmTMAZjMAMzMAAAD//wD/zAD/mQD/ZgD/MwD/AADM/wDMzADMmQDMZgDM
            MwDMAACZ/wCZzACZmQCZZgCZMwCZAABm/wBmzABmmQBmZgBmMwBmAAAz/wAz
            zAAzmQAzZgAzMwAzAAAA/wAAzAAAmQAAZgAAMwAAAP///wAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAQAhDAAEIHEiwoMBr
            BwEgXDgQocKEBiM+NHitYkGHEiFmJOgQI0eLHB8y1HiwokmPJUFu7HhSZcON
            F2GCNBnxJMyGKG8GBAA7}
        image create photo TIMstdelete -data {
            R0lGODlhEAAQAPcAAP//////zP//mf//Zv//M///AP/M///MzP/Mmf/MZv/M
            M//MAP+Z//+ZzP+Zmf+ZZv+ZM/+ZAP9m//9mzP9mmf9mZv9mM/9mAP8z//8z
            zP8zmf8zZv8zM/8zAP8A//8AzP8Amf8AZv8AM/8AAMz//8z/zMz/mcz/Zsz/
            M8z/AMzM/8zMzMzMmczMZszMM8zMAMyZ/8yZzMyZmcyZZsyZM8yZAMxm/8xm
            zMxmmcxmZsxmM8xmAMwz/8wzzMwzmcwzZswzM8wzAMwA/8wAzMwAmcwAZswA
            M8wAAJn//5n/zJn/mZn/Zpn/M5n/AJnM/5nMzJnMmZnMZpnMM5nMAJmZ/5mZ
            zJmZmZmZZpmZM5mZAJlm/5lmzJlmmZlmZplmM5lmAJkz/5kzzJkzmZkzZpkz
            M5kzAJkA/5kAzJkAmZkAZpkAM5kAAGb//2b/zGb/mWb/Zmb/M2b/AGbM/2bM
            zGbMmWbMZmbMM2bMAGaZ/2aZzGaZmWaZZmaZM2aZAGZm/2ZmzGZmmWZmZmZm
            M2ZmAGYz/2YzzGYzmWYzZmYzM2YzAGYA/2YAzGYAmWYAZmYAM2YAADP//zP/
            zDP/mTP/ZjP/MzP/ADPM/zPMzDPMmTPMZjPMMzPMADOZ/zOZzDOZmTOZZjOZ
            MzOZADNm/zNmzDNmmTNmZjNmMzNmADMz/zMzzDMzmTMzZjMzMzMzADMA/zMA
            zDMAmTMAZjMAMzMAAAD//wD/zAD/mQD/ZgD/MwD/AADM/wDMzADMmQDMZgDM
            MwDMAACZ/wCZzACZmQCZZgCZMwCZAABm/wBmzABmmQBmZgBmMwBmAAAz/wAz
            zAAzmQAzZgAzMwAzAAAA/wAAzAAAmQAAZgAAMwAAAP///wAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAQAg5AAEIHEiwoMBr
            CBNeA7Dw4MCGBiNKhEgxoUSCEA8qRHiR4sWPICNmBDny48iSHR2iNLhwZciX
            AgMCADs=}
        image create photo TIMstpolytotale -data {
            R0lGODlhEAAQAPcAAP//////zP//mf//Zv//M///AP/M///MzP/Mmf/MZv/M
            M//MAP+Z//+ZzP+Zmf+ZZv+ZM/+ZAP9m//9mzP9mmf9mZv9mM/9mAP8z//8z
            zP8zmf8zZv8zM/8zAP8A//8AzP8Amf8AZv8AM/8AAMz//8z/zMz/mcz/Zsz/
            M8z/AMzM/8zMzMzMmczMZszMM8zMAMyZ/8yZzMyZmcyZZsyZM8yZAMxm/8xm
            zMxmmcxmZsxmM8xmAMwz/8wzzMwzmcwzZswzM8wzAMwA/8wAzMwAmcwAZswA
            M8wAAJn//5n/zJn/mZn/Zpn/M5n/AJnM/5nMzJnMmZnMZpnMM5nMAJmZ/5mZ
            zJmZmZmZZpmZM5mZAJlm/5lmzJlmmZlmZplmM5lmAJkz/5kzzJkzmZkzZpkz
            M5kzAJkA/5kAzJkAmZkAZpkAM5kAAGb//2b/zGb/mWb/Zmb/M2b/AGbM/2bM
            zGbMmWbMZmbMM2bMAGaZ/2aZzGaZmWaZZmaZM2aZAGZm/2ZmzGZmmWZmZmZm
            M2ZmAGYz/2YzzGYzmWYzZmYzM2YzAGYA/2YAzGYAmWYAZmYAM2YAADP//zP/
            zDP/mTP/ZjP/MzP/ADPM/zPMzDPMmTPMZjPMMzPMADOZ/zOZzDOZmTOZZjOZ
            MzOZADNm/zNmzDNmmTNmZjNmMzNmADMz/zMzzDMzmTMzZjMzMzMzADMA/zMA
            zDMAmTMAZjMAMzMAAAD//wD/zAD/mQD/ZgD/MwD/AADM/wDMzADMmQDMZgDM
            MwDMAACZ/wCZzACZmQCZZgCZMwCZAABm/wBmzABmmQBmZgBmMwBmAAAz/wAz
            zAAzmQAzZgAzMwAzAAAA/wAAzAAAmQAAZgAAMwAAAP///wAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAQAg5AAEIHEiwoMBr
            1wAkXKgwIUGHBiMOREhRIkWIEhVmvBgRI8eMIENOFDmSpEaLJk92RBjyYsWU
            BgMCADs=}
        image create photo TIMstpolypartial -data {
            R0lGODlhEAAQAPcAAP//////zP//mf//Zv//M///AP/M///MzP/Mmf/MZv/M
            M//MAP+Z//+ZzP+Zmf+ZZv+ZM/+ZAP9m//9mzP9mmf9mZv9mM/9mAP8z//8z
            zP8zmf8zZv8zM/8zAP8A//8AzP8Amf8AZv8AM/8AAMz//8z/zMz/mcz/Zsz/
            M8z/AMzM/8zMzMzMmczMZszMM8zMAMyZ/8yZzMyZmcyZZsyZM8yZAMxm/8xm
            zMxmmcxmZsxmM8xmAMwz/8wzzMwzmcwzZswzM8wzAMwA/8wAzMwAmcwAZswA
            M8wAAJn//5n/zJn/mZn/Zpn/M5n/AJnM/5nMzJnMmZnMZpnMM5nMAJmZ/5mZ
            zJmZmZmZZpmZM5mZAJlm/5lmzJlmmZlmZplmM5lmAJkz/5kzzJkzmZkzZpkz
            M5kzAJkA/5kAzJkAmZkAZpkAM5kAAGb//2b/zGb/mWb/Zmb/M2b/AGbM/2bM
            zGbMmWbMZmbMM2bMAGaZ/2aZzGaZmWaZZmaZM2aZAGZm/2ZmzGZmmWZmZmZm
            M2ZmAGYz/2YzzGYzmWYzZmYzM2YzAGYA/2YAzGYAmWYAZmYAM2YAADP//zP/
            zDP/mTP/ZjP/MzP/ADPM/zPMzDPMmTPMZjPMMzPMADOZ/zOZzDOZmTOZZjOZ
            MzOZADNm/zNmzDNmmTNmZjNmMzNmADMz/zMzzDMzmTMzZjMzMzMzADMA/zMA
            zDMAmTMAZjMAMzMAAAD//wD/zAD/mQD/ZgD/MwD/AADM/wDMzADMmQDMZgDM
            MwDMAACZ/wCZzACZmQCZZgCZMwCZAABm/wBmzABmmQBmZgBmMwBmAAAz/wAz
            zAAzmQAzZgAzMwAzAAAA/wAAzAAAmQAAZgAAMwAAAP///wAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAAQAhBAAEIHEiwoMBr
            BREmPMjQoMOGBK9JXPhwoMKKES0alHiRYsaIHDluFIkRgMKQJD+q9Ghy5EGU
            IkM67PiyIk2BAQEAOw==}
        image create photo TIMleafsel -data {
            R0lGODlhEAAQAIAAAP///wAAACH5BAEAAAAALAAAAAAQABAAAAImhI+pFu27
            GkwB1MkyvnYjroAeJX2WUz3HJaqdBoFtST4pttL4UQAAOw==}
        image create photo IMGselectl2r -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQkEMlJq704683n
            QccXipZomhU6giGltuMnvafLsqgNw13v/5sIADs=}
        image create photo IMGshapenode -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQoEMlJaz3Y3qwv
            wkc3heIGlhSJjiPXhSHwofFMA2p54Guda76ea0WJAAA7}
        image create photo IMGshapenodem -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQwEMlJaz3Y3qwv
            wkc3heIGlhSJjiPXhSHwpZIazzT+AWpOHjzLr4aQ9YZE4+q0skQAADs=}
        image create photo IMGannt1 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQdEMlJq704683x
            OQioid9Iid6EpiG4WmXZzXRtaxEAOw==}
        image create photo IMGplotnode -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQqEMlJaz3Y3qwv
            wkc3heIGlhSJjmvajuDZHUBdqxZN3+IO6D0bbxbjvBARADs=}
        image create photo IMGplotnodem -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQwEMlJaz3Y3qwv
            wkc3heIGlhSJjmsqkioos590ADiu1vV96zRYzmcr2nLAjuzUmkQAADs=}
        image create photo IMGannt2 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQqEMlJq70428MR
            P15HfSF4AODYkaSmsas4neaKVnCdulhe4jefSvfjGTERADs=}
        image create photo IMGbigimport -data {
            R0lGODlhEAAQAJEAAAAAAP///xoaGv///yH5BAEAAAMALAAAAAAQABAAAAI7
            nI+pwqznghwuiSHzvBBrkFGQJgGgxF2lyZ7iGbQtOsAyS6vxvRkCuctwRCSY
            qAMMHBGRzXDReD6mhwIAOw==}
        image create photo IMGannt3 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQlEMlJq70428O7
            PxWIiRO5hcjHpeiIrm2ZmaxH0fQdn7dqa8BgBAA7}
        image create photo PANnavigation -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIdhI+pyxgP
            W3ryBHBrzo3z9X1TZZGG2JmYiqquVAAAOw==}
        image create photo PANconformation -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIjhI+puwF+
            gpSxGtimw/bRx3TcpZWhMoLNmaTq64KcydZ2XQAAOw==}
        image create photo PANabstraction -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIchI+py+2/
            QgtUWiZRjvBs+D2hk1Wk2QEVlbZMAQA7}
        image create photo TVcolumns -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQuEMmJDq2XWp3r
            +Rb4ZeBUdpvZrazoosARz6nmnpes0+g9kjQeyVczBXU9H2sVAQA7}
        image create photo TVrows -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQvEMlJq704683p
            6dLxIWJpkucBqOw6iaF5hu9qs5c8k3WLxzHdR0a63V4jIYzGiQAAOw==}
        image create photo TVheigth -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQgEMlJq5Xn3sM1
            5aD3iVVGTuaJpCdLuiLsyRbYvXerkhEAOw==}
        image create photo TVwidth -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQeEMlJq704683r
            wR91hNY4jWiqnqTXIu/ZzXRt31YEADs=}
        image create photo TIMmove -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIdhI+pyxgP
            W3ryBHBrzo3z9X1TZZGG2JmYiqquVAAAOw==}
        image create photo TIMmovel -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIe
            lI+pywgPmwtAmvosFrVt7oEX80ll2JmimmrWCzMFADs=}
        image create photo TIMcopypastecollection -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQqEMlJaz3Y6nPz
            xB4VIhx5mZ8EkuW5oaqmtnBHr3I+szo/9sDMzyKkAScRADs=}
        image create photo TIMzoom4 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQmEMlJqzwU23zz
            0R7XhRMIIppZriz6bSIcyyNd26d9Wx/W6zvgJgIAOw==}
        image create photo TIMdash -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIahI+pGbvt
            WJQIKjsB1m7H7RlhJpJmdaaqWQAAOw==}
        image create photo TIMtextset -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIfhI+py+0P
            XQiAJmvsVLsifEwUBoZaNl7fWEbuC8dIAQA7}
        image create photo TIMtextitalic -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIYhI+pyxit
            Hpx0BlmxrUZv4C1PKJLciSIFADs=}
        image create photo TIMtextnode -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIhhI+Zwbrt
            FmAhnmofzQjz+3XhM3EYFHml5anOWbkkOgIFADs=}
        image create photo TIMsymbolnode -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQgEMlJaz3Y3qwv
            wkc3heIGlhSJjmvaeu2Jglwpr+qrVxEAOw==}
        image create photo TIMswap -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIjhI+puwF+
            gpSxGtimw/bRx3TcpZWhMoLNmaTq64KcydZ2XQAAOw==}
        image create photo TIMoutgroup -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIghI+pwe2r
            ogky0prukxrP720c4jSHGYrYdVYsOFKvJxUAOw==}
        image create photo TIMshrink -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIchI+py+2/
            QgtUWiZRjvBs+D2hk1Wk2QEVlbZMAQA7}
        image create photo TIMtextinsert -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIihI+pqwHO
            EoxoUmODs2dCvXxViHWM+GxNt3HlZcLPLNd2AQA7}
        image create photo TIMsymbolinsert -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIf
            lI+pqyDOEoxoUmOvBbkezjET2GFVaV6furIOysZMAQA7}
        image create photo TIMdrawline -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIZhI+pyx2d
            Hjxygjox1M4azoCLqJCRh6ZHAQA7}
        image create photo TIMcatchfont -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIjhI+puxHw
            mIlOQhRZzno+rlQVBHaXxZXYanmOmrztAc+2UQAAOw==}
        image create photo TIMcatchcolor -data {
            R0lGODlhEAAQANABAP///wAAACH5BAEAAAAALAAAAAAQABAAAAIfhI+py8Hr
            HnJR1tpMwG1rngFggo1HKZ2bl67p+cZpAQA7}
        image create photo TIMbracketdraw -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIm
            lI+pu+BvnAKMHtiEpXYiLl1hxGRRp6EdSl5uoj6sRsOe+VVxyRcAOw==}
        image create photo TIMzoom1 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQfEMlJq73Ynp3n
            8dQmfp9UZueJcl3rvnD8qhonwrRMRQA7}
        image create photo TIMzoom2 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQiEMlJq73Ynp3n
            8R3ySWNWliYXrhpLuiKMtiC1fXeNzXAVAQA7}
        image create photo TIMzoom3 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQhEMlJq73Ynp3n
            8R3ySWNWlibXoWsIuiIsVyzNbTWWz1MEADs=}
        image create photo TIMzoomuser -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQpEMlJ6zzY4kN3
            zdmlIRxHbqYEpqR1smXnpibriveX63vv8zeP52f7RQAAOw==}
        image create photo TIMfgcolor -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQvEMlJq6XnysM3
            yhUHftPoiV6qYmX7oWQqmicNl50balkf/y2fjmUS7jA5DUt5iQAAOw==}
        image create photo TIMbgcolorst1 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQwEMlJq6XnysM3
            yhUHfuToiSc5mWvZfqgLimzJxmv3hlrmq8DWb4cJDnkYnaa4vEQAADs=}
        image create photo TIMfgcolorleaf -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQwEMlJq6XnysM3
            yhUHfuToiSc5mWvZrl0mb+hcsvSIvqE22yqMiyc0AYWYjqa3vEQAADs=}
        image create photo TIMbgcolor -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQwEMlJq6XnysM3
            yhUHfuToiSc5mWvZrl0mbyhasvRoexaezjyM6xVSpXqhjqa4vEQAADs=}
        image create photo TIMwidth+- -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQnEMlJq63n3qzx
            5Bp4jOFHbiboSaNKiacFu1/a2TfSoqtO7jlW0BIBADs=}
        image create photo TIMtextsize+- -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQgEMlJq704623P
            QZ8WeiIVYueJSqTafSQnz6zYxpxLVxEAOw==}
        image create photo TIMtextunder -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQfEMlJq704603P
            QZ8WemJXSmE2fulFklzszXBs33gWAQA7}
        image create photo TIMtextbold -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQdEMlJq704683x
            OQiofeQofmYoZiS6Xu7bzXRtXxEAOw==}
        image create photo TIMtextover -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQeEMlJq704683x
            OQioiV/2nac5iWoIsldZdnRt31oEADs=}
        image create photo TIMannotree -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQpEMlJaz3Y3qwv
            wkc3heIGlmiqrl8rZaT3vjFF1vU479ZNu7pbiMNCRAAAOw==}
        image create photo TIMtextleafc -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQnEMlJaz0Yy2yP
            7dxHeQgpbpuZmuqJuqMGu1rbpfSYvydZ0x7ZjBIBADs=}
        image create photo TIMnodeillustration -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQnEMlJq72Yns1P
            9hnCiV+3feIJXqvkjRPsmqAcn3cb6ntY0b6gkBIBADs=}
        image create photo TIMtextnodebl2 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQiEMlJq734aDz1
            4dTngchHdp55qmfZdq/EcmadpWlWzXEcAQA7}
        image create photo TIMtextnodeblp2 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQmEMlJq7346Hlk
            55v1cYg2luL1nWaIUedLylVM26qnq22b1bRgMAIAOw==}
        image create photo TIMmovematrix -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQfEMlJq70444M4
            1+DkdeRHmRY6ruWZoRI7hiFL33gORgA7}
        image create photo TIMmovecol -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQfEMlJq70466O7
            5RKIiBNZkVw6rmqZmWvoenRc33iORQA7}
        image create photo TIMannfocol -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQfEMlJq734HLSx
            7JrHUV02lSa3oVYYinA8yvRZ3+xdRwA7}
        image create photo TIMannforow -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQfEMlJq734HLSx
            7JrHUV02lSa3oVYYinAsz+TI0nguRwA7}
        image create photo TIMannanchw -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQjEMlJq734HLSx
            7JrHUV02lSa3oVYYinArz/Gq3SMd5+TuexEAOw==}
        image create photo TIMannanche -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQkEMlJq734HLSx
            7JrHUV02lSa3oVYYirBXshdNau4I2/UZ/7AIADs=}
        image create photo TIMd3menus -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQnEMlJq704642O
            r943HWPZSeFIdumZvmhMieG6mmde32jL/cCgMBMBADs=}
        image create photo TIMlocalisation -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQnEMlJq704642O
            r943HWAnkZ14kiHKfqEpoxQcy6W73iPP/cCgEBMBADs=}
        image create photo TIMrotation -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQeEMlJq70466Pr
            4R3yfR1HbhKIUqrViitcnmFt33cEADs=}
        image create photo TIMshrink3 -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIh
            lI+pywudwIPmzShtdVFc9FXhpoweBaLHlEGZybywShsFADs=}
        image create photo TIMshrink4 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQjEMlJq70463nO
            lh4SUl0nktUIrqlluh8Xs3FYaqW65frsTxEAOw==}
        image create photo TIMcollapse -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQeEMlJq70433NQ
            /1injZlIVhwXTmaYtiOsvWdt31oEADs=}
        image create photo TIMsubtree -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQfEMlJq7346IPl
            7hT3gRwYmqGInqvXuq9YojOtvfgUAQA7}
        image create photo TIMabsleaf -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQiEMlJq70428O7
            PloFhtNIgWYpeUiqtufVmWjmfhyp73yPRAA7}
        image create photo TIMtransition1 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQjEMlJq70YnX3y
            7J7EfSBWihlXniHrueKIXiwsa/AXUuru/xEAOw==}
        image create photo TIMtransition2 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQnEMlJ6zwY23q2
            71IGWiNVXqLpkdmKai6SxnNYy+R2hu/Oxz0f0BIBADs=}
        image create photo TIMtransition3 -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQpEMlJq0UnX5y7
            1tQRgli4TaKUniXXbSuryihMxp7HVTjJ0zWgyyfcRAAAOw==}
        image create photo TIMconnect -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQlEMlJq732aE13
            z1x1IB5JhlKZYmm4oWwsf9ksj7XNjryJ68BKBAA7}
        image create photo TIMdrawrectangle -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQpEMlJq70428P7
            yR8VXqNUVqHXbSbyvawLc9s6g/Mpurw+qTSNcEikRAAAOw==}
        image create photo TIMdrawoval -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQlEMlJq70448O1
            PBOYieFIcWRFguyGtO2Fvm+q0rGbj53n/0BJBAA7}
        image create photo TIMstcollapse -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQeEMlJq70433NQ
            /1injZlIVhwXTmaYtiOsvWdt31oEADs=}
        image create photo TIMcopypaste -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQmEMlJq70448Mn
            PxdYdd43IqIkpmioduRpsd7W1htrjrHm/8DgJAIAOw==}
        image create photo TIMcopypastenavi -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQtEMlJaz144mMR
            v5+0haJHfSSpiVlmqeXbmenspe59c3B8zqMRUNaB9XZB2ywCADs=}
        image create photo TIMzoompc -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQiEMlJqzzHUnyz
            7l/4YZ5YluOEaqfYrRacuhdtqzIOhtwtRQA7}
        image create photo TIMzoomxb -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQfEMlJq73Ynp0n
            594mIgdpdl/ZkeDqvnAsa2iquvdcRQA7}
        image create photo TIMzoomyb -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQiEMlJq73Ynp0n
            592BiGJIlibarRrruZK6ypUqbydKUztMRQA7}
        image create photo TIMzoomxyb -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQgEMlJq73Ynp0n
            592BiGJIliaKqWFHsRnszl46grNMVxEAOw==}
        image create photo TIMladder -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQjEMlJq70448Pn
            yZ/XUdyIlOYphVpYeharrVs8kygr33zvaxEAOw==}
        
        image create photo TIMvalbefore -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQdEMlJq704642P
            54h3XOMoiR14quWEcu8Wq3RtSxEAOw==}
        image create photo TIMvalafter -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQdEMlJq704642O
            593HecdUliCaYqTZXe0ognRt0xEAOw==}
        image create photo TIMreset -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQiEMlJq72Ynn3y
            7B7CgR5IZiaHhhorqSF5WvPcviML664XAQA7}
        image create photo TIMconfcircint -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQjEMlJq71Ynr0z
            OhV4iaFFelqqml/Jni0bzzKHijBmo3zvUxEAOw==}
        image create photo TIMconfcircext -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQkEMlJq733UI2l
            PmA3caLnhRhHktVXjmznwvE6ih+avibv/4gIADs=}
        image create photo  TIMtreepatfromt -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQzEMlJqzz4WKv3
            7pl3hRX2eR1FliI3ZiaLHEBdpxMI0PeVXzaaJpYSBmE4XnCGe8F8rVYEADs=}
        #
        image create photo TIMalg2tre -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQlEMlJq733aHlQ
            /9yGUZ8Igt5oaSyXomo8dbJHxy2e67deu79LBAA7}
        image create photo TIMtre2al -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQkEMlJq733aHlQ
            /9yGUZ8Igt5oaSyXomrcxZNItzeu6vt808AIADs=}
        image create photo TIMannothttp -data {
            R0lGODlhEAAQAPcAAP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAAALAAAAAAQABAA
            QAgzAAEIHEiwoMGBAQQmNBhg4cGHCB1CnFhQIkUAEi1e3PiwocaDCT9ODCmSYEaKC0ty3BgQADs=}
        image create photo TIMtrealg- -data {
            R0lGODlhEAAQAPcAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAACwAAAAAEAAQAAAIPwABCBxIsKDBgwcPKBR4AEDD
            hwwXIiT4UCJEiA4nGlTIkWFGjBo1NnQoESHIkQlRekxZUmVIlwVRwtxYMuTB
            gAA7}
        image create photo TIMtrealg+ -data {
            R0lGODlhEAAQAPcAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAACwAAAAAEAAQAAAIOQABCBxIsKDBgwcPKBR4AEDD
            hwwXIiT4UCJEiA4nGlTIkWFGjBpDehQ5kmTDkBxTijxpkmRJlwYDAgA7}
        
        
        image create photo TIMxytot -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQ0EMlJqzw4HzsP
            +N/GIZ4XjiRYduIFmG/Vwqd8aZjVot2dj6IdZXbx3Yq+mYaz+zGdQp4lAgA7}
        image create photo TIMttoxy -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQzEMlJqzz4WKv3
            7pl3hRX2eR1FliI3ZiaLHEBdpxMI0PeVXzaaJpYSBmE4XnCGe8F8rVYEADs=}
        
        
        image create photo TIMselx -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIo
            lI+pAMeamoNIGgsxjkIv6VFdNY0X2YEqmDJuw6oXjJ5mmNWR9Yh+AQA7}
        image create photo TIMarccol -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQwEMlJq63n3I00
            t943haJEiuenDYNhCEJRgAjrwjJtv/GM1S1ejuLZ4XyjkkmZUV4iADs=}
        image create photo TIMfaicol -data {
            R0lGODlhEAAQAKIAAAAAAP////8A/wAA/wD/AP8AAP///wAAACH5BAEAAAYA
            LAAAAAAQABAAAAMvaLrc3gC8aSR19q6sJX+R8l1SUQyDIBAEZpioyrpwurbQ
            e9ozY9Uy3EYzJIaIjwQAOw==}
        image create photo TIMarccour -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIk
            lI9pwKAvnINJUjTnjfzounifFzaMkolPGq7dxcIvZcHNhiMFADs=}
        image create photo TIMarcdel -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIf
            lI+pCbAvHFRynmoNtnvK2mlXBGHhKJ4gymRi1rhLAQA7}
        image create photo TIMarcx -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIh
            lI+pCbAvHFRynmoNtntW2WkaGDrNeVLjyiDgEsJZFGcFADs=}
        image create photo TIMfaidel -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIg
            lI+pCbAvHFRynmodXs3sKVWfd0UQNpZkKqqM5YIpXAAAOw==}
        image create photo TIMfaix -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIj
            lI+pCbAvHFRynmodXs3sWUmf54mj1qQdU7bsRVIWPK+zUgAAOw==}
        image create photo TIMselcol -data {
            R0lGODlhEAAQAKIAAAAAAP////8A/wAA/wD/AP8AAP///wAAACH5BAEAAAYA
            LAAAAAAQABAAAAM0aLrcDmBB16KkzCpNOa+G91giFmZGUQyDIBDEeamsC4fT
            SbdvTOorHqy0sxFKHVRHkzOZEgA7}
        image create photo TIMseldel -data {
            R0lGODlhEAAQAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAAAIm
            lI+pAMeamoNIGgsxjkIv6VFddU2lOWrPiJ6N9bawGWZkBm+iUgAAOw==}
        image create photo TIMfaiadd -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQqEMlJKz02S6wt
            7xc4HSQpIuXGYd82hmuZvmvVsu5Vozm4+71OzJRpnSQRADs=}
        image create photo TIMfairem -data {
            R0lGODlhEAAQALMAAP//////AP8A//8AAAD//wD/AAAA/wAAAP///wAAAAAA
            AAAAAAAAAAAAAAAAAAAAACH5BAEAAAgALAAAAAAQABAAAAQpEMlJKz02o8P1
            5Z03YeJVmlKIkWPbkmBswhW73fhI47a2iz8PDOQ7WSIAOw==}
        ### IRD LOGO
        #image create photo  -file [file join [file dirname [info script]] +/icon/logo.gif]
        image create photo IMGlogo -data {
/9j/4AAQSkZJRgABAgEASABIAAD/7RUAUGhvdG9zaG9wIDMuMAA4QklNA+0AAAAAABAASAAAAAEA
AgBIAAAAAQACOEJJTQQNAAAAAAAEAAAAeDhCSU0EGQAAAAAABAAAAB44QklNA/MAAAAAAAkAAAAA
AAAAAAEAOEJJTQQKAAAAAAABAAA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9m
ZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAAB
AC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA////
/////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////
////////////////////////A+gAADhCSU0EAAAAAAAAAgAFOEJJTQQCAAAAAAASAAAAAAAAAAAA
AAAAAAAAAAAAOEJJTQQIAAAAAAAQAAAAAQAAAkAAAAJAAAAAADhCSU0EHgAAAAAABAAAAAA4QklN
BBoAAAAAAGsAAAAGAAAAAAAAAAAAAADIAAABLAAAAAUAbABvAGcAbwAyAAAAAQAAAAAAAAAAAAAA
AAAAAAAAAAABAAAAAAAAAAAAAAEsAAAAyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAA4QklNBBEAAAAAAAEBADhCSU0EFAAAAAAABAAAABs4QklNBAwAAAAAEhEAAAABAAAAcAAAAEsA
AAFQAABicAAAEfUAGAAB/9j/4AAQSkZJRgABAgEASABIAAD/7gAOQWRvYmUAZIAAAAAB/9sAhAAM
CAgICQgMCQkMEQsKCxEVDwwMDxUYExMVExMYEQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwM
DAwMDAwMAQ0LCw0ODRAODhAUDg4OFBQODg4OFBEMDAwMDBERDAwMDAwMEQwMDAwMDAwMDAwMDAwM
DAwMDAwMDAwMDAwMDAz/wAARCABLAHADASIAAhEBAxEB/90ABAAH/8QBPwAAAQUBAQEBAQEAAAAA
AAAAAwABAgQFBgcICQoLAQABBQEBAQEBAQAAAAAAAAABAAIDBAUGBwgJCgsQAAEEAQMCBAIFBwYI
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
b9nyXZW39b9mVf8A8NXTf9n/AJpJT//T7bqFzGdStrNrg41+p6UEt2saZtrP0WXN/O3/AE1VFs5G
NjjKfvyKXuYw1ndYWD+f3u9lD6vU3ei9v6X9H/1zTyvR9e3d6U7hO71fAfT2ezd+6hfq+138zyP9
NH9pNS0cRxupx7a8uy5jmuE7P5wAub6loub6zLK3/n/n+xNjWud9mDsp7wTYA1zHNLy0NnHyTYbP
1uiLH7Xfp3/9a/SXn/Z9x/mP7XrSl+g1/mO3+mSU52NkNP2Rxy7LBdu2tLHxYSa9nqOb6ja6q93s
fluss/S/zyh9soGPXZ9vvLH3ejusaWmxz/TNdNn2ljLPRbuZ76/9OtUfZ4d/M/L1o/tJP+zw/wDm
voH6Xref0v5CSmV5vxel1ZlADwKqjfSfzg1u32OLtrPpN3+337FgfWTqGRVh9OaTTu2P3F762jmr
6Pr3U/m/6P1F2OPH2OmPTjYyNs7OB/N7vds/cTHgfzP+vgnIfNn9Vvm7XH+iP8Jj/wDvWnHVbvUb
rj/zf+lx/wD3rXo//bKX/bKSnkvqjnOvve259IqDGusDXUvDgBf7bPTtyNjd+2zd7PoLUw/rCL7h
i2ZNW91GPnsfS302+g+0V5DH+vZf9D2epZ6dHsu/R/pf5q91Tb9mZu+ybfXx59aYj1W/zHp+/wC3
f+V2z/tZ6aF0f/k7N/5N/nbP6F/MfQZ/Tf8Ah/8AuR/wPppKavTeu51tLa8qmvE9bHNmKWAD09gc
+xuRU+x9lOyv0djX0/6X1fTTdL+sZturfcK68TMeWYfp03NfYbbC7De617fsv6TD/WX7bf0n86tS
zb9owdnobZsj7Ru9f+bd/RvV/Ser/wByN/8AgFW+rkelbH7Pj2f8nTHB/n5/8DSU/wD/2QA4QklN
BCEAAAAAAH0AAAABAQAAABgAQQBkAG8AYgBlACAAUABoAG8AdABvAHMAaABvAHAAIABFAGwAZQBt
AGUAbgB0AHMAAAAeAEEAZABvAGIAZQAgAFAAaABvAHQAbwBzAGgAbwBwACAARQBsAGUAbQBlAG4A
dABzACAAMQAuADAALgAxAAAAAQA4QklNBAYAAAAAAAcACAAAAAEBAP/uAA5BZG9iZQBkQAAAAAH/
2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECAgICAgICAgIC
AgMDAwMDAwMDAwMBAQEBAQEBAQEBAQICAQICAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMD
AwMDAwMDAwMDAwMDAwMDAwMDA//AABEIAMgBLAMBEQACEQEDEQH/3QAEACb/xAGiAAAABgIDAQAA
AAAAAAAAAAAHCAYFBAkDCgIBAAsBAAAGAwEBAQAAAAAAAAAAAAYFBAMHAggBCQAKCxAAAgEDBAED
AwIDAwMCBgl1AQIDBBEFEgYhBxMiAAgxFEEyIxUJUUIWYSQzF1JxgRhikSVDobHwJjRyChnB0TUn
4VM2gvGSokRUc0VGN0djKFVWVxqywtLi8mSDdJOEZaOzw9PjKThm83UqOTpISUpYWVpnaGlqdnd4
eXqFhoeIiYqUlZaXmJmapKWmp6ipqrS1tre4ubrExcbHyMnK1NXW19jZ2uTl5ufo6er09fb3+Pn6
EQACAQMCBAQDBQQEBAYGBW0BAgMRBCESBTEGACITQVEHMmEUcQhCgSORFVKhYhYzCbEkwdFDcvAX
4YI0JZJTGGNE8aKyJjUZVDZFZCcKc4OTRnTC0uLyVWV1VjeEhaOzw9Pj8ykalKS0xNTk9JWltcXV
5fUoR1dmOHaGlqa2xtbm9md3h5ent8fX5/dIWGh4iJiouMjY6Pg5SVlpeYmZqbnJ2en5KjpKWmp6
ipqqusra6vr/2gAMAwEAAhEDEQA/ANzvtHMfM+v79xu1+jsV0ngukMN0+2f3bvbt7DbyzeT3J2ru
TekmO25tbZEOzt2YM01Bs7aO1chV51q2H1yZzFimd9NSsXuvdVQfy3P5l/z3/mRfEfpn5g7J6c+P
e19o7u+UW0uqOyeu8TJv/O752z1TjO2ts7V7Q37gc3lM3j8Dk6jGbVr6iqaCSkRqSmEtSpmenWGb
3Xur9sdvXZuXqstQ4ndu2cpW4COomztJjs9iq2qwsNHmM5t6rly1PTVcsuOjpc/tjJUMjTBAlZj6
mFrSQSqnuvdYNpb+2Lv/ABE+4Nib02lvXAU1XPQVOb2luPD7kxFPXUsMFTU0c+Sw9ZWUUVXT09TH
JJGzh0SRWIAYE+690FHYnblXmOlOyt9fGjdfTvYm7dmY6sqKGbKbolz+wYsjg1o8vncRuKv2DU5H
J0mRG2jK0EKFXFRJAZNMTM3v3XuqPfg//Mo/mb/NT+WjT/zHuuOr/iBu7Kx1vatb/so9Nt/uDYe5
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
7qx/37r3Xvfuvdf/2Q==
        }
        ### COLOR WHEEL
        image create photo colors_wheel -data {
            R0lGODdhtACWAPYAAP///wAAALa2tllZWQD/ANvb2wAAVQAA/wAoAAAoVQAo/wBV/wB9/wCq
            /wDX/wD/VQD/qgD//ygAACgAVSgA/ygoACgoVSgo/yhVAChVVShV/yh9/yiq/yjX/yj/ACj/
            VSj/qij//1UA/1UoAFUoVVUo/1VVAFVVVVVVqlVV/1V9VVV9qlV9/1Wq/1XX/1X/AFX/VVX/
            qlX//30A/30o/31VVX1Vqn1V/319VX19qn19/32qVX2qqn2q/33X/33/AH3/VX3/qn3//6oA
            /6oo/6pV/6p9Vap9qqp9/6qqVaqqqqqq/6rXqqrX/6r/AKr/Var/qqr//9cA/9co/9dV/9d9
            /9eqqteq/9fXqtfX/9f/ANf/Vdf/qtf///8AAP8AVf8Aqv8A//8oAP8oVf8oqv8o//9VAP9V
            Vf9Vqv9V//99AP99Vf99qv99//+qAP+qVf+qqv+q///XAP/XVf/Xqv/X////AP//Vf//qgAA
            AAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAtACWAAAH/oBKgoOEhYaHiImKi4yNjo+QkZKTlJWW
            l5iZmpucnZ6foKGio6SlpqeoqaqrnT+sowCxsrO0tK+YL7kvP7s/vr++Tj/CTsVOt5a1ysrI
            kbrPvL69wMLDw8bYxc2Py92y24seL+Liz7nRwNTXxNlaTu7u4Ine3vKGHvjj5rro0z9A1qyx
            y/auoJaDWuwRAtClDkOHDR9KjNhFoSB8+cjtewGDF8B/6Z4IE+mEZEmD7xCqtAjAYSwuLrvQ
            kSUzVkN7GDHqK5cLRi4gvXZ9BOgEyMijxUTCewIvpcqD8hjiyUJz5kM8NutgBUfAQ9ecGn1y
            7LnrBcChvoz+eLLupLEt/ga1bHmqxU7dhM1axqIKMWYdin+bEfgKVtwHfWP5dfyx+CPboknd
            ltSi1Mlcp0/t2tmMrCFMAFwAZMHjGaLVlrcGdyWM7zA5n2J9Av3XCy3ktcZEknR3We7BuXI1
            19Vs55XohxH5dgGA5SGW5axUr8bX9QNGGB7Ekv0pFCRRo0Z1n1QqEq7v3wiFbx6+ubiq0fCn
            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
            y7msy7vMy73sy/kaCAA7
        }
    }
    
}

################################################################################
# TOOLS
################################################################################
namespace eval Tools {
    
    
    proc Makebase64encoding {} {
        global S
        package require base64
        set typelist {
            {"All Files" {*}}
        }
        set filenames [tk_getOpenFile -initialdir $S(userDIR)  -defaultextension "*" \
                -filetypes $typelist -title "Select file(s)..." -multiple true]
        set fi64 [open [file join [file dirname [lindex $filenames 0]] export64.txt] w]
        foreach f $filenames {
            if [catch {open $f r} fid] {
                # "Error Opening File"
            } else {
                fconfigure $fid -translation binary
                set suffixe [file extension $f]
                set nomimage [string trimright  [file tail $f] $suffixe]
                puts  $fi64 "image create photo TIM$nomimage -data {"
                    while { ! [eof $fid] } {
                        set input [gets $fid]
                        puts -nonewline $fi64 [::base64::encode $input]
                    }
                    puts  $fi64 "}"
                close $fid
            }
        }
        close $fi64
    }
    ###
    proc BgBdx {s} {
        set i -1
        set id -1
        foreach c [split $s {}] {
            incr id
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
                , {if {$i == 0} {return $id}}
            }
        }
        return ""
    }
    ### NODE
    proc NodeParentNode {t node} {
        if  {[string equal  $node $t] == 1} {
            return $t
        } elseif {[string equal $node [format "%s%s" $t g]] == 1} {
            return $t
        } elseif {[string equal $node [format "%s%s" $t d]] == 1} {
            return $t
        } else  {
            set gennode [string range $node 0 end-1]
            set fathernode [string trimright $gennode {0 1 2 3 4 5 6 7 8 9}]
            return $fathernode
        }
    }
    # calcul de la distance feuille a feuille
    proc DistLL {t l1 l2} {
        global T
        if {[string equal $l1 $l2] == 1} {
            return 0
        } else  {
            set l1code $T($t,ltc,$l1)
            set l2code  $T($t,ltc,$l2)
            set node [string trimright [CommunRoot2 0 $l1code $l2code ""] "0123456789"]
            set cumul 0
            foreach n [NodeFathers $t $node] {
                set cumul [expr $cumul + $T($t,dbl,$n)]
            }
            return [expr $T($t,sox,$l1code) + $T($t,sox,$l2code) - (2 * $cumul)]
        }
    }
    #
    proc CommunRoot2 {index s1 s2 string} {
        if {[string equal $s1 $s2]} {
            return $string
        }
        if {[string equal  [string index $s1 $index] [string index $s2 $index]]} {
            CommunRoot2 [expr $index +1] $s1 $s2 $string[string index $s1 $index]
        } else  {
            return $string
        }
    }
    
    ###
    proc NodeBrotherNode {node} {
        set gennode [string range $node 0 end-1]
        set letter [string range $node end end ]
        if {$letter == "g"} {
            set brothernode [format "%s%s" $gennode d]
        } {set brothernode [format "%s%s" $gennode g]}
        return $brothernode
    }
    # renvoie la liste des codes nodes de la racine a n (le chemin)
    # lf est initialise a $t a l'appel de la procedure
    proc NodeFathers {lf n} {
        if {$n == "" || $n == [lindex $lf 0]} {
            return $lf
        } else  {
            lappend lf $n
            NodeFathers $lf [NodeParentNode  [lindex $lf 0] $n]
        }
    }
    ###  NoToLe retourne la liste des codes feuilles issues de node
    proc NodeNoToLe {treeid nodecode} {
        global T
        set p [format "%s%s" $nodecode *]
        set l {}
        foreach codei $T($treeid,ue_cod) {
            if {[string match $p $codei]} {lappend l $codei}
        }
        return $l
    }
    ###  NoToLeNum
    proc NodeNoToLeNum {t n} {
        global T
        set p [format "%s%s" $n *]
        set l {}
        foreach ni $T($t,ue_cod) {
            if {[string match $p $ni]} {lappend l $ni}
        }
        return [llength $l]
    }
    ###  LeCoToRe retourne la liste des REFERENCES feuilles sachant les CODES feuilles
    proc NodeLeCoToRe {treeid lin} {
        global T
        set lout {}
        foreach c $lin {
            lappend lout $T($treeid,ctl,$c)
        }
        return $lout
    }
    # l est une liste de code node
    # FaNoId retourne la liste des nodes de plus haut niveau
    proc NodeFaNoId {leltpass l} {
        set elt [lindex $l 0]
        set lnew [lrange $l 1 end]
        if {[lsearch -exact $leltpass $elt] == -1} {
            set lprov {}
            lappend leltpass $elt
            set p [format "%s%s" $elt *]
            foreach i $l {
                if {[string match $p $i] != 1} {lappend lprov $i}
            }
            Tools::NodeFaNoId $leltpass [lappend lprov $elt]
        } {return $l}
    }
    ### Node Code Father To Node Code Children
    ### (Node Code Father Inclus )
    proc NodeNoCoFaToNoCoCh {IdTree NoCoFa} {
        global T
        set List_NoCoCh {}
        set pattern [format "%s%s" $NoCoFa *]
        foreach NoCoCh $T($IdTree,all_cod) {
            if {[string match $pattern $NoCoCh]} {lappend List_NoCoCh $NoCoCh}
        }
        return $List_NoCoCh
    }
        ### Node Code Father To Node Code Children
        ### (Node Code Father NON Inclus )
        proc NodeNoCoFaToNoCoCh2 {IdTree NoCoFa} {
            global T
            set List_NoCoCh {}
            set pattern [format "%s%s" $NoCoFa *]
            foreach NoCoCh $T($IdTree,all_cod) {
                if {[string match $pattern $NoCoCh]} {lappend List_NoCoCh $NoCoCh}
            }
            puts "FATHER $NoCoFa"
            puts "CHILD $List_NoCoCh"
            return [lrange $List_NoCoCh 1 end]
        }
    # recherche d'un node pere commun aux leafs
    proc FatherSearch {t SouRefLea} {
        global S T
        set L {}
        # on ne prend pas en compte les codes des feuilles
        set latest [Tools::SousL $T($t,all_cod) $T($t,ue_cod)]
        if {[llength $SouRefLea] != 1} {
            foreach TarCodNod [lsort -dictionary $latest] {
                # selection des codes leaf issus de node
                set TarCodLea [Tools::NodeNoToLe $t $TarCodNod]
                # passage codes leaf -> references leaf
                set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
                # test inclusion des references leaf de TARGET avec SOURCE
                set r [Tools::ListIncluSauf $TarRefLea $SouRefLea $S(nodefilter)]
                if {$r == 1} {lappend L $TarCodNod}
            }
            # meme node pere possibles
            # differents nodes peres possibles
            # -> identification des nodes peres de plus haut niveau
            set l [Tools::NodeFaNoId {} $L]
            if {$L == {}} {return {}} {return $l}
        } {return $T($t,ltc,$SouRefLea) }
    }
    # recherche d'un node pere commun aux leafs
    proc FatherSearch2 {t SouRefLea} {
        global S T
        set L {}
        # on ne prend pas en compte les codes des feuilles
        set latest [Tools::SousL $T($t,all_cod) $T($t,ue_cod)]
        if {[llength $SouRefLea] != 1} {
            foreach TarCodNod [lsort -dictionary $latest] {
                # selection des codes leaf issus de node
                set TarCodLea [Tools::NodeNoToLe $t $TarCodNod]
                # passage codes leaf -> references leaf
                set TarRefLea [Tools::NodeLeCoToRe $t $TarCodLea]
                # test egalite
                set r1 [Tools::SousL $TarRefLea $SouRefLea]
                set r2 [Tools::SousL $SouRefLea $TarRefLea]
                if {$r1 == {} && $r2 == {}} {lappend L $TarCodNod}
            }
            # meme node pere possibles
            # differents nodes peres possibles
            # -> identification des nodes peres de plus haut niveau
            set l [Tools::NodeFaNoId {} $L]
            if {$L == {}} {return {}} {return $l}
        } {return $T($t,ltc,$SouRefLea) }
    }
    ### /home/user/data/x.tree -> x.tree
    proc PathCut {spath} {
        set id [expr [string last "/" $spath] + 1]
        return [string range $spath $id end]
    }
    ### /home/user/data/x.tree -> x
    proc PathCut2 {spath} {
        set id1 [expr [string last "/" $spath] + 1]
        set id2 [expr [string last "." $spath] - 1]
        return [string range $spath $id1 $id2]
    }
    ### {a b c} -> {a \n b \n c}
    proc FormatText {Lin} {
        set Lout {}
        set ll [lsort -dictionary $Lin]
        lappend Lout [lindex $ll 0]
        set ll1end [lrange $ll 1 end]
        foreach e $ll1end {
            lappend Lout \n
            lappend Lout $e
        }
        regsub -all {\}} $Lout "" Lout
        regsub -all {\{} $Lout "" Lout
        regsub -all , $Lout = Lout
        regsub -all "  " $Lout " " Lout
        regsub -all " \n" $Lout "\n" Lout
        regsub -all "\n " $Lout "\n" Lout
        return $Lout
    }
    #
    proc GenId {} {
        global S
        incr S(nbobj)
        return [format "%s%s" [clock second] $S(nbobj)]
    }
    # List manag.
    
    ### DelRep suppression des repetitions d'une liste
    proc DelRep {lin}   {
        set lou {}
        foreach i $lin {
            if {[lsearch -exact $lou $i] == -1} {lappend lou $i}
        }
        return $lou
    }
    ### Retourne 1 si l1 est incluse dans l2
    proc ListInclu {l1 l2}   {
        foreach i1 $l1 {
            if {[lsearch -exact $l2 $i1] == -1} {set b 0 ; break} {set b 1}
        }
        return $b
    }
    ###
    proc ListIncluSauf {l1 l2 nb} {
        # c est le nb d'elt de l1 n'etant pas dans l2
        set c 0
        foreach i1 $l1 {
            if {[lsearch -exact $l2 $i1] == -1} {incr c}
        }
        if {$c > $nb} {return 0} {return 1}
    }
    # l2 est une liste d'elts devant etre retires de l1
    proc SousL {l1 l2} {
        set lout {}
        foreach e $l1 {
            if {[lsearch -exact $l2 $e] == -1} {lappend lout $e} {}
        }
        return $lout
    }
    # operateur AND # l'intersection des listes
    # ll est une liste de liste
    proc operatorANDll {ll} {
        set lintersect {}
        set l1 [lindex $ll 0]
        set ln [lrange $ll 1 end]
        foreach e $l1 {
            set x 1
            foreach l $ln {
                if {[lsearch -exact $l $e] == -1} {set x 0}
            }
            if {$x != 0} {lappend lintersect $e}
        }
        return [Tools::DelRep $lintersect]
    }
    proc operatorAND {l1 l2} {
        set lintersect {}
        foreach i $l1 {
            if {[lsearch -exact $l2 $i] != -1} {lappend lintersect $i}
        }
        return [Tools::DelRep $lintersect]
    }
    # operator OR # l'union des listes en supprimant les repetitions
    # ll est une liste de liste
    proc operatorORll {ll} {
        set lunion {}
        foreach l $ll {
            lappend lunion $l
        }
        return [Tools::DelRep $lunion]
    }
    proc operatorOR {l1 l2} {
        set lunion {}
        foreach i $l2 {
            lappend l1 $i
        }
        return [Tools::DelRep $l1]
    }
    ### {a b c} -> {a \n b \n c}
    proc FormatText {Lin} {
        set Lout {}
        set ll [lsort -dictionary $Lin]
        lappend Lout [lindex $ll 0]
        set ll1end [lrange $ll 1 end]
        foreach e $ll1end {
            lappend Lout \n
            lappend Lout $e
        }
        regsub -all {\}} $Lout "" Lout
        regsub -all {\{} $Lout "" Lout
        regsub -all , $Lout = Lout
        regsub -all "  " $Lout " " Lout
        regsub -all " \n" $Lout "\n" Lout
        regsub -all "\n " $Lout "\n" Lout
        return $Lout
    }
}
################################################################################


################################################################################
# PACKAGE
################################################################################
namespace eval Package {
    ################################################################################
    # PRINT
    ################################################################################
    namespace eval Printer {
        ### attention modif chevenet f. sur print_canvas avec un test sur le state des items
        
        ################################################################
        ## prntcanv.tcl
        ##
        ## Usage:
        ##	Package::Printer::print_widget p
        ##		If the parameter p is anything but default, uses the
        ##		print dialog. If it is default, it uses the default printer.
        ##
        ## Prints a canvas "reasonably" well (as GDI matures...)
        ## John Blattner <johnb@imagix.com> contributed the original
        ## version of this code.
        ## Modifications made by Michael Schwartz (mschwart@nyx.net)
        ##
        ## Handles some additional printer types that do not put numbers in the
        ## resolution field
        ## Darcy Kahle <darcykahle@sympatico.ca> contributed the origianl
        ## version of this code.
        ## Modifications made by Michael Schwartz (mschwart@nyx.net)
        ## Several suggestions and code contributions were made by Mick O'Donnell (micko@wagsoft.com)
        ##
        ## This version (0.1) scales the canvas to "fit" the page.
        ## It is very limited now, by may meet simple user needs.
        ## LIMITATIONS:
        ##   This is limited by GDI (e.g., no arrows on the lines, stipples),
        ##   and is also limited in current canvas items supported.
        ##   For instance, bitmaps and images are not yet supported.
        ##
        ## Idea mill for future enhancements:
        ## c) Add an optional page title and footer
        ## d) Add tk font support to the gdi command if tk is loaded.
        ## e) Make scaling an option
        ## f) Make rendering the canvas something done as PART of a
        ##    print.
        ################################################################
        
        
        
        # First some utilities to ensure we can debug this sucker.
        variable debug
        variable option
        variable vtgPrint
        
        proc init_print_canvas { } {
            variable debug
            variable option
            variable vtgPrint
            
            set debug 0
            set option(use_copybits) 1
            set vtgPrint(printer.bg) white
        }
        
        proc is_win {} {
            return [ info exist tk_patchLevel ]
        }
        
        proc debug_puts {str} {
            variable debug
            if $debug {
                if [ is_win ] {
                    if [! winfo exist .debug ] {
                        set tl [ toplevel .debug ]
                        frame $tl.buttons
                        pack $tl.buttons -side bottom -fill x
                        button $tl.buttons.ok -text OK -command "destroy .debug"
                        pack $tl.buttons.ok
                        text $tl.text -yscroll "$tl.yscroll set"
                        scrollbar $tl.yscroll -orient vertical -command "$tl.text yview"
                        pack $tl.yscroll -side right -fill y -expand false
                        pack $tl.text    -side left -fill both -expand true
                    }
                    $tl.text insert end $str
                } else {
                    puts "Debug: $str"
                    after 100
                }
            }
        }
        
        ################################################################
        ## page_args
        ## Description:
        ##   This is a helper proc used to parse common arguments for
        ##   text processing in the other commands.
        ##   "Reasonable" defaults are provided if not present
        ## Args:
        ##   Name of an array in which to store the various pieces
        ##   needed for text processing
        ################################################################
        proc page_args { array } {
            # use upvar one level to get into the context of the immediate caller.
            upvar 1 $array ary
            
            # First we check whether we have a valid hDC
            # (perhaps we can later make this also an optional argument, defaulting to
            #  the default printer)
            set attr [ printer attr ]
            foreach attrpair $attr {
                set key [lindex $attrpair 0]
                set val [lindex $attrpair 1]
                set ary($key) $val
                switch -exact $key {
                    "page dimensions" {
                        set wid [lindex $val 0]
                        set hgt [lindex $val 1]
                        if { $wid > 0 } { set ary(pw) $wid }
                        if { $hgt > 0 } { set ary(pl) $hgt }
                    }
                    "page margins"    {
                        if { [scan [lindex $val 0] %d tmp] > 0 } {
                            set ary(lm) [ lindex $val 0 ]
                            set ary(tm) [ lindex $val 1 ]
                            set ary(rm) [ lindex $val 2 ]
                            set ary(bm) [ lindex $val 3 ]
                        }
                    }
                    "resolution"      {
                        if { [scan [lindex $val 0] %d tmp] > 0 } {
                            set ary(resx) [ lindex $val 0 ]
                            set ary(resy) [ lindex $val 1 ]
                        } else {
                            set ary(resolution) [lindex $val 0]
                            ;# set ary(resx) 200	;# Set some defaults for this...
                            ;# set ary(resy) 200
                        }
                    }
                }
            }
            
            if { ( [ info exist ary(hDC) ] == 0 ) || ($ary(hDC) == 0x0) } {
                error "Can't get printer attributes"
            }
            
            # Now, set "reasonable" defaults if some values were unavailable
            # Resolution is the hardest. Uses "resolution" first, if it was numeric.
            # Uses "pixels per inch" second, if it is set.
            # Use the words medium and best for resolution third--these are guesses
            # Uses 200 as a last resort.
            if { [ info exist ary(resx) ] == 0 } {
                set ppi "pixels per inch"
                if { [ info exist ary($ppt) ] == 0 } {
                    if { [ scan $ary($ppt) "%d%d" tmp1 tmp2 ] > 0 } {
                        set ary(resx) $tmp1
                        if { $tmp2 > 0 } {
                            set ary(resy) $tmp2
                        }
                    } else {
                        if [ string match -nocase $ary($ppt) "medium" ] {
                            set ary(resx) 300
                            set ary(resy) 300
                        } elseif [ string match -nocase $ary($ppt) "best" ] {
                            set ary(resx) 600
                            set ary(resy) 600
                        } else {
                            set ary(resx) 200
                            set ary(resy) 200
                        }
                    }
                } else {
                    set ary(resx) 200
                }
            }
            if { [ info exist ary(resy) ] == 0 } { set ary(resy) $ary(resx) }
            if { [ info exist ary(tm) ] == 0 } { set ary(tm) 1000 }
            if { [ info exist ary(bm) ] == 0 } { set ary(bm) 1000 }
            if { [ info exist ary(lm) ] == 0 } { set ary(lm) 1000 }
            if { [ info exist ary(rm) ] == 0 } { set ary(rm) 1000 }
            if { [ info exist ary(pw) ] == 0 } { set ary(pw) 8500 }
            if { [ info exist ary(pl) ] == 0 } { set ary(pl) 11000 }
            if { [ info exist ary(copies) ] == 0 } { set ary(copies) 1 }
        }
        
        ################################################################
        # These procedures read in the canvas widget, and write all of #
        # its contents out to the Windows printer.                     #
        ################################################################
        
        ################################################################
        ## print_widget
        ## Description:
        ##   Main procedure for printing a widget.  Currently supports
        ##   canvas widgets.  Handles opening and closing of printer.
        ##   Assumes that printer and gdi packages are loaded.
        ## Args:
        ##   wid                The widget to be printed.
        ##   printer            Flag whether to use the default printer.
        ##   name               App name to pass to printer.
        ################################################################
        
        proc print_widget { wid tag {printer default} {name "tcl canvas"} } {
            # modif chevenet pour mise a l'echelle
            $wid configure -scrollregion [$wid bbox all]
            update
            
            # start printing process ------
            if {[string match "default" $printer]} {
                set hdc [printer open]
            } else {
                set hdc [printer dialog select]
                if { [lindex $hdc 1] == 0 } {
                    # User has canceled printing
                    return
                }
                set hdc [ lindex $hdc 0 ]
            }
            
            variable p
            set p(0) 0 ; unset p(0)
            page_args p
            
            if {![info exist p(hDC)]} {
                set hdc [printer open]
                page_args p
            }
            if {[string match "?" $hdc] || [string match 0x0 $hdc]} {
                catch {printer close}
                error "Problem opening printer: printer context cannot be established"
            }
            
            printer job start -name "$name"
            printer page start
            
            # Here is where any scaling/gdi mapping should take place
            # For now, scale so the dimensions of the window are sized to the
            # width of the page. Scale evenly.
            
            # For normal windows, this may be fine--but for a canvas, one wants the
            # canvas dimensions, and not the WINDOW dimensions.
            if { [winfo class $wid] == "Canvas" } {
                set sc [ lindex [ $wid configure -scrollregion ] 4 ]
                # if there is no scrollregion, use width and height.
                if { "$sc" == "" } {
                    set window_x [ lindex [ $wid configure -width ] 4 ]
                    set window_y [ lindex [ $wid configure -height ] 4 ]
                } else {
                    set window_x [ lindex $sc 2 ]
                    set window_y [ lindex $sc 3 ]
                }
            } else {
                set window_x [ winfo width $wid ]
                set window_y [ winfo height $wid ]
            }
            
            set pd "page dimensions"
            set pm "page margins"
            set ppi "pixels per inch"
            
            set printer_x [ expr ( [lindex $p($pd) 0] - \
                    [lindex $p($pm) 0 ] - \
                    [lindex $p($pm) 2 ] \
                    ) * \
                    [lindex $p($ppi) 0] / 1000.0 ]
            set printer_y [ expr ( [lindex $p($pd) 1] - \
                    [lindex $p($pm) 1 ] - \
                    [lindex $p($pm) 3 ] \
                    ) * \
                    [lindex $p($ppi) 1] / 1000.0 ]
            set factor_x [ expr $window_x / $printer_x ]
            set factor_y [ expr $window_y / $printer_y ]
            
            debug_puts "printer: ($printer_x, $printer_y)"
            debug_puts "window : ($window_x, $window_y)"
            debug_puts "factor : $factor_x $factor_y"
            
            if { $factor_x < $factor_y } {
                set lo $window_y
                set ph $printer_y
            } else {
                set lo $window_x
                set ph $printer_x
            }
            
            # The offset still needs to be set based on page margins
            debug_puts [ list \
                    gdi map $hdc -logical $lo -physical $ph -offset $p(resolution) \
                    ]
            
            gdi map $hdc -logical $lo -physical $ph -offset $p(resolution)
            
            # handling of canvas widgets
            # additional procs can be added for other widget types
            switch [winfo class $wid] {
                Canvas {
                    #	    if {[catch {
                    print_canvas [lindex $hdc 0] $wid $tag
                    #	    } msg]} {
                    #		debug_puts "print_widget: $msg"
                    #		error "Windows Printing Problem: $msg"
                    #	    }
                }
                default {
                    debug_puts "Can't print items of type [winfo class $wid]. No handler registered"
                }
            }
            
            # end printing process ------
            printer page end
            printer job end
            printer close
        }
        
        
        ################################################################
        ## print_canvas
        ## Description:
        ##   Main procedure for writing canvas widget items to printer.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ################################################################
        
        proc print_canvas {hdc cw tag} {
            variable  vtgPrint
            
            # get information about page being printed to
            # print_canvas.CalcSizing $cw
            set vtgPrint(canvas.bg) [string tolower [$cw cget -background]]
            if {$tag == "all"} {set lid [$cw find all]} {set lid [$cw find withtag $tag]}
            
            # re-write each widget from cw to printer
            foreach id $lid {
                # modif chevenet
                if {[$cw itemcget $id -state] != "hidden"} {
                    
                    set type [$cw type $id]
                    if { [ info commands print_canvas.$type ] == "print_canvas.$type" } {
                        print_canvas.[$cw type $id] $hdc $cw $id
                    } else {
                        debug_puts "Omitting canvas item of type $type since there is no handler registered for it"
                    }
                }
            }
        }
        ################################################################
        ## These procedures support the various canvas item types,     #
        ## reading the information about the item on the real canvas   #
        ## and then writing a similar item to the printer.             #
        ################################################################
        
        ################################################################
        ## print_canvas.line
        ## Description:
        ##   Prints a line item.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ##   id                 The id of the canvas item.
        ################################################################
        
        proc print_canvas.line {hdc cw id} {
            variable vtgPrint
            
            set color [print_canvas.TransColor [$cw itemcget $id -fill]]
            if {[string match $vtgPrint(printer.bg) $color]} {return}
            
            set coords  [$cw coords $id]
            set wdth    [$cw itemcget $id -width]
            set arrow   [$cw itemcget $id -arrow]
            set arwshp  [$cw itemcget $id -arrowshape]
            set dash    [$cw itemcget $id -dash]
            
            set cmmd  "gdi line $hdc $coords -fill $color -arrow $arrow -arrowshape [list $arwshp]"
            
            if { $wdth > 1 } {
                set cmmd "$cmmd -width $wdth"
            }
            
            if { $dash != "" } {
                set cmmd "$cmmd -dash [list $dash]"
            }
            
            debug_puts "$cmmd"
            eval $cmmd
        }
        
        
        ################################################################
        ## print_canvas.arc
        ## Description:
        ##   Prints a arc item.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ##   id                 The id of the canvas item.
        ################################################################
        
        proc print_canvas.arc {hdc cw id} {
            variable vtgPrint
            # $w create arc -$rho $rho $rho -$rho \
            # -start -$ad -extent [expr $ad - $ag] -style arc  \
            # -tags "[format "%s%s" $j C] T$t Z"
            
            set color [print_canvas.TransColor [$cw itemcget $id -outline]]
            if {[string match $vtgPrint(printer.bg) $color]} {return}
            set coords  [$cw coords $id]
            set wdth    [$cw itemcget $id -width]
            set style   [ $cw itemcget $id -style ]
            set start   [ $cw itemcget $id -start ]
            set extent  [ $cw itemcget $id -extent ]
            set fill    [ $cw itemcget $id -fill ]
            
            set cmmd  "gdi arc $hdc $coords -outline $color -style $style -start $start -extent $extent"
            if { $wdth > 1 } {
                set cmmd "$cmmd -width $wdth"
            }
            if { $fill != "" } {
                set cmmd "$cmmd -fill $fill"
            }
            
            debug_puts "$cmmd"
            eval $cmmd
        }
        
        ################################################################
        ## print_canvas.polygon
        ## Description:
        ##   Prints a polygon item.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ##   id                 The id of the canvas item.
        ################################################################
        
        proc print_canvas.polygon {hdc cw id} {
            variable vtgPrint
            
            set fcolor [print_canvas.TransColor [$cw itemcget $id -fill]]
            if {![string length $fcolor]} {set fcolor $vtgPrint(printer.bg)}
            set ocolor [print_canvas.TransColor [$cw itemcget $id -outline]]
            if {![string length $ocolor]} {set ocolor $vtgPrint(printer.bg)}
            set coords  [$cw coords $id]
            set wdth [$cw itemcget $id -width]
            
            set cmmd "gdi polygon $hdc $coords -width $wdth \
                    -fill $fcolor -outline $ocolor"
            debug_puts "$cmmd"
            eval $cmmd
        }
        
        
        ################################################################
        ## print_canvas.oval
        ## Description:
        ##   Prints an oval item.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ##   id                 The id of the canvas item.
        ################################################################
        
        proc print_canvas.oval { hdc cw id } {
            variable vtgPrint
            
            set fcolor [print_canvas.TransColor [$cw itemcget $id -fill]]
            if {![string length $fcolor]} {set fcolor $vtgPrint(printer.bg)}
            set ocolor [print_canvas.TransColor [$cw itemcget $id -outline]]
            if {![string length $ocolor]} {set ocolor $vtgPrint(printer.bg)}
            set coords  [$cw coords $id]
            set wdth [$cw itemcget $id -width]
            
            set cmmd "gdi oval $hdc $coords -width $wdth \
                    -fill $fcolor -outline $ocolor"
            debug_puts "$cmmd"
            eval $cmmd
        }
        
        ################################################################
        ## print_canvas.rectangle
        ## Description:
        ##   Prints a rectangle item.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ##   id                 The id of the canvas item.
        ################################################################
        
        proc print_canvas.rectangle {hdc cw id} {
            variable vtgPrint
            
            set fcolor [print_canvas.TransColor [$cw itemcget $id -fill]]
            if {![string length $fcolor]} {set fcolor $vtgPrint(printer.bg)}
            set ocolor [print_canvas.TransColor [$cw itemcget $id -outline]]
            if {![string length $ocolor]} {set ocolor $vtgPrint(printer.bg)}
            set coords  [$cw coords $id]
            set wdth [$cw itemcget $id -width]
            
            set cmmd "gdi rectangle $hdc $coords -width $wdth \
                    -fill $fcolor -outline $ocolor"
            debug_puts "$cmmd"
            eval $cmmd
        }
        
        
        ################################################################
        ## print_canvas.text
        ## Description:
        ##   Prints a text item.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ##   id                 The id of the canvas item.
        ################################################################
        # ajout chevenet
        proc print_canvas.text {hdc cw id} {
            variable vtgPrint
            variable p
            
            set p(0) 1 ; unset p(0)
            page_args p
            
            set color [print_canvas.TransColor [$cw itemcget $id -fill]]
            if {[string match white [string tolower $color]]} {return}
            #  set color black
            set txt [$cw itemcget $id -text]
            regsub -all "_" $txt " " txt
            if {![string length $txt]} {puts ouh! ; return}
            set coords [$cw coords $id]
            set anchr [$cw itemcget $id -anchor]
            set bbox [$cw bbox $id]
            set wdth [expr [lindex $bbox 2] - [lindex $bbox 0]]
            set just [$cw itemcget $id -justify]
            
            
            # Get the canvas font info
            set font [ $cw itemcget $id -font ]
            # Find the real font info
            set font [font actual $font]
            # Create a compatible font, suitable for printer name extraction
            set font [ eval font create $font ]
            # Just get the name and family, or some of the gdi commands will fail.
            # Improve this as GDI improves
            set nb [expr [font configure $font -size] + 2]
            set font [list [font configure $font -family]  -$nb -slant  [font configure $font -slant] -weight [font configure $font -weight]]
            set cmmd "gdi text $hdc $coords  -fill $color -text [list $txt] \
                    -anchor $anchr -font [ list $font ]   \
                    -justify $just"
            
            #        set cmmd "gdi text $hdc $coords -fill $color -text [list $txt] \
            #                -anchor $anchr -font [ list $font ] \
            #                -width $wdth -justify $just"
            
            
            debug_puts "$cmmd"
            eval $cmmd
        }
        
        
        ################################################################
        ## print_canvas.image
        ## Description:
        ##   Prints an image item.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ##   id                 The id of the canvas item.
        ################################################################
        
        proc print_canvas.image {hdc cw id} {
            
            variable vtgPrint
            variable option
            
            # First, we have to get the image name
            set imagename [ $cw itemcget $id -image]
            # Now we get the size
            set wid [ image width $imagename]
            set hgt [ image height $imagename ]
            # next, we get the location and anchor
            set anchor [ $cw itemcget $id -anchor ]
            set coords [ $cw coords $id ]
            
            
            # Since the GDI commands don't yet support images and bitmaps,
            # and since this represents a rendered bitmap, we CAN use
            # copybits IF we create a new temporary toplevel to hold the beast.
            # if this is too ugly, change the option!
            if { [ info exist option(use_copybits) ] } {
                set firstcase $option(use_copybits)
            } else {
                set firstcase 0
            }
            ################################################################################
            # test chevenet
            #set firstcase 0
            ################################################################################
            
            if { $firstcase > 0 } {
                set tl [toplevel .tmptop[expr int( rand() * 65535 ) ] -borderwidth 0 -relief flat -padx 0 -pady 0 \
                        -height $hgt  -width $wid -background $vtgPrint(printer.bg) ]
                #ajout chevenet
                canvas $tl.canvas -width $wid -height $hgt -background $vtgPrint(printer.bg) -relief flat -borderwidth 0
                $tl.canvas create image 0 0 -image $imagename -anchor nw
                pack $tl.canvas -side left -expand false -fill none
                tkwait visibility $tl.canvas
                update
                set srccoords [list "0 0 [ expr $wid - 1] [expr  $hgt - 1 ]" ]
                set dstcoords [ list "[lindex $coords 0] [lindex $coords 1] [expr $wid - 1] [expr $hgt - 1]" ]
                set cmmd "gdi copybits $hdc -window $tl -client -source $srccoords -destination $dstcoords "
                debug_puts "$cmmd"
                eval $cmmd
                destroy $tl
            } else {
                set cmmd "gdi image $hdc $coords -anchor $anchor -image $imagename"
                debug_puts "$cmmd"
                eval $cmmd
            }
        }
        
        ################################################################
        ## print_canvas.bitmap
        ## Description:
        ##   Prints a bitmap item.
        ## Args:
        ##   hdc                The printer handle.
        ##   cw                 The canvas widget.
        ##   id                 The id of the canvas item.
        ################################################################
        
        proc print_canvas.bitmap {hdc cw id} {
            variable option
            variable vtgPrint
            
            # First, we have to get the bitmap name
            set imagename [ $cw itemcget $id -bitmap]
            # Now we get the size
            set wid [ image width $imagename]
            set hgt [ image height $imagename ]
            # next, we get the location and anchor
            set anchor [ $cw itemcget $id -anchor ]
            set coords [ $cw itemcget $id -coords ]
            
            # Since the GDI commands don't yet support images and bitmaps,
            # and since this represents a rendered bitmap, we CAN use
            # copybits IF we create a new temporary toplevel to hold the beast.
            # if this is too ugly, change the option!
            if { [ info exist option(use_copybits) ] } {
                set firstcase $option(use_copybits)
            } else {
                set firstcase 0
            }
            if { $firstcase > 0 } {
                set tl [toplevel .tmptop[expr int( rand() * 65535 ) ] -height $hgt -width $wid -background $vtgPrint(canvas.bg) ]
                canvas $tl.canvas -width $wid -height $hgt
                $tl.canvas create bitmap 0 0 -bitmap $imagename -anchor nw
                pack $tl.canvas -side left -expand false -fill none
                tkwait visibility $tl.canvas
                update
                set srccoords [list "0 0 [ expr $wid - 1] [expr  $hgt - 1 ]" ]
                set dstcoords [ list "[lindex $coords 0] [lindex $coords 1] [expr $wid - 1] [expr $hgt - 1]" ]
                set cmmd "gdi copybits $hdc -window $tl -client -source $srccoords -destination $dstcoords "
                debug_puts "$cmmd"
                eval $cmmd
                destroy $tl
            } else {
                set cmmd "gdi bitmap $hdc $coords -anchor $anchor -bitmap $imagename"
                debug_puts "$cmmd"
                eval $cmmd
            }
        }
        
        ################################################################
        ## These procedures transform attribute setting from the real  #
        ## canvas to the appropriate setting for printing to paper.    #
        ################################################################
        
        ################################################################
        ## print_canvas.TransColor
        ## Description:
        ##   Does the actual transformation of colors from the
        ##   canvas widget to paper.
        ## Args:
        ##   color              The color value to be transformed.
        ################################################################
        
        proc print_canvas.TransColor {color} {
            variable vtgPrint
            
            switch [string toupper $color] {
                $vtgPrint(canvas.bg)       {return $vtgPrint(printer.bg)}
            }
            return $color
        }
        
        # Initialize all the variables once
        init_print_canvas
        
        
        
    }
    namespace eval CanToSVG {
        #  can2svg.tcl ---
        #  This file provides translation from canvas commands to XML/SVG format.
        #  Copyright (c) 2002  Mats Bengtsson
        # ########################### USAGE ############################################
        #
        #   NAME
        #      can2svg - translate canvas command to SVG.
        #
        #   SYNOPSIS
        #      can2svg canvasCmd ?options?
        #           canvasCmd is everything except the widget path name.
        #
        #      canvas2file widgetPath fileName ?options?
        #           options:   -height
        #                      -width
        #
        # ########################### CHANGES ##########################################
        #
        #   0.1      first release
        #
        # ########################### TODO #############################################
        #
        #   handle units (m->mm etc.)
        #   better support for stipple patterns
        #   how to handle tk editing? DOM?
        #   URI encoding
        
        package provide can2svg 0.1
        
        namespace eval ::can2svg:: {
            
            namespace export can2svg canvas2file
            
            variable formatArrowMarker
            variable formatArrowMarkerLast
            
            # The key into this array is 'arrowMarkerDef_$col_$a_$b_$c', where
            # col is color, and a, b, c are the arrow's shape.
            variable defsArrowMarkerArr
            
            # Similarly for stipple patterns.
            variable defsStipplePatternArr
            
            # This shouldn't be hardcoded!
            variable defaultFont {Helvetica 12}
            
            variable anglesToRadians [expr 3.14159265359/180.0]
            variable grayStipples {gray75 gray50 gray25 gray12}
            
            # Make 4x4 squares. Perhaps could be improved.
            variable stippleDataArr
            
            set stippleDataArr(gray75)  \
                    {M 0 0 h3 M 0 1 h1 m 1 0 h2 M 0 2 h2 m 1 0 h1 M 0 3 h3}
            set stippleDataArr(gray50)  \
                    {M 0 0 h1 m 1 0 h1 M 1 1 h1 m 1 0 h1 \
                        M 0 2 h1 m 1 0 h1 M 1 3 h1 m 1 0 h1}
            set stippleDataArr(gray25)  \
                    {M 0 0 h1 M 2 1 h1 M 1 2 h1 M 3 3 h1}
            set stippleDataArr(gray12) {M 0 0 h1 M 2 2 h1}
            
        }
        
        # ::can2svg::can2svg --
        #
        #       Make xml out of a canvas command, widgetPath removed.
        #
        # Arguments:
        #       cmd         canvas command without prepending widget path.
        #       args    -usetags    0|all|first|last
        #
        # Results:
        #   xml data
        
        proc ::can2svg::can2svg {cmd args} {
            
            variable defsArrowMarkerArr
            variable defsStipplePatternArr
            variable anglesToRadians
            variable defaultFont
            variable grayStipples
            
            set nonum_ {[^0-9]}
            set wsp_ {[ ]+}
            set xml ""
            
            array set argsArr {-usetags all}
            array set argsArr $args
            
            switch -- [lindex $cmd 0] {
                
                create {
                    set type [lindex $cmd 1]
                    
                    set rest [lrange $cmd 2 end]
                    regexp -indices -- "-${nonum_}" $rest ind
                    set ind1 [lindex $ind 0]
                    set coo [string trim [string range $rest 0 [expr $ind1 - 1]]]
                    set opts [string range $rest $ind1 end]
                    array set optArr $opts
                    
                    # Figure out if we've got a spline.
                    set haveSpline 0
                    if {[info exists optArr(-smooth)] && ($optArr(-smooth) != "0") &&  \
                                [info exists optArr(-splinesteps)] && ($optArr(-splinesteps) > 2)} {
                        set haveSpline 1
                    }
                    if {[info exists optArr(-fill)]} {
                        set fillValue $optArr(-fill)
                    } else {
                        set fillValue black
                    }
                    if {($argsArr(-usetags) != "0") && [info exists optArr(-tags)]} {
                        switch -- $argsArr(-usetags) {
                            all {
                                set idAttr [list "id" $optArr(-tags)]
                            }
                            first {
                                set idAttr [list "id" [lindex $optArr(-tags) 0]]
                            }
                            last {
                                set idAttr [list "id" [lindex $optArr(-tags) end]]
                            }
                        }
                    } else {
                        set idAttr ""
                    }
                    
                    # If we need a marker (arrow head) need to make that first.
                    if {[info exists optArr(-arrow)]} {
                        if {[info exists optArr(-arrowshape)]} {
                            
                            # Make a key of the arrowshape list into the array.
                            regsub -all -- $wsp_ $optArr(-arrowshape) _ shapeKey
                            set arrowKey ${fillValue}_${shapeKey}
                            set arrowShape $optArr(-arrowshape)
                        } else {
                            set arrowKey ${fillValue}
                            set arrowShape {8 10 3}
                        }
                        if {![info exists defsArrowMarkerArr($arrowKey)]} {
                            set defsArrowMarkerArr($arrowKey)  \
                                    [eval {MakeArrowMarker} $arrowShape {$fillValue}]
                            append xml $defsArrowMarkerArr($arrowKey)
                            append xml "\n\t"
                        }
                    }
                    
                    # If we need a stipple bitmap, need to make that first. Limited!!!
                    # Only: gray12, gray25, gray50, gray75
                    foreach key {-stipple -outlinestipple} {
                        if {[info exists optArr($key)] &&  \
                                    ([lsearch $grayStipples $optArr($key)] >= 0)} {
                            set stipple $optArr($key)
                            if {![info exists defsStipplePatternArr($stipple)]} {
                                set defsStipplePatternArr($stipple)  \
                                        [MakeGrayStippleDef $stipple]
                            }
                            append xml $defsStipplePatternArr($stipple)
                            append xml "\n\t"
                        }
                    }
                    
                    switch -- $type {
                        
                        arc {
                            
                            # Had to do it the hard way! (?)
                            # "Wrong" coordinate system :-(
                            set elem "path"
                            set style [MakeStyle $type $opts]
                            foreach {x1 y1 x2 y2} $coo {}
                            set cx [expr ($x1 + $x2)/2.0]
                            set cy [expr ($y1 + $y2)/2.0]
                            set rx [expr abs($x1 - $x2)/2.0]
                            set ry [expr abs($y1 - $y2)/2.0]
                            set rmin [expr $rx > $ry ? $ry : $rx]
                            
                            # This approximation gives a maximum half pixel error.
                            set deltaPhi [expr 2.0/sqrt($rmin)]
                            set extent [expr $anglesToRadians * $optArr(-extent)]
                            set start [expr $anglesToRadians * $optArr(-start)]
                            set nsteps [expr int(abs($extent)/$deltaPhi) + 2]
                            set delta [expr $extent/$nsteps]
                            set data [format "M %.1f %.1f L"   \
                                    [expr $cx + $rx*cos($start)] [expr $cy - $ry*sin($start)]]
                            for {set i 0} {$i <= $nsteps} {incr i} {
                                set phi [expr $start + $i * $delta]
                                append data [format " %.1f %.1f"  \
                                        [expr $cx + $rx*cos($phi)] [expr $cy - $ry*sin($phi)]]
                            }
                            if {[info exists optArr(-style)]} {
                                switch -- $optArr(-style) {
                                    chord {
                                        append data " Z"
                                    }
                                    pieslice {
                                        append data [format " %.1f %.1f Z" $cx $cy]
                                    }
                                }
                            } else {
                                
                                # Pieslice is the default.
                                append data [format " %.1f %.1f Z" $cx $cy]
                            }
                            set attr [list "d" $data "style" $style]
                            if {[string length $idAttr] > 0} {
                                set attr [concat $attr $idAttr]
                            }
                            set xmlList [MakeXMLList $elem -attrlist $attr]
                        }
                        image - bitmap {
                            set elem "image"
                            set attr [MakeImageAttr $coo $opts]
                            if {[string length $idAttr] > 0} {
                                set attr [concat $attr $idAttr]
                            }
                            set xmlList [MakeXMLList $elem -attrlist $attr]
                        }
                        line {
                            if {$haveSpline} {
                                set elem "path"
                                set style [MakeStyle $type $opts]
                                set data "M [lrange $coo 0 1] Q"
                                set i 4
                                foreach {x y} [lrange $coo 2 end-4] {
                                    set x0 [expr ($x + [lindex $coo $i])/2.0]
                                    incr i
                                    set y0 [expr ($y + [lindex $coo $i])/2.0]
                                    incr i
                                    append data " $x $y $x0 $y0"
                                }
                                append data " [lrange $coo end-3 end]"
                                set attr [list "d" $data "style" $style]
                            } else {
                                set elem "polyline"
                                set style [MakeStyle $type $opts]
                                set attr [list "points" $coo "style" $style]
                            }
                            if {[string length $idAttr] > 0} {
                                set attr [concat $attr $idAttr]
                            }
                            set xmlList [MakeXMLList $elem -attrlist $attr]
                        }
                        oval {
                            foreach {x y w h} [NormalizeRectCoords $coo] {}
                            if {[expr $w == $h]} {
                                set elem "circle"
                                set attr [list  \
                                        "cx" [expr $x + $w/2.0]  \
                                        "cy" [expr $y + $h/2.0]  \
                                        "r"  [expr $w/2.0]]
                            } else {
                                set elem "ellipse"
                                set attr [list  \
                                        "cx" [expr $x + $w/2.0]  \
                                        "cy" [expr $y + $h/2.0]  \
                                        "rx" [expr $w/2.0]       \
                                        "ry" [expr $h/2.0]]
                            }
                            set style [MakeStyle $type $opts]
                            lappend attr "style" $style
                            if {[string length $idAttr] > 0} {
                                set attr [concat $attr $idAttr]
                            }
                            set xmlList [MakeXMLList $elem -attrlist $attr]
                        }
                        polygon {
                            
                            if {$haveSpline} {
                                set elem "path"
                                set style [MakeStyle $type $opts]
                                
                                # Translating a closed polygon into a qubic bezier
                                # path is a little bit tricky.
                                set x0 [expr ([lindex $coo end-1] + [lindex $coo 0])/2.0]
                                set y0 [expr ([lindex $coo end] + [lindex $coo 1])/2.0]
                                set data "M $x0 $y0 Q"
                                set i 2
                                foreach {x y} [lrange $coo 0 end-2] {
                                    set x1 [expr ($x + [lindex $coo $i])/2.0]
                                    incr i
                                    set y1 [expr ($y + [lindex $coo $i])/2.0]
                                    incr i
                                    append data " $x $y $x1 $y1"
                                }
                                append data " [lrange $coo end-1 end] $x0 $y0"
                                set attr [list "d" $data "style" $style]
                            } else {
                                
                                set elem "polygon"
                                set style [MakeStyle $type $opts]
                                puts "AVANT $type $opts APRES $style"
                                set attr [list "points" $coo "style" $style]
                            }
                            if {[string length $idAttr] > 0} {
                                set attr [concat $attr $idAttr]
                            }
                            set xmlList [MakeXMLList $elem -attrlist $attr]
                        }
                        rectangle {
                            set elem "rect"
                            set style [MakeStyle $type $opts]
                            
                            # width and height must be non-negative!
                            foreach {x y w h} [NormalizeRectCoords $coo] {}
                            set attr [list "x" $x "y" $y "width" $w "height" $h]
                            lappend attr "style" $style
                            if {[string length $idAttr] > 0} {
                                set attr [concat $attr $idAttr]
                            }
                            set xmlList [MakeXMLList $elem -attrlist $attr]
                        }
                        text {
                            set elem "text"
                            set style [MakeStyle $type $opts]
                            set nlines 1
                            if {[info exists optArr(-text)]} {
                                set chdata $optArr(-text)
                                set nlines [expr [regexp -all "\n" $chdata] + 1]
                            } else {
                                set chdata ""
                            }
                            
                            # Figure out the coords of the first baseline.
                            set anchor center
                            if {[info exists optArr(-anchor)]} {
                                set anchor $optArr(-anchor)
                            }
                            if {[info exists optArr(-font)]} {
                                set theFont $optArr(-font)
                            } else {
                                set theFont $defaultFont
                            }
                            set ascent [font metrics $theFont -ascent]
                            set lineSpace [font metrics $theFont -linespace]
                            
                            foreach {xbase ybase}  \
                                    [GetTextSVGCoords $coo $anchor $chdata $theFont $nlines] {}
                            
                            set attr [list "x" $xbase "y" $ybase]
                            lappend attr "style" $style
                            if {[string length $idAttr] > 0} {
                                set attr [concat $attr $idAttr]
                            }
                            set dy 0
                            if {$nlines > 1} {
                                
                                # Use the 'tspan' trick here.
                                set subList {}
                                foreach line [split $chdata "\n"] {
                                    lappend subList [MakeXMLList "tspan"  \
                                            -attrlist [list "x" $xbase "dy" $dy] -chdata $line]
                                    set dy $lineSpace
                                }
                                set xmlList [MakeXMLList $elem -attrlist $attr \
                                        -subtags $subList]
                            } else {
                                set xmlList [MakeXMLList $elem -attrlist $attr \
                                        -chdata $chdata]
                            }
                        }
                    }
                }
                move {
                    foreach {tag dx dy} [lrange $cmd 1 3] {}
                    set attr [list "transform" "translate($dx,$dy)"  \
                            "xlink:href" "#$tag"]
                    set xmlList [MakeXMLList "use" -attrlist $gattr]
                }
                scale {
                    
                }
            }
            append xml [MakeXML $xmlList]
            return $xml
        }
        
        # ::can2svg::MakeStyle --
        #
        #       Produce the SVG style attribute from the canvas item options.
        #
        # Arguments:
        #       type        tk canvas widget item type
        #       opts
        #
        # Results:
        #       The SVG style attribute as a a string.
        
        proc ::can2svg::MakeStyle {type opts} {
            
            # Defaults for everything except text.
            if {![string equal $type "text"]} {
                array set styleArr {fill none stroke black}
            }
            set fillCol black
            
            foreach {key value} $opts {
                
                switch -- $key {
                    -arrow {
                        set arrowValue $value
                    }
                    -arrowshape {
                        set arrowShape $value
                    }
                    -capstyle {
                        if {[string equal $value "projecting"]} {
                            set value "square"
                        }
                        if {![string equal $value "butt"]} {
                            set styleArr(stroke-linecap) $value
                        }
                    }
                    -dash {
                        set dashValue $value
                    }
                    -dashoffset {
                        if {$value != 0} {
                            set styleArr(stroke-dashoffset) $value
                        }
                    }
                    -fill {
                        set fillCol $value
                        
                        if {[string equal $type "line"]} {
                            set styleArr(stroke) [MapEmptyToNone $value]
                        } else {
                            set styleArr(fill) [MapEmptyToNone $value]
                        }
                        
                    }
                    -font {
                        set styleArr(font-family) [lindex $value 0]
                        if {[llength $value] > 1} {
                            set styleArr(font-size) [lindex $value 1]
                        }
                        if {[llength $value] > 2} {
                            set tkstyle [lindex $value 2]
                            switch -- $tkstyle {
                                bold {
                                    set styleArr(font-weight) $tkstyle
                                }
                                italic {
                                    set styleArr(font-style) $tkstyle
                                }
                                underline {
                                    set styleArr(text-decoration) underline
                                }
                                overstrike {
                                    set styleArr(text-decoration) overline
                                }
                            }
                        }
                        
                    }
                    -joinstyle {
                        set styleArr(stroke-linejoin) $value
                    }
                    -outline {
                        set styleArr(stroke) [MapEmptyToNone $value]
                    }
                    -outlinestipple {
                        set outlineStippleValue $value
                    }
                    -stipple {
                        set stippleValue $value
                    }
                    -width {
                        set styleArr(stroke-width) $value
                    }
                }
            }
            
            # If any arrow specify its marker def url key.
            if {[info exists arrowValue]} {
                if {[info exists arrowShape]} {
                    foreach {a b c} $arrowShape {}
                    set arrowIdKey "arrowMarkerDef_${fillCol}_${a}_${b}_${c}"
                    set arrowIdKeyLast "arrowMarkerLastDef_${fillCol}_${a}_${b}_${c}"
                } else {
                    set arrowIdKey "arrowMarkerDef_${fillCol}"
                }
                switch -- $arrowValue {
                    first {
                        set styleArr(marker-start) "url(#$arrowIdKey)"
                    }
                    last {
                        set styleArr(marker-end) "url(#$arrowIdKeyLast)"
                    }
                    both {
                        set styleArr(marker-start) "url(#$arrowIdKey)"
                        set styleArr(marker-end) "url(#$arrowIdKeyLast)"
                    }
                }
            }
            
            if {[info exists stippleValue]} {
                
                # Overwrite any existing.
                set styleArr(fill) "url(#tile$stippleValue)"
            }
            if {[info exists outlineStippleValue]} {
                
                # Overwrite any existing.
                set styleArr(stroke) "url(#tile$stippleValue)"
            }
            
            # Transform dash value.
            if {[info exists dashValue]} {
                
                # Two different syntax here.
                if {[regexp {[\.,\-_ ]} $dashValue]} {
                    
                    # .=2 ,=4 -=6 space=4    times stroke width.
                    # A space enlarges the... space.
                    # Not foolproof!
                    regsub -all -- {[^ ]} $dashValue "& " dash
                    regsub -all -- "   "  $dash  "12 " dash
                    regsub -all -- "  "   $dash  "8 " dash
                    regsub -all -- " "    $dash  "4 " dash
                    regsub -all -- {\.}   $dash  "2 " dash
                    regsub -all -- {,}    $dash  "4 " dash
                    regsub -all -- {-}    $dash  "6 " dash
                    
                    # Multiply with stroke width if > 1.
                    if {[info exists styleArr(stroke-width)] &&  \
                                ($styleArr(stroke-width) > 1)} {
                        set width $styleArr(stroke-width)
                        set dashOrig $dash
                        set dash {}
                        foreach num $dashOrig {
                            lappend dash [expr int($width * $num)]
                        }
                    }
                    set styleArr(stroke-dasharray) [string trim $dash]
                } else {
                    set styleArr(stroke-dasharray) $value
                }
            }
            if {[string equal $type "polygon"]} {
                set styleArr(fill-rule) "evenodd"
            }
            
            set style ""
            foreach {key value} [array get styleArr] {
                append style "${key}: ${value}; "
            }
            return [string trim $style]
        }
        
        # ::can2svg::MakeImageAttr --
        #
        #       Special code is needed to make the attributes for an image item.
        #
        # Arguments:
        #       elem
        #
        # Results:
        #
        
        proc ::can2svg::MakeImageAttr {coo opts} {
            
            array set optArr {-anchor nw}
            array set optArr $opts
            set theImage $optArr(-image)
            set w [image width $theImage]
            set h [image height $theImage]
            
            # We should make this an URI.
            set theFile [$theImage cget -file]
            set uri [UriFromLocalFile $theFile]
            foreach {x0 y0} $coo {}
            switch -- $optArr(-anchor) {
                nw {
                    set x $x0
                    set y $y0
                }
                n {
                    set x [expr $x0 - $w/2.0]
                    set y $y0
                }
                ne {
                    set x [expr $x0 - $w]
                    set y $y0
                }
                e {
                    set x $x0
                    set y [expr $y0 - $h/2.0]
                }
                se {
                    set x [expr $x0 - $w]
                    set y [expr $y0 - $h]
                }
                s {
                    set x [expr $x0 - $w/2.0]
                    set y [expr $y0 - $h]
                }
                sw {
                    set x $x0
                    set y [expr $y0 - $h]
                }
                w {
                    set x $x0
                    set y [expr $y0 - $h/2.0]
                }
                center {
                    set x [expr $x0 - $w/2.0]
                    set y [expr $y0 - $h/2.0]
                }
            }
            set attrList [list "x" $x "y" $y "width" $w "height" $h  \
                    "xlink:href" $uri]
            return $attrList
        }
        
        # ::can2svg::GetTextSVGCoords --
        #
        #       Figure out the baseline coords of the svg text element from
        #       the canvas text item.
        #
        # Arguments:
        #       coo         {x y}
        #       anchor
        #       chdata      character data, newlines included.
        #
        # Results:
        #       raw xml data of the marker def element.
        
        proc ::can2svg::GetTextSVGCoords {coo anchor chdata theFont nlines} {
            
            foreach {x y} $coo {}
            set ascent [font metrics $theFont -ascent]
            set lineSpace [font metrics $theFont -linespace]
            
            # If not anchored to the west it gets more complicated.
            if {![string match $anchor "*w*"]} {
                
                # Need to figure out the extent of the text.
                if {$nlines <= 1} {
                    set textWidth [font measure $theFont $chdata]
                } else {
                    set textWidth 0
                    foreach line [split $chdata "\n"] {
                        set lineWidth [font measure $theFont $line]
                        if {$lineWidth > $textWidth} {
                            set textWidth $lineWidth
                        }
                    }
                }
            }
            
            switch -- $anchor {
                nw {
                    set xbase $x
                    set ybase [expr $y + $ascent]
                }
                w {
                    set xbase $x
                    set ybase [expr $y - $nlines*$lineSpace/2.0 + $ascent]
                }
                sw {
                    set xbase $x
                    set ybase [expr $y - $nlines*$lineSpace + $ascent]
                }
                s {
                    set xbase [expr $x - $textWidth/2.0]
                    set ybase [expr $y - $nlines*$lineSpace + $ascent]
                }
                se {
                    set xbase [expr $x - $textWidth]
                    set ybase [expr $y - $nlines*$lineSpace + $ascent]
                }
                e {
                    set xbase [expr $x - $textWidth]
                    set ybase [expr $y - $nlines*$lineSpace/2.0 + $ascent]
                }
                ne {
                    set xbase [expr $x - $textWidth]
                    set ybase [expr $y + $ascent]
                }
                n {
                    set xbase [expr $x - $textWidth/2.0]
                    set ybase [expr $y + $ascent]
                }
                center {
                    set xbase [expr $x - $textWidth/2.0]
                    set ybase [expr $y - $nlines*$lineSpace/2.0 + $ascent]
                }
            }
            
            return [list $xbase $ybase]
        }
        
        # ::can2svg::MakeArrowMarker --
        #
        #       Make the xml for an arrow marker def element.
        #
        # Arguments:
        #       a           arrows length along its symmetry line
        #       b           arrows total length
        #       c           arrows half width
        #       col         its color
        #
        # Results:
        #       raw xml data of the marker def elements, both start and last.
        
        proc ::can2svg::MakeArrowMarker {a b c col} {
            
            variable formatArrowMarker
            variable formatArrowMarkerLast
            
            catch {unset formatArrowMarker}
            
            if {![info exists formatArrowMarker]} {
                
                # "M 0 c, b 0, a c, b 2*c Z" for the start marker.
                # "M 0 0, b c, 0 2*c, b-a c Z" for the last marker.
                set data "M 0 %s, %s 0, %s %s, %s %s Z"
                set style "fill: %s; stroke: %s;"
                set attr [list "d" $data "style" $style]
                set arrowList [MakeXMLList "path" -attrlist $attr]
                set markerAttr [list "id" %s "markerWidth" %s "markerHeight" %s  \
                        "refX" %s "refY" %s "orient" "auto"]
                set defElemList [MakeXMLList "defs" -subtags  \
                        [list [MakeXMLList "marker" -attrlist $markerAttr \
                        -subtags [list $arrowList] ] ] ]
                set formatArrowMarker [MakeXML $defElemList]
                
                # ...and the last arrow marker.
                set dataLast "M 0 0, %s %s, 0 %s, %s %s Z"
                set attrLast [list "d" $dataLast "style" $style]
                set arrowLastList [MakeXMLList "path" -attrlist $attrLast]
                set defElemLastList [MakeXMLList "defs" -subtags  \
                        [list [MakeXMLList "marker" -attrlist $markerAttr \
                        -subtags [list $arrowLastList] ] ] ]
                set formatArrowMarkerLast [MakeXML $defElemLastList]
            }
            set idKey "arrowMarkerDef_${col}_${a}_${b}_${c}"
            set idKeyLast "arrowMarkerLastDef_${col}_${a}_${b}_${c}"
            
            # Figure out the order of all %s substitutions.
            set markerXML [format $formatArrowMarker $idKey  \
                    $b [expr 2*$c] 0 $c  \
                    $c $b $a $c $b [expr 2*$c] $col $col]
            set markerLastXML [format $formatArrowMarkerLast $idKeyLast  \
                    $b [expr 2*$c] $b $c \
                    $b $c [expr 2*$c] [expr $b-$a] $c $col $col]
            
            return "$markerXML\n\t$markerLastXML"
        }
        
        # ::can2svg::MakeGrayStippleDef --
        #
        #
        
        proc ::can2svg::MakeGrayStippleDef {stipple} {
            
            variable stippleDataArr
            
            set pathList [MakeXMLList "path" -attrlist  \
                    [list "d" $stippleDataArr($stipple) "style" "stroke: black; fill: none;"]]
            set patterAttr [list "id" "tile$stipple" "x" 0 "y" 0 "width" 4 "height" 4 \
                    "patternUnits" "userSpaceOnUse"]
            set defElemList [MakeXMLList "defs" -subtags  \
                    [list [MakeXMLList "pattern" -attrlist $patterAttr \
                    -subtags [list $pathList] ] ] ]
            
            return [MakeXML $defElemList]
        }
        
        # ::can2svg::MapEmptyToNone --
        #
        #
        # Arguments:
        #       elem
        #
        # Results:
        #
        
        proc ::can2svg::MapEmptyToNone {val} {
            
            if {[string length $val] == 0} {
                return "none"
            } else {
                return $val
            }
        }
        
        # ::can2svg::NormalizeRectCoords --
        #
        #
        # Arguments:
        #       elem
        #
        # Results:
        #
        
        proc ::can2svg::NormalizeRectCoords {coo} {
            
            foreach {x1 y1 x2 y2} $coo {}
            return [list [expr $x2 > $x1 ? $x1 : $x2]  \
                    [expr $y2 > $y1 ? $y1 : $y2]  \
                    [expr abs($x1-$x2)]  \
                    [expr abs($y1-$y2)]]
        }
        
        # ::can2svg::makedocument --
        #
        #       Adds the prefix and suffix elements to make a complete XML/SVG
        #       document.
        #
        # Arguments:
        #       elem
        #
        # Results:
        #
        
        proc ::can2svg::makedocument {width height xml} {
            
            set pre "<?xml version='1.0'?>\n\
                    <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\"\
                    \"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\">"
            
            set svgStart "<svg width='$width' height='$height'>"
            set svgEnd "</svg>"
            return "${pre}\n${svgStart}\n${xml}${svgEnd}"
        }
        
        # ::can2svg::canvas2file --
        #
        #       Takes everything on a canvas widget, translates it to XML/SVG,
        #       and puts it on a file.
        #
        # Arguments:
        #       wcan        the canvas widget path
        #       path        the file path
        #       args:   -height
        #               -width
        #
        # Results:
        #
        #
        proc ::can2svg::canvas2file {wcan path args} {
            
            variable defsArrowMarkerArr
            variable defsStipplePatternArr
            
            # Need to make a fresh start for marker def's.
            catch {unset defsArrowMarkerArr}
            catch {unset defsStipplePatternArr}
            
            #array set argsArr  \
            #        [list -width [winfo width $wcan] -height [winfo height $wcan]]
            # correction chevenet
            $wcan configure -scrollregion [$wcan bbox all]
            $wcan xview moveto 0
            $wcan yview moveto 0
            set width [expr [lindex [$wcan bbox all] 2] - [lindex [$wcan bbox all] 0]]
            set height [expr [lindex [$wcan bbox all] 3] - [lindex [$wcan bbox all] 1]]
            array set argsArr   [list -width $width -height $height]
            
            
            
            array set argsArr $args
            
            set fd [open $path w]
            
            set xml ""
            # ici pour la modification sur les tags // hidden
            foreach id [$wcan find all] {
                set type [$wcan type $id]
                set opts [$wcan itemconfigure $id]
                set opcmd {}
                foreach opt $opts {
                    set op [lindex $opt 0]
                    set val [lindex $opt 4]
                    
                    # Empty val's except -fill can be stripped off.
                    if {![string equal $op "-fill"] && ([string length $val] == 0)} {
                        continue
                    }
                    lappend opcmd $op $val
                }
                set co [$wcan coords $id]
                set cmd [concat "create" $type $co $opcmd]
                append xml "\t[can2svg $cmd]\n"
            }
            puts $fd [makedocument $argsArr(-width) $argsArr(-height) $xml]
            close $fd
        }
        
        # ::can2svg::MakeXML --
        #
        #       Creates raw xml data from a hierarchical list of xml code.
        #       This proc gets called recursively for each child.
        #       It makes also internal entity replacements on character data.
        #       Mixed elements aren't treated correctly generally.
        #
        # Arguments:
        #       xmlList     a list of xml code in the format described in the header.
        #
        # Results:
        #       raw xml data.
        
        proc ::can2svg::MakeXML {xmlList} {
            
            # Extract the XML data items.
            foreach {tag attrlist isempty chdata childlist} $xmlList {}
            set rawxml "<$tag"
            foreach {attr value} $attrlist {
                append rawxml " ${attr}='${value}'"
            }
            if {$isempty} {
                append rawxml "/>"
                return $rawxml
            } else {
                append rawxml ">"
            }
            
            # Call ourselves recursively for each child element.
            # There is an arbitrary choice here where childs are put before PCDATA.
            foreach child $childlist {
                append rawxml [MakeXML $child]
            }
            
            # Make standard entity replacements.
            if {[string length $chdata]} {
                append rawxml [XMLCrypt $chdata]
            }
            append rawxml "</$tag>"
            return $rawxml
        }
        
        # ::can2svg::MakeXMLList --
        #
        #       Build an element list given the tag and the args.
        #
        # Arguments:
        #       tagname:    the name of this element.
        #       args:
        #           -empty   0|1      Is this an empty tag? If $chdata
        #                             and $subtags are empty, then whether
        #                             to make the tag empty or not is decided
        #                             here. (default: 1)
        #	    -attrlist {attr1 value1 attr2 value2 ..}   Vars is a list
        #                             consisting of attr/value pairs, as shown.
        #	    -chdata $chdata   ChData of tag (default: "").
        #	    -subtags {$subchilds $subchilds ...} is a list containing xmldata
        #                             of $tagname's subtags. (default: no sub-tags)
        #
        # Results:
        #       a list suitable for ::can2svg::MakeXML.
        
        proc ::can2svg::MakeXMLList {tagname args} {
            
            # Fill in the defaults.
            array set xmlarr {-isempty 1 -attrlist {} -chdata {} -subtags {}}
            
            # Override the defults with actual values.
            if {[llength $args] > 0} {
                array set xmlarr $args
            }
            if {!(($xmlarr(-chdata) == "") && ($xmlarr(-subtags) == ""))} {
                set xmlarr(-isempty) 0
            }
            
            # Build sub elements list.
            set sublist {}
            foreach child $xmlarr(-subtags) {
                lappend sublist $child
            }
            set xmlList [list $tagname $xmlarr(-attrlist) $xmlarr(-isempty)  \
                    $xmlarr(-chdata) $sublist]
            return $xmlList
        }
        
        # ::can2svg::XMLCrypt --
        #
        #       Makes standard XML entity replacements.
        #
        # Arguments:
        #       chdata:     character data.
        #
        # Results:
        #       chdata with XML standard entities replaced.
        
        proc ::can2svg::XMLCrypt {chdata} {
            foreach from {\& < > {"} {'}}   \
                    to {{\&amp;} {\&lt;} {\&gt;} {\&quot;} {\&apos;}} {
                        regsub -all $from $chdata $to chdata
                    }
            return $chdata
        }
        # ::can2svg::UriFromLocalFile --
        #
        #       Not foolproof!
        
        proc ::can2svg::UriFromLocalFile {path} {
            
            # Windows???
            # TODO: Encoding?
            if {[string equal $::tcl_platform(platform) "windows"]} {
                
                # Trim the volume specifier.
                set vol_ {([A-Z]:/|[A-Z]:\\)}
                regexp "${vol_}+(.+)$" $path match x path
            }
            set pathList [split $path "/:\\"]
            set pathJoin [join $pathList /]
            
            # Any characters not 7bit encode as %xx hex???
            
            regsub -all -- " " $pathJoin "%20" pathJoin
            
            return file:///${pathJoin}
        }
    }
    
}
################################################################################
# Stage Jerome Cance 2004
namespace eval Subdivision {
    proc SubdivisionPanel {} {
        global S
        global Temp
        toplevel .navigation
        canvas .navigation.motherTreeC
        canvas .navigation.secondTreeC
        pack .navigation.motherTreeC .navigation.secondTreeC -expand 1 -fill both
        destroy .globalFrame
        
        toplevel .globalFrame
        
        set x [expr ([winfo screenwidth .globalFrame] - [winfo reqwidth .globalFrame]) /2]
        set y [expr ([winfo screenheight .globalFrame] - [winfo reqheight .globalFrame]) /2]
        
        wm geometry .globalFrame +$x+$y
        
        button .globalFrame.openFile -text "Open a file" -command Subdivision::OpenFile
        
        label .globalFrame.lbPathname -textvariable Temp(pathname)
        label .globalFrame.lbTreeNb -text "Number of leaves : "
        label .globalFrame.lbLeaves -textvariable Temp(leavesNb)
        
        entry .globalFrame.maxEntry -textvariable Temp(BIseuil) -state disabled -validate all \
                -vcmd {
                    if {[regexp {^[0-9]*$} %P match]} {
                        if {$match!="" && %P<$Temp(leavesNb)} {
                            .globalFrame.launch configure -state normal
                            return true
                        } elseif {$match==""} {
                            .globalFrame.launch configure -state disabled
                            return true
                        } else {
                            return false
                        }
            } else {
                return false
            }
        }
        
        button .globalFrame.launch -text "Launch the subdivision" -state disabled -command {Subdivision::Subdivision}
        
        pack .globalFrame.openFile .globalFrame.lbPathname .globalFrame.lbTreeNb .globalFrame.lbLeaves \
                .globalFrame.maxEntry .globalFrame.launch -expand false -fill x
    }
    
    proc OpenFile {} {
        global Temp
        
        set Temp(pathname) [tk_getOpenFile -filetypes {{"Newicks file" ".nwk"} {"All" "*"}}]
        
        if {[string compare $Temp(pathname) ""]} {
            .globalFrame.maxEntry configure -state normal
            
            if [catch {open $Temp(pathname) r} fid] {
                puts stderr "Incorrect File Format"
            } else {
                set Temp(BImotherFinal) [read -nonewline $fid]
                close $fid
            }
            
            set Temp(BImother) [Verif $Temp(BImotherFinal)]
            
            if {$Temp(BImotherFinal) == 0} {
                puts stderr "Incorrect Tree"
            } else {
                incr Temp(leavesNb)
            }
            
        } else {
            .globalFrame.maxEntry configure -state disabled
            .globalFrame.launch configure -state disabled
        }
    }
    
    proc Verif {tree} {
        
        global Temp
        
        set Temp(leavesNb) [regsub -all {\(} $tree "" q]
        
        if { $Temp(leavesNb) == [regsub -all {\)} $tree "" q]} {
            regsub -all {([a-zA-Z0-9]+(:[0-9]+(\.[0-9]+)?)?,[a-zA-Z0-9]+(:[0-9]+(\.[0-9]+)?)?,)([a-zA-Z0-9]+(:[0-9]+(\.[0-9]+)?)?)} \
                    $tree {\(\1\)\2} tree
            regsub -all ":-" $tree ":" tree
        } else {set tree 0}
        
        return $tree
    }
    
    proc Subdivision {} {
        global S
        global progress
        global History
        
        destroy .globalFrame
        
        Init
        .navigation.motherTreeC delete all
        .navigation.secondTreeC delete all
        
        set S(BImother) $S(BImotherFinal)
        
        set nbF [expr [regsub -all "," $S(BImother) "" q] +1]
        
        set progress [CreateProgressBar "TreeDyn Importation" [set max [expr ($nbF / $S(BIseuil))*10]]]
        
        set S(BInode) {}
        while {$nbF > $S(BIseuil)} {
            BInewickParserRec $S(BImother) 0
            set nbF [expr [regsub -all "," $S(BImother) "" q] +1]
        }
        
        set id [Tools::GenId]
        lappend S(BInode) [format "%s%s" $S(BImother) ";"]
        set S(BInode,$id) [format "%s%s" $S(BImother) ";"]
        
        destroy $progress
        
        set nbF [expr [regsub -all "," $S(BImotherFinal) "" q] +1]
        
        set progress [CreateProgressBar "Loading interface..." $nbF]
        
        set tempTree $S(BImotherFinal)
        
        while {[regexp {(,|\()([^,:;\(\)\.-]+)} $tempTree match sub1 sub2]} {
            $progress.i step
            #.navigation.optionsFr.leaveListbox insert end $sub2
            regsub $sub2 $tempTree "" tempTree
        }
        
        set l {}
        foreach {key value} [array get S BInode,*] {
            set name [string range $key 7 end]
            lappend l [list $name $value]
        }
        
        CreateSymbolicTree
        DrawSymbolicTree .navigation.motherTreeC "" 0 0
        .navigation.motherTreeC configure -scrollregion [.navigation.motherTreeC bbox all]
        CanvasBind .navigation.motherTreeC
        MIimportNWKs .navigation.secondTreeC $S(BImother)
        
        set History(subtreeList) [lsort -dictionary $History(subtreeList)]
        set History(leaveList) [lsort -dictionary $History(leaveList)]
        
        destroy $progress
    }
    
    proc MenuBind {what sequence accText m label} {
        if {[catch {$m index $label} index]} {
            error "$label not in menu $menuName"
        }
        bind $what $sequence [list Subdivision::MenuInvoke $m $index]
        $m entryconfigure $index -accelerator $accText
    }
    
    proc MenuInvoke {m index} {
        set state [$m entrycget $index -state]
        if {[string equal $state normal]} {
            $m invoke $index
        }
        
        Subdivision::AnyEnterCanvas .navigation.motherTreeC
    }
    
    proc InterfaceBuilder {} {
        global S
        global Export
        global Symb
        global History
        
        destroy .navigation
        
        toplevel .navigation
        wm geometry .navigation [winfo screenwidth .]x[winfo screenheight .]+0+0
        
        set mb [menu .navigation.menubar]
        
        foreach m {File Edit Tools Help} {
            set $m [menu $mb.m$m]
            $mb add cascade -label $m -menu $mb.m$m -underline 0
        }
        
        $File add command -label "New" -underline 0 -command {Subdivision::SubdivisionPanel}
        $File add separator
        $File add command -label "Open" -underline 0
        $File add command -label "Save" -underline 0
        $File add command -label "Save as" -underline 1
        $File add separator
        $File add command -label "Quit" -underline 0
        .navigation configure -menu .navigation.menubar
        
        $Edit add command -label "Preferences" -underline 1
        $Edit add command -label "Interface Configuration" -underline 10
        
        $Tools add radio -label "Select" -variable S(tool) -value select -underline 0
        $Tools add radio -label "Zoom" -variable S(tool) -value zoom -underline 0
        $Tools add radio -label "Move" -variable S(tool) -value move -underline 0
        
        $Help add command -label "Help" -underline 0
        $Help add separator
        $Help add command -label "About" -underline 0
        
        MenuBind .navigation <Control-n> Ctrl-n $File New
        MenuBind .navigation <Control-o> Ctrl-o $File Open
        MenuBind .navigation <Control-s> Ctrl-s $File Save
        MenuBind .navigation <Control-q> Ctrl-q $File Quit
        
        MenuBind .navigation <s> s $Tools Select
        MenuBind .navigation <m> m $Tools Move
        MenuBind .navigation <z> z $Tools Zoom
        
        MenuBind .navigation <KP_F1> F1 $Help Help
        MenuBind .navigation <KP_F2> F2 $Help About
        
        frame .navigation.informationsFr
        
        frame .navigation.optionsFr
        
        frame .navigation.informationsFr.haut
        frame .navigation.informationsFr.bas
        
        pack .navigation.informationsFr.haut .navigation.informationsFr.bas -side top -expand true -fill both
        
        frame .navigation.informationsFr.haut.blank
        label .navigation.informationsFr.haut.fixPathnameLb -text "Pathname : " -font $S(etiquetteFont)
        label .navigation.informationsFr.haut.fixleaveNbLb -text "Number of leaves : " -font $S(etiquetteFont)
        label .navigation.informationsFr.haut.pathnameLb -textvariable S(pathname)
        label .navigation.informationsFr.haut.leaveNbLb -textvariable S(leavesNb)
        label .navigation.informationsFr.bas.helpIcon -image IMGhelp
        label .navigation.informationsFr.bas.sbInfoLb -textvariable History(sbInfo)
        
        grid .navigation.informationsFr.haut.fixPathnameLb .navigation.informationsFr.haut.pathnameLb \
                .navigation.informationsFr.haut.blank .navigation.informationsFr.haut.fixleaveNbLb \
                .navigation.informationsFr.haut.leaveNbLb -sticky w
        grid columnconfigure .navigation.informationsFr.haut 2 -weight 1
        
        pack .navigation.informationsFr.bas.helpIcon .navigation.informationsFr.bas.sbInfoLb -side left
        
        scrollbar .navigation.xsbar1 -orient horizontal -command ".navigation.motherTreeC xview" -bg grey -width 5
        scrollbar .navigation.ysbar1 -orient vertical -command ".navigation.motherTreeC yview"  -bg grey -width 5
        canvas .navigation.motherTreeC -relief groove -xscrollcommand ".navigation.xsbar1 set" \
                -yscrollcommand ".navigation.ysbar1 set" -highlightthickness 0
        
        scrollbar .navigation.xsbar2 -orient horizontal -command ".navigation.secondTreeC xview" -bg grey -width 5
        scrollbar .navigation.ysbar2 -orient vertical -command ".navigation.secondTreeC yview"  -bg grey -width 5
        canvas .navigation.secondTreeC -relief groove -xscrollcommand ".navigation.xsbar2 set" \
                -yscrollcommand ".navigation.ysbar2 set" -highlightthickness 0
        
        set toolBar [iwidgets::toolbar .navigation.optionsFr.toolBar]
        
        $toolBar add radiobutton selectB -image TIMselect -variable S(tool) -value select
        $toolBar add radiobutton zoomB -image TIMzoom -variable S(tool) -value zoom
        $toolBar add radiobutton moveB -image TIMmove -variable S(tool) -value move
        
        scrollbar .navigation.optionsFr.xscrollSubtree -command {.navigation.optionsFr.subtreeListbox xview} \
                -orient horizontal -width 5
        scrollbar .navigation.optionsFr.yscrollSubtree -command {.navigation.optionsFr.subtreeListbox yview} \
                -orient vertical -width 5
        label .navigation.optionsFr.subtreeLb -text "Subtree list :"
        label .navigation.optionsFr.subtreeSearchIcon -image IMGsearch
        entry .navigation.optionsFr.subtreeSearch -textvariable History(subtreeSearch) -width 5 \
                -validate key -vcmd {Subdivision::Search .navigation.optionsFr.subtreeListbox "%P"}
        listbox .navigation.optionsFr.subtreeListbox -listvariable History(subtreeList) \
                -xscrollcommand {.navigation.optionsFr.xscrollSubtree set} \
                -yscrollcommand {.navigation.optionsFr.yscrollSubtree set}
        .navigation.optionsFr.subtreeListbox delete 0 end
        
        scrollbar .navigation.optionsFr.xscrollLeave -command {.navigation.optionsFr.leaveListbox xview} \
                -orient horizontal -width 5
        scrollbar .navigation.optionsFr.yscrollLeave -command {.navigation.optionsFr.leaveListbox yview} \
                -orient vertical -width 5
        label .navigation.optionsFr.leaveLb -text "Leave list :"
        label .navigation.optionsFr.leaveSearchIcon -image IMGsearch
        entry .navigation.optionsFr.leaveSearch -textvariable History(leaveSearch) -width 5 \
                -validate key -vcmd {Subdivision::Search .navigation.optionsFr.leaveListbox "%P"}
        listbox .navigation.optionsFr.leaveListbox -listvariable History(leaveList) \
                -xscrollcommand {.navigation.optionsFr.xscrollLeave set} \
                -yscrollcommand {.navigation.optionsFr.yscrollLeave set}
        .navigation.optionsFr.leaveListbox delete 0 end
        
        scrollbar .navigation.optionsFr.xscrollSubtreeLeave -command {.navigation.optionsFr.subtreeLeaveListbox xview} \
                -orient horizontal -width 5
        scrollbar .navigation.optionsFr.yscrollSubtreeLeave -command {.navigation.optionsFr.subtreeLeaveListbox yview} \
                -orient vertical -width 5
        label .navigation.optionsFr.subtreeLeaveLb -text "SubtreeLeave list :"
        label .navigation.optionsFr.subtreeLeaveSearchIcon -image IMGsearch
        entry .navigation.optionsFr.subtreeLeaveSearch -textvariable History(subtreeLeaveSearch) -width 5 \
                -validate key -vcmd {Subdivision::Search .navigation.optionsFr.subtreeLeaveListbox "%P"}
        listbox .navigation.optionsFr.subtreeLeaveListbox -listvariable History(subtreeLeaveList) \
                -xscrollcommand {.navigation.optionsFr.xscrollSubtreeLeave set} \
                -yscrollcommand {.navigation.optionsFr.yscrollSubtreeLeave set}
        .navigation.optionsFr.subtreeLeaveListbox delete 0 end
        
        grid $toolBar -row 0 -column 0 -sticky ew -columnspan 4
        
        grid .navigation.optionsFr.leaveLb -row 1 -column 0 -sticky ew
        grid .navigation.optionsFr.leaveSearchIcon -row 1 -column 1 -sticky ew
        grid .navigation.optionsFr.leaveSearch -row 1 -column 2 -sticky ew
        grid .navigation.optionsFr.leaveListbox -row 2 -column 0 -sticky news -columnspan 3
        grid .navigation.optionsFr.yscrollLeave -row 2 -column 3 -sticky ns
        grid .navigation.optionsFr.xscrollLeave -row 3 -column 0 -sticky ew -columnspan 3
        
        grid .navigation.optionsFr.subtreeLb -row 4 -column 0 -sticky ew
        grid .navigation.optionsFr.subtreeSearchIcon -row 4 -column 1 -sticky ew
        grid .navigation.optionsFr.subtreeSearch -row 4 -column 2 -sticky ew
        grid .navigation.optionsFr.subtreeListbox -row 5 -column 0 -sticky news -columnspan 3
        grid .navigation.optionsFr.yscrollSubtree -row 5 -column 3 -sticky ns
        grid .navigation.optionsFr.xscrollSubtree -row 6 -column 0 -sticky ew -columnspan 3
        
        grid .navigation.optionsFr.subtreeLeaveLb -row 7 -column 0 -sticky ew
        grid .navigation.optionsFr.subtreeLeaveSearchIcon -row 7 -column 1 -sticky ew
        grid .navigation.optionsFr.subtreeLeaveSearch -row 7 -column 2 -sticky ew
        grid .navigation.optionsFr.subtreeLeaveListbox -row 8 -column 0 -sticky news -columnspan 3
        grid .navigation.optionsFr.yscrollSubtreeLeave -row 8 -column 3 -sticky ns
        grid .navigation.optionsFr.xscrollSubtreeLeave -row 9 -column 0 -sticky ew -columnspan 3
        
        grid rowconfigure .navigation.optionsFr 2 -weight 2
        grid rowconfigure .navigation.optionsFr "5 8" -weight 1
        grid columnconfigure .navigation.optionsFr 2 -weight 1
        
        grid .navigation.optionsFr -row 0 -column 0 -rowspan 4 -sticky news -padx 5 -pady 5
        grid .navigation.informationsFr -row 0 -column 1 -columnspan 2 -sticky news
        grid .navigation.motherTreeC -row 1 -column 1 -sticky news
        grid .navigation.xsbar1 -row 2 -column 1 -sticky ew
        grid .navigation.ysbar1 -row 1 -column 2 -sticky ns
        
        grid .navigation.secondTreeC -row 3 -column 1 -sticky news
        grid .navigation.xsbar2 -row 4 -column 1 -sticky ew
        grid .navigation.ysbar2 -row 3 -column 2 -sticky ns
        
        grid rowconfigure .navigation "1 3" -uniform group1 -weight 1
        grid columnconfigure .navigation 1 -weight 1
    }
    
    proc Search {w value {action SubtreeListBoxSelected}} {
        set list [$w get 0 end]
        
        set indice [lsearch -glob $list $value*]
        $w see $indice
        $w selection clear 0 end
        $w selection set $indice $indice
        
        $action $w
        
        return true
    }
    
    proc CanvasBind {c} {
        global S
        global History
        
        bind $c <Any-Enter> "Subdivision::AnyEnterCanvas %W"
        bind $c <Any-Leave> "Subdivision::AnyLeaveCanvas %W"
        
        bind all <ButtonPress-1> {
            set History(lastX) %x
            set History(lastY) %y
        }
        
        bind select <1> {Subdivision::SelectTree %W}
        bind zoom <B1-Motion> {Subdivision::Zoom %W %y}
        bind zoom <B3-Motion> {Subdivision::Zoom %W %y}
        bind move <B1-Motion> {Subdivision::Move %W %x %y}
        #bind .navigation.optionsFr.subtreeListbox <<ListboxSelect>> {Subdivision::SubtreeListBoxSelected %W}
        
        $c bind shwtree <Any-Enter> {Subdivision::DisplayInfo %W}
        $c bind shwtree <Any-Leave> {Subdivision::DisplayInfo %W true}
    }
    
    proc AnyEnterCanvas {w} {
        global S
        bindtags $w [list $S(tool) $w Canvas . all ]
        switch -exact -- $S(tool) {
            select {$w config -cursor arrow}
            move {$w config -cursor hand2}
            zoom {$w config -cursor sb_v_double_arrow}
        }
    }
    proc AnyLeaveCanvas {w} {
        bindtags $w {}
    }
    
    proc Move {w x y} {
        global History
        
        $w move all [expr $x - $History(lastX)] [expr $y - $History(lastY)]
        set History(lastX) $x
        set History(lastY) $y
    }
    proc Zoom {w y} {
        global History
        
        if {$y<$History(lastY) && $History(scale)<40} {
            $w scale all 1 1 1.1 1.1
            #incr History(scale)
        } elseif {$y>$History(lastY) && $History(scale)>0} {
            $w scale all 1 1 0.9 0.9
            #set History(scale) [expr $History(scale) - 1]
        }
        
        set History(lastY) $y
        
        $w configure -scrollregion [.navigation.motherTreeC bbox all]
    }
    
    proc SelectTree {w {selectedTag ""}} {
        global S
        global History
        
        if {$selectedTag == ""} {
            set tags [$w gettags current]
        } else {
            set tags $selectedTag
        }
        
        if {[lsearch -glob $tags shwtree] != -1} {
            set tag [string range [lindex $tags [lsearch -glob $tags sb-$S(subtreePrefix)*]] 3 end]
            $w itemconfigure sbr-$History(selectedTree) -fill red
            $w itemconfigure sbr-$tag -fill green
            set History(selectedTree) $tag
            
            set indexList [lsearch -exact $History(subtreeList) $tag]
            
            if {$indexList != "" && $tag != ""} {
                # .navigation.optionsFr.subtreeListbox selection clear 0 end
                # .navigation.optionsFr.subtreeListbox selection set $indexList $indexList
                # .navigation.optionsFr.subtreeListbox see $indexList
                
                .navigation.secondTreeC delete all
                MIimportNWKs .navigation.secondTreeC $S(BInode,$tag)
                
                set tempTree $S(BInode,$tag)
                
                set nbF [expr [regsub -all "," $tempTree "" q] +1]
                
                if {$nbF > 100} {
                    set progress [CreateProgressBar "Importing leaves..." $nbF]
                }
                
                #.navigation.optionsFr.subtreeLeaveListbox delete 0 end
                while {[regexp {(,|\()([^,:;\(\)\.-]+)} $tempTree match sub1 sub2]} {
                    if {$nbF > 100} {$progress.i step}
                    #.navigation.optionsFr.subtreeLeaveListbox insert end $sub2
                    regsub $sub2 $tempTree "" tempTree
                }
                
                set History(subtreeLeaveList) [lsort -dictionary $History(subtreeLeaveList)]
                
                if {$nbF > 100} {destroy $progress}
            }
        }
    }
    
    proc SubtreeListBoxSelected {w} {
        global S
        
        set S(tool) select
        Subdivision::AnyEnterCanvas .navigation.motherTreeC
        set currentSelection [$w curselection]
        
        if {$currentSelection != ""} {
            SelectTree .navigation.motherTreeC "shwtree sb-[$w get $currentSelection]"
        }
    }
    
    proc LeaveListBoxSelected {w} {
        global S
        
        set S(tool) select
        Subdivision::AnyEnterCanvas .navigation.motherTreeC
        set currentSelection [$w curselection]
        
        if {$currentSelection != ""} {
            #SelectTree .navigation.motherTreeC "shwtree sb-[$w get $currentSelection]"
        }
    }
    
    proc DisplayInfo {w {erase false}} {
        global S
        global History
        
        if {!$erase} {
            
            set tags [$w gettags current]
            
            if {[lsearch -glob $tags shwtree] != -1} {
                set tag [string range [lindex $tags [lsearch -glob $tags sb-$S(subtreePrefix)*]] 3 end]
                
                set tempTree $S(BInode,$tag)
                
                set nbsb [regsub -all "$S(subtreePrefix)\[0-9\]+" $tempTree "" tempTree]
                set nbF [regsub -all {(\(|,)[^,\(\):-]+} $tempTree "" tempTree]
                
                set History(sbInfo) "$tag subtree informations - Subtree number : $nbsb - Leave number : $nbF"
            }
        } else {
            set History(sbInfo) ""
        }
    }
    proc CreateSymbolicTree {} {
        global S
        global Symb
        
        catch {unset Symb}
        
        set Symb(symbolicTree) [CreateTreeBox $S(BImother)]
        
        while {[regexp "$S(subtreePrefix)(\[0-9\]+)" $Symb(symbolicTree) etiquette number]} {
            set tempTree [CreateTreeBox $S(BInode,$etiquette)]
            
            if {![regexp {^\(.*\)$} $tempTree]} {
                set tempTree [format "%s%s%s%s" "id-$number" ( $tempTree )]
            } else {
                set tempTree [format "%s%s" "id-$number" $tempTree]
            }
            
            regsub $etiquette $Symb(symbolicTree) $tempTree Symb(symbolicTree)
        }
        
        while {[regsub -all {\(\)} $Symb(symbolicTree) "" Symb(symbolicTree)] \
                    || [regsub -all {\(,\)} $Symb(symbolicTree) "" Symb(symbolicTree)] \
                    || [regsub -all {\(,} $Symb(symbolicTree) {(} Symb(symbolicTree)] \
                    || [regsub -all {,\)} $Symb(symbolicTree) {)} Symb(symbolicTree)]} {}
        
        #set Symb(symbolicTree) "(id-7(id-20(id-6(id-23((((id-33,id-32),id-31),id-30),(id-25,id-26(id-28)))),id-5)),id-4(id-1,id-3(id-2)))"
        #set Symb(symbolicTree) "(id-6(((id-2,id-4),id-3)id-8))"
        SymbolicTreeParser $Symb(symbolicTree)
    }
    
    proc CreateTreeBox {tree} {
        global S
        regsub -all {:-?[0-9\.]+} $tree "" tree
        while {[regsub -all {,((\(|\))*)[^(),-]+((\(|\))*),} $tree {,\1\3,} tree] != 0} {}
        regsub -all {^((\(|\))*)[^(),-]+((\(|\))*),} $tree {\1\3} tree
        regsub -all {,((\(|\))*)[^(),-]+((\(|\))*)(;?)$} $tree {\1\3\5} tree
        while {[regsub -all {\(\)} $tree "" tree]} {}
        regsub -all {\([^(),-]+\)} $tree "" tree
        while {[regsub -all "\\(($S(subtreePrefix)\[0-9\]+)\\)" $tree {\1} tree]} {}
        while {[regsub -all {\(\)} $tree "" tree]} {}
        regsub -all {,\)} $tree {)} tree
        regsub -all {\(,} $tree {(} tree
        regsub -all {;} $tree "" tree
        return $tree
    }
    proc DrawSymbolicTree {w code x y} {
        global S
        global Symb
        set unitLength 30
        set fontBase [list -family Arial  -weight normal -size [expr $unitLength / 4] -slant roman -underline 0 -overstrike 0]
        set coord1X [expr $x * $unitLength]
        set coord1Y [expr $y * $unitLength + ($unitLength / 2)]
        set coord2X [expr $coord1X + $unitLength]
        set coord2Y $coord1Y
        incr x
        if {$code != ""} {$w create line $coord1X $coord1Y $coord2X $coord2Y -tags ""}
        if {[info exists Symb($code)]} {
            incr x
            set coord1_X $coord2X
            set coord1_Y [expr $coord2Y - ($unitLength / 2)]
            set coord2_X [expr $coord1_X + $unitLength]
            set coord2_Y [expr $coord1_Y + $unitLength]
            $w create rect $coord1_X $coord1_Y $coord2_X $coord2_Y -fill red -tags "shwtree sbr-$Symb($code) sb-$Symb($code)" -activefill blue
            $w create text $coord1_X [expr $coord1_Y + ($unitLength / 2)] -text $Symb($code) -font $fontBase -anchor w \
                    -activefill white -tags "shwtree sbt-$Symb($code) sb-$Symb($code)"
            #.navigation.optionsFr.subtreeListbox insert end $Symb($code)
            set coord1X [expr $x * $unitLength]
            set coord2X [expr $coord1X + $unitLength]
            if {[info exists Symb([format "%s%s%s" $code "g" ,nbOfNode])] \
                        || [info exists Symb([format "%s%s" $code "g"])]} {
                incr x
                $w create line $coord1X $coord1Y $coord2X $coord2Y -tags ""
            }
        }
        set tempCode [format "%s%s" $code c]
        if {[info exists Symb($tempCode)]} {
            DrawSymbolicTree $w $tempCode $x $y
        } else {
            set tempCode1 [format "%s%s" $code g]
            set tempCode2 [format "%s%s" $code d]
            if {([info exists Symb($tempCode1)] && [info exists Symb($tempCode2)]) \
                        || [info exists Symb(${tempCode1},nbOfNode)] || [info exists Symb(${tempCode2},nbOfNode)]} {
                if {[info exists Symb(${tempCode1},nbOfNode)]} {
                    if {([lindex $Symb(${tempCode1},nbOfNode) 0] != 0) && ([lindex $Symb(${tempCode1},nbOfNode) 1] != 0)} {
                        set y1 [expr $y - [lindex $Symb(${tempCode1},nbOfNode) 1] * 2]
                    } else {set y1 [expr $y - 1]}
                } else {
                    set y1 [expr $y - 1]
                }
                if {[info exists Symb(${tempCode2},nbOfNode)]} {
                    if {([lindex $Symb(${tempCode2},nbOfNode) 0] != 0) && ([lindex $Symb(${tempCode2},nbOfNode) 1] != 0)} {
                        set y2 [expr $y + [lindex $Symb(${tempCode2},nbOfNode) 0] * 2]
                    } else {set y2 [expr $y + 1]}
                } else {
                    set y2 [expr $y + 1]
                }
                set coord1X [expr $x * $unitLength]
                set coord1Y [expr $y1 * $unitLength + ($unitLength / 2)]
                set coord2X $coord1X
                set coord2Y [expr $y2 * $unitLength + ($unitLength / 2)]
                $w create line $coord1X $coord1Y $coord2X $coord2Y -tags ""
                DrawSymbolicTree $w $tempCode1 $x $y1
                DrawSymbolicTree $w $tempCode2 $x $y2
            }
        }
    }
    proc ParenthensisCheck {s} {
        set i 0 ; set id 0 ;
        foreach c [split $s {}] {
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
            }
            if {$i == 0} {
                set r [string match *,* [string range $s [expr $id + 1] end]]
                break
            }
            incr id
        }
        return [expr ![string compare $id [expr [string length $s] - 1]]]
    }
    proc CreateProgressBar {title maxStep {x 0} {y 0}} {
        destroy .progress
        toplevel .progress
        wm withdraw .progress
        wm resizable .progress 0 0
        wm overrideredirect .progress 1
        label .progress.l  -text $title
        iwidgets::feedback .progress.i -steps $maxStep
        .progress.i reset
        set x [expr ([winfo screenwidth .progress] - [winfo reqwidth .progress]) /2]
        set y [expr ([winfo screenheight .progress] - [winfo reqheight .progress]) /2]
        wm geometry .progress "+$x+$y"
        pack .progress.l .progress.i -side top -fill both -expand yes
        wm deiconify .progress
        return .progress
    }
    proc SymbolicTreeParser {tree {code ""} {listReturn false}} {
        global S
        global Symb
        
        set nbOfNode {0 0}
        
        if {[regsub -all {,} $tree "" q] > 0} {
            
            set bg ""
            set bd ""
            set bc ""
            set id [Tools::BgBdx $tree]
            
            if {$id != ""} {
                set bg [string range $tree 1 [expr $id - 1]]
                set bd [string range $tree [expr $id + 1] end-1]
                set codeG [format "%s%s" $code g]
                set codeD [format "%s%s" $code d]
            } else {
                set bc [string range $tree 1 end-1]
                set codeC [format "%s%s" $code c]
            }
            
            set ok false
            
            while {!$ok} {
                
                set ok true
                
                if {($bg != "") && [ParenthensisCheck [string range $bg 1 end-1]] && [string index $bg end]==")" && [string index $bg 0]=="("} {
                    set ok false
                    set bg [string range $bg 1 end-1]
                }
                if {($bd != "") && [ParenthensisCheck [string range $bd 1 end-1]] && [string index $bd end]==")" && [string index $bd 0]=="("} {
                    set ok false
                    set bd [string range $bd 1 end-1]
                }
                if {($bc != "") && [ParenthensisCheck [string range $bc 1 end-1]] && [string index $bc end]==")" && [string index $bc 0]=="("} {
                    set ok false
                    set bc [string range $bc 1 end-1]
                }
            }
            
            if {[regexp {^id-([0-9]+)\(} $bg match number]} {
                set Symb($codeG) "$S(subtreePrefix)$number"
                regsub {^id-[0-9]+\(} $bg "(" bg
                lset nbOfNode 0 [SymbolicTreeParser $bg $codeG]
            } elseif {[regexp {^id-([0-9]+)$} $bg match number]} {
                set Symb($codeG) "$S(subtreePrefix)$number"
                lset nbOfNode 0 1
            } elseif {$bg != ""} {
                lset nbOfNode 0 [SymbolicTreeParser $bg $codeG]
            }
            
            if {[regexp {^id-([0-9]+)\(} $bd match number]} {
                set Symb($codeD) "$S(subtreePrefix)$number"
                regsub {^id-[0-9]+\(} $bd "(" bd
                lset nbOfNode 1 [SymbolicTreeParser $bd $codeD]
            } else {
                if {[regexp {^id-([0-9]+)$} $bd match number]} {
                    set Symb($codeD) "$S(subtreePrefix)$number"
                    lset nbOfNode 1 1
                } else {
                    if {$bd != ""} {
                        lset nbOfNode 1 [SymbolicTreeParser $bd $codeD]
                    }
                }
            }
            
            if {[regexp {^id-([0-9]+)\(} $bc match number]} {
                set Symb($codeC) "$S(subtreePrefix)$number"
                regsub {^id-[0-9]+\(} $bc "(" bc
                set nbOfNode [SymbolicTreeParser $bc $codeC true]
            } else {
                if {[regexp {^id-([0-9]+)$} $bc match number]} {
                    set Symb($codeC) "$S(subtreePrefix)$number"
                    set nbOfNode {0 0}
                }
            }
            
        } else {
            
            if {$tree != ""} {
                set codeC [format "%s%s" $code "c"]
                regsub {^\((.*)\)$} $tree {\1} tree
                
                if {[regexp {^id-([0-9]+)\(} $tree match number]} {
                    set Symb($codeC) "$S(subtreePrefix)$number"
                    regsub {^id-[0-9]+\(} $tree "(" tree
                    set nbOfNode [SymbolicTreeParser $tree $codeC true]
                } else {
                    if {[regexp {([0-9]+)} $tree number]} {
                        set tree ""
                        set Symb($codeC) "$S(subtreePrefix)$number"
                        set nbOfNode {0 0}
                    }
                }
                
            } else {set nbOfNode {0 0}}
        }
        
        set Symb($code,nbOfNode) $nbOfNode
        
        if {$listReturn} {
            return $nbOfNode
        } else {
            set tot [expr [lindex $nbOfNode 0] +  [lindex $nbOfNode 1]]
            if {$tot == 0} {set tot 1}
            
            return $tot
        }
    }
    
    proc Init {} {
        global S
        global History
        global Symb
        global Temp
        
        catch {
            unset S
            unset History
            unset Symb
        }
        
        catch {
            set S(pathname) $Temp(pathname)
            set S(leavesNb) $Temp(leavesNb)
            set S(BIseuil) $Temp(BIseuil)
            set S(BImother) $Temp(BImother)
            set S(BImotherFinal) $Temp(BImotherFinal)
            
            unset Temp(pathname)
            unset Temp(leavesNb)
            unset Temp(BIseuil)
            unset Temp(BImother)
            unset Temp(BImotherFinal)
        }
        
        set S(newW) 800
        set S(newH) 600
        set S(Preference_display_eu) 1
        set S(Preference_fgc) black
        set S(fontbase) [list -family Arial  -weight normal -size 7 -slant roman -underline 0 -overstrike 0]
        
        set S(-family) Arial
        set S(-weight) normal
        set S(-size)  7
        set S(-slant)  roman
        set S(-underline)  0
        set S(-overstrike) 0
        set S(gfo) [list -family $S(-family) \
                -weight $S(-weight) \
                -size $S(-size) \
                -slant $S(-slant) \
                -underline $S(-underline) \
                -overstrike $S(-overstrike)]
        set S(col) black
        set S(etiquetteFont) {-family Arial -weight bold -slant italic -size 10}
        #ne doit pas Ãªtre le mot "id-" et doit Ãªtre de pattern ^[0-9a-zA-Z]+-$
        set S(subtreePrefix) "sb-"
        set S(optionsWidth) 200
        set S(margeCanvas) 100
        
        set S(ilt) 0
        set S(nbobj) 0
        set S(MultiImportTDY) 0
        set S(display_eu) normal
        
        set S(tool) select
        
        set History(scale) 20
        set History(lastY) 0
        set History(lastX) 0
        set History(selectedTree) 0
        set History(subtreeSearch) ""
        set History(leaveSearch) ""
        set History(subtreeLeaveSearch) ""
        set History(sbInfo) ""
        set History(subtreeList) ""
        set History(leaveList) ""
        set History(subtreeLeaveList) ""
    }
    
    proc NewickToTreeDyn {s} {
        global Export
        set code xxx ; set n 0
        set Export(xmax) 0
        set Export(tot) 0
        set Export(all_cod) $code
        set Export(ue_lab) {}
        set Export(ue_cod) {}
        set Export(Duplication) {}
        #liste de tous les codes nodes
        # TEST presence de longueur de branches
        if {[string match *:* $s] == 0} {
            regsub -all "," $s {:1.0,} s
            regsub -all {\)} $s {:1.0)} s
        }
        set Export(dbl,$code) 0 ;# longeur de branche du code node
        set Export(nwk,$code) $s ;# chaine newick du code node
        ######
        if {[Dicho $s] == 1} {
            set s [format "%s%s%s" ( $s ):0]
        }
        ######
        set tp [string last ")" $s]
        set dt [string range $s 0 $tp]
        #set dx [string range $s [expr $tp + 1] end]
        ######
        if {[string compare [string range $dt 0 0] ( ] != 0 || \
                    [string compare [string range $dt end end] ) ] != 0} {
            set dt [format "%s%s%s" ( $dt )]
        }
        ######
        set id [BgBdx $dt]
        set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
        set bd [string range $dt 1 [expr $id - 1]]
        lappend Export(cbg,$n) 0 ;#la liste des codes nodes de level $n
        incr n
        NewickParser $bg [format "%s%s" $code g] $n 0
        NewickParser $bd [format "%s%s" $code d] $n 0
        return
    }
    
    proc MIimportNWKs {w s} {
        global S Export T
        # nettoyage
        #original
        regsub -all "\n| " $s "" s
        #regsub -all "\n" $s "" s PAS SI SIMPLE
        regsub -all {\[} $s "" s
        #regsub -all {:-} $s ":" s
        regsub -all {:-[0-9]*.[0-9]+|:-[0-9]+} $s ":0.0" s
        regsub -all {\]} $s "" s
        # update progress bar
        
        # splitting sur ; si un fichier contient plusieurs chaines newick
        set l [split $s ";"]
        set id 0
        foreach s [lrange $l 0 end-1] {
            # update progress bar
            # parsing
            if {[catch [NewickToTreeDyn $s] err] != 0} {
                puts "Error"
            } else {
                incr id
                #update progress bar
                set max 0
                foreach c [split $s {}] {
                    if {[string equal $c ","]} {incr max}
                }
                # Export vers T
                set lkv [array get Export]
                foreach {key value} $lkv {
                    set T(xxx,$key) $value
                }
                unset Export
                # graphic
                set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
                lappend S(ilt) $t
                lappend S($w,t) $t
                set S($t,w) $w
                TreeInit $t
                set S($t,tit) PROTO
                xxxEncode $t
                set S(newH) [expr 10.0 * [llength $T($t,ue_cod)] ]
                PhyNJ $t $w [expr [winfo screenwidth .] - $S(optionsWidth) - $S(margeCanvas)] $S(newH)
                #NodeBind $w $t
                Operation::TreeViewerPanelUpdate
            }
        }
    }
    
    proc TreeInit {t} {
        global T S B
        set S($t,orient) W
        set S($t,a_ori) 0 ;# angle aditionel utilise dans les rotations
        set S($t,a_uni) 0 ;# unite d'angle
        set S($t,tit) "" ;# le pathcut2 du fichier tdy
        set S($t,type) PhyNJ    ;# le type de tree par defaut
        set S($t,init) 0 ;# cette variable fixe le mode inclusif/exclusif du panel identification
        set S($t,display_eu) $S(display_eu)
        set S($t,LabelMatrixBase) 5 ;# matrice d'annotation
        set T($t,eu_collapse) {} ;# liste des noms de feuilles a retirer en abstraction
        set T($t,xmax) 0        ;# branch length max
        set T($t,tot) 0         ;# level max
        set T($t,all_cod) {}    ;# codes nodes
        set T($t,ue_cod) {}     ;# UE - codes LISTE ORDONNEE
        set T($t,ue_lab) {}     ;# UE - labels LISTE ORDONNEE
        set B($t,shi) {}        ;# List des nodes shrink
        set B($t,qyn) {}        ;# list des items querynode
        set B($t,ova) {}        ;# la liste des node reliant 1 tree (decomposition)
        set B($t,bll) {}        ;# la liste des nodes ayant des BLL (bulles labels link : eu;db,users)
        set B($t,bgs) {}        ;# la liste des items background nodes
        set B($t,bgl) {}        ;# la liste des items background leaves
        set B($t,con) {}        ;# la liste des reseaux de connection
    }
    proc xxxEncode {t} {
        global T
        set uold xxx
        set unew $t
        set kvT [array get T xxx*]
        foreach {key value} $kvT {
            regsub  -all xxx $value $t valueswi
            unset T($key) ; regsub  -all xxx $key $t keyswi ; set T($keyswi) $valueswi
        }
    }
    
    proc Dicho {s} {
        set i 0 ; set id 0 ; set r 1
        foreach c [split $s {}] {
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
            }
            if {$i == 0} {
                set r [string match *,* [string range $s [expr $id + 1] end]]
                break
            }
            incr id
        }
        return $r
    }
    proc NewickParser {s code n sx} {
        global Export
        
        lappend Export(all_cod) $code ;# liste de tous les codes nodes
        set Export(nwk,$code) $s ;# chaine newick du code node
        if {[string match *,* $s]} {
            ######
            if {[Dicho $s] == 1} {
                set s [format "%s%s%s" ( $s ):0]
            }
            ######
            set tp [string last ")" $s]
            set dt [string range $s 0 $tp]
            set dx [string range $s [expr $tp + 1] end]
            set Export(dbl,$code) [expr abs([string range $dx [expr [string last ":" $dx] + 1] end])] ;# longeur de branche du code node
            set Export(dbv,$code) [string range $dx 0 [expr [string last ":" $dx] - 1]] ; #bootstrap value
            ######
            if {[string compare [string range $dt 0 0] ( ] != 0 || \
                        [string compare [string range $dt end end] ) ] != 0} {
                set dt [format "%s%s%s" ( $dt )]
            }
            ######
            set id [BgBdx $dt]
            set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
            set bd [string range $dt 1 [expr $id - 1]]
            lappend Export(cbg,$n) [format "%s%s" $code $n] ;#la liste des codes nodes de level $n
            NewickParser $bg [format "%s%s%s" $code $n g] [expr $n +1] [expr $sx + $Export(dbl,$code)]
            NewickParser $bd [format "%s%s%s" $code $n d] [expr $n +1] [expr $sx + $Export(dbl,$code)]
        } {
            set tp [string last ":" $s]
            set dt [string range $s 0 [expr $tp - 1]]
            set dx [string range $s [expr $tp + 1] end]
            set Export(dbl,$code) [expr abs([string range $dx [expr [string last ":" $dx] + 1] end])]
            # liste des labels leaf
            if {[lsearch $Export(ue_lab) $dt] == -1}  {
                lappend Export(ue_lab) $dt
                set Export(ctl,$code) $dt ;# code to leaf
                set Export(ltc,$dt) $code ;# leaf to code
            } else {
                set newdt [format "%s%s%s" $dt - [GenId]]
                lappend Export(Duplication) "$dt swtich to $newdt"
                lappend Export(ue_lab) $newdt
                set Export(ctl,$code) $newdt ;# code to leaf
                set Export(ltc,$newdt) $code ;# leaf to code
            }
            lappend Export(ue_cod) $code ;# liste de codes leaf
            set sx [expr $sx + $dx]
            set Export(sox,$code) $sx
            if {$sx >= $Export(xmax)} {set Export(xmax) $sx}
            if {$n >= $Export(tot)} {set Export(tot) $n}
            return
        }
    }
    
    proc BgBdx {s} {
        set i -1
        set id -1
        foreach c [split $s {}] {
            incr id
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
                , {if {$i == 0} {return $id}}
            }
        }
        return ""
    }
    
    proc GenId {} {
        global S
        incr S(nbobj)
        return [format "%s%s" $S(subtreePrefix) $S(nbobj)]
    }
    
    proc BInewickParserRec {s n} {
        global S
        global progress
        
        $progress.i step
        
        if {[Dicho $s] == 1} {
            set s [format "%s%s%s" ( $s ):0.0]
        }
        set tp [string last ")" $s]
        set dt [string range $s 0 $tp]
        if {[string compare [string range $dt 0 0] ( ] != 0 || \
                    [string compare [string range $dt end end] ) ] != 0} {
            set dt [format "%s%s%s" ( $dt )]
        }
        set id [BgBdx $dt]
        set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
        set bd [string range $dt 1 [expr $id - 1]]
        
        set nbFbg [expr [regsub -all "," $bg "" q] +1]
        set nbFbd [expr [regsub -all "," $bd "" q] +1]
        
        if {$nbFbg == 0} {set nbFbg 1}
        if {$nbFbd == 0} {set nbFbd 1}
        if {$nbFbg <= $S(BIseuil) && $nbFbg > 1} {
            
            set id [GenId]
            lappend S(BInode) [format "%s%s" $bg ";"]
            set S(BInode,$id) [format "%s%s" $bg ";"]
            set indexDebut [string first $bg $S(BImother)]
            set indexFin [expr $indexDebut + [string length $bg ] -1]
            
            set S(BImother) [string replace $S(BImother) $indexDebut $indexFin [format "%s%s" $id :1.0]]
            
            return
        } elseif {$nbFbd <= $S(BIseuil) && $nbFbd > 1 } {
            
            set id [GenId]
            lappend S(BInode) [format "%s%s" $bd ";"]
            set S(BInode,$id) [format "%s%s" $bd ";"]
            set indexDebut [string first $bd $S(BImother)]
            set indexFin [expr $indexDebut + [string length $bd] -1]
            
            set S(BImother) [string replace $S(BImother) $indexDebut $indexFin [format "%s%s" $id :1.0]]
            
            return
        } elseif {$nbFbg > $S(BIseuil)} {
            BInewickParserRec $bg [expr $n +1]
        } elseif {$nbFbd > $S(BIseuil)} {
            BInewickParserRec $bd [expr $n +1]
        }
    }
    
    
    proc PhyNJ {t w  {largeur 200} {hauteur 200}} {
        global T S
        set y 0
        set nb [llength $T($t,ue_cod)]
        set fy [expr double($hauteur)  / $nb ]
        set fx [expr double($largeur) / $T($t,xmax)]
        set n 0
        set t3 [format "%s%s" T $t ]
        ### EU
        foreach i $T($t,ue_cod) {
            incr n
            
            set y [expr $n * $fy ]
            set G($i,x) [expr ($T($t,sox,$i) - $T($t,dbl,$i) )* $fx]
            set G($i,y) $y
            set t2 [format "%s%s" EU $T($t,ctl,$i) ]
            set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
            set t2bis [format "%s%s" $i C]
            $w create line [expr $T($t,sox,$i) * $fx] $G($i,y) $G($i,x) $G($i,y)  \
                    -tags "$i $t2 $t3 $t2bis Z" -fill $S(Preference_fgc)
            $w create text [expr ($T($t,sox,$i) * $fx) + 2]  $G($i,y) \
                    -text  $T($t,ctl,$i) -anchor w   \
                    -tags " $t3 $t4 L" \
                    -font $S(fontbase) -state $S($t,display_eu)
        }
        ### NODES
        for {set i [expr $T($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            foreach b $T($t,cbg,$i) {
                set bg [format "%s%s" $b g]
                set bd [format "%s%s" $b d]
                #************************************************************* PB SWAP
                set yn [expr $G($bg,y) - (($G($bg,y) - $G($bd,y)) / 2)]
                #*************************************************************
                set j [string range $bg 0 [expr [string last $i $bg] - 1]]
                set t2 [format "%s%s" $j C]
                # Vertical
                $w create line $G($bg,x) $G($bg,y) $G($bg,x) $G($bd,y) -tags "$t2 $t3 Z" -fill $S(Preference_fgc)
                # Horizontal
                set G($j,x) [expr $G($bg,x) - ($T($t,dbl,$j) * $fx)]
                $w create line $G($bg,x) $yn $G($j,x) $yn  -tags "$j $t2 $t3 Z" -fill $S(Preference_fgc)
                set G($j,y) $yn
            }
        }
        ### ROOT
        set ch [$w coords [format "%s%s" $t g]]
        set cb [$w coords [format "%s%s" $t d]]
        set yh [lrange $ch 1 1]
        set yb [lrange $cb 3 3]
        set x [lrange $ch 2 2]
        set yn [expr $yh - (($yh - $yb) / 2)]
        # Vertical
        $w create line $x $yh $x $yb -tags "[format "%s%s" $t C] $t3 Z" -fill $S(Preference_fgc)
        # scrollregion
        $w configure -scrollregion [$w bbox all]
        # modif 4 mars 2003, avant pas unset G cela cachait un bug
        
        unset G
    }
    ### DEBUT ancien espace proto (matrice d'arbres)
    # ouverture d'une structure obtenue apres importation par user
    # A VOIR
    proc BIopenUser {} {
        global S
        set file [tk_getOpenFile -initialdir $S(userDIR)  -title "Open Newick File"]
        if {$file != ""} {set S(userDIR) [file dirname $file]}
        if [catch {open $file r} fid] {
            puts stderr "Incorrect File Format"
        } else {
            set S(BIfile) $file
            set S(BIrow) 1
            set S(BIcol) 1
        }
    }
    # ouverture d'une structure obtenue apres importation automatique
    # A VOIR
    proc BIopenTreeDyn {} {
    }
    # procedure d'importation des grosses chaines newick
    proc BIimport {} {
        global S
        set file $S(BIfile)
        if [catch {open $file r} fid] {
            puts stderr "Incorrect File Format"
        } else {
            set S(BInode) {}
            set s [read -nonewline $fid]
            close $fid
            regsub -all "\n| " $s "" s
            regsub -all {\[} $s "" s
            #regsub -all {:-} $s ":" s
            regsub -all {:-[0-9]*.[0-9]+|:-[0-9]+} $s ":0.0" s
            regsub -all {\]} $s "" s
            set S(BImother) $s
            regsub -all ";" $S(BImother) "" S(BImother)
            set nbF [expr [regsub -all "," $S(BImother) "" q] +1]
            set S(BItotalL) "Number of Leaves: $nbF"
            while {$nbF > $S(BIseuil)} {
                BInewickParserRec $S(BImother) 0
                set nbF [expr [regsub -all "," $S(BImother) "" q] +1]
            }
            #
            set id [Tools::GenId]
            lappend S(BInode) [format "%s%s" $S(BImother) ";"]
            set S(BInode,$id) [format "%s%s" $S(BImother) ";"]
            set S(BItotalN)  "Number of Sub-Tree: [llength $S(BInode)]"
            # mise a jour des spin row col
            .sb.n.canvas.notebook.cs.page1.cs.in.childsite.ro \
                    configure -range [list 1 [llength $S(BInode)]]
            .sb.n.canvas.notebook.cs.page1.cs.in.childsite.co \
                    configure -range [list 1 [llength $S(BInode)]]
            set S(BIrow) [llength $S(BInode)]
        }
    }
    proc BIswitchRowtoCol {} {
        global S
        set S(BIrow) [expr round(0.5 + double([llength $S(BInode)]) / $S(BIcol))]
        .sb.n.canvas.notebook.cs.page1.cs.in.childsite.ro \
                configure -range [list 1 [llength $S(BInode)]]
        .sb.n.canvas.notebook.cs.page1.cs.in.childsite.co \
                configure -range [list 1 [llength $S(BInode)]]
    }
    proc BIswitchRowtoCol+ {} {
        global S
        if {$S(BIcol) < [llength $S(BInode)]} {incr S(BIcol) +1}
        BIswitchRowtoCol
    }
    proc BIswitchRowtoCol- {} {
        global S
        if {$S(BIcol) != 1} {incr S(BIcol) -1}
        BIswitchRowtoCol
    }
    proc BIswitchColtoRow {} {
        global S
        set S(BIcol) [expr round(0.5 + double([llength $S(BInode)]) / $S(BIrow))]
        .sb.n.canvas.notebook.cs.page1.cs.in.childsite.ro \
                configure -range [list 1 [llength $S(BInode)]]
        .sb.n.canvas.notebook.cs.page1.cs.in.childsite.co \
                configure -range [list 1 [llength $S(BInode)]]
    }
    proc BIswitchColtoRow+ {} {
        global S
        if {$S(BIrow) < [llength $S(BInode)]} {incr S(BIrow) +1}
        BIswitchColtoRow
    }
    proc BIswitchColtoRow- {} {
        global S
        if {$S(BIrow) != 1} {incr S(BIrow) -1}
        BIswitchColtoRow
    }
    ### ce parser recherche en decomposant de facon recurssive
    ### bras gauche/ bras droit le premier node ayant un nombre de feuille
    ### egal ou inferieur au seuil utilisateur. Des que le node
    ### est trouve il est memorise et remplacer par une "feuille"
    ### au sein de la chaine newick mere formant une nouvelle chaine newixk mere.
    ### La recurssion s'arrete et est relancee sur cette nouvelle
    ### chaine mere
    proc BInewickParserRec {s n} {
        global S
        global progress
        if {[ImportExport::Dicho $s] == 1} {
            set s [format "%s%s%s" ( $s ):0.0]
        }
        set tp [string last ")" $s]
        set dt [string range $s 0 $tp]
        if {[string compare [string range $dt 0 0] ( ] != 0 || \
                    [string compare [string range $dt end end] ) ] != 0} {
            set dt [format "%s%s%s" ( $dt )]
        }
        set id [Tools::BgBdx $dt]
        set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
        set bd [string range $dt 1 [expr $id - 1]]
        set nbFbg [expr [regsub -all "," $bg "" q] +1]
        set nbFbd [expr [regsub -all "," $bd "" q] +1]
        if {$nbFbg == 0} {set nbFbg 1}
        if {$nbFbd == 0} {set nbFbd 1}
        if {$nbFbg <= $S(BIseuil) && $nbFbg > 1} {
            set id [Tools::GenId]
            lappend S(BInode) [format "%s%s" $bg ";"]
            set S(BInode,$id) [format "%s%s" $bg ";"]
            set indexDebut [string first $bg $S(BImother)]
            set indexFin [expr $indexDebut + [string length $bg ] -1]
            set S(BImother) [string replace $S(BImother) $indexDebut $indexFin [format "%s%s" $id :1.0]]
            return
        } elseif {$nbFbd <= $S(BIseuil) && $nbFbd > 1 } {
            set id [Tools::GenId]
            lappend S(BInode) [format "%s%s" $bd ";"]
            set S(BInode,$id) [format "%s%s" $bd ";"]
            set indexDebut [string first $bd $S(BImother)]
            set indexFin [expr $indexDebut + [string length $bd] -1]
            set S(BImother) [string replace $S(BImother) $indexDebut $indexFin [format "%s%s" $id :1.0]]
            return
        } elseif {$nbFbg > $S(BIseuil)} {
            BInewickParserRec $bg [expr $n +1]
        } elseif {$nbFbd > $S(BIseuil)} {
            BInewickParserRec $bd [expr $n +1]
        }
    }
    proc BInewickParserRecORI {s n} {
        global S
        if {[ImportExport::Dicho $s] == 1} {
            set s [format "%s%s%s" ( $s ):0.0]
        }
        set tp [string last ")" $s]
        set dt [string range $s 0 $tp]
        if {[string compare [string range $dt 0 0] ( ] != 0 || \
                    [string compare [string range $dt end end] ) ] != 0} {
            set dt [format "%s%s%s" ( $dt )]
        }
        set id [Tools::BgBdx $dt]
        set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
        set bd [string range $dt 1 [expr $id - 1]]
        set nbFbg [expr [regsub -all "," $bg "" q] +1]
        set nbFbd [expr [regsub -all "," $bd "" q] +1]
        # regsub renvoie -1 si feuille
        if {$nbFbg == 0} {set nbFbg 1}
        if {$nbFbd == 0} {set nbFbd 1}
        if {$nbFbg <= $S(BIseuil) && $nbFbg > 1} {
            set id [Tools::GenId]
            lappend S(BInode) [format "%s%s" $bg ";"]
            set S(BInode,$id) [format "%s%s" $bg ";"]
            set indexDebut [string first $bg $S(BImother)]
            set indexFin [expr $indexDebut + [string length $bg ] -1]
            set S(BImother) [string replace $S(BImother) $indexDebut $indexFin [format "%s%s" $id :1.0]]
            return
        } elseif {$nbFbd <= $S(BIseuil) && $nbFbd > 1 } {
            set id [Tools::GenId]
            lappend S(BInode) [format "%s%s" $bd ";"]
            set S(BInode,$id) [format "%s%s" $bd ";"]
            set indexDebut [string first $bd $S(BImother)]
            set indexFin [expr $indexDebut + [string length $bd] -1]
            set S(BImother) [string replace $S(BImother) $indexDebut $indexFin [format "%s%s" $id :1.0]]
            return
        } elseif {$nbFbg > $S(BIseuil)} {
            # ici un biais... voir parametrage user
            BInewickParserRec $bg [expr $n +1]
        } elseif {$nbFbd > $S(BIseuil)} {
            BInewickParserRec $bd [expr $n +1]
        }
    }
    ### Graphique
    proc BImatrixCanvas {} {
        global S
        # r = nb de lignes de canvas fenetre contenante
        set r $S(BIrow)
        # c = nb de colonnes de canvas fenetre contenante
        set c $S(BIcol)
        # px espace x entre chaque canvas + marges
        set px 20
        # py espace y entre chaque canvas + marges
        set py 20
        # h = hauteur fenetre contenante
        set h 500
        # w = largeur fenetre contenante
        set w 500
        # ch = hauteur chaque canvas
        set ch [expr ($h - ($py * ($r + 1))) / $r]
        # cw = largeur chaque canvas
        set cw [expr ($h - ($py * ($r + 1))) / $r]
        set geo [format "%s%s%s%s"  $w x $h +250+150]
        destroy .proto
        toplevel .proto
        wm geometry .proto $geo
        ImportExport::MIMakeProgressBarGen 100
        set l {}
        foreach {key value} [array get S BInode,*] {
            set name [string range $key 6 end]
            lappend l [list $name $value]
        }
        for  {set row 0} {$row < $r} {incr row} {
            for  {set col 0} {$col < $c} {incr col} {
                set w [frame .proto.c$row$col -bg grey -relief groove]
                set ca [BInewCanvas $w $cw $ch]
                grid $w -row $row -column $col -sticky news -padx 1 -pady 1
                grid rowconfigure .proto $row -weight 1
                grid columnconfigure .proto $col -weight 1
                set couple [lindex $l [expr ($row *$c) + $col]]
                ImportExport::MIimportNWKs $ca [lindex $couple 1]
                $ca create text 10 10 -text [lindex $couple 0] -font $S(gfo) -fill $S(col) -tags TXT
            }
        }
        destroy .progress
    }
    ###
    proc BInewCanvas { w {largeur 800} {hauteur 600} } {
        global S
        set S(Z) [set S(Y) [set S(X) [set S(SF) [expr 400/2.]]]]
        set S(ZU) 10
        set S(ZFO,0) [expr 1+.002*$S(ZU)]
        set S(ZFO,1) [expr 1+.01*$S(ZU)]
        set S(ZF) $S(ZFO,0)
        set c $w.c
        set S($c,t) {}
        set S($c,con) {} ;# la liste des ID des connectors de la fenetre
        set S($c,com) {} ;# la liste des ID des comments de la fenetre
        set S(sav,$c) ""
        scrollbar $w.xsbar -orient horizontal -command "$w.c xview" -bg grey -width 5
        scrollbar $w.ysbar -orient vertical -command "$w.c yview"  -bg grey -width 5
        canvas $w.c -width $largeur -height $hauteur  -relief groove  \
                -xscrollcommand "$w.xsbar set" -yscrollcommand "$w.ysbar set"\
                -highlightthickness 0
        grid $w.c -row 0 -column 0 -sticky news
        grid $w.xsbar -row 1 -column 0 -sticky ew
        grid $w.ysbar -row 0 -column 1 -sticky ns
        grid rowconfigure $w 0  -weight 1
        grid columnconfigure $w 0 -weight 1
        ImportExport::CanvasBind $c
        return $c
    }
    proc NodeExtract {tsource nodes} {
        global S T
        set w [ImportExport::NewWindowName]
        toplevel $w
        wm title $w "TreeDyn Extraction query"
        set c [BInewCanvas $w 600 400]
        foreach node $nodes {
            set f [Tools::NodeNoToLeNum $tsource $node]
            if { $f >= 2} {
                set t [expr [lrange [lsort -integer -increasing $S(ilt)] end end] + 1]
                lappend S(ilt) $t
                set T($t,nwk) $T($tsource,nwk,$node)
                ImportExport::TreeInit $t
                ImportExport::NewickParser_Root $t $T($t,nwk)
                # modif dec 2004 la copy garde le xmax de la structure de rattachement
                set T($t,xmax) $T($tsource,xmax)
                set S($t,w) $c
                set S($t,tit) [format "%s%s" # $S($tsource,tit)]
                set S($t,type) $S($tsource,type)
                set S($t,tar) 0
                lappend S($c,t) $t
                Conformation::ArrToCanType2 $t $c
                ImportExport::NodeBind $c $t
                Operation::TreeViewerPanelUpdate
            }
        }
        set S($c,BIcol) 1
        set S($c,BIrow) [llength $S($c,t)]
        Navigation::Reorganize $c
    }
    ### FIN  ancien espace proto (matrice d'arbres)
    
}
################################################################################

################################################################################
# TreeMat
################################################################################
namespace eval TreeMat {
    
    
    proc TreeMatpanel {} {
        global S
        if {[winfo exists .leaf] == 1} {
            wm deiconify .leaf
        } else  {
            set w [toplevel .leaf]
            wm title $w "TreePAT"
            #wm geometry .leaf 650x600
            wm protocol .leaf WM_DELETE_WINDOW {TreeMat::PanelQuit}
            
            ### CONTROLS
            set w1 [frame .leaf.c]
            menubutton $w1.target -text "Tree" -menu $w1.target.m -indicatoron 1 -direction below
            set z  [menu  $w1.target.m -tearoff 0]
            $z configure -postcommand "TreeMat::TreeTarget $z"
            button $w1.e -text "Exit" -command  "destroy .leaf"
            pack $w1.target $w1.e -side left -expand no
            
            ### PANEL CLASSES
            set w2 [frame .leaf.pc]
            set S(IGmode) user
            set S(IGtabul) 50
            set S(IGcurve) 150
            set S(IGline) 1
            set S(IGannot) 0
            set S(IGcolorAuto) black
            set S(IGtabulAuto) 5
            set S(IGcurveAuto)  2
            set S(IGlineAuto) 1
            set S(IGcolorAutocheck) 1
            set S(IGtabulAutocheck) 0
            set S(IGcurveAutocheck)  1
            set S(IGlineAutocheck) 0
            set S(ClassMethod) ?
            PanelDeffClass $w2
            pack $w2.dc
            
            #### CANVAS controls
            set w3 [frame .leaf.cac]
            button $w3.mini -text Display -command "TreeMat::MiniMatrix"
            set S(LLmatrixW) 3 ; set S(LLmatrixH) 3
            iwidgets::entryfield $w3.wi -width 5 -labeltext Width -textvariable S(LLmatrixW)  \
                    -labelpos w -validate integer  -fixed 30
            iwidgets::entryfield $w3.he -width 5 -labeltext Height -textvariable S(LLmatrixH)  \
                    -labelpos w -validate integer  -fixed 30
            #iwidgets::Labeledframe $w3.tools -labelpos ne -labeltext "Toolbox"
            #set pt [$w3.tools childsite]
            #pack $pt -expand 1 -fill both
            set pt [frame  $w3.tools]
            foreach {tool color} {treepatfromt ivory2 } {
                radiobutton $pt.$tool -value $tool  -image TIM$tool \
                        -overrelief sunken -offrelief raised -selectcolor LightGoldenrodYellow \
                        -variable S(tool)  -indicatoron off -highlightthickness 0\
                        -background  $color -borderwidth 2
                pack $pt.$tool -side left
                bind $pt.$tool <Any-Enter> "Toolbox::balloonhelp_show $tool"
                bind $pt.$tool <Any-Leave> "Toolbox::balloonhelpCurrent"
            }
            button $w3.ps -text PostScript -command "TreeMat::exportPS"
            # menu operation
            set wop [frame $w3.wop]
            menubutton $wop.loca  -text "Operation: " -menu $wop.loca.m  -relief groove -indicatoron 1
            set mc [menu  $wop.loca.m -tearoff 0]
            $mc add radio -label "Leaf Foreground Color" -variable S(operation) \
                    -value leaffgcolor -command {set S(operationName) "Leaf Foreground Color"}
            $mc add radio -label "Leaf Background Color" -variable S(operation) \
                    -value leafbgcolor -command {set S(operationName) "Leaf Background Color"}
            $mc add separator
            $mc add radio -label "Node Foreground Color" -variable S(operation) \
                    -value nodefgcolor -command {set S(operationName) "Node Foreground Color"}
            $mc add radio -label "Node Background Color" -variable S(operation) \
                    -value nodebgcolor -command {set S(operationName) "Node Background Color"}
            set wop2 [frame $w3.wop2]
            menubutton $wop2.reset -text "Reset" -menu $wop2.reset.m  -indicatoron 1 -relief groove
            set mc [menu  $wop2.reset.m -tearoff 0 ]
            $mc add check -label "Automatic Reset" -variable S(AutoReset)
            $mc add separator
            $mc add command -label  "Reset" -command {Operation::ResetGraphicVariables}
            $mc add separator
            $mc add command -label  "Graphical Variables to Reset:" -command ""
            $mc add check -label  "Leaf Foreground Color" -variable S(OpResetLFgC)
            $mc add check -label  "Leaf Background Color" -variable S(OpResetLBgC)
            $mc add check -label  "Node Foreground Color" -variable S(OpResetNFgC)
            $mc add check -label  "Node Background Color" -variable S(OpResetNBgC)
            $mc add command -label  "Select All" -command "Operation::ResetAllFig+"
            $mc add command -label  "UnSelect All" -command "Operation::ResetAllFig-"
            pack $wop2.reset
            
            #message $wop.msg -width 200 -textvariable S(operationName)
            #pack $wop.loca $wop.msg -side left -expand yes -fill x
            pack $wop.loca  -side left -expand yes -fill x
            
            #  info case ij
            set w5 [frame .leaf.msg]
            message $w5.msg  -textvariable S(LLmsg) -width 300  -borderwidth 1 -foreground blue -anchor w
            pack $w5.msg -expand 1 -fill x
            
            #pack
            pack $w3.wi $w3.he  $w3.mini $w3.tools $w3.wop $w3.wop2 $w3.ps -side left -expand 0
            
            
            ### matrice
            set w4 [frame .leaf.mc]
            set canvasw 500.0
            set canvash 500.0
            scrollbar $w4.xsbar -orient horizontal -command "$w4.c xview" -bg grey -width 5
            scrollbar $w4.ysbar -orient vertical -command "$w4.c yview"  -bg grey -width 5
            canvas $w4.c -width $canvasw -height $canvash  -relief groove  \
                    -xscrollcommand "$w4.xsbar set" -yscrollcommand "$w4.ysbar set"\
                    -highlightthickness 0
            grid $w4.c -row 0 -column 0 -sticky news
            grid $w4.xsbar -row 1 -column 0 -sticky ew
            grid $w4.ysbar -row 0 -column 1 -sticky ns
            grid rowconfigure $w4 0  -weight 1
            grid columnconfigure $w4 0 -weight 1
            set S(LLcanvas) $w4.c
            
            ### PACK
            pack $w1 -side top -expand 0
            pack $w2 -side top -expand 0
            pack $w3 -side top -expand 0
            pack $w5 -side top -expand 0
            pack $w4 -side top -expand 1 -fill both
        }
    }
    # selection d'une feuille
    # recherche a partir de la matrice des ensembles de feuilles
    # par classe de couleur
    proc treepatfromt {w x y} {
        global S T temp
        set c .leaf.mc.c
        set colorTrans $S(col)
        set tags [$w gettags [$w find withtag current]]
        set l [string range [lindex $tags [lsearch -glob $tags EUL*]] 3 end]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$l != ""} {
            set lid [$c find withtag $l]
            set lcolors {}
            foreach id $lid {
                set tags [$c  gettags $id]
                set l1 [lindex $tags 0]
                set l2 [lindex $tags 1]
                set color [lindex [$c itemconfigure $id -fill ] end]
                if {$l1 == $l} {set ltarget $l2} else {set ltarget $l1}
                if {[lsearch -exact $lcolors $color] != -1} {
                    set temp($color) $ltarget
                    lappend lcolors $color
                } else  {
                    lappend temp($color)  $ltarget
                }
            }
            foreach {color ll} [array get temp] {
                set S(col) $color
                Operation::OperationAction $w $t $ll
            }
            unset temp
        }
        set S(col) $colorTrans
    }
    proc exportPS {} {
        global S
        set c .leaf.mc.c
        set typelist {
            {"Postscript Files" {".ps"} }
            {"All Files" {*}}
        }
        set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".ps" \
                -filetypes $typelist -title "Save graphic as a Postscript file..."]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        # init si canvas vide
        set x0 0
        set y0 0
        set x1 [winfo width $c]
        set y1 [winfo height $c]
        # affectation des variables
        foreach {x0 y0 x1 y1} [$c bbox all] {}
        set w [expr $x1 - $x0]
        set h [expr $y1 - $y0]
        $c postscript  -file  $file -colormode color \
                -x $x0 -y $y0 -width $w -height $h \
                -pagex 0 -pagey 0 -pagewidth 20.c -pageheight 30.c \
                -pageanchor nw
    }
    proc MiniMatrix {} {
        global S
        switch -- $S(ClassMethod) {
            level {MiniMatrixLevel}
            distance {MiniMatrixDistance}
        }
    }
    #
    proc MiniMatrixDistance {} {
        global f T S IG
        TreeMat::ClassOK2 .leaf.pc.dc.fd.ca
        set t $S(LLtree)
        set c $S(LLcanvas)
        $c delete all
        set i 1
        if {$S(LLmatrixW) == 1 || $S(LLmatrixH) == 1} {
            foreach la $T($t,ue_lab)  {
                set j 1
                foreach lb $T($t,ue_lab)  {
                    set level [DrawGoClass2Level $f($i,$j) $IG(classesfound)]
                    $c create rectangle [expr $j * $S(LLmatrixW) ] [expr $i * $S(LLmatrixH)] \
                            [expr ($j * $S(LLmatrixW))+ $S(LLmatrixW) ] [expr ($i * $S(LLmatrixH)) +$S(LLmatrixH) ] \
                            -fill $IG(color,$level) -outline  $IG(color,$level) -tags "$la $lb IJ"
                    incr j
                }
                incr i
            }
        } else  {
            foreach la $T($t,ue_lab)  {
                set j 1
                foreach lb $T($t,ue_lab)  {
                    set level [DrawGoClass2Level $f($i,$j) $IG(classesfound)]
                    $c create rectangle [expr $j * $S(LLmatrixW) ] [expr $i * $S(LLmatrixH)] \
                            [expr ($j * $S(LLmatrixW))+ $S(LLmatrixW) ] [expr ($i * $S(LLmatrixH)) +$S(LLmatrixH) ] \
                            -fill $IG(color,$level) -outline black -tags "$la $lb IJ"
                    incr j
                }
                incr i
            }
        }
        $c configure -scrollregion [$c bbox all]
        $c bind IJ <Any-Enter> "TreeMat::DisplayInfo"
        #legend
        set lbornes [concat "0 " $IG(classesfound)]
        set long [expr [llength $lbornes] -2]
        puts LBORNES$lbornes
        for  {set index 0} {$index <= $long} {incr index} {
            puts INDEX$index
            set text "[lindex $lbornes $index] - [lindex $lbornes [expr $index +1]]"
            set color $IG(color,[lindex $lbornes [expr $index +1]])
            $c create rectangle [expr ($j * $S(LLmatrixW)) + 10 ] [expr 10 + ($index *10)] [expr ($j * $S(LLmatrixW)) + 20 ] [expr 20 + ($index *10)] \
                    -fill $color -outline $color
            $c create text [expr ($j * $S(LLmatrixW)) + 25 ] [expr 10 + ($index *10)] -text $text  -fill black -anchor nw -font {helvetica 8 normal}
            
        }
    }
    proc MiniMatrixLevel {} {
        global f T S IG
        TreeMat::ClassOK .leaf.pc.dc.fd.ca
        set t $S(LLtree)
        set c $S(LLcanvas)
        $c delete all
        set i 1
        if {$S(LLmatrixW) == 1 || $S(LLmatrixH) == 1} {
            foreach la $T($t,ue_lab)  {
                set j 1
                foreach lb $T($t,ue_lab)  {
                    set level $f($i,$j)
                    $c create rectangle [expr $j * $S(LLmatrixW) ] [expr $i * $S(LLmatrixH)] \
                            [expr ($j * $S(LLmatrixW))+ $S(LLmatrixW) ] [expr ($i * $S(LLmatrixH)) +$S(LLmatrixH) ] \
                            -fill $IG(color,$level) -outline  $IG(color,$level) -tags "$la $lb IJ"
                    incr j
                }
                incr i
            }
        } else {
            foreach la $T($t,ue_lab)  {
                set j 1
                foreach lb $T($t,ue_lab)  {
                    set level $f($i,$j)
                    $c create rectangle [expr $j * $S(LLmatrixW) ] [expr $i * $S(LLmatrixH)] \
                            [expr ($j * $S(LLmatrixW))+ $S(LLmatrixW) ] [expr ($i * $S(LLmatrixH)) +$S(LLmatrixH) ] \
                            -fill $IG(color,$level) -outline black -tags "$la $lb IJ"
                    incr j
                }
                incr i
            }
        }
        $c configure -scrollregion [$c bbox all]
        $c bind IJ <Any-Enter> "TreeMat::DisplayInfo"
    }
    #
    proc DisplayInfo {} {
        global S
        set c $S(LLcanvas)
        set tags [$c gettags current]
        set S(LLmsg) "[lindex $tags 0] [lindex $tags 1]"
    }
    # attention ici menu tree target specifique : un seul arbre a la fois
    proc TreeTarget {m} {
        global S
        $m  delete 0 end
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set win [format "%s%s%s" .t $wi .c]
                foreach t $S($win,t) {
                    $m add radiobutton -label $S($t,tit) -variable S(LLtree) -value $t \
                            -columnbreak 0
                }
            }
        }
    }
    #
    proc PanelDeffClass {w} {
        global S T
        frame $w.dc -relief raised -borderwidth 2
        # panel controls
        set fc [frame $w.dc.co]
        button $w.dc.co.add -text "Add a Class" -relief groove -command "TreeMat::AddClassCAP $w.dc.fd.ca"
        menubutton $w.dc.co.var -text Method -relief groove -menu $w.dc.co.var.m -direction below -indicatoron 1
        set zc  [menu  $w.dc.co.var.m -tearoff 0]
        $zc add radio -label "Level" -variable S(ClassMethod) -value level -command "TreeMat::DeffClassVar1 $w.dc.fd.ca"
        $zc add radio -label "Distance" -variable S(ClassMethod) -value distance -command "TreeMat::DeffClassVar2 $w.dc.fd.ca"
        pack $w.dc.co.var $w.dc.co.add  -side left
        # panel graphic
        set fd [frame $w.dc.fd]
        set canvasw 500.0
        set canvash 100.0
        set c [canvas $w.dc.fd.ca -background LightGoldenrodYellow -borderwidth 1 \
                -width $canvasw -height $canvash]
        pack $w.dc.fd.ca
        set S(LLcanvas)  $w.dc.fd.ca
        puts $w.dc.fd.ca
        $c bind FL <Button-1> {TreeMat::MoveStart %W %x %y}
        $c bind FL <B1-Motion> {TreeMat::Move %W %x %y}
        $c bind FL <Button-3> {TreeMat::ClassM3 %W %x %y}
        $c bind FL2 <Button-1> {TreeMat::MoveStart2 %W %x %y}
        $c bind FL2 <B1-Motion> {TreeMat::Move2 %W %x %y}
        $c bind FL2 <Button-3> {TreeMat::ClassM3 %W %x %y}
        # packing
        pack $w.dc.co  $w.dc.fd -side top
    }
    # level
    proc DeffClassVar1 {c} {
        global S T f
        $c delete all
        $c create line 0 50 500 50
        # tree target
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        #MIN / MAX
        set MIN 0
        set MAX 0
        foreach t $ltreetarget  {
            if {$T($t,tot) >= $MAX} {set MAX $T($t,tot)}
        }
        set MAX [expr $MAX *2]
        #
        set S(classFactor) [expr 500.0 / ($MAX - $MIN)]
        set S(classMin) $MIN
        # graduations
        for {set i 0} {$i <= $MAX} {incr i} {
            set x [expr $S(classFactor) * ($i - $MIN) ]
            $c create line $x 48 $x 52 -tag "b b$i"
        }
        # remplissage complet matrice f($i,$j) == f($j,$i)
        set i 1
        foreach la $T($t,ue_lab)  {
            set j 1
            foreach lb $T($t,ue_lab)  {
                # distance entre les deux feuilles
                set d [DistLLlevel $t $la $lb]
                set f($i,$j) $d
                incr j
            }
            incr i
        }
        AddClassCAP $c
    }
    # voir le module Amelie
    # regsub -all {[0-9]} $T($ti,ltc,$l) "" l1
    # regsub -all {[0-9]} $T($ti,ltc,$vi) "" l2
    # set root [CommunRoot2 0 $l1 $l2 ""]
    # regsub $root $l1 "" frag1
    # regsub $root $l2 "" frag2
    # set level [expr  abs([string length $frag1] + [string length $frag2])]
    proc DistLLlevel {t l1 l2} {
        global T
        set l1code $T($t,ltc,$l1)
        set l2code $T($t,ltc,$l2)
        if {[string equal $l1code $l2code]} {
            set comm $l1code
        } else  {
            set comm [Nodeper 0 $l1code $l2code ""]
        }
        regsub -all {[0-9]} [string trimleft $l1code $comm] "" l1s
        regsub -all {[0-9]} [string trimleft $l2code $comm] "" l2s
        set level [expr [string length $l1s] + [string length $l2s]]
        #puts "$l1code $l2code *** $comm *** $l1s $l2s $level"
        return $level
    }
    proc Nodeper {index s1 s2 string} {
        if {[string equal $s1 $s2]} {
            return $string
        }
        if {[string equal  [string index $s1 $index] [string index $s2 $index]]} {
            Nodeper [expr $index +1] $s1 $s2 $string[string index $s1 $index]
        } else  {
            return $string
        }
    }
    # distance
    proc DeffClassVar2 {c} {
        global S T f
        $c delete all
        $c create line 0 50 500 50
        set t $S(LLtree)
        set MIN 0.0
        set MAX [expr $T($t,xmax) *2.0]
        set S(classFactor) [expr 500.0 / ($MAX - $MIN)]
        set S(classMin) $MIN
        # remplissage complet matrice f($i,$j) == f($j,$i)
        set i 1
        foreach la $T($t,ue_lab)  {
            set j 1
            foreach lb $T($t,ue_lab)  {
                # distance entre les deux feuilles
                set d [Tools::DistLL $t $la $lb]
                set f($i,$j) $d
                incr j
            }
            incr i
        }
        # affichage valeurs
        set jj 1 ; set i [expr $i -1]
        set n 0 ; set somme 0 ; set somme2 0
        for {set ii 1} {$ii <= $i} {incr ii} {
            for {set jj 1} {$jj < $ii} {incr jj} {
                
                set somme [expr $somme + $f($ii,$jj)]
                #set somme2 [expr $somme2 + ($f($ii,$jj) * $f($ii,$jj))]
                set x [expr $S(classFactor) * ($f($ii,$jj) - $MIN) ]
                $c create line $x 48 $x 52
            }
        }
        
        set moy [expr $somme / ((( $i * $i) - $i) / 2)]
        set x [expr $S(classFactor) * ($moy - $MIN) ]
        $c create line $x 40 $x 60
        
        AddClassCAP $c
    }
    #
    proc GenId {} {
        global S
        incr S(nbobj)
        return [format "%s%s" [clock second] $S(nbobj)]
    }
    #
    proc ClassM3 {w x y} {
        if {[winfo exists $w.menu ] == 1} {destroy $w.menu}
        set m [menu $w.menu -tearoff 0]
        set i [$w find withtag current]
        if {$i != {}}  {
            set tags [$w gettags $i]
            set id [lindex [split [lindex $tags [lsearch -glob $tags class*]] ¶] end]
            $m add command -label "Color..." -command "TreeMat::ClassColor $id"
            $m add command -label "Delete" -command "TreeMat::ClassDelete $id"
            tk_popup $m [winfo pointerx $w] [winfo pointery $w]
        }
    }
    #
    proc propertiesApply {ID} {
        global IG
        set c .leaf.pc.dc.fd.ca
        # mise a jour couleur
        foreach item [$c find withtag class¶$ID] {
            set type [$c type $item]
            switch -exact $type {
                line {
                    $c itemconfigure $item -fill $IG(class,color,$ID)
                }
                polygon {
                    $c itemconfigure $item -fill $IG(class,color,$ID) -outline $IG(class,color,$ID)
                }
            }
        }
    }
    #
    proc ClassColor {id} {
        global IG
        set color [tk_chooseColor]
        set IG(class,color,$id) $color
        propertiesApply $id
    }
    #
    proc ClassDelete {id} {
        set c .leaf.pc.dc.fd.ca
        $c delete class¶$id
    }
    #
    proc MoveStart {w x y} {
        global S
        set S(mox) $x
    }
    proc MoveStart2 {w x y} {
        global S
        set S(mox) $x
    }
    #
    proc Move {w x y} {
        global S IG
        set tags [$w gettags current]
        set tag [lindex $tags [lsearch -glob $tags class*]]
        set ID [lindex [split $tag ¶] end]
        $w delete "$tag && val"
        set xx [lindex  [$w coords [list BOC && $tag]] 0]
        if {$x < 501 && $x >= 0} {
            $w move $tag [expr $x - $S(mox)] 0
            $w create text [expr $xx + 5] 10 -text [expr round(0.5+($x / $S(classFactor)) + $S(classMin)) ] \
                    -fill black  -tags "CL BOV BOVBOV $tag val" -anchor w
            set S(mox) $x
        }
    }
    #
    proc Move2 {w x y} {
        global S IG
        set tags [$w gettags current]
        set tag [lindex $tags [lsearch -glob $tags class*]]
        set ID [lindex [split $tag ¶] end]
        $w delete "$tag && val"
        set xx [lindex  [$w coords [list BOC && $tag]] 0]
        if {$x < 501 && $x >= 0} {
            $w move $tag [expr $x - $S(mox)] 0
            $w create text [expr $xx + 5] 10 -text [expr ($x / $S(classFactor)) + $S(classMin) ] \
                    -fill black  -tags "CL BOV BOVBOV $tag val" -anchor w
            set S(mox) $x
        }
    }
    #
    proc AddClassCAP {c} {
        global S
        switch -- $S(ClassMethod) {
            level {TreeMat::AddClass $c}
            distance {TreeMat::AddClass2 $c}
        }
    }
    #
    proc AddClass {c} {
        global S IG
        if {$S(ClassMethod) != "?"} {
            set ID [GenId]
            set tag [format "%s%s" class¶ $ID]
            set color [format #%06x [expr {int(rand() * 0xFFFFFF)}]]
            set IG(class,color,$ID) $color
            set IG(class,tabul,$ID) $S(IGtabul)
            set IG(class,curve,$ID) $S(IGcurve)
            set IG(class,line,$ID)  $S(IGline)
            $c create line 250 0 250 100 -fill $color -width 1 -tags "CL BOC $tag "
            $c create polygon 250 10 240 20 250 30 -fill $color -outline $color -width 1 -tags "FL CL $tag"
            $c create text 255 10 -text [expr round(0.5+(250.0 / $S(classFactor)) + $S(classMin))] \
                    -fill black  -tags "CL  BOV BOVBOV val $tag" -anchor w
        }
    }
    #
    proc AddClass2 {c} {
        global S IG
        if {$S(ClassMethod) != "?"} {
            set ID [GenId]
            set tag [format "%s%s" class¶ $ID]
            set color [format #%06x [expr {int(rand() * 0xFFFFFF)}]]
            set IG(class,color,$ID) $color
            set IG(class,tabul,$ID) $S(IGtabul)
            set IG(class,curve,$ID) $S(IGcurve)
            set IG(class,line,$ID)  $S(IGline)
            $c create line 250 0 250 100 -fill $color -width 1 -tags "CL BOC $tag "
            $c create polygon 250 10 240 20 250 30 -fill $color -outline $color -width 1 -tags "FL2 CL $tag"
            $c create text 255 10 -text [expr (250.0 / $S(classFactor)) + $S(classMin)] \
                    -fill black  -tags "CL  BOV BOVBOV val $tag" -anchor w
        }
    }
    # construction des classes par level
    proc ClassOK {w} {
        global C S T IG
        set t $S(LLtree)
        set MIN 0
        set MAX [expr $T($t,tot) *2]
        # init
        foreach {k v} [array get IG color,*] {
            unset IG($k)
        }
        # les bornes presentes
        set class [$w find withtag BOVBOV]
        set lbornes {}
        foreach c $class {
            set tags [$w gettags $c]
            set borne [lindex [$w itemconfigure $c -text] end]
            lappend lbornes $borne
            set ID [lindex [split [lindex $tags [lsearch -glob $tags class*]] ¶] end]
            set IG(color,$borne) $IG(class,color,$ID)
        }
        # remplissage
        set lbornes [lsort -integer -increasing $lbornes]
        set maxborne [lindex $lbornes end]
        for {set i 0} {$i <= $MAX} {incr i} {
            if {[lsearch $lbornes $i] == -1} {
                if {$i > $maxborne} {
                    set IG(color,$i) black
                } else  {
                    foreach b $lbornes {
                        if {$i <= $b} {
                            if [catch {set test $IG(color,$i)} test] {
                                set IG(color,$i) $IG(color,$b)
                            }
                        }
                    }
                }
            }
        }
    }
    # construction des classes par distance
    proc ClassOK2 {w} {
        global C S IG T f
        foreach {k v} [array get IG color,*] {
            unset IG($k)
        }
        set class [$w find withtag BOVBOV]
        set lbornes {}
        foreach c $class {
            set tags [$w gettags $c]
            set bornesup [lindex [$w itemconfigure $c -text] end]
            lappend lbornes $bornesup
            set ID [lindex [split [lindex $tags [lsearch -glob $tags class*]] ¶] end]
            set IG(color,$bornesup) $IG(class,color,$ID)
        }
        set bornesup [expr (500.0 / $S(classFactor)) + $S(classMin)]
        set IG(color,$bornesup) black
        lappend lbornes $bornesup
        set IG(classesfound) [lsort -real -increasing $lbornes]
    }
    #
    proc DrawGoClass2Level {v lv} {
        foreach i $lv {
            if {$v <= $i} {
                return $i
            }
        }
    }
    proc DrawGoClass2Level {v lv} {
        foreach i $lv {
            if {[expr $v <= $i] == 1 } {
                return $i
            }
        }
    }
    #
    proc ColorSpecific {w} {
        global S
        $w configure -background $S(col)
        set S(AmelieColor) $S(col)
    }
    #
    proc PanelQuit {} {
        set choix [tk_messageBox -type okcancel -default ok  \
                -message "Exit TreePAT ?" -icon question]
        if {$choix == "ok"} {
            eval destroy .leaf
        }
    }
}
################################################################################


################################################################################
# TREEBASE
################################################################################
namespace eval TreeBase {
    #Given a taxon name (e.g. Candida albicans), display a list of all names in
    #TreeBASE that start with this name. Start by replacing any spaces in the taxon
    # name with plus (+) signs, and enter this result into an URL, as follows:
    #http://www.treebase.org/cgi-bin/treebase.pl?Name=Candida+albicans&Submit=Taxon+Name
    #genere <FRAME SRC="http://search.treebase.org/treebase/TreeBASE.acgi?Keyword=Candida+albicans%40&SourceData=5&RanNum=1108&Button=Submit" NAME="queryInput" SCROLLING=NO>
    #
    #Given a taxon ID number (e.g. T3692), display a list of all studies that have
    # this taxon in at least one trees. Edit the URL as follows:
    #http://www.treebase.org/cgi-bin/treebase.pl?TaxonID=T3692&Submit=Taxon+ID
    #genere http://search.treebase.org/treebase/TreeBASE.acgi?PickedItems=T3692&RanNum=4443&SourceData=5&Button=Search
    #
    #Given a study ID number (e.g. S644), display the citation, analyses, matrices,
    # and trees associated with this study. Edit the URL as follows:
    #http://www.treebase.org/cgi-bin/treebase.pl?StudyID=S644&Submit=Study+ID
    #genere http://search.treebase.org/treebase/TreeBASE.acgi?PickedItems=S644&RanNum=3137&SourceData=2&Button=Search
    #
    #Show the tree corresponding to the given ID number (e.g. Tree775). Edit the URL as follows:
    #http://www.treebase.org/cgi-bin/treebase.pl?TreeID=Tree775&Submit=Show+Tree
    #genere http://search.treebase.org/treebase/TreeBASE.acgi?PickedItems=Tree775&RanNum=1757&PickedItems=1&Button=Tree
    #
    
    proc TreeBasepanel {} {
        
        global S
        set S(TBStudyListIDall) {}
        set S(TBdoc) -
        if {[winfo exists .treebase] == 1} {destroy .treebase}
        set S(TBdocument) 1
        set p [toplevel .treebase]
        wm  title $p "TreeBASEinterf"
        iwidgets::tabnotebook $p.t -width 600 -height 400 -tabpos n
        set t1 [$p.t add -label "Study" ]
        
        #########" STUDY S644 S625
        $p.t view "Study"
        pack $p.t -side left -expand yes -fill both
        set st1 [frame $t1.control]
        set st2 [frame $t1.top]
        set st3 [frame $t1.bottom]
        
        ###CONTROL ST1
        iwidgets::entryfield $st1.studyid  -textvariable S(TreeBaseStudyID)  \
                -labeltext "Study ID" -labelpos w -command TreeBase::GoStudy
        
        button $st1.go -text Query -command TreeBase::GoStudy
        pack $st1.studyid  $st1.go -side left -expand 1 -fill x
        set S(TreeBaseStudyID) S
        
        ### TOP ST2
        #study list
        set wd [frame $st2.liststudy]
        scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
        scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
        listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                -width 12 -height 5 -selectmode extended
        
        grid $wd.l -row 0 -column 0 -sticky news
        grid $wd.yscroll -row 0 -column 1 -sticky ns
        grid $wd.xscroll -row 1 -column 0 -sticky ew
        grid rowconfigure $wd 0 -weight 1
        grid columnconfigure $wd 0 -weight 1
        bind $wd.l <ButtonRelease> "TreeBase::UpdateTreeListFromStudy"
        set S(TBStudyPathListStudy) $wd.l
        # text study info
        set wd2 [frame $st2.textstudy]
        text $wd2.txt -yscrollcommand "$wd2.sy set" -height 10
        #html $wd2.txt -yscrollcommand "$wd2.sy set"
        scrollbar $wd2.sy -orient vert -command "$wd2.txt yview"
        pack $wd2.sy -side right -fill y
        pack $wd2.txt -side left -fill both -expand true
        set S(TBStudyPathTextStudy) $wd2.txt
        # pack st2
        pack $wd $wd2 -side left -expand 1 -fill both
        
        ### BOTTOM ST3
        # Tree list (/study)
        set wd [frame $st3.listtree]
        scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
        scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
        listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                -width 12 -height 5 -selectmode extended
        set S(TBStudyPathListTree) $wd.l
        grid $wd.l -row 0 -column 0 -sticky news
        grid $wd.yscroll -row 0 -column 1 -sticky ns
        grid $wd.xscroll -row 1 -column 0 -sticky ew
        grid rowconfigure $wd 0 -weight 1
        grid columnconfigure $wd 0 -weight 1
        bind $wd.l <ButtonRelease> ""
        
        # display control
        set fc [frame $st3.control]
        set fcfc [frame $fc.control2]
        radiobutton $fc.newdoc -text "1 Tree/Document" -variable S(TBdocument) -value 1 -command "$fcfc.doc configure -state disable"
        
        radiobutton $fcfc.insdoc -text "Insertion:" -variable S(TBdocument) -value 0 -command "$fcfc.doc configure -state normal"
        menubutton $fcfc.doc -text ""  -menu $fcfc.doc.m -indicatoron 1
        set z  [menu  $fcfc.doc.m -tearoff 0]
        $z configure -postcommand "TreeBase::TreeDoc $fcfc.doc $z"
        pack $fcfc.insdoc $fcfc.doc -side left
        $fcfc.doc configure -state disable
        checkbutton $fc.disann -text "Annotation" -variable S(TBannotation)
        button $fc.query -text Query -command "TreeBase::GoStudyTree"
        pack $fc.newdoc $fcfc  $fc.disann $fc.query -side top -expand 1 -fill x -anchor w
        
        # text tree info
        set wd2 [frame $st3.texttree]
        text $wd2.txt -yscrollcommand "$wd2.sy set" -height 10
        scrollbar $wd2.sy -orient vert -command "$wd2.txt yview"
        pack $wd2.sy -side right -fill y
        pack $wd2.txt -side left -fill both -expand true
        set S(TBStudyPathTextTree) $wd2.txt
        # pack st3
        pack $st3.listtree $st3.control $st3.texttree -side left -expand 1 -fill both
        # final pack
        pack $st1 -expand 1 -fill x
        pack $st2 -expand 1 -fill both
        pack $st3 -expand 1 -fill both
    }
    #
    proc TreeDoc {b m} {
        global S
        $m  delete 0 end
        foreach wi $S(ilw)  {
            if {$wi != 0 && [winfo exists .t$wi] == 1} {
                set tt [format "%s%s" Document: [file tail [wm title .t$wi]]]
                set fval [format "%s%s%s" .t $wi .c]
                # .t$wi
                $m add radiobutton -label [file tail [wm title .t$wi]] -foreground blue  \
                        -variable S(TBdoc) -value  $fval
            }
        }
        $m add separator
        $m add command -label New -command "TreeBase::NewInsertion"
    }
    #
    ################################################################################
    #     proc GoTree {} {
    #         global S
    #         foreach yop [split $S(TreeBaseTreeID) ","] {
    #             set url "http://128.205.184.102/treebase/TreeBASE.acgi?PickedItems=$yop&Button=TView"
    #             http::geturl $url -command TreeBase::httpDrawTree
    #             vwait S(TBvwait)
    #             update idletasks
    #         }
    #     }
    ################################################################################
    proc GoStudy {} {
        global S
        .treebase  config -cursor watch
        #S(TBStudyPathListStudy)
        foreach yop [split $S(TreeBaseStudyID) ","] {
            set S(IDcurrentStudy) $yop
            set url "http://search.treebase.org/treebase/TreeBASE.acgi?PickedItems=$yop&SourceData=2&Button=Search"
            http::geturl $url -command "TreeBase::httpGetStudy"
        }
        destroy .progress
    }
    #
    proc NewInsertion {} {
        global S
        set w [ImportExport::NewCanvas]
        set S(TBdoc) $w
    }
    #
    proc httpGetStudy {token} {
        global S tcl_platform T
        upvar #0 $token state
        update idletasks
        set s [format "%s%s%s" "{" [http::data $token] "}"]
        regsub -all "\n" $s "" s
        regsub -all "\r" $s "" s
        #tree
        set lt [regexp -all -inline {Tree[0-9]+} $s]
        set S(TBStudyListTree,$S(IDcurrentStudy)) [lsort [Tools::DelRep $lt]]
        # update listbox
        if {[lsearch $S(TBStudyListIDall) $S(IDcurrentStudy)] == -1 } {
            lappend  S(TBStudyListIDall) $S(IDcurrentStudy)
        }
        $S(TBStudyPathListStudy) delete 0 end
        $S(TBStudyPathListTree) delete 0 end
        foreach st $S(TBStudyListIDall) {
            $S(TBStudyPathListStudy) insert end $st
        }
        foreach t $S(TBStudyListTree,$S(IDcurrentStudy)) {
            $S(TBStudyPathListTree) insert end $t
        }
        #study notes (tree notes : ok au fur a mesure)
        set T1 "This data set was downloaded from TreeBASE, a prototype relational database of phylogenetic knowledge. TreeBASE has been supported by the NSF, Harvard University, and UC Davis, and Leiden University. TreeBASE Â© 1994-2006"
        set T2 "$S(IDcurrentStudy), [llength $S(TBStudyListTree,$S(IDcurrentStudy))] tree(s)"
        set patt [format "%s%s%s" "Study #\[0-9\]+</B>:(.+\\\[" $S(IDcurrentStudy) "\\\])"]
        regexp  $patt $s f T3
        set S(TBStudyRef) $T3
        set T4 " For more information, see TreeBASE"
        set S(TBstudyT1,$S(IDcurrentStudy)) $T1
        set S(TBstudyT2,$S(IDcurrentStudy)) $T2
        set S(TBstudyT3,$S(IDcurrentStudy)) $T3
        set S(TBstudyT4,$S(IDcurrentStudy)) $T4
        $S(TBStudyPathTextStudy) delete 0.0 end
        $S(TBStudyPathTextStudy) insert end $T2 t2
        $S(TBStudyPathTextStudy) insert end "\n\n"
        $S(TBStudyPathTextStudy) insert end $T3 t3
        $S(TBStudyPathTextStudy) insert end "\n\n"
        $S(TBStudyPathTextStudy) insert end $T1 t1
        $S(TBStudyPathTextStudy) insert end $T4 t4
        $S(TBStudyPathTextStudy) tag configure t1 -foreground grey50 -font {Arial 8 normal}
        $S(TBStudyPathTextStudy) tag configure t2 -foreground purple -font {Arial 10 bold}
        $S(TBStudyPathTextStudy) tag configure t3 -foreground blue
        $S(TBStudyPathTextStudy) tag configure t4 -foreground grey50 -font {Arial 8 italic}
        .treebase  config -cursor arrow
    }
    proc UpdateTreeListFromStudy {} {
        global S
        # on reselect un elt de la liste des study
        # -> update S(IDcurrentStudy)
        # -> update liste des trees
        # -> text info study
        set S(IDcurrentStudy) [$S(TBStudyPathListStudy) get  [$S(TBStudyPathListStudy) curselection]]
        $S(TBStudyPathListTree) delete 0 end
        foreach t $S(TBStudyListTree,$S(IDcurrentStudy)) {
            $S(TBStudyPathListTree) insert end $t
        }
        $S(TBStudyPathTextStudy) delete 0.0 end
        $S(TBStudyPathTextStudy) insert end $S(TBstudyT2,$S(IDcurrentStudy)) t2
        $S(TBStudyPathTextStudy) insert end "\n\n"
        $S(TBStudyPathTextStudy) insert end $S(TBstudyT3,$S(IDcurrentStudy)) t3
        $S(TBStudyPathTextStudy) insert end "\n\n"
        $S(TBStudyPathTextStudy) insert end $S(TBstudyT1,$S(IDcurrentStudy)) t1
        $S(TBStudyPathTextStudy) insert end $S(TBstudyT4,$S(IDcurrentStudy)) t4
    }
    #
    proc GoStudyTree {} {
        global S
        if {$S(TBdoc) == "-"} {TreeBase::NewInsertion}
        set selection  [$S(TBStudyPathListTree) curselection]
        ImportExport::MIMakeProgressBarGen [llength $selection]
        $S(TBStudyPathTextTree) delete 0.0 end ; #clear info tree
        foreach i $selection {
            set t [$S(TBStudyPathListTree) get $i]
            set url "http://128.205.184.102/treebase/TreeBASE.acgi?PickedItems=$t&Button=TView"
            http::geturl $url -command TreeBase::httpDrawTree
            vwait S(TBvwait)
            .progress.n step
            .progress.i reset
            update idletasks
        }
        # reorganisation rows x columns
        if {$S(TBdocument) == 0} {
            set S($S(TBdoc),BIcol) 3
            Navigation::Reorganize $S(TBdoc)
            $S(TBdoc) move all 15 100
            $S(TBdoc) delete treebase
            $S(TBdoc) delete $S(IDcurrentStudy)
            $S(TBdoc) create text 15 20  -justify left -font {Helvetica 8 normal}\
                    -text "This data set was downloaded from TreeBASE, a prototype relational database of phylogenetic knowledge.\n\
                    TreeBASE has been supported by the NSF, Harvard University, and UC Davis, and Leiden University.\n\
                    TreeBASE Â© 1994-2006" -anchor w -justify left -fill black -tag "TXT treebase"
            $S(TBdoc) create text 15 70 -text $S(TBStudyRef)  -font {Helvetica 8 normal} -fill blue\
                    -anchor w -justify left -tag "TXT " -width 500 -tag $S(IDcurrentStudy)
        }
        destroy .progress
    }
    #
    proc httpDrawTree {token} {
        global S tcl_platform T
        upvar #0 $token state
        update idletasks
        set s [format "%s%s%s" "{" [http::data $token] "}"]
        regsub -all "\n" $s "" s
        regsub -all "\r" $s "" s
        regexp {Tree[0-9]+} $s IDtree
        regexp {S[0-9]+} $s IDstudy
        regexp {\!.+S[0-9]+} $s Study
        set S(TBtreeStudy,$IDtree) $Study
        regexp {1\t.+'\t} $s Leaves
        regexp {;[^(]+([^;]+);END|end;} $s ok Newick
        regsub -all "," $Leaves "" Leaves
        set Nick ""
        regsub -all {(\(|,|\))} $Newick { & } Newick
        foreach e $Newick {
            if [string is integer $e] {
                set Nick $Nick[lindex $Leaves [expr [lsearch $Leaves $e] +1]]
            } else {
                set Nick $Nick$e
            }
        }
        MIimportNWK [format "%s%s" $Nick ";"] $IDstudy $IDtree
        InfoTree $IDtree
        # pour le vwait en cas de query multiple
        set S(TBvwait) $token
    }
    #
    proc DisplayInternalAnnotation {} {
        global S
        # affichage des built-in annotations
        set col $S(col)
        set gfo $S(gfo)
        set S(col) blue
        set S(gfo) {Times 8 normal}
        set S(ANBLoperation) displayvalue
        set S(ANBLoperationName) "Node Annotate (value)"
        set S(ANBL-what) avant
        set S(ANBL-how) tout
        set S(ANBL-howleaves) 0
        set S(ANBLwhere) "----x"
        Annotation::ANBLgo
        set S(col) $col
        set S(gfo) $gfo
    }
    #
    proc InfoTree {IDtree} {
        global S
        #regexp  {!.+2006} $S(TBtreeStudy,$IDtree)  t0
        set t1 "This data set was downloaded from TreeBASE, a prototype relational database of phylogenetic knowledge. TreeBASE has been supported by the NSF, Harvard University, and UC Davis, and Leiden University. TreeBASE Â© 1994-2006"
        set t4 " For more information, see TreeBASE"
        regexp  {Study.+(Study.+)} $S(TBtreeStudy,$IDtree) tx t3
        # info study tab
        $S(TBStudyPathTextTree) insert end $IDtree t2
        $S(TBStudyPathTextTree) insert end "\n\n"
        $S(TBStudyPathTextTree) insert end $t1 t1
        $S(TBStudyPathTextTree) insert end $t4 t4
        $S(TBStudyPathTextTree) insert end "\n________________\n"
        $S(TBStudyPathTextTree) yview end
        #config
        $S(TBStudyPathTextTree) tag configure t1 -foreground grey50 -font {Verdana 8 normal}
        $S(TBStudyPathTextTree) tag configure t2 -foreground purple -font {Arial 10 bold}
        $S(TBStudyPathTextTree) tag configure t3 -foreground blue
        $S(TBStudyPathTextTree) tag configure t4 -foreground grey50 -font {Arial 8 italic}
    }
    #
    proc MIimportNWK {s IDstudy IDtree} {
        global S Export T
        if {$S(TBdocument) == "1"} {
            set w [ImportExport::NewCanvas ]
            set S(TBdoc) $w
        } else  {
            set w $S(TBdoc)
        }
        set max 0
        foreach c [split $s {}] {
            if {[string equal $c ","]} {incr max}
        }
        .progress.i configure -steps $max
        # nettoyage
        regsub -all "\n| " $s "" s
        regsub -all {\[} $s "" s
        #regsub -all {:-} $s ":" s
        regsub -all {:-[0-9]*.[0-9]+|:-[0-9]+} $s ":0.0" s
        regsub -all {\]} $s "" s
        ImportExport::NewickToTreeDyn $s
        # Export vers T
        set lkv [array get Export]
        foreach {key value} $lkv {
            set T(xxx,$key) $value
        }
        unset Export
        # graphic
        set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
        lappend S(ilt) $t
        lappend S($w,t) $t
        set S($t,w) $w
        ImportExport::TreeInit $t
        set S($t,tar) 1
        set S($t,tit) [format "%s%s%s%s" TreeBASE-Study: $IDstudy - $IDtree]
        ImportExport::xxxEncode $t
        # si petit arbre on utilise toute la hauteur de la fenetre
        if {[expr 10.0 * [llength $T($t,ue_cod)] ] >= $S(newH)} {
            set S(newH) [expr 10.0 * [llength $T($t,ue_cod)] ]
        }
        Conformation::PhyNJ $t $w 100 $S(newH)
        ImportExport::NodeBind $w $t
        Operation::TreeViewerPanelUpdate
        #name
        set co [$w bbox [list Z && T$t]]
        Annotation::AnnotateBuiltIn $w $t [lindex $co 0] [expr [lindex $co 1] -10] File
        if {$S(TBdocument) == 1} {
            $S(TBdoc) delete treebase
            $S(TBdoc) delete $S(IDcurrentStudy)
            $S(TBdoc) move all 15 100
            $S(TBdoc) create text 15 20 -justify left -font {Helvetica 8 normal}\
                    -text "This data set was downloaded from TreeBASE, a prototype relational database of phylogenetic knowledge.\n\
                    TreeBASE has been supported by the NSF, Harvard University, and UC Davis, and Leiden University.\n\
                    TreeBASE Â© 1994-2006" -anchor w -justify left -fill black -tag "TXT treebase"
            $S(TBdoc) create text 15 70 -text $S(TBStudyRef)  -font {Helvetica 8 normal} -fill blue \
                    -anchor w  -tag "TXT " -width 500 -justify left -tag $S(IDcurrentStudy)
        }
    }
}
################################################################################



################################################################################
# SUPERTREE
################################################################################
namespace eval SuperTree {
    
    
    #
    proc stcopypasteStart {w x y} {
        global S
        
        set i [$w find withtag current]
        set tags [$w gettags $i]
        set codeC [lindex $tags [lsearch -glob $tags *C]]
        if {$codeC != ""} {
            $w config -cursor plus
            #set co [$w coords $i]
            set S(LinkMemoryX) [$w canvasx $x]
            set S(LinkMemoryY) [$w canvasy $y]
            set S(LinkMemoryNodeFrom) $codeC
            bindtags $w [list nodefrom $w Canvas . all]
            bind nodefrom <Motion> "SuperTree::UpdateLinkMemory %W $codeC %x %y"
            bind nodefrom <Button-1> "SuperTree::InsertionGo $w"
            $w bind Z <Any-Enter> "SuperTree::SwitchCursorFromNode $w"
            $w bind Z <Any-Leave> "$w config -cursor plus"
            $w bind L <Any-Enter> "$w config -cursor plus"
            $w bind L <Any-Leave> "$w config -cursor plus"
            bind $w <Any-Enter> "SuperTree::AnyEnterCanvas $w"
            bind $w <Any-Leave> "SuperTree::AnyLeaveCanvas $w"
        }
    }
    proc AnyEnterCanvas {w} {
        global S
        bindtags $w [list nodefrom $w Canvas . all ]
    }
    ### Event
    proc AnyLeaveCanvas {w} {
        bindtags $w {}
    }
    #
    proc restaureBindsCursor {w} {
        global S
        $w config -cursor top_left_arrow
        $w bind Z <Any-Enter> "$w config -cursor hand2"
        $w bind Z <Any-Leave> "$w config -cursor top_left_arrow"
        $w bind L <Any-Enter> "$w config -cursor hand2"
        $w bind L <Any-Leave> "$w config -cursor top_left_arrow"
        bind nodefrom <Motion> ""
        bind nodefrom <Button-1> ""
        bind $w <Any-Enter> "Interface::AnyEnterCanvas %W"
        bind $w <Any-Leave> "Interface::AnyLeaveCanvas %W ; Annotation::CanvasTextDone %W"
        $w delete LinkMemory
        
    }
    #
    proc SwitchCursorFromNode {w} {
        global S
        set i [$w find withtag current]
        set tags [$w gettags $i]
        set code [string range [lindex $tags [lsearch -glob $tags *C]] 0 end-1]
        if {[lsearch $tags $code] != 0} {
            # horizontal
            $w config -cursor right_side
            set S(LinkMemoryMode) polytomy
        } else {
            # vertical
            $w config -cursor bottom_side
            set S(LinkMemoryMode) node
        }
    }
    #
    proc UpdateLinkMemory {w n xmouse ymouse} {
        global S
        $w delete LinkMemory
        set lcoords "$S(LinkMemoryX) $S(LinkMemoryY) $xmouse $ymouse"
        $w create line  $lcoords -width 1 -fill black  -tags LinkMemory
    }
    #
    proc InsertionGo {w} {
        global S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            restaureBindsCursor $w
            InsertionGoGo $w [string range $S(LinkMemoryNodeFrom) 0 end-1] \
                    $n $S(LinkMemoryMode)
            # passage en mode move
            #set S(tool) move
            #bindtags $w [list move $w Canvas . all]
        } else {
            # undo
            $w config -cursor top_left_arrow
            $w bind Z <Any-Enter> "$w config -cursor hand2"
            $w bind Z <Any-Leave> "$w config -cursor top_left_arrow"
            $w bind L <Any-Enter> "$w config -cursor hand2"
            $w bind L <Any-Leave> "$w config -cursor top_left_arrow"
            bind nodefrom <Motion> ""
            bind nodefrom <Button-1> ""
            set S(tool) stcopypaste
            bindtags $w [list stcopypaste $w Canvas . all]
            bind stcopypaste <Button-1> {SuperTree::stcopypasteStart %W %x %y}
            $w delete LinkMemory
            bind $w <Any-Enter> "Interface::AnyEnterCanvas %W"
            bind $w <Any-Leave> "Interface::AnyLeaveCanvas %W ; Annotation::CanvasTextDone %W"
        }
    }
    # procedure de nettoyage supprime les bv bl
    # conservation topologie seuleument
    proc cleanToTopo {nwk} {
        regsub -all {:[0-9]+.[0-9]+|:[0-9]+} $nwk "" nwk
        regsub -all {\)[0-9]+.[0-9]+|\)[0-9]+} $nwk ")" nwk
        return $nwk
    }
    proc InsertionGoGo {w nodeFrom nodeTo mode} {
        global S T B
        regexp {[0-9]+} $nodeFrom tfrom
        regexp {[0-9]+} $nodeTo tTo
        switch $mode {
            node {
                # COPY & INSERT AS NODE
                # newickFrom est le node "propre" (topologie seuleument) A INSERER
                set newickFrom [cleanToTopo $T($tfrom,nwk,$nodeFrom)]
                # NWKI est le node "propre" (toplogie seuleument) A MODIFIER
                set nwki [cleanToTopo $T($tTo,nwk,$nodeTo)]
                set newnwk [format "%s%s%s" $nwki "," $newickFrom ]
                # MERE est la chaine newick totale propre (topologie seuleument)
                set mere [cleanToTopo $T($tTo,nwk,$tTo)]
                # si arbre sur lui meme on ajoute l'operation de supprssion de nodefrom dans mere
                if {$tfrom == $tTo} {
                    set mere [ToTdelete $tTo $mere $nodeFrom]
                }
                # PROCESSUS FINAL d'insertion
                # attention
                # set s (a,(b,c)) ; regsub (b,c) $s x t ; puts $t => (a,(x))
                # le regsub ne prend pas en compte les () de la chaine a remplacer
                # il faut regsub {\(b,c\)} $s x t ; puts $t => (a,x)
                # donc tel que ca fct si on target un node
                # si on cible une feuille : on reste en polytomy
                # donc test suivant si une feuille on met () sur $newnwk
                # pour corriger le fait qu'elles ne sont pas prises en compte
                # avec regsub sur $nwki
                if {[string match *,* $nwki] != 1} {
                    regsub $nwki $mere [format "%s%s%s" {\(} $newnwk {\)} ] NewNewick
                } else  {
                    regsub -all {\(} $nwki {\(} nwki
                    regsub -all {\)} $nwki {\)} nwki
                    regsub $nwki $mere [format "%s%s%s" {\(} $newnwk {\)} ] NewNewick
                }
                set NewNewick [format "%s%s" $NewNewick ";"]
            }
            polytomy {
                # COPY & INSERT AS POLYTOMY
                # newickFrom
                set newickFrom [cleanToTopo $T($tfrom,nwk,$nodeFrom)]
                # nwki
                set nwki [cleanToTopo $T($tTo,nwk,$nodeTo)]
                set nwki2 [string range $nwki 1 end-1]
                set newnwk [format "%s%s%s%s%s" ( $nwki2 , $newickFrom ) ]
                # MERE
                set mere [cleanToTopo $T($tTo,nwk,$tTo)]
                # si arbre sur lui meme on ajoute l'operation de supprssion de nodefrom dans mere
                if {$tfrom == $tTo} {set mere [ToTdelete $tTo $mere $nodeFrom] }
                # modif la chaine $nwki a remplacer doit etre du format {\(x,y\)}
                # pour que le regsub supprime bien les ( et )
                # ATTENTION A VERIFIER \(Erethizon,(Agouti,(Cavia,Hydrochoe\))) pas sur la derniere )
                # ainsi ajout de -all a verifier
                regsub -all {\(} $nwki {\(} nwki
                regsub -all {\)} $nwki {\)} nwki
                regsub $nwki $mere $newnwk NewNewick
                set NewNewick [format "%s%s" $NewNewick ";"]
            }
        }
        set t [DisplaySame $w $NewNewick]
    }
    proc ToTdelete {t mere node} {
        global T
        set nwki [cleanToTopo $T($t,nwk,$node)]
        set nodePere [Tools::NodeParentNode $t $node]
        set nwkPere [cleanToTopo $T($t,nwk,$nodePere)]
        set nodeBrother [Tools::NodeBrotherNode $node]
        set nwkBrother [cleanToTopo $T($t,nwk,$nodeBrother)]
        regsub -all {\(} $nwkPere {\(} nwkPere
        regsub -all {\)} $nwkPere {\)} nwkPere
        regsub $nwkPere $mere $nwkBrother NewNewick
        return $NewNewick
    }
    # le pere de node est remplace par le bras alternatif de node
    proc stDeleteGo {w x y} {
        set item [$w find withtag current]
        set tags [$w gettags $item]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            stDeleteGoGo $w $n delete
        }
    }
    # le noeud est remplace par une feuille
    proc stCollapseGo {w x y} {
        set item [$w find withtag current]
        set tags [$w gettags $item]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            stDeleteGoGo $w $n collapse
        }
    }
    # le noeud est remplace polytomy totale
    proc stPolytomyTotale {w x y} {
        set item [$w find withtag current]
        set tags [$w gettags $item]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            stDeleteGoGo $w $n polyTotale
        }
    }
    # le noeud est remplace polytomy descandants directs seuleument
    proc stPolytomyPartielle {w x y} {
        global T
        set item [$w find withtag current]
        set tags [$w gettags $item]
        set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        if {$n != ""} {
            #tester que n n'est pa un code feuille (cad arrete terminale)
            if {[lsearch $T($t,ue_cod) $n] == -1} {
                stDeleteGoGo $w $n polyPartielle
            } }
    }
    #
    proc  stDeleteGoGo {w node mode} {
        global S T B
        switch $mode {
            collapse {
                # on remplace le node par une feuille artificielle
                regexp {[0-9]+} $node t
                # MERE
                set mere [cleanToTopo $T($t,nwk,$t)]
                # nwki a suprimer
                set nwki [cleanToTopo $T($t,nwk,$node)]
                #
                regsub -all {\(} $nwki {\(} nwki
                regsub -all {\)} $nwki {\)} nwki
                # nom de la feuille artificielle
                set EUScode [Tools::NodeNoToLe $t $node]
                set EUS [lsort -dictionary [Tools::NodeLeCoToRe $t $EUScode]]
                regsub -all " " [join $EUS] "_" NF
                #regsub $nwki $mere [Tools::GenId] NewNewick
                regsub $nwki $mere $NF NewNewick
                #puts "regsub $nwki $mere __ NewNewick"
            }
            delete {
                # Vraie deletion (feuille ou node)
                # du node pointe on passe au noeud pere et on
                # remplace ce noeud pere par le bras alternatif de node
                regexp {[0-9]+} $node t
                # MERE
                set mere [cleanToTopo $T($t,nwk,$t)]
                # nwki a suprimer
                set nwki [cleanToTopo $T($t,nwk,$node)]
                set nodePere [Tools::NodeParentNode $t $node]
                set nwkPere [cleanToTopo $T($t,nwk,$nodePere)]
                set nodeBrother [Tools::NodeBrotherNode $node]
                set nwkBrother [cleanToTopo $T($t,nwk,$nodeBrother)]
                regsub -all {\(} $nwkPere {\(} nwkPere
                regsub -all {\)} $nwkPere {\)} nwkPere
                regsub $nwkPere $mere $nwkBrother NewNewick
            }
            polyTotale {
                # on remplace le node par la  liste (a,b,c...) (ses feuilles)
                regexp {[0-9]+} $node t
                # MERE
                set mere [cleanToTopo $T($t,nwk,$t)]
                # nwki a suprimer
                set nwki [cleanToTopo $T($t,nwk,$node)]
                regsub -all {\(} $nwki {\(} nwki
                regsub -all {\)} $nwki {\)} nwki
                # construction du nouveau node
                set EUScode [Tools::NodeNoToLe $t $node]
                set EUS [lsort -dictionary [Tools::NodeLeCoToRe $t $EUScode]]
                regsub -all " " [join $EUS] "," NF
                set NewNwk [format "%s%s%s" ( $NF )]
                # remplacement
                regsub $nwki $mere $NewNwk NewNewick
            }
            polyPartielle {
                # on remplace le node (a,(b,(x,y))) par (a,b,(x,y)) en pointant (b,(x,y))
                # il suffit de retirer la topo de node
                regexp {[0-9]+} $node t
                # MERE (totale)
                set mere [cleanToTopo $T($t,nwk,$t)]
                # nwki a remplacer
                set nwki [cleanToTopo $T($t,nwk,$node)]
                set NewNewick [string range $nwki 1 end-1]
                regsub -all {\(} $nwki {\(} nwki
                regsub -all {\)} $nwki {\)} nwki
                # remplacement
                regsub $nwki $mere $NewNewick NewNewick
            }
        }
        set t [DisplaySame $w $NewNewick]
    }
    
    ################################################################################
    
    proc SuperTreePanel {} {
        global T S
        destroy .st
        set f [toplevel .st]
        wm title $f "TreeSPU"
        
        ### COLLAPSING BY BOOTSTRAP TRESHOLD
        iwidgets::Labeledframe $f.clp -labelpos ne -labeltext "Collapsing by Bootstrap Treshold"
        set S(supertreeDisplay) 1
        set S(supertreeFile) 0
        set S(supertreeCas) 0
        set cs1 [$f.clp childsite]
        iwidgets::entryfield $cs1.seuil -width 5  -textvariable S(supertreeSeuil) \
                -labeltext "Bootstrap Treshold" -validate integer
        set cs12 [frame $cs1.what ]
        
        button $cs1.g -text "Collapse" -command SuperTree::SeuilParser
        pack $cs1.seuil  $cs1.g  -anchor w -expand yes -fill x
        pack $f.clp -expand true -fill both
        
        ### COLORATION SPECIFIQUE / PARTIEL / UNIVERSEL
        set S(supertreeColorSpecific) blue
        set S(supertreeColorPartiel) red
        set S(supertreeColorUniversel) green
        set S(supertreeColorLeave) 1
        set S(supertreeColorSubtree) 1
        iwidgets::Labeledframe $f.spu -labelpos ne -labeltext "Specific/Partial/Universal Colors"
        set cs [$f.spu childsite]
        set cs11 [frame $cs.what]
        checkbutton $cs11.w1 -text "Leaves" -variable S(supertreeColorLeave)
        checkbutton $cs11.w2 -text "Sub-trees" -variable S(supertreeColorSubtree)
        pack    $cs11.w1 $cs11.w2 -side left
        set cs12 [frame $cs.col ]
        button $cs12.b00 -text "Specific"  -command "SuperTree::ColorSpecificGo $cs.b0"
        button $cs12.b10 -text "Partial"  -command "SuperTree::ColorPartielGo $cs.b1"
        button $cs12.b20 -text "Universal" -command "SuperTree::ColorUniverselGo $cs.b2"
        button $cs12.b01 -text " " -background $S(supertreeColorSpecific) \
                -command "SuperTree::ColorSpecific $cs12.b01"
        button $cs12.b12 -text " " -background $S(supertreeColorPartiel) \
                -command "SuperTree::ColorPartiel $cs12.b12"
        button $cs12.b23 -text " " -background $S(supertreeColorUniversel) \
                -command "SuperTree::ColorUniversel $cs12.b23"
        grid $cs12.b00  -row 0 -column 0 -sticky ew
        grid $cs12.b10  -row 1 -column 0 -sticky ew
        grid $cs12.b20  -row 2 -column 0 -sticky ew
        grid $cs12.b01  -row 0 -column 1 -sticky ew
        grid $cs12.b12  -row 1 -column 1 -sticky ew
        grid $cs12.b23  -row 2 -column 1 -sticky ew
        grid $cs11 -row 0 -column 0 -sticky ew
        grid $cs12 -row 1 -column 0 -sticky ew
        grid columnconfigure $cs12 0 -weight 1
        grid rowconfigure $cs12 1 -weight 1
        pack $cs -expand true -fill x
        pack $f.spu -expand true -fill both
        
        ### REMOVING SPECIFIQUE / PARTIEL / UNIVERSEL
        iwidgets::Labeledframe $f.rem -labelpos ne -labeltext "Removing by Specific/Partial/Universal"
        set S(supertreeRemDisplay) 1
        set S(supertreeRemFile) 0
        set cs4 [$f.rem childsite]
        set cr [frame $cs4.what ]
        checkbutton $cr.d -text "Display" -variable S(supertreeRemDisplay)
        checkbutton $cr.f -text "Save Newick" -variable S(supertreeRemFile)
        pack    $cr.d $cr.f -side left
        button $cs4.b0 -text "Keep Universal Only"  -command "SuperTree::RemoveKeepOnlyUniversal"
        pack $cs4.what $cs4.b0 -side top -expand true -fill x -anchor w
        pack $cs4 -expand true -fill x
        pack $f.rem -expand true -fill both
        
        ### MATRICE PRESENCE/ABSENCE
        set S(supertreeColorPresence) orange
        set S(supertreeColorAbsence) LightCyan2
        set S(supertreeAnnotGlobal) 1
        set S(supertreeAnnotGlobalSPU) 0
        set S(supertreeAnnotTree) 0
        set S(supertreeAnnotTreeOutline) 1
        iwidgets::Labeledframe $f.pa -labelpos ne -labeltext "Presence/Absence Matrix"
        set cs3 [$f.pa childsite]
        set cs31 [frame $cs3.how ]
        checkbutton $cs31.w1 -text "Global (alpha)" -variable S(supertreeAnnotGlobal)
        checkbutton $cs31.w2 -text "Global (SPU)" -variable S(supertreeAnnotGlobalSPU)
        checkbutton $cs31.w3 -text "Linked to trees" -variable S(supertreeAnnotTree)
        checkbutton $cs31.w4 -text "Outline" -variable S(supertreeAnnotTreeOutline)
        pack    $cs31.w1 $cs31.w2 $cs31.w3 $cs31.w4 -side top -anchor w
        button $cs3.b0 -text "Presence Color" -background $S(supertreeColorPresence) \
                -command "SuperTree::ColorPresence $cs3.b0"
        button $cs3.b1 -text "Absence Color" -background $S(supertreeColorAbsence) \
                -command "SuperTree::ColorAbsence $cs3.b1"
        button $cs3.b2 -text "Ok" -command "SuperTree::PresenceAbsenceMatrix"
        pack $cs31 $cs3.b0 $cs3.b1 $cs3.b2 -side top -expand true -fill x -anchor w
        pack $cs3 -expand true -fill x
        pack $f.pa -expand true -fill both
        
        ### GRID
        pack $f.clp $f.spu $f.rem $f.pa -expand 1 -fill x
        update
        wm geometry $f [winfo reqwidth $f]x[winfo reqheight $f]
    }
    # sachant un seuil boot, par 75, on remplace les valeurs de boot
    # inferieure a 75 par 0, et les > par 1, l'arbre resultatnt est traite
    # avec des longueurs de branches
    # open treedyn : (Procavia,(Trichechu,Dugong)100.0)73.0)
    # representation treedyn interne : (Procavia:1.0,(Trichechu:1.0,Dugong:1.0)100.0:1.0)73.0:1.0)
    # apres collapse a : (Procavia:1.0,(Trichechu:1.0,Dugong:1.0)100.0:1.0)73.0:1.0)
    # ATTENTION UNIQUEMENT VALABLE POUR LES ARBRES BINAIRES
    proc SeuilParser {} {
        global T S
        set AlistWinTree  [Selection::TreeTar]
        if {$AlistWinTree == {}} {
            tk_messageBox -message "No Tree selected" -type ok; return
        } else  {
            set lnewick {}
            foreach {w t} $AlistWinTree {
                set n $T($t,nwk,$t)
                regsub -all {:} $n " :"  n
                regsub -all {\)} $n ") "  n
                set newnewick {}
                foreach i $n {
                    # tester si i est un nombre
                    # comparaison seuil
                    # remplacement
                    # reconstruction newick
                    if {[string is double $i]} {
                        if {$i < $S(supertreeSeuil)} {
                            set i 0.0
                        } else  {
                            set i 1.0
                        }
                    }
                    lappend newnewick $i
                }
                regsub -all " " $newnewick ""  newnewick
                set s [format "%s%s" $newnewick ";" ]
                set lnewick [concat $lnewick $s]
            }
            TransNewick2 $lnewick
        }
    }
    # faudra passer a l'autre version bg bd
    proc TransNewick2 {ls} {
        global S
        set lnewick {}
        foreach s $ls {
            regsub -all {1.0:1.0} $s ""  s
            regsub -all {1.0:0.0} $s ""  s
            regsub -all {0.0:1.0} $s ":"  s
            regsub -all {0.0:0.0} $s ":"  s
            # les bl associees aux feuilles
            regsub -all {:1.0} $s ""  s
            regsub -all {:0.0} $s ""  s
            # regsub -all {0.0} $s ""  s
            # reste donc les : des nodes a ecraser
            # DE ((Myrmecoph,Tamandua),(Choloepus,Choloepuh)):
            # VERS (Myrmecoph,Tamandua),(Choloepus,Choloepuh)
            # puts $s
            # pour  chaque : index de la ")" limitrophe = x, puis chercher index
            # de la parenthese fermante de x, puis suppression
            set li [lsearch -all [split $s {}] :]
            set lio {}
            foreach i $li {
                # chercher l'index de la parenthese fermante de $i sur s
                lappend lio [CloseIndex [string range $s 0 [expr $i - 1]] [expr $i - 1]  ]
            }
            # suppression des parentheses aux index lio
            foreach i $lio {
                set s [string replace $s $i $i :]
            }
            regsub -all {\):} $s ""  s
            regsub -all ":" $s ""  s
            set lnewick [concat $lnewick $s]
        }
        if {$S(supertreeDisplay)} {Display $lnewick }
        if {$S(supertreeFile)} {SaveNewick $lnewick}
    }
    #
    proc Display {ls} {
        global S Export T
        set w [ImportExport::NewCanvas]
        ImportExport::MIMakeProgressBarGen 100
        set id 0
        foreach s $ls {
            # update progress bar
            .progress.n step
            # parsing
            if {[catch [ImportExport::NewickToTreeDyn $s] err] != 0} {
                Interface::TreeDynMessage "Error"
            } else {
                incr id
                #update progress bar
                .progress.i reset
                set max 0
                foreach c [split $s {}] {
                    if {[string equal $c ","]} {incr max}
                }
                .progress.i configure -steps $max
                # Export vers T
                set lkv [array get Export]
                foreach {key value} $lkv {
                    set T(xxx,$key) $value
                }
                unset Export
                # graphic
                set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
                lappend S(ilt) $t
                lappend S($w,t) $t
                set S($t,w) $w
                ImportExport::TreeInit $t
                set S($t,tit) PROTO
                ImportExport::xxxEncode $t
                set S(newH) [expr 10.0 * [llength $T($t,ue_cod)] ]
                Conformation::PhyNJ $t $w $S(newW) $S(newH)
                ImportExport::NodeBind $w $t
                Operation::TreeViewerPanelUpdate
            }
        }
        destroy .progress
    }
    #
    proc DisplaySame {w ls} {
        global S Export T
        #set w [ImportExport::NewCanvas]
        ImportExport::MIMakeProgressBarGen 100
        set id 0
        foreach s $ls {
            # update progress bar
            .progress.n step
            # parsing
            if {[catch [ImportExport::NewickToTreeDyn $s] err] != 0} {
                Interface::TreeDynMessage "Error"
            } else {
                incr id
                #update progress bar
                .progress.i reset
                set max 0
                foreach c [split $s {}] {
                    if {[string equal $c ","]} {incr max}
                }
                .progress.i configure -steps $max
                # Export vers T
                set lkv [array get Export]
                foreach {key value} $lkv {
                    set T(xxx,$key) $value
                }
                unset Export
                # graphic
                set t [expr [lrange [lsort  -integer -increasing $S(ilt)] end end] + 1]
                lappend S(ilt) $t
                lappend S($w,t) $t
                set S($t,w) $w
                ImportExport::TreeInit $t
                set S($t,tit) PROTO
                ImportExport::xxxEncode $t
                set S(newH) [expr 10.0 * [llength $T($t,ue_cod)] ]
                Conformation::PhyNJ $t $w $S(newW) $S(newH)
                ImportExport::NodeBind $w $t
                Operation::TreeViewerPanelUpdate
            }
        }
        set x [lindex [$w bbox L] 2]
        $w move T$t $x 1
        destroy .progress
        return $t
    }
    ###
    proc SaveNewick {s} {
        global S
        set typelist {
            {"Newick Files" {".nwk"} }
            {"All Files" {*}}
        }
        set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".nwk" \
                -filetypes $typelist -title "Save as Newick file(s)..."]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        if {$file != ""} {
            set fid [open $file w]
            puts $fid $s
            close $fid
        }
    }
    #
    proc ColorSpecific {w} {
        global S
        $w configure -background $S(col)
        set S(supertreeColorSpecific) $S(col)
    }
    #
    proc ColorPartiel {w} {
        global S
        $w configure -background $S(col)
        set S(supertreeColorPartiel) $S(col)
    }
    #
    proc ColorUniversel {w} {
        global S T
        $w configure -background $S(col)
        set S(supertreeColorUniversel) $S(col)
        
    }
    proc ColorSpecificGo {w} {
        global S T
        # a chaque arbre x on construit la liste des feuilles
        # de tous les autres arbres (sauf x) et on compare
        # avec la liste des feuilles de x
        set AlistWinTree  [Selection::TreeTar]
        if {$AlistWinTree == {}} {
            tk_messageBox -message "No Tree selected" -type ok; return
        } else  {
            set lt {} ;# liste des trees
            foreach {w t} $AlistWinTree {
                lappend lt $t
            }
            foreach t $lt {
                set lfeuillesautres {}
                foreach ti $lt {
                    if {$ti != $t} {
                        #lappend lfeuillesautres $T($ti,ue_lab)
                        set lfeuillesautres [concat $lfeuillesautres $T($ti,ue_lab)]
                    }
                }
                set lfeuillesautres [Tools::DelRep $lfeuillesautres]
                # on retire de x la liste des autres feuilles
                set lspe [Tools::SousL $T($t,ue_lab) $lfeuillesautres]
                FigurationSPU $t $lspe $S(supertreeColorSpecific)
            }
        }
    }
    proc FigurationSPU {t leaves color} {
        global S T
        if {$S(supertreeColorLeave)} {
            set leu {}
            foreach e $leaves {
                if {[lsearch -exact $T($t,ue_lab) $e] != -1} {lappend leu $e}
            }
            Figuration::EUColorFgLeaf $t $leu $color
        }
        if {$S(supertreeColorSubtree)} {
            set peres  [Operation::FindFatherNode $t $leaves]
            foreach e $peres {Figuration::NodeColorFgTree $t $e $color}
        }
    }
    #
    proc ColorPartielGo {w} {
        global S T
        # les partielles = TOUT - (les communes + les specifiques)
        set AlistWinTree  [Selection::TreeTar]
        if {$AlistWinTree == {}} {
            tk_messageBox -message "No Tree selected" -type ok; return
        } else  {
            # COMMUNES
            set ll {} ;# liste de liste de feuilles
            set lt {} ;# liste des trees
            foreach {w t} $AlistWinTree {
                lappend ll $T($t,ue_lab)
                lappend lt $t
            }
            set lcommunes [Tools::operatorANDll $ll]
            # SPECIFIQUES
            foreach t $lt {
                set lfeuillesautres {}
                foreach ti $lt {
                    if {$ti != $t} {
                        #lappend lfeuillesautres $T($ti,ue_lab)
                        set lfeuillesautres [concat $lfeuillesautres $T($ti,ue_lab)]
                    }
                }
                set lfeuillesautres [Tools::DelRep $lfeuillesautres]
                # on retire de x la liste des autres feuilles
                set lspe [Tools::SousL $T($t,ue_lab) $lfeuillesautres]
                # TOUT - (les communes + les specifiques)
                set l1 [Tools::SousL $T($t,ue_lab) $lspe]
                set l2 [Tools::SousL $l1 $lcommunes]
                FigurationSPU $t $l2 $S(supertreeColorPartiel)
            }
        }
    }
    #
    proc ColorUniverselGo {w} {
        global S T
        set AlistWinTree  [Selection::TreeTar]
        if {$AlistWinTree == {}} {
            tk_messageBox -message "No Tree selected" -type ok; return
        } else  {
            set ll {} ;# liste de liste de feuilles
            foreach {w t} $AlistWinTree {
                lappend ll $T($t,ue_lab)
            }
            set lcommunes [Tools::operatorANDll $ll]
            foreach {w t} $AlistWinTree {
                FigurationSPU $t $lcommunes $S(supertreeColorUniversel)
            }
        }
    }
    proc ColorCopyPaste1 {w} {
        global S
        $w configure -background $S(col)
        set S(STColorCP1) $S(col)
    }
    proc ColorCopyPaste2 {w} {
        global S
        $w configure -background $S(col)
        set S(STColorCP2) $S(col)
    }
    proc ColorCopyPaste3 {w} {
        global S
        $w configure -background $S(col)
        set S(STColorCP3) $S(col)
    }
    proc ColorPresence {w} {
        global S
        $w configure -background $S(col)
        set S(supertreeColorPresence) $S(col)
    }
    #
    proc ColorAbsence {w} {
        global S
        $w configure -background $S(col)
        set S(supertreeColorAbsence) $S(col)
    }
    # construction de la matrice de symbole presence absence
    proc PresenceAbsenceMatrix {} {
        global S T
        set AlistWinTree  [Selection::TreeTar]
        if {$AlistWinTree == {}} {
            tk_messageBox -message "No Tree selected" -type ok; return
        } else  {
            # POUR l'instant en ligne les feuilles par ordre alpha
            # plus tard ajouter possibilte par classement universel/partiel/specifique
            set ll {} ;# liste de liste de feuilles
            set lt {} ;# liste des trees
            set lw {} ;# liste des fenetres
            foreach {w t} $AlistWinTree {
                set ll [concat $ll $T($t,ue_lab)]
                lappend  lw $w
                lappend lt $t
            }
            if {$S(supertreeAnnotTree)} {
                foreach t $lt {
                    MatrixAnnotateGoGo $t $lt
                }
            }
            if {$S(supertreeAnnotGlobalSPU)} {
                set ID [Tools::GenId]
                set ltot {}
                # COMMUNES
                set llspu {} ;# liste de liste de feuilles
                foreach t $lt {lappend llspu $T($t,ue_lab)}
                set lcommunes [Tools::operatorANDll $llspu]
                set ltot [concat $ltot $lcommunes]
                foreach t $lt {
                    set lfeuillesautres {}
                    foreach ti $lt {
                        if {$ti != $t} {
                            set lfeuillesautres [concat $lfeuillesautres $T($ti,ue_lab)]
                        }
                    }
                    set lfeuillesautres [Tools::DelRep $lfeuillesautres]
                    # on retire de x la liste des autres feuilles
                    set lspe [Tools::SousL $T($t,ue_lab) $lfeuillesautres]
                    set ltot [concat $ltot $lspe]
                }
                foreach t $lt {
                    set lfeuillesautres {}
                    foreach ti $lt {
                        if {$ti != $t} {
                            set lfeuillesautres [concat $lfeuillesautres $T($ti,ue_lab)]
                        }
                    }
                    set lfeuillesautres [Tools::DelRep $lfeuillesautres]
                    # on retire de x la liste des autres feuilles
                    set lspe [Tools::SousL $T($t,ue_lab) $lfeuillesautres]
                    # TOUT - (les communes + les specifiques)
                    set l1 [Tools::SousL $T($t,ue_lab) $lspe]
                    set l2 [Tools::SousL $l1 $lcommunes]
                    set ltot [concat $ltot $l2]
                }
                set ltot [Tools::DelRep $ltot]
                foreach w $lw {
                    set x 8
                    set y 8
                    foreach f $ltot {
                        set x 8
                        incr y 8
                        $w create text $x $y -text $f \
                                -anchor e -tags "SuperTreeM ST$ID "
                        foreach t $lt {
                            incr x 8
                            if {[lsearch -exact $T($t,ue_lab) $f] != -1} {
                                set color $S(supertreeColorPresence)
                            } else  {
                                set color $S(supertreeColorAbsence)
                            }
                            if {$S(supertreeAnnotTreeOutline)} {
                                $w create rectangle [expr $x -2 ] [expr $y - 2] [expr $x  +2] [expr $y +2 ] \
                                        -fill $color -tags "SuperTreeM ST$ID "
                            } else  {
                                $w create rectangle [expr $x -2 ] [expr $y - 2] [expr $x  +2] [expr $y +2 ] \
                                        -fill $color -outline $color -tags "SuperTreeM ST$ID "
                            }
                        }
                    }
                }
            }
            if {$S(supertreeAnnotGlobal)} {
                set ID [Tools::GenId]
                set lftout [lsort -dictionary [Tools::DelRep $ll]]
                foreach w $lw {
                    set x 8
                    set y 8
                    foreach f $lftout {
                        set x 8
                        incr y 8
                        $w create text $x $y -text $f \
                                -anchor e -tags "SuperTreeM ST$ID "
                        foreach t $lt {
                            incr x 8
                            if {[lsearch -exact $T($t,ue_lab) $f] != -1} {
                                set color $S(supertreeColorPresence)
                            } else  {
                                set color $S(supertreeColorAbsence)
                            }
                            if {$S(supertreeAnnotTreeOutline)} {
                                $w create rectangle [expr $x -2 ] [expr $y - 2] [expr $x  +2] [expr $y +2 ] \
                                        -fill $color -tags "SuperTreeM ST$ID "
                            } else  {
                                $w create rectangle [expr $x -2 ] [expr $y - 2] [expr $x  +2] [expr $y +2 ] \
                                        -fill $color -outline $color -tags "SuperTreeM ST$ID "
                            }
                            
                        }
                    }
                }
            }
        }
    }
    # ti arbre en annotation
    # ltx arbres en comparaison, chaque arbre = 1 colonne
    proc MatrixAnnotateGoGo {ti ltx} {
        global S  T
        set w $S($ti,w)
        set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
        set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
        set XMAX3 [lindex [$w bbox [list T$ti && AnnotMatrix]] 2]
        if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
        if {$XMAX < $XMAX3} {set XMAX $XMAX3 }
        if [catch {expr $S($ti,LabelMatrixBase) + $S(TabulationAnnot)} result] {
            set S($ti,LabelMatrixBase) $S(TabulationAnnot)
        } else  {
            set S($ti,LabelMatrixBase) $result
        }
        set x [expr $XMAX + $S($ti,LabelMatrixBase)]
        set colnumber 0
        foreach tx $ltx {
            if {$ti != $tx} {
                incr colnumber 1
                incr x 6
                set dx [expr 4 / 2]
                set dy [expr 4 / 2]
                # tag de colonne
                set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                foreach l $T($ti,ue_lab) {
                    # recherche y
                    set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$ti]]
                    if {$item == ""} {
                        set items [$w find withtag [list ADD¶$l && T$ti]]
                        set y 0
                        foreach ii $items {
                            set yii [lindex [$w coords $ii] 1]
                            if {$yii >= $y} {
                                set y $yii
                            }
                        }
                    } else  {
                        set co [$w coords $item]
                        set y [lindex $co 1]
                    }
                    if {[lsearch -exact $T($tx,ue_lab) $l] != -1 } {
                        set color $S(supertreeColorPresence)
                    } else  {
                        set color $S(supertreeColorAbsence)
                    }
                    # coordonnees
                    if {$S(supertreeAnnotTreeOutline)} {
                        $w create rectangle [expr $x-$dx] [expr $y-$dy] [expr $x+$dx] [expr $y+$dy] \
                                -fill $color -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo NBC$colnumber"
                    } else  {
                        $w create rectangle [expr $x-$dx] [expr $y-$dy] [expr $x+$dx] [expr $y+$dy] -outline $color \
                                -fill $color -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo NBC$colnumber"
                    }
                }
            }
        }
    }
    
    ###
    proc RemoveKeepOnlyUniversal {} {
        global S T
        set AlistWinTree  [Selection::TreeTar]
        if {$AlistWinTree == {}} {
            tk_messageBox -message "No Tree selected" -type ok; return
        } else  {
            set ll {} ;# liste de liste de feuilles
            foreach {w t} $AlistWinTree {
                lappend ll $T($t,ue_lab)
            }
            set lcommunes [Tools::operatorANDll $ll]
            set lnewick {}
            foreach {w t} $AlistWinTree {
                set s $T($t,nwk,$t)
                #on supprime tous les nombres
                regsub -all {[0-9]+.[0-9]+} $s "" s
                regsub -all : $s "" s
                #regsub -all {:1.0} $s ""  s
                #regsub -all {:0.0} $s ""  s
                # pour chaque tree, extraire la liste des feuilles a supprimer
                set lfsupp [Tools::SousL $T($t,ue_lab) $lcommunes]
                foreach i $lfsupp {
                    set index  [string first [format "%s%s%s" ( $i ,] $s]
                    if {$index != -1} {
                        # cas "(a,"
                        set indexParentFermante [OpenIndex [string range $s $index end] $index ]
                        set indexvirgule [expr $index  + [string length $i] + 1]
                        set brasdroit [string range $s [expr $indexvirgule + 1] [expr $indexParentFermante -1]]
                        # rendre bras droit dichotomique
                        
                        if {[ImportExport::Dicho $brasdroit] == 1} {
                            set brasdroit [format "%s%s%s" ( $brasdroit )]
                        }
                        
                        set s [string replace $s $index $indexParentFermante $brasdroit]
                    } else  {
                        set index  [string first [format "%s%s%s" , $i )] $s]
                        if {$index != -1} {
                            # cas ",a)"
                            set ii [expr $index + [string length $i] +1]
                            set indexParentOuvrante [CloseIndex [string range $s 0 $ii] $ii]
                            set brasgauche [string range $s [expr $indexParentOuvrante +1 ] [expr $index -1]]
                            if {[ImportExport::Dicho $brasgauche] == 1} {
                                set brasgauche [format "%s%s%s" ( $brasgauche )]
                            }
                            set s [string replace $s $indexParentOuvrante $ii $brasgauche]
                        } else  {
                            set index  [string first [format "%s%s%s" , $i ,] $s]
                            if {$index != -1} {
                                # cas ,a,
                                set s [string replace $s $index [expr $index + [string length $i]] ""]
                            } else  {
                                
                            }
                        }
                    }
                }
                set lnewick [concat  [format "%s%s" $s ";"] $lnewick ]
            }
            if {$S(supertreeRemDisplay)} {Display $lnewick }
            if {$S(supertreeRemFile)} {SaveNewick $lnewick}
        }
    }
    proc Recnettoage {s} {
        if {[string first ,, $s] != -1 } {
            regsub -all ,, $s , s
            Recnettoage $s
        } else  {
            return $s
        }
    }
    proc OpenIndex {s if} {
        set i 0 ; set id $if
        foreach c [split $s {}] {
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
            }
            if {$i == 0} {return $id}
            incr id
        }
    }
    proc CloseIndex {s if} {
        set lreverse [Lreverse [split $s {}]]
        set i 0 ; set id 0
        foreach c $lreverse {
            switch -exact -- $c {
                ) {incr i}
                ( {incr i -1}
            }
            if {$i == 0} {return [expr $if - $id]}
            incr id
        }
    }
    proc Lreverse {l} {
        set lout {}
        foreach e $l {
            set lout [concat $e $lout]
        }
        return $lout
    }
    
    # shift M1 retour normale Figuration::NodeLineDashToolbox %W 0
    # ajout icone pour arbre multiple
    proc stcollapse {w x y} {
        Figuration::NodeLineDashToolbox $w 1
        
        
    }
    proc stdelete   {w x y} {
        Figuration::FontOverstrike $w
    }
    proc stcollapsemulti {w x y} {
        global S
        set S(operation) nodedashOn
        Reflection::Transition-I $w
        
    }
    proc stdeletemulti   {w x y} {
        global S
        set S(gfo) {Arial 8 overstrike}
        set S(operation) leaffontglob
        Reflection::Transition-I $w
    }
    # copy and paste as node
    proc stcopinsertnode  {w x y} {
        global S
        set S(col) $S(STColorCP1)
        Connection $w
        
    }
    # copy and paste as polytomy
    proc stcopinsertpoly {w x y} {
        global S
        set S(col) $S(STColorCP2)
        Connection $w
    }
    # copy and paste, replace
    proc stcopreplace  {w x y} {
        global S
        set S(col) $S(STColorCP3)
        Connection $w
    }
    proc Connection {w {id ""} } {
        global B S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if {$id == ""} {
                set id [Tools::GenId]
                # tree
                set B(CONtre,$id) {}
                # node
                set B(CONnod,$id) {}
                # note (also query from identification)
                set B(CONnot,$id) [list $id]
                #
                lappend S($w,con) $id
            }
            set nodeindex [lsearch -exact $B(CONnod,$id) $n]
            if {$nodeindex == -1} {
                # liste node connectes
                lappend B(CONnod,$id) $n
                if {[lsearch -exact $B(CONtre,$id) $t] == -1} {
                    lappend B(CONtre,$id) $t
                }
                bindtags $w [list connect $w Canvas . all]
                bind connect <Button-1> "Reflection::Connection %W $id"
                bind connect <Double-Button-1> "Reflection::UpdateLinkStop %W $t $id"
                bind connect <Motion> "Reflection::UpdateLink %W $t $id %x %y"
            } else  {
                # selectioner un node deja dans le reseau signifie qu'on le retire
                # on le retire
                set B(CONnod,$id)  [concat [lrange $B(CONnod,$id) 0 [expr $nodeindex - 1]] \
                        [lrange $B(CONnod,$id) [expr $nodeindex + 1] end]]
                #
                bindtags $w [list connect $w Canvas . all]
                #bindtags $w [list $S(tool) $w Canvas . all]
                #
                bind connect <Button-1> "Reflection::Connection %W $id"
                bind connect <Double-Button-1> "Reflection::UpdateLinkStop %W $t $id"
                bind connect <Motion> "Reflection::UpdateLink %W $t $id %x %y"
                $w bind Connect <Any-Enter> "$w config -cursor hand2"
                $w bind Connect <Any-Leave> "$w config -cursor top_left_arrow"
            }
        }
    }
    
    # delete
    proc ConnectorDelete  {w id} {
        global B S
        # nettoyage canvas
        $w delete [format "%s%s%s" Connect ¶ $id]
        $w delete [format "%s%s%s" ConIconTag ¶ $id]
        # nettoyage array B
        unset B(CONtre,$id)
        unset B(CONnod,$id)
        unset B(CONnot,$id)
        # retrait
        set index [lsearch -exact $S($w,con) $id]
        set S($w,con) [concat [lrange $S($w,con) 0 [expr $index - 1]] \
                [lrange $S($w,con) [expr $index + 1] end]]
    }
    
    ### voir modifications pour network en etoile
    proc UpdateLink {w t id xmouse ymouse} {
        global B S
        set lcoords {}
        foreach n $B(CONnod,$id) {
            set co [$w coords $n]
            lappend lcoords [lindex $co 0] [lindex $co 1]
        }
        lappend lcoords [$w canvasx [expr $xmouse -5] ] [$w canvasy [expr $ymouse -5 ]
        # prise en compte figuration preexistante
        set j [format "%s%s%s"  Connect ¶ $id ]
        if {[$w find withtag $j] != ""} {
            set width_line [lindex [$w itemconfigure $j -width] end]
            set dash_line [lindex [$w itemconfigure $j -dash] end]
            set color_line [lindex [$w itemconfigure $j -fill] end]
        } else  {
            set width_line 1
            set dash_line {2 2}
            set color_line $S(col)
        }
        $w delete $j
        if {$lcoords != {} } {
            $w create line  $lcoords -width $width_line -fill $color_line -dash $dash_line \
                    -tags "Connect [format "%s%s%s"  Connect ¶ $id ]  "
        }
        $w lower Connect
    }
    #
    proc UpdateLinkStop {w t id} {
        global B
        set lcoords {}
        foreach n $B(CONnod,$id) {
            set co [$w coords $n]
            lappend lcoords [lindex $co 0] [lindex $co 1]
        }
        set j [format "%s%s%s"  Connect ¶ $id ]
        set width_line [lindex [$w itemconfigure $j -width] end]
        set dash_line [lindex [$w itemconfigure $j -dash] end]
        set color_line [lindex [$w itemconfigure $j -fill] end]
        $w delete $j
        if {[llength $lcoords] != 2 } {
            $w create line  $lcoords -fill $color_line -dash $dash_line -width $width_line \
                    -tags "Connect $j"
        }
        bind connect <Button-1> "Reflection::Connection %W"
        # mise a nil pour le reste
        bind connect <Motion> ""
        bind connect <Double-Button-1> ""
    }
    proc preBuilding {mode} {
        global S
        set transa $S(supertreeConsDisplaySameWindow)
        set transb $S(supertreeConsDisplayNewWindow)
        set transc $S(supertreeConsFile)
        switch -exact $mode {
            a {
                # Display as same window
                set S(supertreeConsDisplaySameWindow) 1
                set S(supertreeConsDisplayNewWindow) 0
                set S(supertreeConsFile) 0
                Building
            }
            b {
                # Display as new window
                set S(supertreeConsDisplaySameWindow) 0
                set S(supertreeConsDisplayNewWindow) 1
                set S(supertreeConsFile) 0
                Building
            }
            c {
                # Save Newick strings
                set S(supertreeConsDisplaySameWindow) 0
                set S(supertreeConsDisplayNewWindow) 0
                set S(supertreeConsFile) 1
                Building
            }
        }
        set S(supertreeConsDisplaySameWindow) $transa
        set S(supertreeConsDisplayNewWindow) $transb
        set S(supertreeConsFile) $transc
    }
    proc Building {} {
        global S T B
        set AlistWinTree  [Selection::TreeTar]
        if {$AlistWinTree == {}} {
            tk_messageBox -message "No Tree selected" -type ok; return
        } else  {
            # B(CONtre,$id)
            # B(CONnod,$id)
            # B(CONnot,$id)
            # S($w,con)
            set lw {}
            foreach {w t} $AlistWinTree {
                set lw [concat $lw $w]
            }
            set lwClean [Tools::DelRep $lw]
            foreach wi $lwClean {
                set ln $S($w,con)
                if {$ln != {}} {
                    foreach id $ln {
                        set j [format "%s%s%s"  Connect ¶ $id ]
                        set color [$w itemconfigure $j -fill]
                        # ATTENTION
                        # set s ((a,b),c,(d,e))
                        # set n (a,b)
                        # regsub $n $s x t
                        # puts $t
                        # ((x),c,(d,e))
                        #        set S(STColorCP1) blue
                        #        set S(STColorCP2) red
                        #        set S(STColorCP3) green
                        #puts "LA COULEUR [lindex $color end]"
                        #puts "$S(STColorCP1)  $S(STColorCP2)  $S(STColorCP3)"
                        if {[lindex $color end] == $S(STColorCP1)} {
                            # COPY & INSERT AS NODE
                            set nodeFrom [lindex $B(CONnod,$id) 0]
                            set nodeTo [lrange $B(CONnod,$id) 1 end]
                            # NodeFrom
                            # newickFrom est le node "propre" (topologie seuleument) A INSERER
                            regexp {[0-9]+} $nodeFrom tfrom
                            regsub -all {[0-9]+.[0-9]+} $T($tfrom,nwk,$nodeFrom) "" newickFrom
                            regsub -all : $newickFrom "" newickFrom
                            # les NodeTo
                            foreach ni $nodeTo {
                                # NWKI est le node "propre" (toplogie seuleument) A MODIFIER
                                regexp {[0-9]+} $ni tTo
                                regsub -all {[0-9]+.[0-9]+} $T($tTo,nwk,$ni) "" nwki
                                regsub -all : $nwki "" nwki
                                set newnwk [format "%s%s%s" $nwki "," $newickFrom ]
                                # MERE est la chaine newick totale propre (topologie seuleument)
                                if [catch {set exist $C($tTo,NewNewick)} nwk] {
                                    regsub -all {[0-9]+.[0-9]+} $T($tTo,nwk,$tTo) "" mere
                                    regsub -all : $mere "" mere
                                } else  {
                                    set mere $nwk
                                }
                                # PROCESSUS FINAL d'insertion
                                # attention
                                #  set s (a,(b,c)) ; regsub (b,c) $s x t ; puts $t => (a,(x))
                                # le regsub ne prend pas en compte les () de la chaine a remplacer
                                # il faut regsub {\(b,c\)} $s x t ; puts $t => (a,x)
                                # donc tel que ca fct si on target un node
                                # si on cible une feuille : on reste en polytomy
                                # donc test suivant si une feuille on met () sur $newnwk
                                # pour corriger le fait qu'elles ne sont pas prises en compte
                                # avec regsub sur $nwki
                                if {[string match *,* $nwki] != 1} {
                                    regsub $nwki $mere [format "%s%s%s" {\(} $newnwk {\)} ] C($tTo,NewNewick)
                                } else  {
                                    regsub $nwki $mere $newnwk C($tTo,NewNewick)
                                }
                            }
                            # construction de la liste des nouvelles chaines pour post-traitement (affichage, stockage)
                            set lnewick {}
                            foreach {key value} [array get C *,NewNewick] {
                                set lnewick [concat  [format "%s%s" $value ";"] $lnewick ]
                            }
                            # variables a faire
                            if {$S(supertreeConsDisplayNewWindow)} {Display $lnewick }
                            if {$S(supertreeConsDisplaySameWindow)} {DisplaySame $wi $lnewick }
                            if {$S(supertreeConsFile)} {SaveNewick $lnewick}
                            # nettoyage
                            unset C
                        } elseif {[lindex $color end] == $S(STColorCP2)} {
                            # COPY & INSERT AS POLYTOMY
                            set nodeFrom [lindex $B(CONnod,$id) 0]
                            set nodeTo [lrange $B(CONnod,$id) 1 end]
                            # NodeFrom
                            regexp {[0-9]+} $nodeFrom tfrom
                            regsub -all {[0-9]+.[0-9]+} $T($tfrom,nwk,$nodeFrom) "" newickFrom
                            regsub -all : $newickFrom "" newickFrom
                            # les NodeTo
                            foreach ni $nodeTo {
                                regexp {[0-9]+} $ni tTo
                                regsub -all {[0-9]+.[0-9]+} $T($tTo,nwk,$ni) "" nwki
                                regsub -all : $nwki "" nwki
                                set newnwk [format "%s%s%s" $nwki "," $newickFrom ]
                                if [catch {set exist $C($tTo,NewNewick)} nwk] {
                                    regsub -all {[0-9]+.[0-9]+} $T($tTo,nwk,$tTo) "" mere
                                    regsub -all : $mere "" mere
                                } else  {
                                    set mere $nwk
                                }
                                # modif la chaine $nwki a remplacer doit etre du format {\(x,y\)}
                                # pour que le regsub supprime bien les ( et )
                                # NON regsub $nwki $mere [string range $newnwk 1 end-1] C($tTo,NewNewick) pb si feuille
                                regsub {\(} $nwki {\(} nwki
                                regsub {\)} $nwki {\)} nwki
                                regsub $nwki $mere $newnwk C($tTo,NewNewick)
                                
                            }
                            #
                            set lnewick {}
                            foreach {key value} [array get C *,NewNewick] {
                                set lnewick [concat  [format "%s%s" $value ";"] $lnewick ]
                            }
                            # variables a faire
                            if {$S(supertreeConsDisplayNewWindow)} {Display $lnewick }
                            if {$S(supertreeConsDisplaySameWindow)} {DisplaySame $wi $lnewick }
                            if {$S(supertreeConsFile)} {SaveNewick $lnewick}
                            # nettoyage
                            unset C
                        } elseif {[lindex $color end] == $S(STColorCP3)} {
                            # COPY & REPLACE
                            set nodeFrom [lindex $B(CONnod,$id) 0]
                            set nodeTo [lrange $B(CONnod,$id) 1 end]
                            # NodeFrom
                            regexp {[0-9]+} $nodeFrom tfrom
                            regsub -all {[0-9]+.[0-9]+} $T($tfrom,nwk,$nodeFrom) "" newickFrom
                            regsub -all : $newickFrom "" newickFrom
                            # les NodeTo
                            foreach ni $nodeTo {
                                regexp {[0-9]+} $ni tTo
                                regsub -all {[0-9]+.[0-9]+} $T($tTo,nwk,$ni) "" nwki
                                regsub -all : $nwki "" nwki
                                # ici
                                set newnwk $newickFrom
                                if [catch {set exist $C($tTo,NewNewick)} nwk] {
                                    regsub -all {[0-9]+.[0-9]+} $T($tTo,nwk,$tTo) "" mere
                                    regsub -all : $mere "" mere
                                } else  {
                                    set mere $nwk
                                }
                                regsub {\(} $nwki {\(} nwki
                                regsub {\)} $nwki {\)} nwki
                                regsub $nwki $mere $newnwk C($tTo,NewNewick)
                            }
                            #
                            set lnewick {}
                            foreach {key value} [array get C *,NewNewick] {
                                set lnewick [concat  [format "%s%s" $value ";"] $lnewick ]
                            }
                            # variables a faire
                            if {$S(supertreeConsDisplayNewWindow)} {Display $lnewick }
                            if {$S(supertreeConsDisplaySameWindow)} {DisplaySame $wi $lnewick }
                            if {$S(supertreeConsFile)} {SaveNewick $lnewick}
                            # nettoyage
                            unset C
                        }
                    }
                }
            }
        }
    }
}
################################################################################


################################################################################
# AMELIE
################################################################################
namespace eval Amelie {
    
    
    #
    proc Toolboxfaiadd {w x y} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if {[winfo exists $w.d3faiadd ] == 1} {destroy $w.d3faiadd}
            set m [menu $w.d3faiadd -tearoff 0]
            faiaddMenu $w $t $n $m $x $y
            tk_popup $m [winfo pointerx $w] [winfo pointery $w]
        }
    }
    #
    proc Toolboxfairem {w x y} {
        global T S
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            if {[winfo exists $w.d3fairem ] == 1} {destroy $w.d3fairem}
            set m [menu $w.d3fairem -tearoff 0]
            fairemMenu $w $t $n $m $x $y
            tk_popup $m [winfo pointerx $w] [winfo pointery $w]
        }
    }
    #
    proc ToolboxArcx {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set S(mox) $x
            set S(moy) $y
            set tags [$w gettags $id]
            set tag [lindex $tags [lsearch -glob $tags ARCU*]]
            if {$tag != ""} {
                #bind arcx <B1-Motion> "Amelie::ToolboxArcxMotion %W %x %y $tag"
                bind arcx <B1-Motion> "Amelie::ToolboxArcxMotion %W %x %y current"
            }
        }
    }
    #
    proc ToolboxArcxMotion {w x y tag} {
        global S T
        $w move $tag [expr $x - $S(mox)] 0
        set S(mox) $x
        set S(moy) $y
        update
    }
    #
    proc ToolboxFaix {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set S(mox) $x
            set S(moy) $y
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags Arc] != -1} {
                set tag [lindex $tags [lsearch -glob $tags COL¶*]]
                bind faix <B1-Motion> "Amelie::ToolboxFaixMotion %W %x %y $tag"
            }
        }
    }
    #
    proc ToolboxFaixMotion {w x y tag} {
        global S T
        $w move $tag [expr $x - $S(mox)] 0
        #$w move $tag [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
        update
    }
    #
    proc ToolboxSelx {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set S(mox) $x
            set S(moy) $y
            set tags [$w gettags $id]
            if  {[lsearch -exact $tags Arc] != -1} {
                set tag [lindex $tags [lsearch -glob $tags SEL¶*]]
                bind selx <B1-Motion> "Amelie::ToolboxSelxMotion %W %x %y $tag"
            }
        }
    }
    #
    proc ToolboxSelxMotion {w x y tag} {
        global S T
        $w move $tag [expr $x - $S(mox)] 0
        #$w move $tag [expr $x - $S(mox)] [expr $y - $S(moy)]
        set S(mox) $x
        set S(moy) $y
        update
    }
    #
    proc ToolboxArccour {w x y} {
        global S
        set id [$w find withtag current]
        if {[$w type $id] == "line"} {
            
            if  {$id == ""} {set id [$w find closest $x $y]}
            if  {$id != ""} {
                set S(mox) $x
                set S(moy) $y
                set tags [$w gettags $id]
                
                set tag [lindex $tags [lsearch -glob $tags ARCU*]]
                if {$tag != ""} {
                    #bind arccour <B1-Motion> "Amelie::ToolboxArccourMotion %W %x %y $tag"
                    bind arccour <B1-Motion> "Amelie::ToolboxArccourMotion %W %x %y current"
                }
            }
        } else  {
            bind arccour <B1-Motion> ""
        }
    }
    #
    proc ToolboxArccourMotion {w x y id} {
        global S
        set tags [$w gettags $id]
        set co [$w coords $id]
        set x1 [lindex $co 0]
        set y1 [lindex $co 1]
        set x2 [lindex $co end-1]
        set y2 [lindex $co end]
        set color [lindex [$w itemconfigure $id -fill] end]
        set width [lindex [$w itemconfigure $id -width] end]
        $w delete $id
        set ymoy  [expr ($y1+$y2)/2]
        if {$y >= $ymoy} {
            set ymid [expr $y + abs($ymoy - $y)]
        } else  {
            set ymid [expr $y - abs($ymoy - $y)]
        }
        $w create line $x1 $y1 [expr $x + abs($x1 - $x)] $ymid $x2 $y2 \
                -width $width -smooth 1 -splinesteps 100 -fill $color -tags $tags
        update idletasks
    }
    #
    proc ToolboxArccol {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            set tag [lindex $tags [lsearch -glob $tags ARCU*]]
            if {$tag != ""} {
                #$w itemconfigure $tag -fill $S(col)
                $w itemconfigure current -fill $S(col)
            }
        }
    }
    #
    proc ToolboxFaicol {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            set tag [lindex $tags [lsearch -glob $tags COL¶*]]
            $w itemconfigure $tag -fill $S(col)
        }
    }
    proc ToolboxSelcol {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            set tag [lindex $tags [lsearch -glob $tags SEL¶*]]
            $w itemconfigure $tag -fill $S(col)
        }
    }
    #
    proc ToolboxArcdel {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            set tag [lindex $tags [lsearch -glob $tags ARCU*]]
            if {$tag != ""} {
                #$w delete $tag
                $w delete current
            }
        }
    }
    #
    proc ToolboxFaidel {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            set tag [lindex $tags [lsearch -glob $tags COL¶*]]
            $w delete $tag
        }
    }
    #
    proc ToolboxSeldel {w x y} {
        global S
        set id [$w find withtag current]
        if  {$id == ""} {set id [$w find closest $x $y]}
        if  {$id != ""} {
            set tags [$w gettags $id]
            set tag [lindex $tags [lsearch -glob $tags SEL¶*]]
            $w delete $tag
        }
    }
    #
    proc fairemMenu {w t n m x y} {
        global T S
        set euls [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        set database $S(database)
        set variables [Database::dbQueryVarAll $database]
        foreach variable $variables {
            set mm [format "%s%s%s" $m . [string tolower $variable]]
            $m add cascade -label "$variable" -menu $mm
            menu $mm -tearoff 0
            set linter {}
            set li {}
            foreach eu $euls {
                set records [Database::dbQueryRecordsFromVarVal $database EU $eu]
                set values [Database::dbQueryVarFromRecords $database $variable $records]
                set linter [concat $linter " $values"]
                #lappend linter $values
                set i [format "%s%s%s" $eu : $values ]
                lappend li $i
                $mm add command  -label $i -command "Amelie::fairemGo $w [list [list $i]]"
            }
            $mm add command -label All -command "Amelie::fairemGo $w [list $li]"
        }
    }
    #
    proc fairemGo {w lv} {
        foreach v $lv {
            set vsplit [split $v ":"]
            set l [lindex $vsplit 0]
            $w delete Arc$l
        }
    }
    #
    proc faiaddMenu {w t n m x y} {
        global T S
        set euls [Tools::NodeLeCoToRe $t [Tools::NodeNoToLe $t $n]]
        set database $S(database)
        set variables [Database::dbQueryVarAll $database]
        foreach variable $variables {
            set mm [format "%s%s%s" $m . [string tolower $variable]]
            $m add cascade -label "$variable" -menu $mm
            menu $mm -tearoff 0
            set linter {}
            set li {}
            foreach eu $euls {
                set records [Database::dbQueryRecordsFromVarVal $database EU $eu]
                set values [Database::dbQueryVarFromRecords $database $variable $records]
                set linter [concat $linter " $values"]
                #lappend linter $values
                set i [format "%s%s%s" $eu : $values ]
                lappend li $i
                $mm add command  -label $i -command "Amelie::faiaddGo1 [list [list $i]]"
            }
            $mm add command -label All -command "Amelie::faiaddGo1 [list $li]"
            $mm add separator
            $mm add command -label "Intersection:"
            set intersection [lsort -dictionary [Tools::operatorANDll $linter]]
            if {$intersection != ""} {
                foreach i $intersection {
                    $mm add command  -label $i -command "Amelie::faiaddGo2 $w $t $database $variable $i"
                }
            }
        }
    }
    #
    proc faiaddGo1 {lv} {
        global S
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        foreach v $lv {
            DrawGoAuto [list $v] $ltreetarget
        }
    }
    #
    proc faiaddGo1 {lv} {
        global S
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        foreach v $lv {
            DrawGoAuto [list $v] $ltreetarget
        }
    }
    #
    proc faiaddGo2 {w t database variable eu} {
        global S
        set records [Database::dbQueryRecordsFromVarVal $database EU $eu]
        set values [Database::dbQueryVarFromRecords $database $variable $records]
        set i [format "%s%s%s" $eu : $values ]
        faiaddGo1 [list $i]
    }
    #
    proc InteractionGraph {} {
        global S
        set S(AmelieColor) grey
        if {[winfo exists .amelie] == 1} {
            wm deiconify .amelie
        } else  {
            set w [toplevel .amelie]
            wm title $w "TreeIG"
            wm geometry .amelie 650x600
            wm protocol .amelie WM_DELETE_WINDOW {Amelie::PanelQuit}
            ### CONTROLS
            set w1 [frame .amelie.c]
            # button load annotations
            button $w1.l1 -text "Load annotations..." -command  "Amelie::AnnotateLoadLabel"
            # MENU choix Fichier de Label(s)
            iwidgets::optionmenu $w1.m1 -command "Amelie::AnnotateLabelsFileSwitch $w1.m1"
            foreach lf $S(ldatabase) {$w1.m1 insert end $lf}
            menubutton $w1.target -text "Tree(s)" -menu $w1.target.m -indicatoron 1 -direction below
            set z  [menu  $w1.target.m -tearoff 0]
            $z configure -postcommand "Database::TreeTarget $z"
            button  $w1.e -text "Exit" -command  "destroy .amelie"
            ### PACK CONTROLS
            pack   $w1.l1 $w1.m1  $w1.target $w1.e -side left -expand no
            ### PANED WINDOW
            iwidgets::panedwindow .amelie.p
            ### TOP tktable annotation
            .amelie.p add "top"
            set p1 [.amelie.p childsite "top"]
            iwidgets::tabnotebook $p1.n -width 200 -height 200  -tabpos n
            set p1t1 [$p1.n add -label "List" -compound left]
            set p1t2 [$p1.n add -label "Table" -compound left]
            $p1.n view "List"
            pack $p1.n -expand yes -fill both
            ### BOTTOM
            .amelie.p add "bottom"
            set p2 [.amelie.p childsite "bottom"]
            set pt [frame $p2.toolbox ]
            foreach {tool color} {faiadd ivory2 fairem ivory2 \
                        arccour ivory2 arcx ivory2 faix ivory2 selx ivory2 \
                        arccol ivory2 faicol ivory2 selcol ivory2 \
                        arcdel ivory2 faidel ivory2 seldel ivory2   } {
                radiobutton $pt.$tool -value $tool  -image TIM$tool \
                        -overrelief sunken -offrelief raised -selectcolor LightGoldenrodYellow \
                        -variable S(tool)  -indicatoron off -highlightthickness 0\
                        -background  $color -borderwidth 2
                pack $pt.$tool -side left
                bind $pt.$tool <Any-Enter> "Toolbox::balloonhelp_show $tool"
                bind $pt.$tool <Any-Leave> "Toolbox::balloonhelpCurrent"
            }
            pack $pt -expand no -anchor w
            iwidgets::tabnotebook $p2.n -width 200 -height 100 -tabpos n
            set p2t1 [$p2.n add -label "Manual" -compound left]
            set p3t1 [$p2.n add -label "Auto" -compound left]
            set p2t2 [$p2.n add -label "Classes" -compound left]
            $p2.n view "Manual"
            pack $p2.n -expand yes -fill both
            ### PACK
            pack $w1 -expand no
            .amelie.p fraction 60  40
            pack .amelie.p -expand yes -fill both
            # REMPLISSAGE P1T1
            # list Variables du fichier de label courant
            set wd [frame $p1t1.lfa]
            scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
            scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
            listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                    -width 8 -height 5 -selectmode extended
            grid $wd.l -row 0 -column 0 -sticky news
            grid $wd.yscroll -row 0 -column 1 -sticky ns
            grid $wd.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $wd 0 -weight 1
            grid columnconfigure $wd 0 -weight 1
            bind $wd.l <ButtonRelease> "Amelie::AnnotateAddItem $p1t1.lfa.l $p1t1.lfa2.l "
            set wd2 [frame $p1t1.lfa2]
            scrollbar $wd2.yscroll -bd 1 -command "$wd2.l yview"
            scrollbar $wd2.xscroll -bd 1 -orient horizontal -command "$wd2.l xview "
            listbox   $wd2.l -xscroll "$wd2.xscroll set" -yscroll "$wd2.yscroll set" \
                    -width 30 -height 5 -selectmode extended
            grid $wd2.l -row 0 -column 0 -sticky news
            grid $wd2.yscroll -row 0 -column 1 -sticky ns
            grid $wd2.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $wd2 0 -weight 1
            grid columnconfigure $wd2 0 -weight 1
            pack $p1t1.lfa -side left -expand yes -fill both
            #pack $p1t1.bselect -side left -expand no
            pack $p1t1.lfa2 -side left -expand yes -fill both
            set wcc [frame $p1t1.controls]
            iwidgets::entryfield $wcc.filter -width 8 -textvariable S(IGfilter)   \
                    -labeltext "Pattern:" -command "Amelie::PatternSelection $wd2.l"
            button $wcc.all -text "Select all" -command "$wd2.l selection set 0 end"
            pack $wcc.filter $wcc.all -side top
            pack $wcc -side left
            
            # MODE REMPLISSAGE  manual
            set p [frame $p2t1.c]
            # variable graphic
            iwidgets::Labeledframe $p.user -labelpos nw -labeltext "Graphical variables"
            set p1 [$p.user childsite]
            button $p1.color -text "Color" -background $S(col) -command "Amelie::userColor $p1.color"
            iwidgets::entryfield $p1.tabul  -labeltext "Tabulation" -width 5 -textvariable S(IGtabul) -labelpos w
            iwidgets::entryfield $p1.curve  -labeltext "Curve" -width 5 -textvariable S(IGcurve) -labelpos w
            iwidgets::entryfield $p1.line   -labeltext "Line" -width 5 -textvariable S(IGline) -labelpos w
            pack $p1.color $p1.tabul $p1.curve $p1.line -side top -expand yes -fill x
            # draw
            iwidgets::Labeledframe $p.controls -labelpos nw -labeltext "Draw"
            set p3 [$p.controls childsite]
            button $p3.b1 -text "Only the selection" -command "set S(IGmode) user ; Amelie::Draw only"
            button $p3.b2 -text "Remove the selection" -command "set S(IGmode) user ;Amelie::Draw rem"
            button $p3.b3 -text "Add the selection" -command "set S(IGmode) user ;Amelie::Draw add"
            button $p3.b4 -text "Clear" -command "set S(IGmode) user ; Amelie::Draw clear"
            checkbutton $p3.b5 -text "Add text" -variable  S(IGannot)
            pack $p3.b1 $p3.b2 $p3.b3 $p3.b4 $p3.b5 -side top -expand 1 -fill x
            pack  $p.user $p.controls  -side left -expand yes -fill x
            pack $p -expand 1 -fill both
            
            # MODE REMPLISSAGE  auto
            set pauto [frame $p3t1.c]
            # variable graphic
            iwidgets::Labeledframe $pauto.user -labelpos nw -labeltext "Graphical variables"
            set p3 [$pauto.user childsite]
            checkbutton $p3.color -text "Color"  -variable S(IGcolorAutocheck)
            iwidgets::entryfield $p3.tabulincr  -labeltext "Increment: " -width 5 -textvariable S(IGtabulAuto) -labelpos w
            iwidgets::entryfield $p3.curveincr  -labeltext "Increment: " -width 5 -textvariable S(IGcurveAuto) -labelpos w
            checkbutton $p3.tabul  -text "Tabulation"  -variable S(IGtabulAutocheck)
            checkbutton $p3.curve  -text "Curve"  -variable S(IGcurveAutocheck)
            checkbutton $p3.line   -text "Line"  -variable S(IGlineAutocheck)
            grid $p3.color -row 0 -column 0 -sticky w
            grid $p3.tabul -row 1 -column 0 -sticky w
            grid $p3.tabulincr -row 1 -column 1 -sticky w
            grid $p3.curve -row 2 -column 0 -sticky w
            grid $p3.curveincr  -row 2 -column 1 -sticky w
            grid  $p3.line -row 3 -column 0 -sticky w
            #pack $p3.color $p3.tabul $p3.curve $p3.line -side top -expand 1 -anchor w
            # draw
            iwidgets::Labeledframe $pauto.controls -labelpos nw -labeltext "Draw"
            set p4 [$pauto.controls childsite]
            button $p4.b1 -text "Only the selection" -command "set S(IGmode) auto ; Amelie::Draw only"
            button $p4.b2 -text "Remove the selection" -command "set S(IGmode) auto ;Amelie::Draw rem"
            button $p4.b3 -text "Add the selection" -command "set S(IGmode) auto ;Amelie::Draw add"
            button $p4.b4 -text "Clear" -command "set S(IGmode) auto ; Amelie::Draw clear"
            checkbutton $p4.b5 -text "Add text" -variable  S(IGannot)
            pack $p4.b1 $p4.b2 $p4.b3 $p4.b4 $p4.b5 -side top -expand 1 -fill x
            pack  $pauto.user $pauto.controls  -side left -expand yes -fill x
            pack $pauto -expand 1 -fill both
            
            # REMPLISSAGE classes
            set S(IGmode) user
            set S(IGtabul) 50
            set S(IGcurve) 150
            set S(IGline) 1
            set S(IGannot) 0
            set S(IGcolorAuto) black
            set S(IGtabulAuto) 5
            set S(IGcurveAuto)  2
            set S(IGlineAuto) 1
            set S(IGcolorAutocheck) 1
            set S(IGtabulAutocheck) 0
            set S(IGcurveAutocheck)  1
            set S(IGlineAutocheck) 0
            set S(ClassMethod) ?
            PanelDeffClass $p2t2
            # draw
            iwidgets::Labeledframe $p2t2.controls -labelpos nw -labeltext "Draw"
            set p3 [$p2t2.controls childsite]
            button $p3.b1 -text "Only the selection" -command "set S(IGmode) clas ; Amelie::Draw only"
            button $p3.b2 -text "Remove the selection" -command "set S(IGmode) clas ;Amelie::Draw rem"
            button $p3.b3 -text "Add the selection" -command "set S(IGmode) clas ;Amelie::Draw add"
            button $p3.b4 -text "Clear" -command "set S(IGmode) clas ;Amelie::Draw clear"
            checkbutton $p3.b5 -text "Add text" -variable  S(IGannot)
            pack $p3.b1 $p3.b2 $p3.b3 $p3.b4 $p3.b5 -side top -expand 1 -fill x
            pack $p2t2.dc $p2t2.controls  -side left -expand yes -fill x
            pack $p2t2
        }
    }
    #
    proc userColor {id} {
        global S
        set S(col) [tk_chooseColor]
        $id configure -background $S(col)
    }
    #
    proc PatternSelection {w} {
        global S
        $w selection clear 0 end
        set litems [$w get 0 end]
        set id 0
        foreach i $litems {
            set leaf [lindex [split $i :] 0]
            if {[string match $S(IGfilter) $leaf]} {$w selection set $id }
            incr id
        }
        $w yview [lindex [$w curselection] 0]
    }
    #
    proc PanelDeffClass {w} {
        global S T
        frame $w.dc -relief raised -borderwidth 2
        puts $w.dc
        # panel controls
        set fc [frame $w.dc.co]
        button $w.dc.co.add -text "Add a Class" -relief groove -command "Amelie::AddClassCAP $w.dc.fd.ca"
        menubutton $w.dc.co.var -text Method -relief groove -menu $w.dc.co.var.m -direction below -indicatoron 1
        set zc  [menu  $w.dc.co.var.m -tearoff 0]
        $zc add radio -label "Level" -variable S(ClassMethod) -value level -command "Amelie::DeffClassVar1 $w.dc.fd.ca"
        $zc add radio -label "Distance" -variable S(ClassMethod) -value distance -command "Amelie::DeffClassVar2 $w.dc.fd.ca"
        pack $w.dc.co.var $w.dc.co.add  -side left
        # panel graphic
        set fd [frame $w.dc.fd]
        set canvasw 500.0
        set canvash 100.0
        set c [canvas $w.dc.fd.ca -background LightGoldenrodYellow -borderwidth 1 \
                -width $canvasw -height $canvash]
        pack $w.dc.fd.ca
        
        $c bind FL <Button-1> {Amelie::MoveStart %W %x %y}
        $c bind FL <B1-Motion> {Amelie::Move %W %x %y}
        $c bind FL <Button-3> {Amelie::ClassM3 %W %x %y}
        
        $c bind FL2 <Button-1> {Amelie::MoveStart2 %W %x %y}
        $c bind FL2 <B1-Motion> {Amelie::Move2 %W %x %y}
        $c bind FL2 <Button-3> {Amelie::ClassM3 %W %x %y}
        # packing
        pack $w.dc.co  $w.dc.fd -side top
    }
    proc AddClassCAP {c} {
        global S
        switch -- $S(ClassMethod) {
            level {Amelie::AddClass $c}
            distance {Amelie::AddClass2 $c}
        }
    }
    
    #
    proc DeffClassVar1 {c} {
        global S T
        $c delete all
        $c create line 0 50 500 50
        # tree target
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        #MIN / MAX
        set MIN 0
        set MAX 0
        foreach t $ltreetarget  {
            if {$T($t,tot) >= $MAX} {set MAX $T($t,tot)}
        }
        set MAX [expr $MAX *2]
        #
        set S(classFactor) [expr 500.0 / ($MAX - $MIN)]
        set S(classMin) $MIN
        for {set i 0} {$i <= $MAX} {incr i} {
            set x [expr $S(classFactor) * ($i - $MIN) ]
            $c create line $x 48 $x 52 -tag "b b$i"
        }
        AddClass $c
    }
    #
    proc DeffClassVar2 {c} {
        global S T
        $c delete all
        $c create line 0 50 500 50
        # tree target
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        #MIN / MAX
        set MIN 0.0
        set MAX 0.0
        foreach t $ltreetarget  {
            if {$T($t,xmax) >= $MAX} {set MAX $T($t,xmax)}
        }
        set MAX [expr $MAX *2.0]
        #
        set S(classFactor) [expr 500.0 / ($MAX - $MIN)]
        set S(classMin) $MIN
        # ok ceci fct affiche sur un axe les valeurs de cumul de longueur
        # de branche de la racine a la feuille
        foreach t $ltreetarget  {
            foreach l $T($t,ue_cod) {
                set x [expr $S(classFactor) * ($T($t,sox,$l) - $MIN) ]
                # puts "[expr $S(classFactor) * ($T($t,sox,$l) - $MIN) ] == $x"
                $c create line $x 48 $x 52 -tag "b b$l"
            }
        }
        AddClass2 $c
    }
    #
    proc GenId {} {
        global S
        incr S(nbobj)
        return [format "%s%s" [clock second] $S(nbobj)]
    }
    #
    proc ClassM3 {w x y} {
        if {[winfo exists $w.menu ] == 1} {destroy $w.menu}
        set m [menu $w.menu -tearoff 0]
        set i [$w find withtag current]
        if {$i != {}}  {
            set tags [$w gettags $i]
            set id [lindex [split [lindex $tags [lsearch -glob $tags class*]] ¶] end]
            $m add command -label "Properties..." -command "Amelie::Properties $id"
            $m add command -label "Delete" -command "Amelie::ClassDelete $id"
            tk_popup $m [winfo pointerx $w] [winfo pointery $w]
        }
    }
    #
    proc Properties {ID} {
        global IG
        set c .dc.fd.ca
        set p1 [toplevel .f$ID]
        button $p1.color -text Color -command "Amelie::ClassColor $ID $p1.color" -background $IG(class,color,$ID)
        iwidgets::entryfield $p1.tabul  -labeltext "Tabulation" -width 5 -textvariable IG(class,tabul,$ID) -labelpos w
        iwidgets::entryfield $p1.curve  -labeltext "Curve" -width 5 -textvariable IG(class,curve,$ID) -labelpos w
        iwidgets::entryfield $p1.line   -labeltext "Line" -width 5 -textvariable IG(class,line,$ID) -labelpos w
        button $p1.apply -text Apply -command "Amelie::propertiesApply $ID"
        pack $p1.color $p1.tabul $p1.curve $p1.line $p1.apply -expand 1 -fill x
    }
    #
    proc propertiesApply {ID} {
        global IG
        set c .amelie.p.pane1.childsite.n.canvas.notebook.cs.page3.cs.dc.fd.ca
        # mise a jour couleur
        foreach item [$c find withtag class¶$ID] {
            set type [$c type $item]
            switch -exact $type {
                line {
                    $c itemconfigure $item -fill $IG(class,color,$ID)
                }
                polygon {
                    $c itemconfigure $item -fill $IG(class,color,$ID) -outline $IG(class,color,$ID)
                }
            }
        }
        # mise a jour text
        set i [$c find withtag [list class¶$ID && tabul]]
        $c itemconfigure $i -text "tab: $IG(class,tabul,$ID)"
        set i [$c find withtag [list class¶$ID && curve]]
        $c itemconfigure $i -text "cur: $IG(class,curve,$ID)"
        set i [$c find withtag [list class¶$ID && line]]
        $c itemconfigure $i -text "lin: $IG(class,line,$ID)"
    }
    #
    proc ClassColor {id pathbut} {
        global IG
        set color [tk_chooseColor]
        set IG(class,color,$id) $color
        $pathbut configure -background $color
    }
    #
    proc ClassDelete {id} {
        set c .amelie.p.pane1.childsite.n.canvas.notebook.cs.page3.cs.dc.fd.ca
        $c delete class¶$id
    }
    #
    proc MoveStart {w x y} {
        global S
        set S(mox) $x
    }
    proc MoveStart2 {w x y} {
        global S
        set S(mox) $x
    }
    #
    proc Move {w x y} {
        global S IG
        set tags [$w gettags current]
        set tag [lindex $tags [lsearch -glob $tags class*]]
        set ID [lindex [split $tag ¶] end]
        $w delete "$tag && val"
        set xx [lindex  [$w coords [list BOC && $tag]] 0]
        if {$x < 501 && $x >= 0} {
            $w move $tag [expr $x - $S(mox)] 0
            $w create text [expr $xx + 5] 10 -text [expr round(0.5+($x / $S(classFactor)) + $S(classMin)) ] \
                    -fill black  -tags "CL BOV BOVBOV $tag val" -anchor w
            $w create text [expr $xx + 5] 70 -text "tab: $IG(class,tabul,$ID)" \
                    -fill black  -tags "tabul CL  BOV val $tag" -anchor w
            $w create text [expr $xx + 5] 80 -text "cur: $IG(class,curve,$ID)" \
                    -fill black  -tags "curve CL  BOV val $tag" -anchor w
            $w create text [expr $xx + 5] 90 -text "lin: $IG(class,line,$ID)" \
                    -fill black  -tags "line CL  BOV val $tag" -anchor w
            set S(mox) $x
        }
    }
    proc Move2 {w x y} {
        global S IG
        set tags [$w gettags current]
        set tag [lindex $tags [lsearch -glob $tags class*]]
        set ID [lindex [split $tag ¶] end]
        $w delete "$tag && val"
        set xx [lindex  [$w coords [list BOC && $tag]] 0]
        if {$x < 501 && $x >= 0} {
            $w move $tag [expr $x - $S(mox)] 0
            $w create text [expr $xx + 5] 10 -text [expr ($x / $S(classFactor)) + $S(classMin) ] \
                    -fill black  -tags "CL BOV BOVBOV $tag val" -anchor w
            $w create text [expr $xx + 5] 70 -text "tab: $IG(class,tabul,$ID)" \
                    -fill black  -tags "tabul CL  BOV val $tag" -anchor w
            $w create text [expr $xx + 5] 80 -text "cur: $IG(class,curve,$ID)" \
                    -fill black  -tags "curve CL  BOV val $tag" -anchor w
            $w create text [expr $xx + 5] 90 -text "lin: $IG(class,line,$ID)" \
                    -fill black  -tags "line CL  BOV val $tag" -anchor w
            set S(mox) $x
        }
    }
    #
    proc AddClass {c} {
        global S IG
        if {$S(ClassMethod) != "?"} {
            set ID [GenId]
            set tag [format "%s%s" class¶ $ID]
            set color [format #%06x [expr {int(rand() * 0xFFFFFF)}]]
            set IG(class,color,$ID) $color
            set IG(class,tabul,$ID) $S(IGtabul)
            set IG(class,curve,$ID) $S(IGcurve)
            set IG(class,line,$ID)  $S(IGline)
            $c create line 250 0 250 100 -fill $color -width 1 -tags "CL BOC $tag "
            $c create polygon 250 10 240 20 250 30 -fill $color -outline $color -width 1 -tags "FL CL $tag"
            $c create text 255 10 -text [expr round(0.5+(250.0 / $S(classFactor)) + $S(classMin))] \
                    -fill black  -tags "CL  BOV BOVBOV val $tag" -anchor w
            $c create text 255 70 -text "tab: $IG(class,tabul,$ID)" \
                    -fill black  -tags "tabul CL  BOV val $tag" -anchor w
            $c create text 255 80 -text "cur: $IG(class,curve,$ID)" \
                    -fill black  -tags "curve CL  BOV val $tag" -anchor w
            $c create text 255 90 -text "lin: $IG(class,line,$ID)" \
                    -fill black  -tags "line CL  BOV val $tag" -anchor w
        }
    }
    proc AddClass2 {c} {
        global S IG
        if {$S(ClassMethod) != "?"} {
            set ID [GenId]
            set tag [format "%s%s" class¶ $ID]
            set color [format #%06x [expr {int(rand() * 0xFFFFFF)}]]
            set IG(class,color,$ID) $color
            set IG(class,tabul,$ID) $S(IGtabul)
            set IG(class,curve,$ID) $S(IGcurve)
            set IG(class,line,$ID)  $S(IGline)
            $c create line 250 0 250 100 -fill $color -width 1 -tags "CL BOC $tag "
            $c create polygon 250 10 240 20 250 30 -fill $color -outline $color -width 1 -tags "FL2 CL $tag"
            $c create text 255 10 -text [expr (250.0 / $S(classFactor)) + $S(classMin)] \
                    -fill black  -tags "CL  BOV BOVBOV val $tag" -anchor w
            $c create text 255 70 -text "tab: $IG(class,tabul,$ID)" \
                    -fill black  -tags "tabul CL  BOV val $tag" -anchor w
            $c create text 255 80 -text "cur: $IG(class,curve,$ID)" \
                    -fill black  -tags "curve CL  BOV val $tag" -anchor w
            $c create text 255 90 -text "lin: $IG(class,line,$ID)" \
                    -fill black  -tags "line CL  BOV val $tag" -anchor w
        }
    }
    # construction des classes par level
    proc ClassOK {w} {
        global C S T IG
        #min max
        set MIN 0
        set MAX 0
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        foreach t $ltreetarget  {
            if {$T($t,tot) >= $MAX} {set MAX $T($t,tot)}
        }
        set MAX [expr $MAX *2]
        #init
        foreach {k v} [array get IG color,*] {
            unset IG($k)
        }
        foreach {k v} [array get IG tabul,*] {
            unset IG($k)
        }
        foreach {k v} [array get IG curve,*] {
            unset IG($k)
        }
        foreach {k v} [array get IG line,*] {
            unset IG($k)
        }
        # for {set i 0} {$i <= $MAX} {incr i} {
        # catch {unset IG(color,$i)} u
        # catch {unset IG(tabul,$i)} u
        # catch {unset IG(curve,$i)} u
        # catch {unset IG(line,$i)} u
        # }
        # les bornes presentes
        set class [$w find withtag BOVBOV]
        set lbornes {}
        
        foreach c $class {
            set tags [$w gettags $c]
            set borne [lindex [$w itemconfigure $c -text] end]
            lappend lbornes $borne
            set ID [lindex [split [lindex $tags [lsearch -glob $tags class*]] ¶] end]
            set IG(color,$borne) $IG(class,color,$ID)
            set IG(tabul,$borne) $IG(class,tabul,$ID)
            set IG(curve,$borne) $IG(class,curve,$ID)
            set IG(line,$borne) $IG(class,line,$ID)
        }
        #remplissage
        set lbornes [lsort -integer -increasing $lbornes]
        #puts "LBORNES $lbornes"
        set maxborne [lindex $lbornes end]
        for {set i 0} {$i <= $MAX} {incr i} {
            if {[lsearch $lbornes $i] == -1} {
                if {$i > $maxborne} {
                    set IG(color,$i) black
                    set IG(tabul,$i) 50
                    set IG(curve,$i) 50
                    set IG(line,$i) 1
                } else  {
                    foreach b $lbornes {
                        if {$i <= $b} {
                            if [catch {set test $IG(color,$i)} test] {
                                set IG(color,$i) $IG(color,$b)
                                set IG(tabul,$i) $IG(tabul,$b)
                                set IG(curve,$i) $IG(curve,$b)
                                set IG(line,$i) $IG(line,$b)
                            }
                        }
                    }
                }
            }
        }
    }
    # construction des classes par distance
    proc ClassOK2 {w} {
        global C S IG T
        #init
        foreach {k v} [array get IG color,*] {
            unset IG($k)
        }
        foreach {k v} [array get IG tabul,*] {
            unset IG($k)
        }
        foreach {k v} [array get IG curve,*] {
            unset IG($k)
        }
        foreach {k v} [array get IG line,*] {
            unset IG($k)
        }
        set class [$w find withtag BOVBOV]
        set lbornes {}
        foreach c $class {
            set tags [$w gettags $c]
            set bornesup [lindex [$w itemconfigure $c -text] end]
            lappend lbornes $bornesup
            set ID [lindex [split [lindex $tags [lsearch -glob $tags class*]] ¶] end]
            set IG(color,$bornesup) $IG(class,color,$ID)
            set IG(tabul,$bornesup) $IG(class,tabul,$ID)
            set IG(curve,$bornesup) $IG(class,curve,$ID)
            set IG(line,$bornesup) $IG(class,line,$ID)
        }
        set bornesup [expr (500.0 / $S(classFactor)) + $S(classMin)]
        set IG(color,$bornesup) black
        set IG(tabul,$bornesup) 50
        set IG(curve,$bornesup) 50
        set IG(line,$bornesup) 1
        lappend lbornes $bornesup
        set IG(classesfound) [lsort -real -increasing $lbornes]
        
    }
    #
    proc ColorSpecific {w} {
        global S
        $w configure -background $S(col)
        set S(AmelieColor) $S(col)
    }
    # ls : listbox source ; lt listbox target
    proc AnnotateAddItem {ls lt} {
        global S
        if {$S(database) != ""} {
            $lt delete 0 end
            set variable [$ls get [$ls curselection]]
            set lrecords [Database::dbQueryRecordsAll $S(database)]
            set lres {}
            foreach record $lrecords {
                set leaf [Database::dbQueryVarFromRecords $S(database) EU $record]
                set int [Database::dbQueryVarFromRecords $S(database) $variable $record]
                #$lt insert end [format "%s%s%s" $leaf : $int ]
                lappend lres [format "%s%s%s" $leaf : $int ]
            }
            foreach r [lsort -dictionary $lres] {
                $lt insert end $r
            }
        }
    }
    #
    proc PanelQuit {} {
        set choix [tk_messageBox -type okcancel -default ok  \
                -message "Exit TreeIG ?" -icon question]
        if {$choix == "ok"} {
            eval destroy .amelie
        }
    }
    #
    proc AnnotateLoadLabel {} {
        global S
        set filtre {}
        lappend filtre [list {TreeDyn Label File} .txt]
        set typelist {
            {"TreeDyn Labels Files" {".tlf"} }
            {"All Files" {*}}
        }
        set filename [tk_getOpenFile -initialdir $S(userDIR)  -defaultextension "tlf" \
                -filetypes $typelist -title "Load Annotations..."]
        if {$filename != ""} {set S(userDIR) [file dirname $filename]}
        if [catch {open $filename r} fid] {
            puts stderr "Error Opening File"
        } else {
            set currentfile [Tools::PathCut2 $filename]
            if {[lsearch $S(ldatabase) $currentfile] != -1 } {
                upvar #0 $currentfile X
                array unset X
            } else  {
                set S(database) $currentfile
                lappend S(ldatabase) $currentfile
            }
            Database::db $currentfile
            while {[eof $fid] != 1} {
                set id [incr S(lastid)]
                gets $fid data
                eval $currentfile [concat $id EU $data]
            }
            close $fid
        }
        # mise a jour menu de la liste des labels file
        .amelie.c.m1 delete 0 end
        foreach lf $S(ldatabase) {.amelie.c.m1 insert end $lf}
        .amelie.c.m1 select $currentfile
        # mise a jour listbox des variables
        set lvar [Database::dbQueryVarAll $S(database)]
        # remplissage listbox
        .amelie.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l delete 0 end
        eval {.amelie.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l insert end} $lvar
        # table
        dbBrowserFill .amelie.p.pane0.childsite.n.canvas.notebook.cs.page2.cs
    }
    #
    proc dbBrowserFill {w} {
        global f S
        set database $S(database)
        if {$database != ""} {
            upvar #0 $database X
            # init
            if {[winfo exists $w.t] == 1} {destroy $w.t $w.sy $w.sx}
            catch {unset f}
            
            # unset f
            # remplissage row 0 col j
            set variables [Database::dbQueryVarAll $database]
            set records [lsort -dictionary [Database::dbQueryRecordsAll $database]]
            set j -1
            foreach variable $variables {
                incr j
                set f(0,$j) $variable
            }
            set NBvariables [llength $variables]
            set NBrecords [llength $records]
            # construction Tktable
            set ta [table $w.t -rows [expr $NBrecords + 1] -cols $NBvariables -variable f  \
                    -yscrollcommand "$w.sy set"  -xscrollcommand  "$w.sx set " \
                    -titlerows 1 -titlecols 0    \
                    -height 10 -rowheight 1 -selectmode extended -bd 1\
                    -colstretch unset -rowstretch last  ]
            
            # remplissage i,j
            set NBvariables [llength $variables]
            set NBrecords [llength $records]
            set S(msgindent1) "$NBrecords records * [expr $NBvariables -1] columns"
            set row 0 ; set col -1
            foreach record $records {
                incr row ; set col -1
                foreach variable $variables {
                    incr col
                    set data [$database $record $variable]
                    if {$data == ""} {set data -}
                    #regsub -all " " $data "\n" data
                    set f($row,$col) $data
                }
                $ta tag row $record $row
            }
            $ta tag config title -bg grey60 -relief groove
            #
            scrollbar $w.sy -command [list $w.t yview]
            scrollbar $w.sx -command [list $w.t xview] -orient horizontal
            # GRID
            grid $w.t -row 0 -column 0 -sticky news
            grid $w.sx -row 1 -column 0 -sticky ew
            grid $w.sy -row 0 -column 1 -sticky ns
            grid rowconfigure $w 0  -weight 1
            grid columnconfigure $w 0 -weight 1
        }
    }
    #
    proc AnnotateLabelsFileSwitch {m} {
        global S
        set select [$m get]
        switch -exact $select {
            "?" {puts Default}
            default {set S(database) $select}
        }
        # mise a jour listbox des variables
        set lvar [Database::dbQueryVarAll $S(database)]
        # remplissage listbox
        .amelie.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l delete 0 end
        eval {.amelie.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa.l insert end} $lvar
    }
    #
    proc Draw {mode} {
        global S
        # tree target
        set lkv [array get S *,tar]
        set ltreetarget {}
        foreach {k v} $lkv {
            if {$S($k) == 1} {
                lappend ltreetarget [string range $k 0 [expr [string first , $k] - 1]]
            }
        }
        # couple feuille source:feuille cibles
        set lv {}
        set lindex [.amelie.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa2.l curselection]
        foreach i $lindex {
            lappend lv [.amelie.p.pane0.childsite.n.canvas.notebook.cs.page1.cs.lfa2.l get $i]
        }
        #
        switch -- $mode {
            only {
                # on efface tout et on trace la selection
                foreach ti $ltreetarget {set w $S($ti,w) ; $w delete Arc}
                DrawGo $lv $ltreetarget
            }
            rem  {
                # on retire la selection
                foreach ti $ltreetarget {
                    set w $S($ti,w)
                    foreach v $lv {
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0]
                        $w delete Arc$l
                    }
                }
            }
            add  {
                # on ajoute a la selection
                DrawGo $lv $ltreetarget
            }
            clear {
                # on efface tout
                foreach ti $ltreetarget {set w $S($ti,w) ; $w delete Arc}
            }
        }
    }
    #
    proc CommunRoot {index s1 s2 string} {
        if {[string equal  [string index $s1 $index] [string index $s2 $index]]} {
            CommunRoot [expr $index +1] $s1 $s2 $string[string index $s1 $index]
        } else  {
            return [string length $string]
        }
    }
    #
    proc CommunRoot2 {index s1 s2 string} {
        if {[string equal $s1 $s2]} {
            return $string
        }
        if {[string equal  [string index $s1 $index] [string index $s2 $index]]} {
            CommunRoot2 [expr $index +1] $s1 $s2 $string[string index $s1 $index]
        } else  {
            return $string
        }
    }
    #
    proc DrawGo  {lv ltreetarget} {
        global S
        switch -- $S(IGmode) {
            user {DrawGoUser $lv $ltreetarget}
            clas {
                switch -- $S(ClassMethod) {
                    level {
                        Amelie::ClassOK .amelie.p.pane1.childsite.n.canvas.notebook.cs.page3.cs.dc.fd.ca
                        DrawGoClass $lv $ltreetarget
                    }
                    distance {
                        Amelie::ClassOK2 .amelie.p.pane1.childsite.n.canvas.notebook.cs.page3.cs.dc.fd.ca
                        DrawGoClass2 $lv $ltreetarget
                    }
                }
            }
            auto {
                #Amelie::DrawAutoOK .amelie.p.pane1.childsite.n.canvas.notebook.cs.page3.cs.dc.fd.ca
                DrawGoAuto $lv $ltreetarget
            }
        }
    }
    #
    proc DrawGoUser {lv ltreetarget} {
        global S ann T
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set w $S($ti,w)
                    set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    set x [expr $XMAX + $S(IGtabul)]
                    set tagS [format "%s%s%s" SEL ¶ [Tools::GenId]]
                    foreach v $lv {
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0] ;# source
                        set ll [lindex [lindex $vsplit end] 0] ;# targets
                        set y1 [WhatY $w $ti $l]
                        foreach vi [split $ll] {
                            
                            set tagos [format "%s%s%s%s%s" ARCU ¶ $l ¶ $vi]
                            if {$vi != $l} {
                                set y2 [WhatY $w $ti $vi]
                                set ymoy [expr ($y1 + $y2) / 2]
                                if {$y1 != 0 && $y2 !=0 } {
                                    
                                    $w create line $x $y1 [expr $x + $S(IGcurve)] $ymoy \
                                            $x $y2 -width $S(IGline) -smooth 1 -splinesteps 100 -fill $S(col) \
                                            -tags "T$ti A$ti $tagC Arc$l Arc$vi Arc $tagS $tagos"
                                    if {$S(IGannot) == 1} {
                                        $w create text $x $y1 \
                                                -fill $S(col) -anchor e -text "$l" -font $S(gfo)\
                                                -tags "T$ti A$ti $tagC Arc$l Arc$vi Arc $tagS $tagos"
                                        
                                        $w create text $x $y2 \
                                                -fill $S(col) -anchor e -text "$vi" -font $S(gfo)\
                                                -tags "T$ti A$ti $tagC Arc$l Arc$vi Arc $tagS $tagos"
                                    }
                                }
                            } else  {
                                set y2 [WhatY $w $ti $vi]
                                set ymoy [expr ($y1 + $y2) / 2]
                                if {$y1 != 0 && $y2 !=0 } {
                                    $w create oval [expr $x - 20]  [expr $y1 -5] $x  [expr $y1 +5]   -outline $S(col) \
                                            -tags "T$ti A$ti $tagC Arc$l Arc$vi Arc $tagos $tagS "
                                }
                            }
                        }
                    }
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                    
                }
                ClaCir1 - ClaCir2  {
                    
                }
                ClaCir3 {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set w $S($ti,w)
                    set co [$w bbox [list T$ti && Z]]
                    set x1 [lindex $co 0]
                    set y1 [lindex $co 1]
                    set x2 [lindex $co 2]
                    set y2 [lindex $co 3]
                    set xcenter [expr double($x2 + $x1)/2]
                    set ycenter [expr double($y2 + $y1)/2]
                    set tagS [format "%s%s%s" SEL ¶ [Tools::GenId]]
                    foreach v $lv {
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0] ;# source
                        set ll [lindex [lindex $vsplit end] 0] ;# targets
                        foreach vi [split $ll] {
                            set tagos [format "%s%s%s%s%s" ARCU ¶ $l ¶ $vi]
                            if {[lsearch $T($ti,ue_lab) $vi] != -1  && [lsearch $T($ti,ue_lab) $l] != -1} {
                                set coVI [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$vi) C ] && T$ti]]]
                                set coL [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$l) C ] && T$ti]]]
                                set xVI [lindex $coVI 2]
                                set yVI [lindex $coVI 3]
                                set xL [lindex $coL 2]
                                set yL [lindex $coL 3]
                                if {$yVI != 0 &&  $yL !=0  && $xVI !=0 && $xL !=0} {
                                    $w create line $xVI $yVI $xcenter $ycenter $xL $yL \
                                            -width $S(IGline) -smooth 1 -splinesteps 100 -fill $S(col) \
                                            -tags "T$ti A$ti $tagC Arc$l Arc$vi Arc $tagos $tagS"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #
    proc DrawGoAuto {lv ltreetarget} {
        global S ann T  IG
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set w $S($ti,w)
                    set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    set S($ti,LabelMatrixBase) [expr $S($ti,LabelMatrixBase) + $S(TabulationAnnot)]
                    set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                    set tagS [format "%s%s%s" SEL ¶ [Tools::GenId]]
                    foreach v $lv {
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0] ;# source
                        set ll [lindex [lindex $vsplit end] 0] ;# targets
                        foreach {k v} [MakeLevels $w $ti $l [split $ll]] {set ff($k) $v}
                        set y1 [WhatY $w $ti $l]
                        if {$S(IGcolorAutocheck)} {set color [format #%06x [expr {int(rand() * 0xFFFFFF)}]]} else  {set color black}
                        foreach vi [split $ll] {
                            
                            set tagos [format "%s%s%s%s%s" ARCU ¶ $l ¶ $vi]
                            if {[lsearch $T($ti,ue_lab) $vi] != -1  && [lsearch $T($ti,ue_lab) $l] != -1} {
                                if {$vi != $l} {
                                    set y2 [WhatY $w $ti $vi]
                                    set ymoy [expr ($y1 + $y2) / 2]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        set level [expr round(abs($y1 - $y2)/10.0)]
                                        if {$S(IGtabulAutocheck)} {set leveltabul $ff($vi)} else  {set leveltabul 1}
                                        if {$S(IGcurveAutocheck)} {set levelcurve $level} else  {set levelcurve 1}
                                        if {$S(IGlineAutocheck)} {set levelline $level} else  {set levelline 1}
                                        $w create line [expr $x + ($leveltabul * $S(IGtabulAuto))] $y1 [expr $x + ($leveltabul * $S(IGtabulAuto)) + ($levelcurve * $S(IGcurveAuto))] $ymoy \
                                                [expr $x + ($leveltabul * $S(IGtabulAuto))] $y2 -width [expr $S(IGlineAuto) * $levelline] -smooth 1 -splinesteps 100 -fill $color \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                        if {$S(IGannot) == 1} {
                                            $w create text [expr $x + ($leveltabul * $S(IGtabulAuto))] $y1 \
                                                    -fill $color -anchor e -text "$l" -font $S(gfo)\
                                                    -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                            
                                            $w create text [expr $x + ($leveltabul * $S(IGtabulAuto))] $y2 \
                                                    -fill $color -anchor e -text "$vi" -font $S(gfo)\
                                                    -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                        }
                                    }
                                } else  {
                                    set y2 [WhatY $w $ti $vi]
                                    set ymoy [expr ($y1 + $y2) / 2]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        $w create oval [expr $x + $S(IGtabulAuto) - 20]  [expr $y1 -5] \
                                                [expr $x + $S(IGtabulAuto)]  [expr $y1 +5]   -outline $color \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                    }
                                }
                            }
                        }
                    }
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                }
                ClaCir1 - ClaCir2  {
                }
                ClaCir3 {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set w $S($ti,w)
                    set co [$w bbox [list T$ti && Z]]
                    set x1 [lindex $co 0]
                    set y1 [lindex $co 1]
                    set x2 [lindex $co 2]
                    set y2 [lindex $co 3]
                    set xcenter [expr double($x2 + $x1)/2]
                    set ycenter [expr double($y2 + $y1)/2]
                    set tagS [format "%s%s%s" SEL ¶ [Tools::GenId]]
                    foreach v $lv {
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0] ;# source
                        set ll [lindex [lindex $vsplit end] 0] ;# targets
                        foreach vi [split $ll] {
                            
                            set tagos [format "%s%s%s%s%s" ARCU ¶ $l ¶ $vi]
                            if {[lsearch $T($ti,ue_lab) $vi] != -1  && [lsearch $T($ti,ue_lab) $l] != -1} {
                                if {$vi != $l} {
                                    regsub -all {[0-9]} $T($ti,ltc,$l) "" l1
                                    regsub -all {[0-9]} $T($ti,ltc,$vi) "" l2
                                    set root [CommunRoot2 0 $l1 $l2 ""]
                                    regsub $root $l1 "" frag1
                                    regsub $root $l2 "" frag2
                                    set level [expr  abs([string length $frag1] + [string length $frag2])]
                                    set coVI [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$vi) C ] && T$ti]]]
                                    set coL [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$l) C ] && T$ti]]]
                                    set xVI [lindex $coVI 2]
                                    set yVI [lindex $coVI 3]
                                    set xL [lindex $coL 2]
                                    set yL [lindex $coL 3]
                                    if {$yVI != 0 &&  $yL !=0  && $xVI !=0 && $xL !=0} {
                                        # courbe avec centre cercle
                                        $w create line $xVI $yVI $xcenter $ycenter $xL $yL \
                                                -width $IG(line,$level) -smooth 1 -splinesteps 100 -fill $IG(color,$level) \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                    }
                                } else  {
                                    set coVI [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$vi) C ] && T$ti]]]
                                    set xVI [lindex $coVI 2]
                                    set yVI [lindex $coVI 3]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        $w create oval [expr $xVI - 5]  [expr $yVI -5] [expr $xVI +5]  [expr $yVI +5]  \
                                                -outline $IG(color,0) \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #
    proc MakeLevels {w t fs fts} {
        global S T
        set y1 [WhatY $w $t $fs]
        # ltarget est la liste des feuilles de t sans repetitions
        set ltarget {}
        foreach f $fts {
            if {[lsearch $T($t,ue_lab) $f] != -1} {
                if {[lsearch $ltarget $f] == -1} {lappend ltarget $f}
            }
        }
        # liste des couples feuille-level
        set flAlist {}
        set llevel {}
        foreach f $ltarget {
            set y2 [WhatY $w $t $f]
            set level [expr round(abs($y1 - $y2)/10.0)]
            lappend flAlist $f $level
            if {[lsearch $llevel $level] == -1} {lappend llevel $level}
        }
        # remplacement des levels par leur index sur de la liste classee des levels
        set levels [lsort -integer -increasing $llevel]
        set index 0
        foreach level $levels {
            regsub -all " $level " $flAlist " [expr $index +1] " flAlist
            incr index
        }
        return $flAlist
    }
    #
    proc DrawGoClass {lv ltreetarget} {
        global S ann T  IG
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set w $S($ti,w)
                    set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    set S($ti,LabelMatrixBase) [expr $S($ti,LabelMatrixBase) + $S(TabulationAnnot)]
                    set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                    set tagS [format "%s%s%s" SEL ¶ [Tools::GenId]]
                    foreach v $lv {
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0] ;# source
                        set ll [lindex [lindex $vsplit end] 0] ;# targets
                        set y1 [WhatY $w $ti $l]
                        foreach vi [split $ll] {
                            
                            set tagos [format "%s%s%s%s%s" ARCU ¶ $l ¶ $vi]
                            if {[lsearch $T($ti,ue_lab) $vi] != -1  && [lsearch $T($ti,ue_lab) $l] != -1} {
                                if {$vi != $l} {
                                    set y2 [WhatY $w $ti $vi]
                                    set ymoy [expr ($y1 + $y2) / 2]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        regsub -all {[0-9]} $T($ti,ltc,$l) "" l1
                                        regsub -all {[0-9]} $T($ti,ltc,$vi) "" l2
                                        set root [CommunRoot2 0 $l1 $l2 ""]
                                        regsub $root $l1 "" frag1
                                        regsub $root $l2 "" frag2
                                        set level [expr  abs([string length $frag1] + [string length $frag2])]
                                        # METH 1 ***********  set level [expr $T($ti,tot) - [CommunRoot 0 $l1 $l2 ""]]
                                        # METH 2 *********** set level [CommunRoot 0 $l1 $l2 ""]
                                        #set level [expr abs([string length $l1] - [string length $l2])]
                                        $w create line [expr $x + $IG(tabul,$level)] $y1 \
                                                [expr $x + $IG(tabul,$level) + $IG(curve,$level)] $ymoy \
                                                [expr $x + $IG(tabul,$level)] $y2 \
                                                -smooth 1 -splinesteps  100 -fill $IG(color,$level) -width $IG(line,$level) \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                        if {$S(IGannot) == 1} {
                                            $w create text [expr $x + $IG(tabul,$level)] $y1 \
                                                    -fill $IG(color,$level) -anchor e -text "$l" -font $S(gfo)\
                                                    -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                            $w create text [expr $x + $IG(tabul,$level)] $y2 \
                                                    -fill $IG(color,$level) -anchor e -text "$vi" -font $S(gfo)\
                                                    -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                        }
                                    }
                                } else  {
                                    set y2 [WhatY $w $ti $vi]
                                    set ymoy [expr ($y1 + $y2) / 2]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        $w create oval [expr $x + $IG(tabul,0) - 20]  [expr $y1 -5] \
                                                [expr $x + $IG(tabul,0)]  [expr $y1 +5]   -outline $IG(color,0) \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                    }
                                }
                            }
                        }
                    }
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                }
                ClaCir1 - ClaCir2  {
                }
                ClaCir3 {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set w $S($ti,w)
                    set co [$w bbox [list T$ti && Z]]
                    set x1 [lindex $co 0]
                    set y1 [lindex $co 1]
                    set x2 [lindex $co 2]
                    set y2 [lindex $co 3]
                    set xcenter [expr double($x2 + $x1)/2]
                    set ycenter [expr double($y2 + $y1)/2]
                    set tagS [format "%s%s%s" SEL ¶ [Tools::GenId]]
                    foreach v $lv {
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0] ;# source
                        set ll [lindex [lindex $vsplit end] 0] ;# targets
                        foreach vi [split $ll] {
                            set tagos [format "%s%s%s%s%s" ARCU ¶ $l ¶ $vi]
                            if {[lsearch $T($ti,ue_lab) $vi] != -1  && [lsearch $T($ti,ue_lab) $l] != -1} {
                                if {$vi != $l} {
                                    regsub -all {[0-9]} $T($ti,ltc,$l) "" l1
                                    regsub -all {[0-9]} $T($ti,ltc,$vi) "" l2
                                    set root [CommunRoot2 0 $l1 $l2 ""]
                                    regsub $root $l1 "" frag1
                                    regsub $root $l2 "" frag2
                                    set level [expr  abs([string length $frag1] + [string length $frag2])]
                                    set coVI [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$vi) C ] && T$ti]]]
                                    set coL [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$l) C ] && T$ti]]]
                                    set xVI [lindex $coVI 2]
                                    set yVI [lindex $coVI 3]
                                    set xL [lindex $coL 2]
                                    set yL [lindex $coL 3]
                                    if {$yVI != 0 &&  $yL !=0  && $xVI !=0 && $xL !=0} {
                                        # courbe avec centre cercle
                                        $w create line $xVI $yVI $xcenter $ycenter $xL $yL \
                                                -width $IG(line,$level) -smooth 1 -splinesteps 100 -fill $IG(color,$level) \
                                                -tags "T$ti A$ti  $tagC  Arc$l Arc$vi Arc $tagos $tagS"
                                        
                                        #droite
                                        #$w create line $xVI $yVI [expr ($xVI + $xL) /2]  [expr ($yVI + $yL) /2] $xL $yL \
                                        #        -width $IG(line,$level) -smooth 1 -splinesteps 100 -fill $IG(color,$level) \
                                        #        -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo Arc$l Arc$vi Arc"
                                        
                                        #
                                        # set Dx [expr abs($xcenter - $xVI)]
                                        # set Dy [expr abs($ycenter - $yVI)]
                                        # set D [expr sqrt(($Dx * $Dx) + ($Dy * $Dy))]
                                        # set xxVI [expr ($Dx / $D) * $IG(tabul,$level)]
                                        # set yyVI [expr ($Dy / $D) * $IG(tabul,$level)]
                                        #
                                        # set Dx [expr abs($xcenter - $xL)]
                                        # set Dy [expr abs($ycenter - $yL)]
                                        # set D [expr sqrt(($Dx * $Dx) + ($Dy * $Dy))]
                                        # set xxL [expr ($Dx / $D) * $IG(tabul,$level)]
                                        # set yyL [expr ($Dy / $D) * $IG(tabul,$level)]
                                        #
                                        #
                                        # $w create line $xVI $yVI $xxVI $yyVI $xxL $yyL $xL $yL \
                                        # -width $IG(line,$level) -smooth 1 -splinesteps 100 -fill $IG(color,$level) \
                                        # -tags "T$ti AnnotMatrix AM$ti MA¶$l $tagC AMatrixCo Arc$l Arc$vi Arc"
                                    }
                                } else  {
                                    set coVI [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$vi) C ] && T$ti]]]
                                    set xVI [lindex $coVI 2]
                                    set yVI [lindex $coVI 3]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        $w create oval [expr $xVI - 5]  [expr $yVI -5] [expr $xVI +5]  [expr $yVI +5]  \
                                                -outline $IG(color,0) \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagos $tagS"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    # methode distance
    proc DrawGoClass2 {lv ltreetarget} {
        global S ann T  IG
        foreach ti $ltreetarget {
            switch -exact $S($ti,type) {
                PhyNJ - ClaSla - ClaRec {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set w $S($ti,w)
                    set XMAX1 [lindex [$w bbox [list T$ti && Z]] 2]
                    set XMAX2 [lindex [$w bbox [list T$ti && L]] 2]
                    if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                    set S($ti,LabelMatrixBase) [expr $S($ti,LabelMatrixBase) + $S(TabulationAnnot)]
                    set x [expr $XMAX + $S($ti,LabelMatrixBase)]
                    set tagS [format "%s%s%s" SEL ¶ [Tools::GenId]]
                    foreach v $lv {
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0] ;# source
                        set ll [lindex [lindex $vsplit end] 0] ;# targets
                        set y1 [WhatY $w $ti $l]
                        foreach vi [split $ll] {
                            set tagos [format "%s%s%s%s%s" ARCU ¶ $l ¶ $vi]
                            if {[lsearch $T($ti,ue_lab) $vi] != -1  && [lsearch $T($ti,ue_lab) $l] != -1} {
                                if {$vi != $l} {
                                    set y2 [WhatY $w $ti $vi]
                                    set ymoy [expr ($y1 + $y2) / 2]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        # distance separant les deux feuilles
                                        set dist [Tools::DistLL $ti $l $vi]
                                        # trouver l'intervalle (la borne sup) ok de dist dans IG(classesfound)
                                        set level [DrawGoClass2Level $dist $IG(classesfound)]
                                        
                                        $w create line [expr $x + $IG(tabul,$level)] $y1 \
                                                [expr $x + $IG(tabul,$level) + $IG(curve,$level)] $ymoy \
                                                [expr $x + $IG(tabul,$level)] $y2 \
                                                -smooth 1 -splinesteps  100 -fill $IG(color,$level) -width $IG(line,$level) \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                        if {$S(IGannot) == 1} {
                                            $w create text [expr $x + $IG(tabul,$level)] $y1 \
                                                    -fill $IG(color,$level) -anchor e -text "$l" -font $S(gfo)\
                                                    -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                            $w create text [expr $x + $IG(tabul,$level)] $y2 \
                                                    -fill $IG(color,$level) -anchor e -text "$vi" -font $S(gfo)\
                                                    -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                        }
                                    }
                                } else  {
                                    set level [lindex $IG(classesfound) 0]
                                    set y2 [WhatY $w $ti $vi]
                                    set ymoy [expr ($y1 + $y2) / 2]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        $w create oval [expr $x + $IG(tabul,$level) - 20]  [expr $y1 -5] \
                                                [expr $x + $IG(tabul,$level)]  [expr $y1 +5]   -outline $IG(color,$level) \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagS $tagos"
                                    }
                                }
                            }
                        }
                    }
                }
                PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
                }
                ClaCir1 - ClaCir2  {
                }
                ClaCir3 {
                    set database $S(database)
                    upvar #0 $S(database) X
                    set w $S($ti,w)
                    set co [$w bbox [list T$ti && Z]]
                    set x1 [lindex $co 0]
                    set y1 [lindex $co 1]
                    set x2 [lindex $co 2]
                    set y2 [lindex $co 3]
                    set xcenter [expr double($x2 + $x1)/2]
                    set ycenter [expr double($y2 + $y1)/2]
                    set tagS [format "%s%s%s" SEL ¶ [Tools::GenId]]
                    foreach v $lv {
                        set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                        set vsplit [split $v ":"]
                        set l [lindex $vsplit 0] ;# source
                        set ll [lindex [lindex $vsplit end] 0] ;# targets
                        foreach vi [split $ll] {
                            set tagos [format "%s%s%s%s%s" ARCU ¶ $l ¶ $vi]
                            if {[lsearch $T($ti,ue_lab) $vi] != -1  && [lsearch $T($ti,ue_lab) $l] != -1} {
                                if {$vi != $l} {
                                    set dist [Tools::DistLL $ti $l $vi]
                                    # trouver l'intervalle (la borne sup) ok de dist dans IG(classesfound)
                                    set level [DrawGoClass2Level $dist $IG(classesfound)]
                                    set coVI [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$vi) C ] && T$ti]]]
                                    set coL [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$l) C ] && T$ti]]]
                                    set xVI [lindex $coVI 2]
                                    set yVI [lindex $coVI 3]
                                    set xL [lindex $coL 2]
                                    set yL [lindex $coL 3]
                                    if {$yVI != 0 &&  $yL !=0  && $xVI !=0 && $xL !=0} {
                                        # courbe avec centre cercle
                                        $w create line $xVI $yVI $xcenter $ycenter $xL $yL \
                                                -width $IG(line,$level) -smooth 1 -splinesteps 100 -fill $IG(color,$level) \
                                                -tags "T$ti A$ti  $tagC  Arc$l Arc$vi Arc $tagos $tagS"
                                    }
                                } else  {
                                    set level [lindex $IG(classesfound) 0]
                                    set coVI [$w coords [$w find withtag [list [format "%s%s" $T($ti,ltc,$vi) C ] && T$ti]]]
                                    set xVI [lindex $coVI 2]
                                    set yVI [lindex $coVI 3]
                                    if {$y1 != 0 && $y2 !=0 } {
                                        $w create oval [expr $xVI - 5]  [expr $yVI -5] [expr $xVI +5]  [expr $yVI +5]  \
                                                -outline $IG(color,$level) \
                                                -tags "T$ti A$ti $tagC  Arc$l Arc$vi Arc $tagos $tagS"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    proc DrawGoClass2Level {v lv} {
        foreach i $lv {
            if {$v <= $i} {
                return $i
            }
        }
    }
    #
    proc WhatY {w t l} {
        
        set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$t]]
        if {$item == ""} {
            set items [$w find withtag [list ADD¶$l && T$t]]
            set y 0
            foreach ii $items {
                set yii [lindex [$w coords $ii] 1]
                if {$yii >= $y} {
                    set y $yii
                }
            }
        } else  {
            set co [$w coords $item]
            set y [lindex $co 1]
        }
        return $y
    }
    #
    # proc WhatY {w t l} {
    # set item [$w find withtag [list [format "%s%s" EUL  $l ] && T$t]]
    # if {$item == ""} {
    # return 0
    # } else  {
    # set co [$w coords $item]
    # set y [lindex $co 1]
    # }
    # return $y
    # }
}
################################################################################


################################################################################
# TREEXY
################################################################################
namespace eval TreeALI {
    
    
    proc treeALIPanel {} {
        global S
        # valeur par defaut
        set S(TreeALI,size) 8
        set S(TreeALI,weight) normal
        set S(TreeALI,hiali) bg
        set S(TreeALI,hitre) bgle
        set S(TreeALI,padx) 10
        set S(TreeALI,pady) 10
        set S(TreeALI,offset) 0
        set S(col) #ff8040
        set S(TreeALI,msg1) ?
        set S(TreeALI,msg2) ?
        set S(TreeALI,resetauto) 0
        set S(tool) trealg+
        set S(TreeALI,zonpos) ?
        set S(TreeALI,preabs) ?
        if {[winfo exists .tal] == 1} {
            wm deiconify .tal
        } else  {
            set w [toplevel .tal]
            wm title $w "TreeALI"
            wm geometry .tal 1000x700
            wm protocol .tal WM_DELETE_WINDOW {TreeALI::PanelQuit}
            ### CONTROLS
            set p1 [frame .tal.co]
            button $p1.l1 -text "Load FASTA Alig." -command  "TreeALI::LoadAlign"
            button $p1.l2 -text "Load Tree(s)" -command {ImportExport::MIimport}
            button  $p1.e -text "Exit" -command  "TreeALI::PanelQuit"
            button  $p1.c -text ".ps" -command  "TreeALI::exportPS"
            button  $p1.g -text "Gaps" -command  "TreeALI::DisHidGAP"
            menubutton $p1.fo -text "Font" -indicatoron on -menu $p1.fo.m -relief groove
            set zfo  [menu  $p1.fo.m -tearoff 0]
            $zfo add command -label "Size +" -command "TreeALI::Fontali in"
            $zfo add command -label "Size -" -command "TreeALI::Fontali out"
            #$zfo add command -label "Bold on/off" -command "TreeALI::Fontali bold"
            iwidgets::entryfield $p1.ofs -width 5 -labeltext "Offset" -textvariable S(TreeALI,offset)  \
                    -labelpos w -validate integer  -fixed 30 -command TreeALI::UpOffset
            iwidgets::entryfield $p1.padx -width 5 -labeltext "Pad X" -textvariable S(TreeALI,padx)  \
                    -labelpos w -validate integer  -fixed 30 -command TreeALI::PadXY
            iwidgets::entryfield $p1.pady -width 5 -labeltext "Pad Y" -textvariable S(TreeALI,pady)  \
                    -labelpos w -validate integer  -fixed 30 -command TreeALI::PadXY
            label $p1.msg1  -textvariable S(TreeALI,msg1) -width 15  \
                    -borderwidth 1 -foreground blue -background LightGoldenrodYellow -anchor w
            label $p1.msg2  -textvariable S(TreeALI,msg2) -width 15  \
                    -borderwidth 1 -foreground blue -background LightGoldenrodYellow -anchor w
            #listbox seq
            set wd [frame $p1.lfa]
            scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
            scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
            listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                    -width 20 -height 15 -selectmode extended
            grid $wd.l -row 0 -column 0 -sticky news
            grid $wd.yscroll -row 0 -column 1 -sticky ns
            grid $wd.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $wd 0 -weight 1
            grid columnconfigure $wd 0 -weight 1
            bind $wd.l <ButtonRelease> "TreeALI::SelectRow $wd.l"
            
            
            menubutton $p1.pa -text "P/A pos." -indicatoron on -menu $p1.pa.m  -relief groove
            set zpa  [menu  $p1.pa.m -tearoff 0]
            $zpa add radio -label "PA tree & alig"  -variable S(TreeALI,preabs) \
                    -value yes -command "TreeALI::PreAbs"
            #$zpa add radio -label "From Alig. To Tree(s)" -variable S(TreeALI,preabs) \
            #         -value FromAli2Tree -command "TreeALI::PreAbs"
            # $zpa add radio -label "Tree(s) AND Alig." -variable S(TreeALI,preabs)  \
            #         -value AliAndTree -command "TreeALI::PreAbs"
            # $zpa add separator
            $zpa add radio -label "No P/A pos." -variable S(TreeALI,preabs)  \
                    -value no -command "TreeALI::PreAbs"
            
            iwidgets::entryfield $p1.pdb -width 5 -labeltext "pdb code" -textvariable S(pdbcode)  \
                    -labelpos w -fixed 30 -command TreeALI::loadpdb
            
            
            
            
            
            iwidgets::entryfield $p1.zon -width 12 -labeltext "Pos. sel" -textvariable S(TreeALI,zonpos)  \
                    -labelpos w   -command TreeALI::ZonePosSelection
            
            button $p1.col -text "Color" -background $S(col) -command "TreeALI::userColor $p1.col"
            button $p1.alist -text "Pos. Col. Export" -command "TreeALI::ExportAlist"
            menubutton $p1.mopali -text "Alig op." -indicatoron on -menu $p1.mopali.m  -relief groove
            menubutton $p1.moptre -text "Tree op." -indicatoron on -menu $p1.moptre.m  -relief groove
            set zali  [menu  $p1.mopali.m -tearoff 0]
            $zali add radio -label "Background color" -variable S(TreeALI,hiali) -value bg
            $zali add radio -label "Foreground color" -variable S(TreeALI,hiali) -value fg
            $zali add separator
            $zali add radio -label "No Hightlight" -variable S(TreeALI,hiali) -value no
            set ztre  [menu  $p1.moptre.m -tearoff 0]
            $ztre add radio -label "Sub-tree Background color" -variable S(TreeALI,hitre) -value bgsb
            $ztre add radio -label "Sub-tree Foreground color" -variable S(TreeALI,hitre) -value fgsb
            $ztre add radio -label "Leaf Background color" -variable S(TreeALI,hitre) -value bgle
            $ztre add radio -label "Leaf Foreground color" -variable S(TreeALI,hitre) -value fgle
            $ztre add separator
            $ztre add radio -label "No Hightlight" -variable S(TreeALI,hitre) -value no
            menubutton $p1.mresetali -text "Reset" -indicatoron on -menu $p1.mresetali.m  -relief groove
            set zresetali  [menu  $p1.mresetali.m -tearoff 0]
            $zresetali add command -label "Now" -command "TreeALI::Reset"
            $zresetali add separator
            $zresetali add checkbutton -label "Automatic" -variable S(TreeALI,resetauto)
            radiobutton $p1.trealg+ -value trealg+  -image TIMtrealg+ \
                    -overrelief sunken -offrelief raised -selectcolor LightGoldenrodYellow \
                    -variable S(tool)  -indicatoron off -highlightthickness 0\
                    -background  ivory2 -borderwidth 2
            bind $p1.trealg+ <Any-Enter> "Toolbox::balloonhelp_show trealg+"
            bind $p1.trealg+ <Any-Leave> "Toolbox::balloonhelpCurrent"
            radiobutton $p1.trealg- -value trealg-  -image TIMtrealg- \
                    -overrelief sunken -offrelief raised -selectcolor LightGoldenrodYellow \
                    -variable S(tool)  -indicatoron off -highlightthickness 0\
                    -background  ivory2 -borderwidth 2
            bind $p1.trealg- <Any-Enter> "Toolbox::balloonhelp_show trealg-"
            bind $p1.trealg- <Any-Leave> "Toolbox::balloonhelpCurrent"
            grid $p1.l1 -row 0 -column 0 -sticky news
            grid $p1.l2 -row 1 -column 0 -sticky news
            grid $p1.mopali -row 2 -column 0 -sticky news
            grid $p1.moptre -row 3 -column 0 -sticky news
            grid $p1.col -row 4 -column 0 -sticky news
            grid $p1.mresetali -row 5 -column 0 -sticky news
            grid $p1.fo -row 6 -column 0 -sticky news
            grid $p1.pa -row 7 -column 0 -sticky news
            
            grid $p1.padx -row 8 -column 0 -sticky news
            grid $p1.pady -row 9 -column 0 -sticky news
            grid $p1.trealg+ -row 10 -column 0 -sticky news
            grid $p1.trealg- -row 11 -column 0 -sticky news
            grid $p1.lfa -row 12 -column 0 -sticky news
            grid $p1.g -row 13 -column 0 -sticky news
            grid $p1.c -row 14 -column 0 -sticky news
            grid $p1.ofs -row 15 -column 0 -sticky news
            grid $p1.pdb -row 16 -column 0 -sticky news
            grid $p1.msg1 -row 17 -column 0 -sticky ew
            grid $p1.msg2 -row 18 -column 0 -sticky ew
            grid $p1.zon -row 19 -column 0 -sticky ew
            grid $p1.alist -row 20 -column 0 -sticky ew
            grid $p1.e -row 21 -column 0 -sticky news
            
            
            
            ### CANVAS
            set p2 [frame .tal.ca]
            scrollbar $p2.xsbar -orient horizontal -command "$p2.c xview"
            scrollbar $p2.ysbar -orient vertical -command "$p2.c yview"
            canvas $p2.c -width 900 -height 500  \
                    -xscrollcommand "$p2.xsbar set" -yscrollcommand "$p2.ysbar set"\
                    -highlightthickness 0
            grid $p2.c -row 0 -column 0 -sticky news
            grid $p2.xsbar -row 1 -column 0 -sticky ew
            grid $p2.ysbar -row 0 -column 1 -sticky ns
            grid rowconfigure $p2 0  -weight 1
            grid columnconfigure $p2 0 -weight 1
            bind $p2.c <Any-Enter> "Interface::AnyEnterCanvas %W"
            bind $p2.c <Any-Leave> "Interface::AnyLeaveCanvas %W"
            bind trealg+  <Button-1> {TreeALI::algtre+ %W %x %y}
            bind trealg-  <Button-1> {TreeALI::algtre- %W %x %y}
            pack $p1 -side left -expand no -anchor n
            pack $p2 -side left -expand yes -fill both
        }
    }
    proc loadpdb {} {
        global fl S
        set fl [open "| ./../../../Users/pierre/Desktop/pymol -p" w]
        set run "run ./../../../Users/pierre/dossier/myscript.py"
        set load "remote(\'$S(pdbcode)\')"
        puts $fl $run
        flush $fl
        puts $fl $load
        flush $fl
    }
    
    proc UpOffset {} {
        global S
        set S(TreeALI,weight) normal
        # reset tre
        set AlistWTtarget [Selection::TreeTar]
        if {$AlistWTtarget != {}} {
            foreach {wi ti} $AlistWTtarget {
                Navigation::resetTreeVar $wi $ti tl
            }
        }
        # redraw (reset) align
        DisplayAlign
        PreAbs
    }
    proc ZonePosSelection {} {
        global S
        #S(TreeALI,zonpos)
        regsub -all "," $S(TreeALI,zonpos) " " l1
        set lpos {}
        foreach e $l1 {
            if {[string match "*-*" $e] == 1 } {
                set li [split $e "-"]
                set borneinf [lindex $li 0]
                set bornesup [lindex $li end]
                for {set i $borneinf} {$i <= $bornesup} {incr i} {
                    lappend lpos $i
                }
            } else  {
                lappend lpos $e
            }
        }
        #
        set lfinal {}
        foreach k $lpos {
            if {[lsearch $lfinal $k] == -1} {lappend lfinal $k}
        }
        set lfinal [lsort -integer -increasing $lfinal ]
        # affichage
        set c .tal.ca.c
        foreach col $lfinal {
            
            # hightlight alignement
            switch $S(TreeALI,hiali)  {
                bg {
                    $c delete BBCOL$col
                    set co [$c bbox COL$col]
                    if {$co != ""} {
                        set x1 [lindex $co 0] ; set y1 [lindex $co 1] ; set x2 [lindex $co 2] ; set y2 [lindex $co 3]
                        
                        set idc [$c create rectangle $x1 $y1 $x2 $y2 \
                                -tag "BBCOL$col BBC" -fill $S(col) -outline $S(col) -width 1]
                        $c lower $idc
                    }
                }
                fg {
                    $c itemconfigure COL$col -fill $S(col)
                }
            }
            # hightlight tree
            if {$S(TreeALI,hitre) != "no"} {
                switch $S(TreeALI,hitre)  {
                    bgsb {set S(operation) nodebgcolor}
                    fgsb {set S(operation) nodefgcolor}
                    bgle {set S(operation) leafbgcolor}
                    fgle {set S(operation) leaffgcolor}
                }
                set AlistWTtarget [Selection::TreeTar]
                if {$AlistWTtarget != {}} {
                    foreach {wi ti} $AlistWTtarget {
                        Operation::Operation $wi $ti $col
                    }
                }
            }
        }
        $c lower SHOW
    }
    #
    proc ExportAlist {} {
        global S align
        set c .tal.ca.c
        set lid [$c find withtag BBC]
        if {$lid != ""} {
            set alist {}
            foreach id $lid {
                set tags [$c gettag $id]
                set pos [string trimleft \
                        [lindex $tags [lsearch -glob $tags BBCOL*]] BBCOL]
                set col [lindex [$c itemconfigure $id -fill] end]
                lappend alist $pos $col
            }
            
            # gaps, primary seq as reference
            # set seq $align([lindex $align(seqnam) 0])
            # set newalist {}
            # foreach {pos col} $alist {
            # set frag [string range $seq 0 [expr $pos - 1]]
            # set nb [regsub -all {\-} $frag 0 temp]
            # #puts $nb
            # lappend newalist [expr $pos - $nb] $col
            # }
            # offset
            #set lastalist {}
            #foreach {pos col} $newalist {
            #    lappend lastalist [expr $pos + $S(TreeALI,offset)] $col
            #}
            #save
            set typelist {
                {"Position Color Alist Files" {".txt"} }
                {"All Files" {*}}
            }
            set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".txt" \
                    -filetypes $typelist -title "Save as Position Color Alist file(s)..."]
            if {$file != "" } {set S(userDIR) [file dirname $file]}
            if {$file != ""} {
                set fid [open $file w]
                #puts $fid $newalist
                puts $fid $alist
                close $fid
            }
        }
    }
    #
    #
    proc PadXY {} {
        # save pos
        set c .tal.ca.c
        set lid [$c find withtag BBC]
        if {$lid != ""} {
            set alist {}
            foreach id $lid {
                set tags [$c gettag $id]
                set pos [string trimleft \
                        [lindex $tags [lsearch -glob $tags BBCOL*]] BBCOL]
                set col [lindex [$c itemconfigure $id -fill] end]
                lappend alist $pos $col
            }
        }
        # padding
        TreeALI::DisplayAlign
        # restaure pos
        foreach {col couleur} $alist {
            set co [$c bbox COL$col]
            if {$co != ""} {
                set x1 [lindex $co 0] ; set y1 [lindex $co 1] ; set x2 [lindex $co 2] ; set y2 [lindex $co 3]
                set idc [$c create rectangle $x1 $y1 $x2 $y2 \
                        -tag "BBCOL$col BBC" -fill $couleur -outline $couleur -width 1]
                $c lower $idc
            }
        }
    }
    #
    proc SelectRow {l} {
        set c .tal.ca.c
        set na [$l get [$l curselection]]
        set ytot [lindex [$c bbox all] end]
        set rowtag [lindex [$c gettags $na] 0]
        set co [$c coords $na]
        set y [lindex $co 1]
        $c yview moveto [format %1.1f [expr $y / $ytot]]
        $c delete SHOW
        for  {set i 0} {$i <= 3} {incr i} {
            after 100
            $c create rectangle [$c bbox $rowtag] -tag SHOW -outline white -fill grey
            $c lower SHOW
            update
            after 100
            $c delete SHOW
            update
        }
        $c create rectangle [$c bbox $rowtag] -tag SHOW -outline white -fill grey
        $c lower SHOW
    }
    proc Reset {} {
        global S
        # pour l'instant ali ET tre, toutes variables
        set c .tal.ca.c
        #reset ali
        #$c itemconfigure str -fill black
        $c delete BBC
        set S(TreeALI,weight) normal
        # reset tre
        set AlistWTtarget [Selection::TreeTar]
        if {$AlistWTtarget != {}} {
            foreach {wi ti} $AlistWTtarget {
                Navigation::resetTreeVar $wi $ti tl
            }
        }
    }
    proc algtre- {w x y} {
        if {$w == ".tal.ca.c"} {
            algtre-- $w $x $y
        } else  {
            trealg- $w $x $y
        }
    }
    # en provenance ali
    proc algtre-- {w x y} {
        global S T
        set c .tal.ca.c
        set tags [$c gettags [$c find withtag current]]
        set col [string trimleft \
                [lindex $tags [lsearch -glob $tags COL*]] COL]
        if {$col != ""} {
            # reset align i
            switch $S(TreeALI,hiali)  {
                bg {
                    $c delete BBCOL$col
                }
                fg {
                    $c itemconfigure COL$col -fill black
                }
            }
            #reset tree
            set AlistWTtarget [Selection::TreeTar]
            if {$AlistWTtarget != {}} {
                switch $S(TreeALI,hitre)  {
                    bgsb {set op tbg}
                    fgsb {set op tfg}
                    bgle {set op lbg}
                    fgle {set op lfg}
                }
                foreach {wi ti} $AlistWTtarget {
                    catch    {Navigation::resetNodeVar $wi $ti $T($ti,ltc,$col) $op}
                }
            }
        }
    }
    # en provenance tre
    proc trealg- {w x y} {
        global S T
        set c .tal.ca.c
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            set leafs [Tools::NodeNoToLe $t $n]
            set EUS [lsort -dictionary [Tools::NodeLeCoToRe $t $leafs]]
            # reset alignement
            foreach l $EUS {
                switch $S(TreeALI,hiali)  {
                    bg {
                        $c delete BBCOL$l
                    }
                    fg {
                        $c itemconfigure COL$l -fill black
                    }
                }
            }
            # reset tree
            switch $S(TreeALI,hitre)  {
                bgsb {set op tbg}
                fgsb {set op tfg}
                bgle {set op lbg}
                fgle {set op lfg}
            }
            Navigation::resetNodeVar $w $t $n $op
        }
    }
    proc PanelQuit {} {
        set choix [tk_messageBox -type okcancel -default ok  \
                -message "Exit TreeALI ?" -icon question]
        if {$choix == "ok"} {
            eval destroy .tal
        }
    }
    proc DisHidGAP {} {
        set c .tal.ca.c
        set gaps [$c find withtag GAP]
        set etat [lindex [$c itemconfigure [lindex $gaps 0] -state] end]
        
        if {$etat == "normal" || $etat == ""} {
            $c itemconfigure GAP -state hidden
        } else  {
            $c itemconfigure GAP -state normal
        }
    }
    proc userColor {id} {
        global S
        set S(col) [tk_chooseColor]
        $id configure -background $S(col)
    }
    #
    proc LoadAlign {} {
        global S align
        set typelist {
            {"All Files" {*}}
        }
        set file [tk_getOpenFile -initialdir $S(userDIR)  -filetypes $typelist -title "Load a matrix..."]
        if [catch {open $file r} fid] {
        } else {
            set align(seqnam) ""
            while {[eof $fid] != 1} {
                set s [gets $fid]
                if {$s != ""} {
                    set seqaa [gets $fid]
                    lappend align(seqnam) $s
                    set align($s) $seqaa
                }
            }
        }
        DisplayAlign
    }
    #
    proc DisplayAlign {} {
        global S align
        set c .tal.ca.c
        $c delete all
        # $S(TreeALI,weight)
        set font [list Courrier $S(TreeALI,size) ]
        # padding (pixels)
        set padx $S(TreeALI,padx)
        set pady $S(TreeALI,pady)
        set y 0
        set rowid 0
        # traitement sequence reference
        set indexvrai [expr $S(TreeALI,offset) -1]
        set indexgap [expr $S(TreeALI,offset) -1]
        foreach v [split $align([lindex $align(seqnam) 0]) {}] {
            incr indexvrai
            if {$v != "-"} {
                incr indexgap
                set align(index,$indexvrai) $indexgap
                
            } else  {
                set align(index,$indexvrai) GAP
            }
        }
        set align(totalindexgap) $indexgap
        # traitement seq 1 end ORIGINAL  OK
        ################################################################################
        #         foreach s $align(seqnam) {
        #             set y [expr $y + $pady]
        #             incr rowid
        #             set colid [expr $S(TreeALI,offset) -1]
        #             set x 0
        #             $c create text $x $y -text $rowid -font $font -tags "ROW$rowid str NAMnb" -anchor e
        #             #regsub -all {[|]} $s " " nam
        #             $c create text $x $y -text $s -font $font -tags "ROW$rowid str NAMna $s" -anchor w
        #
        #             foreach v [split $align($s) {}] {
        #                 incr colid
        #                 set x [expr $x + $padx]
        #                 if {$v == "-"} {
        #                     set tags "$s ROW$rowid COL$colid GAP aa str str2"
        #                 } else  {
        #                     set tags "$s ROW$rowid COL$colid str aa str2 "
        #                 }
        #                 $c create text $x $y -text $v -font $font -tags $tags
        #             }
        #         }
        ################################################################################
        foreach s $align(seqnam) {
            set y [expr $y + $pady]
            incr rowid
            #set colid [expr $S(TreeALI,offset) -1]
            set indexvrai [expr $S(TreeALI,offset) -1]
            set x 0
            $c create text $x $y -text $rowid -font $font -tags "ROW$rowid str NAMnb" -anchor e
            #regsub -all {[|]} $s " " nam
            $c create text $x $y -text $s -font $font -tags "ROW$rowid str NAMna $s" -anchor w
            
            foreach v [split $align($s) {}] {
                incr indexvrai
                set x [expr $x + $padx]
                
                set tags "$s ROW$rowid COL$align(index,$indexvrai) GAP aa str str2"
                if {$v == "-"} {
                    #set tags "$s ROW$rowid COL$colid GAP aa str str2"
                    set tags "$s ROW$rowid COL$align(index,$indexvrai) GAP aa str str2"
                } else  {
                    #set tags "$s ROW$rowid COL$colid str aa str2 "
                    set tags "$s ROW$rowid COL$align(index,$indexvrai) str aa str2 "
                }
                $c create text $x $y -text $v -font $font -tags $tags
            }
            
        }
        # numero de seq
        $c bind aa <Any-Enter> "TreeALI::EnterAA %W %x %y"
        set co [$c bbox NAMnb]
        set x1 [lindex $co 0] ; set y1 [lindex $co 1] ; set x2 [lindex $co 2] ; set y2 [lindex $co 3]
        set idc [$c create rectangle $x1 $y1 $x2 $y2 -tag "BBNAMnb" -fill grey -outline grey -width 1]
        $c lower $idc
        #nom sequence
        $c move NAMna [expr $x2 + 5] 0
        set co [$c bbox NAMna]
        set x1 [lindex $co 0] ; set y1 [lindex $co 1] ; set x2 [lindex $co 2] ; set y2 [lindex $co 3]
        set idc [$c create rectangle $x1 $y1 $x2 $y2 -tag "BBNAMnb" -fill AntiqueWhite1 -outline AntiqueWhite1 -width 1]
        $c lower $idc
        # move sequence
        $c move str2 [expr $x2 + 5] 0
        # list nam seq
        .tal.co.lfa.l delete 0 end
        eval {.tal.co.lfa.l insert end} $align(seqnam)
        $c configure -scrollregion [$c bbox all]
        $c yview moveto 0
        $c xview moveto 0
    }
    #
    proc EnterAA {w x y} {
        global S
        set tags [$w gettag current]
        set seq [lindex $tags 0]
        set pos [string trimleft \
                [lindex $tags [lsearch -glob $tags COL*]] COL]
        set S(TreeALI,msg1) "Seq. $seq"
        set S(TreeALI,msg2) "Pos. $pos"
    }
    #
    proc GlobalView {} {
        #$c create rectangle $x $y [expr $x +1] [expr $y+1]  -tags $tags -outline black -fill black
    }
    #
    proc Fontali {z} {
        global S
        # save pos
        set c .tal.ca.c
        set lid [$c find withtag BBC]
        set alist {}
        if {$lid != ""} {
            
            foreach id $lid {
                set tags [$c gettag $id]
                set pos [string trimleft \
                        [lindex $tags [lsearch -glob $tags BBCOL*]] BBCOL]
                set col [lindex [$c itemconfigure $id -fill] end]
                lappend alist $pos $col
            }
        }
        # update font
        switch  $z {
            in {
                #set font [list Courrier $S(TreeALI,size) $S(TreeALI,weight)]
                set S(TreeALI,size) [expr $S(TreeALI,size) + 1]
                set font [list Courrier $S(TreeALI,size)]
            }
            out {
                #set font [list Courrier $S(TreeALI,size) $S(TreeALI,weight)]
                set S(TreeALI,size) [expr $S(TreeALI,size) - 1]
                set font [list Courrier $S(TreeALI,size)]
            }
            
        }
        $c itemconfigure str -font $font
        $c delete BBC
        # restaure pos
        
        
        foreach {col couleur} $alist {
            set co [$c bbox COL$col]
            if {$co != ""} {
                set x1 [lindex $co 0] ; set y1 [lindex $co 1] ; set x2 [lindex $co 2] ; set y2 [lindex $co 3]
                set idc [$c create rectangle $x1 $y1 $x2 $y2 \
                        -tag "BBCOL$col BBC" -fill $couleur -outline $couleur -width 1]
                $c lower $idc
            }
        }
        
        PreAbs
    }
    #
    proc PreAbs {} {
        global S
        switch -- $S(TreeALI,preabs) {
            yes {
                NoPA
                TreeALI::FromTree2Ali
                TreeALI::FromAli2Tree
            }
            no {TreeALI::NoPA}
        }
    }
    #
    proc NoPA {} {
        #reset  ali
        global T S align
        set c .tal.ca.c
        set AlistWTtarget [Selection::TreeTar]
        set font [list Courrier $S(TreeALI,size) normal]
        # Allumage (font bold) positions de ALI
        set lPosTot {}
        if {$AlistWTtarget != {}} {
            foreach {wi ti} $AlistWTtarget {
                $c itemconfigure aa -fill black -font $font
            }
        }
        foreach {wi ti} $AlistWTtarget {
            foreach position $T($ti,ue_lab) {
                $wi itemconfigure EUL$position -fill black -font {Helvetica 8 normal}
            }
        }
    }
    #
    proc FromTree2Ali {} {
        global T S align
        set c .tal.ca.c
        set AlistWTtarget [Selection::TreeTar]
        # Allumage (font bold) positions de ALI
        set lPosTot {}
        if {$AlistWTtarget != {}} {
            foreach {wi ti} $AlistWTtarget {
                foreach position $T($ti,ue_lab) {
                    if {[lsearch $lPosTot $position] == -1} {lappend lPosTot $position}
                }
            }
            $c itemconfigure aa -fill grey40
            if {$S(TreeALI,weight) == "normal"} {
                set S(TreeALI,weight) bold
                set font [list Courrier $S(TreeALI,size) bold]
                foreach position $lPosTot {
                    $c itemconfigure COL$position -font $font -fill black
                }
            } else  {
                set S(TreeALI,weight) normal
                set font [list Courrier $S(TreeALI,size) bold]
                foreach position $lPosTot {
                    $c itemconfigure COL$position -font $font -fill black
                }
            }
        }
    }
    # on regarde les positions de la sequence de reference
    proc FromAli2Tree {} {
        global T S align
        set c .tal.ca.c
        set AlistWTtarget [Selection::TreeTar]
        # Allumage (font bold) positions tree(s)
        if {$AlistWTtarget != {}} {
            foreach {wi ti} $AlistWTtarget {
                foreach position $T($ti,ue_lab) {
                    if {$position <= $align(totalindexgap)} {
                        $wi itemconfigure EUL$position -font {Helvetica 8 bold}
                    } else  {
                        $wi itemconfigure EUL$position -fill grey40
                    }
                }
            }
        }
    }
    proc AliAndTree {} {
    }
    #
    proc Pad {z} {
        global S
        set c .tal.ca.c
        switch  $z {
            in {
                set S(TreeALI,size) [expr $S(TreeALI,size) + 1]
                set font [list Courrier $S(TreeALI,size) $S(TreeALI,weight)]
            }
            out {
                set S(TreeALI,size) [expr $S(TreeALI,size) - 1]
                set font [list Courrier $S(TreeALI,size) $S(TreeALI,weight)]
            }
        }
        $c itemconfigure all -font $font
    }
    #
    proc algtre+ {w x y} {
        global S
        if {$S(TreeALI,resetauto) == 1} {Reset}
        if {$w == ".tal.ca.c"} {
            algtre++ $w $x $y
        } else  {
            trealg+ $w $x $y
        }
    }
    # en provenance de align
    proc algtre++ {w x y} {
        global S
        set c .tal.ca.c
        set tags [$c gettags [$c find withtag current]]
        set col [string trimleft \
                [lindex $tags [lsearch -glob $tags COL*]] COL]
        if {$col != ""} {
            
            # hightlight alignement
            switch $S(TreeALI,hiali)  {
                bg {
                    $c delete BBCOL$col
                    set co [$c bbox COL$col]
                    if {$co != ""} {
                        set x1 [lindex $co 0] ; set y1 [lindex $co 1] ; set x2 [lindex $co 2] ; set y2 [lindex $co 3]
                        
                        set idc [$c create rectangle $x1 $y1 $x2 $y2 \
                                -tag "BBCOL$col BBC" -fill $S(col) -outline $S(col) -width 1]
                        $c lower $idc
                    }
                }
                fg {
                    $c itemconfigure COL$col -fill $S(col)
                }
            }
            # hightlight tree
            if {$S(TreeALI,hitre) != "no"} {
                switch $S(TreeALI,hitre)  {
                    bgsb {set S(operation) nodebgcolor}
                    fgsb {set S(operation) nodefgcolor}
                    bgle {set S(operation) leafbgcolor}
                    fgle {set S(operation) leaffgcolor}
                }
                set AlistWTtarget [Selection::TreeTar]
                if {$AlistWTtarget != {}} {
                    foreach {wi ti} $AlistWTtarget {
                        Operation::Operation $wi $ti $col
                    }
                }
            }
        }
        $c lower SHOW
    }
    # en provenance de tree
    proc trealg+ {w x y} {
        global S T
        set c .tal.ca.c
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            set leafs [Tools::NodeNoToLe $t $n]
            set EUS [lsort -dictionary [Tools::NodeLeCoToRe $t $leafs]]
            # hightlight alignement
            if {$S(TreeALI,hiali) != "no"} {
                foreach l $EUS {
                    switch $S(TreeALI,hiali)  {
                        bg {
                            $c delete BBCOL$l
                            set co [$c bbox COL$l]
                            if {$co != ""} {
                                set x1 [lindex $co 0] ; set y1 [lindex $co 1] ; set x2 [lindex $co 2] ; set y2 [lindex $co 3]
                                set idc [$c create rectangle $x1 $y1 $x2 $y2 \
                                        -tag "BBCOL$l BBC" -fill $S(col) -outline $S(col) -width 1]
                                $c lower $idc
                            }
                        }
                        fg {
                            $c itemconfigure COL$l -fill $S(col)
                        }
                    }
                }
            }
            # hightlight tree
            if {$S(TreeALI,hitre) != "no"} {
                switch $S(TreeALI,hitre)  {
                    bgsb {set S(operation) nodebgcolor}
                    fgsb {set S(operation) nodefgcolor}
                    bgle {set S(operation) leafbgcolor}
                    fgle {set S(operation) leaffgcolor}
                }
                set AlistWTtarget [Selection::TreeTar]
                if {$AlistWTtarget != {}} {
                    foreach {wi ti} $AlistWTtarget {
                        Operation::Operation $wi $ti $EUS
                    }
                }
            }
        }
        $c lower SHOW
    }
    #
    proc exportPS {} {
        global S
        set c .tal.ca.c
        set typelist {
            {"Postscript Files" {".ps"} }
            {"All Files" {*}}
        }
        set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".ps" \
                -filetypes $typelist -title "Save graphic as a Postscript file..."]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        # init si canvas vide
        set x0 0
        set y0 0
        set x1 [winfo width $c]
        set y1 [winfo height $c]
        # affectation des variables
        foreach {x0 y0 x1 y1} [$c bbox all] {}
        set w [expr $x1 - $x0]
        set h [expr $y1 - $y0]
        $c postscript  -file  $file -colormode color \
                -x $x0 -y $y0 -width $w -height $h \
                -pagex 0 -pagey 0 -pagewidth 20.c -pageheight 30.c \
                -pageanchor nw
    }
}
################################################################################


################################################################################
# TREEXY
################################################################################
namespace eval TreeXY {
    
    
    #
    proc treexyPanel {} {
        global S
        set S(TXYbrushw) 50
        set S(TXYbrushh) 50
        set S(TXYtaillC) 400
        set S(TXYhisiz) 0
        set S(TXYhicol) 1
        set S(TXYaxe) 1
        set S(TXYResetfont) 1
        set S(TXYResetcolor) 1
        if {[winfo exists .txy] == 1} {
            wm deiconify .txy
        } else  {
            set w [toplevel .txy]
            wm title $w "TreeXY"
            wm geometry .txy 700x750
            wm protocol .txy WM_DELETE_WINDOW {TreeXY::PanelQuit}
            ### CONTROLS
            set w1 [frame .txy.c]
            button $w1.l1 -text "Load annotations..." -command  "TreeXY::AnnotateLoadLabel"
            
            button  $w1.e -text "Exit" -command  "destroy .txy"
            pack $w1.l1  $w1.e -side left -expand no
            pack $w1 -expand no
            ### PANED WINDOW
            iwidgets::panedwindow .txy.p
            ### TOP tktable annotation
            .txy.p add "top"
            set p1 [.txy.p childsite "top"]
            
            ### BOTTOM canvas
            .txy.p add "bottom"
            set wc [.txy.p childsite "bottom"]
            set p2 [frame $wc.can]
            scrollbar $p2.xsbar -orient horizontal -command "$p2.c xview"
            scrollbar $p2.ysbar -orient vertical -command "$p2.c yview"
            canvas $p2.c -width 500 -height 500  \
                    -xscrollcommand "$p2.xsbar set" -yscrollcommand "$p2.ysbar set"\
                    -highlightthickness 0
            grid $p2.c -row 0 -column 0 -sticky news
            grid $p2.xsbar -row 1 -column 0 -sticky ew
            grid $p2.ysbar -row 0 -column 1 -sticky ns
            grid rowconfigure $p2 0  -weight 1
            grid columnconfigure $p2 0 -weight 1
            
            
            set ww [frame $wc.bot -width 150]
            set wd [frame $ww.li -width 150]
            scrollbar $wd.yscroll -bd 1 -command "$wd.l yview"
            scrollbar $wd.xscroll -bd 1 -orient horizontal -command "$wd.l xview "
            listbox   $wd.l -xscroll "$wd.xscroll set" -yscroll "$wd.yscroll set" \
                    -width 8 -height 5 -selectmode extended
            grid $wd.l -row 0 -column 0 -sticky news
            grid $wd.yscroll -row 0 -column 1 -sticky ns
            grid $wd.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $wd 0 -weight 1
            grid columnconfigure $wd 0 -weight 1
            bind $wd.l <ButtonRelease> ""
            
            
            set wd3 [frame $ww.li2 ]
            scrollbar $wd3.yscroll -bd 1 -command "$wd3.l yview"
            scrollbar $wd3.xscroll -bd 1 -orient horizontal -command "$wd3.l xview "
            listbox   $wd3.l -xscroll "$wd3.xscroll set" -yscroll "$wd3.yscroll set" \
                    -width 8 -height 5 -selectmode extended
            grid $wd3.l -row 0 -column 0 -sticky news
            grid $wd3.yscroll -row 0 -column 1 -sticky ns
            grid $wd3.xscroll -row 1 -column 0 -sticky ew
            grid rowconfigure $wd3 0 -weight 1
            grid columnconfigure $wd3 0 -weight 1
            bind $wd3.l <ButtonRelease> ""
            
            # SCATTERPLOT MATRIX
            iwidgets::Labeledframe $ww.co -labelpos ne -labeltext "Scatterplot matrix"
            set csco [$ww.co childsite]
            ##
            iwidgets::entryfield $csco.txytaillc -textvariable S(TXYtaillC) \
                    -labeltext "Size (p)" -labelpos w -fixed 20
            ##   taille des points
            menubutton $csco.fo -text "Dot size: " -menu $csco.fo.m -relief groove  -indicatoron 1
            set mc [menu  $csco.fo.m -tearoff 0 -relief groove]
            set S(TXYfos) 4
            $mc add radio -label "4" -variable S(TXYfos) -value 4 -command TreeXY::RedrawforSize
            $mc add radio -label "6" -variable S(TXYfos) -value 6 -command TreeXY::RedrawforSize
            $mc add radio -label "8" -variable S(TXYfos) -value 8 -command TreeXY::RedrawforSize
            $mc add radio -label "10" -variable S(TXYfos) -value 10 -command TreeXY::RedrawforSize
            $mc add radio -label "12" -variable S(TXYfos) -value 12 -command TreeXY::RedrawforSize
            ##   affichage axe
            checkbutton $csco.axe -variable  S(TXYaxe) -text Axis
            button $csco.go -text Draw -command TreeXY::TXYdraw
            # taille brush
            iwidgets::entryfield $csco.w -textvariable S(TXYbrushw) \
                    -labeltext "Brush Width (p)" -labelpos w -fixed 10
            iwidgets::entryfield $csco.h -textvariable S(TXYbrushh) \
                    -labeltext "Brush Height (p)" -labelpos w -fixed 10
            # operation ed XY vers XY
            menubutton $csco.xyhi -text "Highligthing" -menu $csco.xyhi.m  -indicatoron 1 -relief groove
            set mc [menu  $csco.xyhi.m -tearoff 0 ]
            $mc add check -label "Size" -variable S(TXYhisiz)
            $mc add check -label "Color" -variable S(TXYhicol)
            #postscript
            button $csco.ps -text "Postscript" -command TreeXY::exportPS
            ###menu reset
            menubutton $csco.reset -text "Reset" -menu $csco.reset.m  -indicatoron 1 -relief groove
            set mc [menu  $csco.reset.m -tearoff 0 ]
            $mc add check -label  "Font" -variable S(TXYResetfont)
            $mc add check -label  "Color" -variable S(TXYResetcolor)
            ## PACK
            pack $csco.txytaillc $csco.fo $csco.axe $csco.go $csco.w $csco.h $csco.xyhi $csco.reset $csco.ps -expand 1 -fill x
            pack $csco
            ### TREE
            iwidgets::Labeledframe $ww.pr -labelpos ne -labeltext "Tree"
            set cs [$ww.pr childsite]
            # check tree
            checkbutton $cs.cht -variable S(TXYcheckT) -text "Tree Highligth"
            # tree target
            menubutton $cs.target -text "Tree(s)" -menu $cs.target.m -indicatoron 1 -direction below
            set z  [menu  $cs.target.m -tearoff 0]
            $z configure -postcommand "Database::TreeTarget $z"
            #menu operation
            set mo [Operation::MenuOperation $cs ]
            ###menu reset
            menubutton $cs.reset -text "Reset" -menu $cs.reset.m  -indicatoron 1 -relief groove
            set mc [menu  $cs.reset.m -tearoff 0 ]
            $mc add check -label "Automatic Reset" -variable S(AutoReset)
            $mc add separator
            $mc add command -label  "Reset" -command {Operation::ResetGraphicVariables}
            $mc add separator
            $mc add command -label  "Graphical Variables to Reset:" -command ""
            $mc add check -label  "Leaf Foreground Color" -variable S(OpResetLFgC)
            $mc add check -label  "Leaf Background Color" -variable S(OpResetLBgC)
            $mc add check -label  "Leaf Font" -variable S(OpResetLF)
            $mc add check -label  "Node Foreground Color" -variable S(OpResetNFgC)
            $mc add check -label  "Node Background Color" -variable S(OpResetNBgC)
            $mc add check -label  "Node Line (Width)" -variable S(OpResetNLW)
            $mc add check -label  "Node Line (Dash)" -variable S(OpResetNLD)
            $mc add command -label  "Select All" -command "Operation::ResetAllFig+"
            $mc add command -label  "UnSelect All" -command "Operation::ResetAllFig-"
            pack $cs
            pack $wd $wd3 $ww.co   $ww.pr $cs.cht $cs.target $mo $cs.reset -side top -expand true -fill both
            ### TOOLBOX
            iwidgets::Labeledframe $ww.tools -labelpos ne -labeltext "Toolbox"
            set pt [$ww.tools childsite]
            foreach {tool color} {xytot ivory2 ttoxy ivory2    } {
                radiobutton $pt.$tool -value $tool  -image TIM$tool \
                        -overrelief sunken -offrelief raised -selectcolor LightGoldenrodYellow \
                        -variable S(tool)  -indicatoron off -highlightthickness 0\
                        -background  $color -borderwidth 2 -command TreeXY::$tool
                pack $pt.$tool -side left
                bind $pt.$tool <Any-Enter> "Toolbox::balloonhelp_show $tool"
                bind $pt.$tool <Any-Leave> "Toolbox::balloonhelpCurrent"
            }
            pack $pt -expand 1 -fill both
            pack $ww.tools -expand 1 -fill both
            pack $ww $p2 -expand 1 -fill both -side left
            .txy.p fraction 20  80
            pack .txy.p -expand yes -fill both
        }
    }
    proc exportPS {} {
        global S
        set c .txy.p.pane1.childsite.can.c
        set typelist {
            {"Postscript Files" {".ps"} }
            {"All Files" {*}}
        }
        set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".ps" \
                -filetypes $typelist -title "Save graphic as a Postscript file..."]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        # init si canvas vide
        set x0 0
        set y0 0
        set x1 [winfo width $c]
        set y1 [winfo height $c]
        # affectation des variables
        foreach {x0 y0 x1 y1} [$c bbox all] {}
        set w [expr $x1 - $x0]
        set h [expr $y1 - $y0]
        $c postscript  -file  $file -colormode color \
                -x $x0 -y $y0 -width $w -height $h \
                -pagex 0 -pagey 0 -pagewidth 20.c -pageheight 30.c \
                -pageanchor nw
    }
    proc xytot {} {
        Brush .txy.p.pane1.childsite.can.c
    }
    proc ttoxy {} {
        global S
        set S(tool) ttoxy
        .txy.p.pane1.childsite.can.c delete box
    }
    proc ttoxyGO {w x y} {
        global S T
        set c .txy.p.pane1.childsite.can.c
        set tags [$w gettags [$w find withtag current]]
        set n [string trimright \
                [lindex $tags [lsearch -glob $tags *C]] C]
        set t [string range \
                [lindex $tags [lsearch -glob $tags T*]] 1 end]
        if {$n != ""} {
            set w $S($t,w)
            set ltag {} ; set ll {}
            set leafs [Tools::NodeNoToLe $t $n]
            foreach code $leafs {
                lappend ltag F$T($t,ctl,$code)
                lappend ll $T($t,ctl,$code)
            }
            XYhi $c $ltag
            Operation::OperationAction $w $t $ll
        }
    }
    proc PanelQuit {} {
        set choix [tk_messageBox -type okcancel -default ok  \
                -message "Exit TreeXY ?" -icon question]
        if {$choix == "ok"} {
            eval destroy .txy
        }
    }
    proc RedrawforSize {} {
        global S
        set c .txy.p.pane1.childsite.can.c
        set font [list Helvetica $S(TXYfos)]
        $c itemconfigure dot -font $font
    }
    proc TXYdraw {} {
        global S
        set c .txy.p.pane1.childsite.can.c
        $c delete all
        # set c .t1.c
        # taille scatterplot
        set TaillC $S(TXYtaillC)
        #liste des variables
        set lv {}
        set lindex [.txy.p.pane1.childsite.bot.li.l curselection]
        foreach i $lindex {
            lappend lv [.txy.p.pane1.childsite.bot.li.l get $i]
        }
        # nombre de variables
        set n [llength $lv]
        # taille de chaque nuage
        set TaillN  [expr round($TaillC / $n)]
        # recherche Xmax et Ymax global
        set MAX 0.0 ; set MIN 0.0
        foreach var $lv  {
            foreach i [Database::dbQueryValFromVar $S(database) $var] {
                if {$i >= $MAX} {set MAX $i}
                if {$i <= $MIN} {set MIN $i}
            }
        }
        
        set FACTOR [expr abs($TaillN / ($MAX-$MIN)) ]
        set lf [Database::dbQueryValFromVar $S(database) EU]
        set indexX 0
        set indexY 0
        
        
        set font [list Helvetica $S(TXYfos)]
        
        foreach vY $lv {
            set indexX 0
            incr indexY
            foreach vX $lv  {
                incr indexX
                set lx [Database::dbQueryValFromVar $S(database) $vX]
                set ly [Database::dbQueryValFromVar $S(database) $vY]
                #set color [format #%06x [expr {int(rand() * 0xFFFFFF)}]]
                set color black
                foreach xi $lx yi $ly f $lf  {
                    set x [expr $xi * $FACTOR]
                    set y [expr $yi * $FACTOR]
                    $c create text $x $y \
                            -text + -font $font -tags "C$indexX$indexY F$f FFF dot" -fill $color
                }
                # axe ?
                if {$S(TXYaxe)} {
                    $c create line [expr $MIN * $FACTOR] 0  [expr $MAX * $FACTOR]  0 \
                            -tags "C$indexX$indexY FFF" -fill grey
                    $c create line 0 [expr $MIN * $FACTOR] 0  [expr $MAX * $FACTOR]   \
                            -tags "C$indexX$indexY  FFF" -fill grey
                }
                # affichage variable
                if {$indexY == 1} {
                    $c create text [expr $MIN * $FACTOR] [expr $MIN * $FACTOR] -anchor sw \
                            -text $vX -font {Helvetica 7} -tags "C$indexX$indexY FFF" -fill blue
                }
                if {$indexX == 1} {
                    $c create text [expr $MIN * $FACTOR] [expr $MIN * $FACTOR] -anchor ne \
                            -text $vY -font {Helvetica 7} -tags "C$indexX$indexY FFF" -fill blue
                }
                
                $c create rectangle [expr $MIN * $FACTOR] [expr $MIN * $FACTOR]\
                        [expr $MAX * $FACTOR] [expr $MAX * $FACTOR] -tags "C$indexX$indexY FFF" -outline black
                $c move C$indexX$indexY [expr ($indexX * $TaillN)] [expr ($indexY * $TaillN)]
            }
        }
        set co [$c bbox FFF]
        set x [lindex $co 0] ; set y [lindex $co 1] ; set x2 [lindex $co 2]
        $c move FFF 0 20
        $c create text $x $y -text "Min= $MIN Max= $MAX" \
                -font {Helvetica 7} -anchor w -tags "MINMAX" -fill blue
        #Brush $c
        #FishEyeList $c [lsort $lf] $x2 $y
        $c configure -scrollregion [$c bbox all]
    }
    #
    proc AnnotateLoadLabel {} {
        global S
        set filtre {}
        lappend filtre [list {TreeDyn Label File} .txt]
        set typelist {
            {"TreeDyn Labels Files" {".tlf"} }
            {"All Files" {*}}
        }
        set filename [tk_getOpenFile -initialdir $S(userDIR)  -defaultextension "tlf" \
                -filetypes $typelist -title "Load Annotations..."]
        if {$filename != ""} {set S(userDIR) [file dirname $filename]}
        if [catch {open $filename r} fid] {
            puts stderr "Error Opening File"
        } else {
            set currentfile [Tools::PathCut2 $filename]
            if {[lsearch $S(ldatabase) $currentfile] != -1 } {
                upvar #0 $currentfile X
                array unset X
            } else  {
                set S(database) $currentfile
                lappend S(ldatabase) $currentfile
            }
            Database::db $currentfile
            while {[eof $fid] != 1} {
                set id [incr S(lastid)]
                gets $fid data
                eval $currentfile [concat $id EU $data]
            }
            close $fid
        }
        #listbox variables
        set lvar [Database::dbQueryVarAll $S(database)]
        # remplissage listbox
        .txy.p.pane1.childsite.bot.li.l delete 0 end
        eval {.txy.p.pane1.childsite.bot.li.l insert end} $lvar
        # table
        dbBrowserFill .txy.p.pane0.childsite
        #remplisage lisbox
        .txy.p.pane1.childsite.bot.li2.l delete 0 end
        eval {.txy.p.pane1.childsite.bot.li2.l insert end} [lsort [Database::dbQueryValFromVar $S(database) EU]]
    }
    proc dbBrowserFill {w} {
        global fxy S
        set database $S(database)
        if {$database != ""} {
            upvar #0 $database X
            # init
            if {[winfo exists $w.t] == 1} {destroy $w.t $w.sy $w.sx}
            catch {unset f}
            
            # unset f
            # remplissage row 0 col j
            set variables [Database::dbQueryVarAll $database]
            set records [lsort -dictionary [Database::dbQueryRecordsAll $database]]
            set j -1
            foreach variable $variables {
                incr j
                set fxy(0,$j) $variable
            }
            set NBvariables [llength $variables]
            set NBrecords [llength $records]
            # construction Tktable
            set ta [table $w.t -rows [expr $NBrecords + 1] -cols $NBvariables -variable fxy  \
                    -yscrollcommand "$w.sy set"  -xscrollcommand  "$w.sx set " \
                    -titlerows 1 -titlecols 0    \
                    -height 10 -rowheight 1 -selectmode extended -bd 1\
                    -colstretch unset -rowstretch last  ]
            
            # remplissage i,j
            set NBvariables [llength $variables]
            set NBrecords [llength $records]
            set S(msgindent1) "$NBrecords records * [expr $NBvariables -1] columns"
            set row 0 ; set col -1
            foreach record $records {
                incr row ; set col -1
                foreach variable $variables {
                    incr col
                    set data [$database $record $variable]
                    if {$data == ""} {set data -}
                    #regsub -all " " $data "\n" data
                    set fxy($row,$col) $data
                }
                $ta tag row $record $row
            }
            $ta tag config title -bg grey60 -relief groove
            #
            scrollbar $w.sy -command [list $w.t yview]
            scrollbar $w.sx -command [list $w.t xview] -orient horizontal
            # GRID
            grid $w.t -row 0 -column 0 -sticky news
            grid $w.sx -row 1 -column 0 -sticky ew
            grid $w.sy -row 0 -column 1 -sticky ns
            grid rowconfigure $w 0  -weight 1
            grid columnconfigure $w 0 -weight 1
        }
    }
    proc FishEyeList {c l x y} {
        global T  NBelt
        set t 1
        set NBelt 0
        foreach i $l {
            $c create text $x $y -text $i -tags "FE$t FE FE$i" -font {Courier 2 normal} -anchor w
            incr y 3
            incr t 1
            incr NBelt
        }
        $c bind FE <Any-Enter> "TreeXY::Up %W %x %y"
        $c bind FE <Any-Leave> "TreeXY::Cl %W %x %y"
        $c bind FE <Button-1> "TreeXY::Hi %W %x %y"
    }
    proc Hi {w x y} {
        set tag [string range [lindex [$w gettags current] 2] 2 end]
        
        $w itemconfigure F$tag -font {Courier 10 normal}
    }
    proc Up {w x y} {
        global NBelt
        set tag [string range [lindex [$w gettags current] 0] 2 end]
        
        # central
        $w itemconfigure current -font {Courier 12} -fill blue
        # rang -1 RETRAIT de 10
        $w itemconfigure FE[expr $tag - 1] -font {Courier 10}
        $w move FE[expr $tag - 1] 0 -10
        # rang +1
        $w itemconfigure FE[expr $tag + 1] -font {Courier 10}
        $w move FE[expr $tag + 1] 0 +10
        # rang -2 RETRAIT relatif de 8, donc RETRAIT absolu de 18
        $w itemconfigure FE[expr $tag - 2] -font {Courier 8}
        $w move FE[expr $tag - 2] 0 -18
        # rang +2
        $w itemconfigure FE[expr $tag + 2] -font {Courier 8}
        $w move FE[expr $tag + 2] 0 +18
        # rang -3 RETRAIT relatif de 6, donc RETRAIT absolu de 24
        $w itemconfigure FE[expr $tag - 3] -font {Courier 6}
        $w move FE[expr $tag - 3] 0 -24
        # rang +3
        $w itemconfigure FE[expr $tag + 3] -font {Courier 6}
        $w move FE[expr $tag + 3] 0 +24
        # Tous les autres en amont de current
        for  {set i 0 } {$i <= [expr $tag - 4]} {incr i} {
            $w move  FE$i 0  -30
            $w itemconfigure FE$i -font {Courier 2} -fill black
        }
        # Tous les autres en aval de current
        for  {set i [expr $tag + 4]} {$i <= $NBelt} {incr i} {
            $w move   FE$i 0 +30
            $w itemconfigure FE$i -font {Courier 2} -fill black
        }
    }
    proc Cl {w x y} {
        global NBelt
        set tag [string range [lindex [$w gettags current] 0] 2 end]
        # central
        $w itemconfigure current -font {Courier 2} -fill black
        # rang -1
        $w itemconfigure FE[expr $tag - 1] -font {Courier 2}
        $w move FE[expr $tag - 1] 0 +10
        # rang +1
        $w itemconfigure FE[expr $tag + 1] -font {Courier 2}
        $w move FE[expr $tag + 1] 0 -10
        # rang -2
        $w itemconfigure FE[expr $tag - 2] -font {Courier 2}
        $w move FE[expr $tag - 2] 0 +18
        # rang +2
        $w itemconfigure FE[expr $tag + 2] -font {Courier 2}
        $w move FE[expr $tag + 2] 0 -18
        # rang -3
        $w itemconfigure FE[expr $tag - 3] -font {Courier 2}
        $w move FE[expr $tag - 3] 0 +24
        # rang +3
        $w itemconfigure FE[expr $tag + 3] -font {Courier 2}
        $w move FE[expr $tag + 3] 0 -24
        # Tous les autres en amont de current
        for  {set i 0 } {$i <= [expr $tag - 4]} {incr i} {
            $w move  FE$i 0  +30
            $w itemconfigure FE$i -font {Courier 2} -fill black
        }
        # Tous les autres en aval de current
        for  {set i [expr $tag + 4]} {$i <= $NBelt} {incr i} {
            $w move FE$i 0 -30
            $w itemconfigure FE$i -font {Courier 2} -fill black
        }
    }
    #
    proc Brush {c} {
        global S
        set co [$c bbox C11]
        set x [$c canvasx [lindex $co 0]] ; set y [$c canvasy [lindex $co 1]]
        bind $c <Button-1>  "TreeXY::BrowserB1 %W %x %y"
        Brush_Create $c $x $y [expr $x + $S(TXYbrushw)] [expr $y + $S(TXYbrushh)]
    }
    ###
    proc Brush_Create {w x1 y1 x2 y2} {
        global S
        set S(TXYbrushw) [expr $x2 - $x1]
        set S(TXYbrushh) [expr $y2 - $y1]
        set S(TXYbrushX) $x1
        set S(TXYbrushY) $y1
        $w create rectangle $x1 $y1 $x2 $y2 -tags "box boxsel" -outline blue -width 1
        $w create rectangle [expr $x1 -2] [expr $y1 - 2] [expr $x1 + 2] [expr $y1 + 2] \
                -tags "bbox box NW" -fill orange
        $w create rectangle [expr $x1 -2] [expr $y2 - 2] [expr $x1 + 2] [expr $y2 + 2] \
                -tags "bbox box SW" -fill orange
        $w create rectangle [expr $x2 -2] [expr $y1 - 2] [expr $x2 + 2] [expr $y1 + 2] \
                -tags "bbox box NE" -fill orange
        $w create rectangle [expr $x2 -2] [expr $y2 - 2] [expr $x2 + 2] [expr $y2 + 2] \
                -tags "bbox box SE" -fill orange
        $w bind bbox <Any-Enter> "$w itemconfigure bbox -fill yellow"
        $w bind bbox <Any-Leave> "$w itemconfigure bbox -fill orange"
    }
    
    ###
    proc BrowserB1 {w x y} {
        set tags [$w gettags [$w find withtag current]]
        if {[lsearch -exact $tags SE] != -1} {
            bind $w <B1-Motion> "TreeXY::BrowserB1MotionResizeBrush %W %x %y SE"
        } elseif {[lsearch -exact $tags SW] != -1} {
            bind $w <B1-Motion> "TreeXY::BrowserB1MotionResizeBrush %W %x %y SW"
        } elseif {[lsearch -exact $tags NE] != -1} {
            bind $w <B1-Motion> "TreeXY::BrowserB1MotionResizeBrush  %W %x %y NE"
        } elseif {[lsearch -exact $tags NW] != -1} {
            bind $w <B1-Motion> "TreeXY::BrowserB1MotionResizeBrush  %W %x %y NW"
        } else {
            bind $w <B1-Motion> "TreeXY::BrowserB1MotionMoveBrush %W %x %y"
        }
    }
    ###
    proc BrowserB1MotionMoveBrush  {w x y } {
        global S
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        $w move box [expr $x - $S(TXYbrushX)] [expr $y - $S(TXYbrushY)]
        set S(TXYbrushX) $x
        set S(TXYbrushY) $y
        set ll {}
        set ltag {}
        foreach i [$w find enclosed $x $y [expr $x + $S(TXYbrushw)] [expr $y + $S(TXYbrushh)]] {
            set tag [lindex [$w gettags $i] 1]
            lappend ltag $tag
            lappend ll [string range $tag 1 end]
        }
        
        XYhi $w $ltag
        if {$S(TXYcheckT)} {
            set AlistWTtarget [Selection::TreeTar]
            if {$AlistWTtarget != {}} {
                foreach {wi ti} $AlistWTtarget {
                    Operation::Operation $wi $ti $ll
                }
            }
        }
        
    }
    proc XYhi {w ltag} {
        global S
        #reset
        if {$S(TXYResetfont)} {
            set font [list Helvetica $S(TXYfos)]
            $w itemconfigure dot -font $font
        }
        if {$S(TXYResetcolor)} {
            $w itemconfigure dot -fill black
        }
        
        if {$S(TXYhisiz) == 1 && $S(TXYhicol) == 1} {
            set fontHI  [format "%s%s%s%s" \{ Helvetica [expr $S(TXYfos) + 4] \}]
            #
            foreach tag $ltag {
                $w itemconfigure $tag -fill $S(col)
                $w itemconfigure $tag -font $fontHI
            }
        }
        if {$S(TXYhisiz) == 1 && $S(TXYhicol) == 0} {
            
            set fontHI  [format "%s%s%s%s" \{ Helvetica [expr $S(TXYfos) + 4] \}]
            #
            foreach tag $ltag {
                $w itemconfigure $tag -font $fontHI
            }
        }
        if {$S(TXYhisiz) == 0 && $S(TXYhicol) == 1} {
            #
            foreach tag $ltag {
                $w itemconfigure $tag -fill $S(col)
            }
        }
    }
    ###
    proc BrowserB1MotionResizeBrush {w x y ori} {
        set coords [$w coords box]
        set x1 [lindex $coords 0]
        set y1 [lindex $coords 1]
        set x2 [lindex $coords 2]
        set y2 [lindex $coords 3]
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        $w delete box
        switch $ori {
            NW {TreeXY::Brush_Create $w $x $y $x2 $y2}
            SW {TreeXY::Brush_Create $w $x $y1 $x2 $y}
            NE {TreeXY::Brush_Create $w $x1 $y $x $y2}
            SE {TreeXY::Brush_Create $w $x1 $y1 $x $y}
        }
        $w itemconfigure bbox -fill yellow
    }
    
    
}
################################################################################*


################################################################################
# TDCOM
################################################################################
namespace eval TDcom {
    # INIT
    
    
    proc com {argv} {
        wm withdraw .
        global T S Export asedCon
        
        ### ARGUMENTS
        #affectations par defaut, ensuite affections selon arguments commande
        set S(version) 179
        set S(ilw) 0
        set S(display_eu) normal
        set S(gfo) {Helvetica 4 normal}
        set S(lastid) 0
        set S(nbobj) 0
        set S(database) ""
        set S(ldatabase) {}
        set S(nodefilter) 0
        set S(stipple) z.xbm
        set S(defaultshape) 1
        set S(treewidth) 200
        set S(treeheight) auto
        set S(operation) nodebgcolor ;# ou nodefgcolor
        set fileTLF ""
        set fileTDS ""
        set fileGeneric out
        foreach {k v} $argv {
            switch -- $k {
                "-tree" {
                    set fileNWK [file join [pwd] $v]
                    # sur la base du fichier tree on obtient les noms des fichiers out
                    #set fileGeneric [format "%s%s" [string range $v 0 [expr [string last "." $v] - 1]] [GenId]]
                }
                "-label" {
                    set fileTLF [file join [pwd] $v]
                }
                "-script" {
                    set fileTDS [file join [pwd] $v]
                }
                "-font" {
                    set S(gfo) $v
                }
                "-height" {
                    set S(treeheight) $v
                }
                "-width" {
                    set S(treewidth) $v
                }
                "-operation" {
                    set S(operation) $v
                }
                "-displayleaves" {
                    set S(display_eu) $v
                }
                "-out" {
                    set fileGeneric $v
                }
            }
        }
        
        ### lecture tree
        set fid [open $fileNWK r]
        set s [read -nonewline $fid]
        close $fid
        ### T
        regsub -all "\n| " $s "" s
        regsub -all {\[} $s "" s
        #regsub -all {:-} $s ":" s
        regsub -all {:-[0-9]*.[0-9]+|:-[0-9]+} $s ":0.0" s
        regsub -all {\]} $s "" s
        TDcom::NewickToTreeDyn $s
        set lkv [array get Export]
        foreach {key value} $lkv {set T(xxx,$key) $value}
        unset Export
        ### GRAPHIC
        set c [ImportExport::NewCanvas]
        set t 1
        lappend S(ilt) $t
        lappend S($c,t) $t
        set S($t,w) $c
        set S($t,tar) 1
        ImportExport::TreeInit $t
        ImportExport::xxxEncode $t
        TDcom::PhyNJ $t $c
        ### IDENTIFICATION/LOCALISATION
        #interp delete $asedCon
        #set asedCon [interp create treedyn]
        #$asedCon alias db "TDcom::db"
        set S(targetTree) $t
        set S(targetWind) $c
        if {$fileTLF != ""} {TDcom::LoadAnnotations $fileTLF}
        if {$fileTDS != ""} {Scripting::OpenScript $fileTDS}
        
        ### EXPORT
        TDcom::exportPS [file join [pwd] $fileGeneric]  $c
        #exportGIF [file join [pwd] $fileGeneric]
        #exportHTML $fileGeneric
        TDcom::exportTGF [file join [pwd] $fileGeneric] $c
        #::can2svg::canvas2file $c [file join [pwd] $fileGeneric.svg]
        exit
    }
    ###
    proc exportPS {file c} {
        global S T
        # export CANVAS vers PS
        foreach {x0 y0 x1 y1} [$c bbox all] {}
        set w [expr $x1 - $x0]
        set h [expr $y1 - $y0]
        $c postscript  -file  [format "%s%s" $file .ps] -colormode color \
                -x $x0 -y $y0 -width $w -height $h \
                -pagex 0 -pagey 0 -pagewidth 20.c -pageheight 30.c \
                -pageanchor nw
    }
    ###
    proc exportTGF {file c} {
        global S
        set file [format "%s%s" $file .tgf]
        set script [canvas_saveArray $S(targetWind) $S(targetTree)]
        append script [canvas_saveItems $S(targetWind) $S(targetTree)]
        set fid [open $file w]
        set data [split $script "\n"]
        foreach elt $data {puts $fid $elt}
        close $fid
    }
    ###
    proc canvas_saveArray {w t} {
        global S T B
        set script    "### $S(version)\n"
        append script "set E(tree) \{$t\} \n"
        set pattern  [format "%s%s%s" $t , * ]
        ######### ARRAY T
        append script "### T\n"
        foreach {k v} [array get T [format "%s%s" $t *]] {
            append script "set ET($k) \{ $v\} \n"
        }
        ######### ARRAY S
        append script "### S\n"
        foreach {k v} [array get S [format "%s%s" $t *]] {
            append script "set ES($k) \{ $v\} \n"
        }
        ######### ARRAY B ici pas d'espace avant v
        append script "### B\n"
        foreach {k v} [array get B [format "%s%s" $t *]] {
            append script "set EB($k) \{$v\} \n"
        }
        # B // BGS
        foreach Id $B($t,bgs) {
            set pattern [format "%s%s%s" BGS* , $Id]
            foreach {k v} [array get B $pattern] {
                append script "set EB($k) \{ $v\} \n"
            }
        }
        # B // BGL
        foreach Id $B($t,bgl) {
            set pattern [format "%s%s%s" BGL* , $Id]
            foreach {k v} [array get B $pattern] {
                append script "set EB($k) \{ $v\} \n"
            }
        }
        # B // SHI
        foreach Id $B($t,shi) {
            set pattern [format "%s%s%s" SHI* , $Id]
            foreach {k v} [array get B $pattern] {
                append script "set EB($k) \{ $v\} \n"
            }
        }
        # B // BLL
        foreach Id $B($t,bll) {
            set pattern [format "%s%s%s" BLL* , $Id]
            foreach {k v} [array get B $pattern] {
                append script "set EB($k) \{ $v\} \n"
            }
        }
        # B // QYN
        foreach i $B($t,qyn) {
            set pattern [format "%s%s%s" QYN* , $i]
            foreach {k v} [array get B $pattern] {
                append script "set EB($k) \{ $v\} \n"
            }
        }
        # B // OVA
        foreach i $B($t,ova) {
            set pattern [format "%s%s%s" OVA* , $i]
            foreach {k v} [array get B $pattern] {
                append script "set EB($k) \{ $v\} \n"
            }
        }
        # items sans reference a un IDtree, ou faisant reference a plusieurs IDtree
        # B // CON = connectors
        append script "set ES(con) \{$S($w,con)\} \n"
        foreach i $S($w,con) {
            set pattern [format "%s%s%s" CON* , $i]
            foreach {k v} [array get B $pattern] {
                append script "set EB($k) \{ $v\} \n"
            }
        }
        # FIN
        return $script
    }
    ###
    proc canvas_saveItems {w t} {
        global S
        set lid { }
        foreach item [$w find withtag T$t] {
            set id [GenId]
            lappend lid $id
            set tags [$w gettags $item]
            set type   [$w type $item]
            set coords [$w coords $item]
            set opts ""
            foreach desc [$w itemconfigure $item] {
                set name [lindex $desc 0]
                set init [lindex $desc 3]
                set val  [lindex $desc 4]
                # correction bug canvas qui place la valeur "bezier" au lieu de "true"
                # comme valeur de l'option -smooth dans les items canvas
                if {$val == "bezier"} {set val true}
                if {$val != $init} {
                    if {$name != "-tags"} {
                        lappend opts $name $val
                    }
                }
            }
            append script "set EC($t,opts,$id) \{ $type $coords $opts\} \n"
            append script "set EC($t,tags,$id) \{ $tags\} \n"
        }
        append script "set EC($t,ids) \{ $lid\} \n"
        
        # items graphique non identifie par $id
        # cas des connectors par exemple
        # cas des notes canvas par exemple
        # CONNECTORS, 2 type d'items : line et chaine d'iconification (tags distincts)
        foreach item [$w find withtag {Connect || ConnectIcon}] {
            set id [GenId]
            lappend lid $id
            set tags [$w gettags $item]
            set type   [$w type $item]
            set coords [$w coords $item]
            set opts ""
            foreach desc [$w itemconfigure $item] {
                set name [lindex $desc 0]
                set init [lindex $desc 3]
                set val  [lindex $desc 4]
                if {$val != $init} {
                    if {$name != "-tags"} {
                        lappend opts $name $val
                    }
                }
            }
            append script "set EC($t,opts,$id) \{ $type $coords $opts\} \n"
            append script "set EC($t,tags,$id) \{ $tags\} \n"
        }
        #essai save legend
        foreach item [$w find withtag Legend] {
            set id [GenId]
            lappend lid $id
            set tags [$w gettags $item]
            set type   [$w type $item]
            set coords [$w coords $item]
            set opts ""
            foreach desc [$w itemconfigure $item] {
                set name [lindex $desc 0]
                set init [lindex $desc 3]
                set val  [lindex $desc 4]
                if {$val != $init} {
                    if {$name != "-tags"} {
                        lappend opts $name $val
                    }
                }
            }
            append script "set EC($t,opts,$id) \{ $type $coords $opts\} \n"
            append script "set EC($t,tags,$id) \{ $tags\} \n"
        }
        append script "set EC($t,ids) \{ $lid\} \n"
        # FIN
        return $script
    }
    ###
    proc NewickToTreeDyn {s} {
        global Export
        set code xxx ; set n 0
        set Export(xmax) 0
        set Export(tot) 0
        set Export(all_cod) $code
        set Export(ue_lab) {}
        set Export(ue_cod) {}
        set Export(Duplication) {}
        if {[string match *:* $s] == 0} {
            regsub -all "," $s {:1.0,} s
            regsub -all {\)} $s {:1.0)} s
        }
        set Export(dbl,$code) 0
        set Export(nwk,$code) $s
        if {[Dicho $s] == 1} {
            set s [format "%s%s%s" ( $s ):0]
        }
        set tp [string last ")" $s]
        set dt [string range $s 0 $tp]
        if {[string compare [string range $dt 0 0] ( ] != 0 || \
                    [string compare [string range $dt end end] ) ] != 0} {
            set dt [format "%s%s%s" ( $dt )]
        }
        set id [BgBdx $dt]
        set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
        set bd [string range $dt 1 [expr $id - 1]]
        lappend Export(cbg,$n) 0
        incr n
        NewickParser $bg [format "%s%s" $code g] $n 0
        NewickParser $bd [format "%s%s" $code d] $n 0
        return
    }
    ###
    proc NewickParser {s code n sx} {
        global Export
        lappend Export(all_cod) $code
        set Export(nwk,$code) $s
        if {[string match *,* $s]} {
            if {[Dicho $s] == 1} {
                set s [format "%s%s%s" ( $s ):0]
            }
            set tp [string last ")" $s]
            set dt [string range $s 0 $tp]
            set dx [string range $s [expr $tp + 1] end]
            set Export(dbl,$code) [expr abs([string range $dx [expr [string last ":" $dx] + 1] end])]
            set Export(dbv,$code) [string range $dx 0 [expr [string last ":" $dx] - 1]]
            if {[string compare [string range $dt 0 0] ( ] != 0 || \
                        [string compare [string range $dt end end] ) ] != 0} {
                set dt [format "%s%s%s" ( $dt )]
            }
            set id [BgBdx $dt]
            set bg [string range $dt [expr $id + 1] [expr [string length $dt] - 2]]
            set bd [string range $dt 1 [expr $id - 1]]
            lappend Export(cbg,$n) [format "%s%s" $code $n]
            NewickParser $bg [format "%s%s%s" $code $n g] [expr $n +1] [expr $sx + $Export(dbl,$code)]
            NewickParser $bd [format "%s%s%s" $code $n d] [expr $n +1] [expr $sx + $Export(dbl,$code)]
        } {
            set tp [string last ":" $s]
            set dt [string range $s 0 [expr $tp - 1]]
            set dx [string range $s [expr $tp + 1] end]
            set Export(dbl,$code) [expr abs([string range $dx [expr [string last ":" $dx] + 1] end])]
            if {[lsearch $Export(ue_lab) $dt] == -1}  {
                lappend Export(ue_lab) $dt
                set Export(ctl,$code) $dt
                set Export(ltc,$dt) $code
            } else {
                set newdt [format "%s%s%s" $dt - [GenId]]
                lappend Export(Duplication) "$dt swtich to $newdt"
                lappend Export(ue_lab) $newdt
                set Export(ctl,$code) $newdt
                set Export(ltc,$newdt) $code
            }
            lappend Export(ue_cod) $code
            set sx [expr $sx + $dx]
            set Export(sox,$code) $sx
            if {$sx >= $Export(xmax)} {set Export(xmax) $sx}
            if {$n >= $Export(tot)} {set Export(tot) $n}
            return
        }
    }
    ###
    proc GenId {} {
        global S
        incr S(nbobj)
        return [format "%s%s" [clock second] $S(nbobj)]
    }
    ###
    proc BgBdx {s} {
        set i -1
        set id -1
        foreach c [split $s {}] {
            incr id
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
                , {if {$i == 0} {return $id}}
            }
        }
        return ""
    }
    ###
    proc Dicho {s} {
        set i 0 ; set id 0 ; set r 1
        foreach c [split $s {}] {
            switch -exact -- $c {
                ( {incr i}
                ) {incr i -1}
            }
            if {$i == 0} {
                set r [string match *,* [string range $s [expr $id + 1] end]]
                break
            }
            incr id
        }
        return $r
    }
    ###
    proc PhyNJ {t w} {
        global T S
        set y 0
        set nb [llength $T($t,ue_cod)]
        set largeur $S(treewidth)
        if {$S(treeheight) == "auto"} {
            set hauteur [expr 10 * $nb]
        } else  {
            set hauteur $S(treeheight)
        }
        set fy [expr double($hauteur)  / $nb ]
        set fx [expr double($largeur) / $T($t,xmax)]
        set n 0
        set t3 [format "%s%s" T $t ]
        ### EU
        foreach i $T($t,ue_cod) {
            incr n
            set y [expr $n * $fy ]
            set G($i,x) [expr ($T($t,sox,$i) - $T($t,dbl,$i) )* $fx]
            set G($i,y) $y
            set t2 [format "%s%s" EU $T($t,ctl,$i) ]
            set t4 [format "%s%s" EUL $T($t,ctl,$i) ]
            set t2bis [format "%s%s" $i C]
            $w create line [expr $T($t,sox,$i) * $fx] $G($i,y) $G($i,x) $G($i,y)  \
                    -tags "$i $t2 $t3 $t2bis Z" -fill black
            $w create text [expr ($T($t,sox,$i) * $fx) + 2]  $G($i,y) \
                    -text  $T($t,ctl,$i) -anchor w   \
                    -tags " $t3 $t4 L" \
                    -font $S(gfo) -state $S($t,display_eu)
        }
        ### NODES
        for {set i [expr $T($t,tot) - 1 ]} {$i >= 1} {incr i -1} {
            foreach b $T($t,cbg,$i) {
                set bg [format "%s%s" $b g]
                set bd [format "%s%s" $b d]
                set yn [expr $G($bg,y) - (($G($bg,y) - $G($bd,y)) / 2)]
                set j [string range $bg 0 [expr [string last $i $bg] - 1]]
                set t2 [format "%s%s" $j C]
                # Vertical
                $w create line $G($bg,x) $G($bg,y) $G($bg,x) $G($bd,y) -tags "$t2 $t3 Z" -fill black
                # Horizontal
                set G($j,x) [expr $G($bg,x) - ($T($t,dbl,$j) * $fx)]
                $w create line $G($bg,x) $yn $G($j,x) $yn  -tags "$j $t2 $t3 Z" -fill black
                set G($j,y) $yn
            }
        }
        ### ROOT
        set ch [$w coords [format "%s%s" $t g]]
        set cb [$w coords [format "%s%s" $t d]]
        set yh [lrange $ch 1 1]
        set yb [lrange $cb 3 3]
        set x [lrange $ch 2 2]
        set yn [expr $yh - (($yh - $yb) / 2)]
        $w create line $x $yh $x $yb -tags "[format "%s%s" $t C] $t3 Z" -fill black
        $w configure -scrollregion [$w bbox all]
        unset G
    }
    ###
    proc LoadAnnotations {filename} {
        global S asedCon
        set currentfile [Tools::PathCut2 $filename]
        if {[lsearch $S(ldatabase) $currentfile] != -1 } {
            upvar #0 $currentfile X
            array unset X
        } else  {
            lappend S(ldatabase) $currentfile
        }
        TDcom::db $currentfile
        catch {open $filename r} fid
        while {[eof $fid] != 1} {
            set id [incr S(lastid)]
            gets $fid data
            
            # modif
            regsub -all " " [lindex $data 0] "¶" sans
            set datasans [lreplace $data 0 0 $sans]
            interp eval treedyn $currentfile [concat $id EU $datasans]
            
            
            #interp eval treedyn $currentfile [concat $id EU $data]
        }
        close $fid
        set S(database) $currentfile
    }
    ###
    proc db {database args} {
        global asedCon
        upvar #0 $database db
        set key ""
        foreach {- key item value} $args break
        set exists [info exists db($key)]
        set res {}
        switch [llength $args] {
            0 {
                array set db {}
                interp alias {} $database {} TDcom::db $database -
                $asedCon alias  $database TDcom::db $database -
                set res $database
            }
            1 {set res [array names db]}
            2 {
                if {$key != ""} {
                    if {$exists} {set res $db($key)}
                } else {array unset db }
            }
            3 {if {$item != ""} {
                    if {$exists} {
                        set t $db($key)
                        if {!([set pos [lsearch $t $item]]%2)} {
                            set res [lindex $t [incr pos]]
                        }
                    }
                } elseif {$exists} {unset db($key)}
            }
            4 {
                if {$exists} {
                    if {!([set pos [lsearch $db($key) $item]]%2)} {
                        if {$value != ""} {
                            set db($key) [lreplace $db($key) [incr pos] $pos $value]
                        } else {set db($key) [lreplace $db($key) $pos [incr pos]]}
                    } elseif {$value != ""} {
                        lappend db($key) $item $value
                    }
                } elseif {$value != ""} {set db($key) [list $item $value]}
                set res $value
            }
            default {
                if {[llength $args]%2} {error "non-paired item/value list"}
                foreach {item value} [lrange $args 2 end] {
                    db $database - $key $item $value
                }
            }
        }
    }
}
################################################################################
namespace eval LeafSelection {
    
    
    # switch add/remove
    proc CheckControlBarD1 {w x y} {
        global T S
        set id [$w find withtag current]
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        if {$id != {}}  {
            set tags [$w gettags $id]
            if {[lsearch -glob $tags *C] != -1} {
                # NODE N
                set n [string trimright \
                        [lindex $tags [lsearch -glob $tags *C]] C]
                set t [string range \
                        [lindex $tags [lsearch -glob $tags T*]] 1 end]
                set leafscode [Tools::NodeNoToLe $t $n]
                set leafs [Tools::NodeLeCoToRe $t $leafscode]
                foreach l $leafs  {
                    set tagi [format "%s%s" SELECT¶ $l]
                    set id [$w find withtag $tagi]
                    if {$id != {}} {SwitchOnOff $w $id}
                }
            }  elseif  {[lsearch -exact $tags L] != -1} {
                # LEAF
                set l  [string trimleft \
                        [lindex $tags [lsearch -glob $tags EUL*]] EUL]
                set tagi [format "%s%s" SELECT¶ $l]
                set id [$w find withtag $tagi]
                if {$id != {}} {SwitchOnOff $w $id}
            } elseif {[lsearch -glob $tags SelMatrix] != -1} {
                SwitchOnOff $w $id
            }
        } elseif {[$w find overlapping [expr $x -10] [expr $y - 5] [expr $x+10] [expr $y+5] ] != "" } {
            set id [lindex [$w find overlapping [expr $x -10] [expr $y - 5] [expr $x+10] [expr $y+5]] 0]
            set tags [$w gettags $id]
            if {[lsearch -glob $tags SelMatrix] != -1} {
                SwitchOnOff $w $id
            }
        } else {
            # TREE
            if {[winfo exists $w.d3menu ] == 1} {destroy $w.d3menu}
            set m [menu $w.d3menu -tearoff 0]
            set id [$w find closest $x $y]
            set tags [$w gettags $id]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$t != ""} {
                LeafSelection::D3Tree $w $m $t $x $y $tags
                tk_popup $m [winfo pointerx $w] [winfo pointery $w]
            }
        }
    }
    # selection systematique
    proc CheckControlBarShiftD1 {w x y} {
        global T S
        set id [$w find withtag current]
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        if {$id != {}}  {
            set tags [$w gettags $id]
            if {[lsearch -glob $tags *C] != -1} {
                # NODE N
                set n [string trimright \
                        [lindex $tags [lsearch -glob $tags *C]] C]
                set t [string range \
                        [lindex $tags [lsearch -glob $tags T*]] 1 end]
                set leafscode [Tools::NodeNoToLe $t $n]
                set leafs [Tools::NodeLeCoToRe $t $leafscode]
                foreach l $leafs  {
                    set tagi [format "%s%s" SELECT¶ $l]
                    set id [$w find withtag $tagi]
                    if {$id != {}} {SwitchOn $w $id}
                }
            }  elseif  {[lsearch -exact $tags L] != -1} {
                # LEAF
                set l  [string trimleft \
                        [lindex $tags [lsearch -glob $tags EUL*]] EUL]
                set tagi [format "%s%s" SELECT¶ $l]
                set id [$w find withtag $tagi]
                if {$id != {}} {SwitchOn $w $id}
            } elseif {[lsearch -glob $tags SelMatrix] != -1} {
                SwitchOn $w $id
            }
        } elseif {[$w find overlapping [expr $x -10] [expr $y - 5] [expr $x+10] [expr $y+5] ] != "" } {
            set id [lindex [$w find overlapping [expr $x -10] [expr $y - 5] [expr $x+10] [expr $y+5]] 0]
            set tags [$w gettags $id]
            if {[lsearch -glob $tags SelMatrix] != -1} {
                SwitchOn $w $id
            }
        } else {
            # TREE
            if {[winfo exists $w.d3menu ] == 1} {destroy $w.d3menu}
            set m [menu $w.d3menu -tearoff 0]
            set id [$w find closest $x $y]
            set tags [$w gettags $id]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$t != ""} {
                LeafSelection::D3Tree $w $m $t $x $y $tags
                tk_popup $m [winfo pointerx $w] [winfo pointery $w]
            }
        }
    }
    # deselection systematique
    proc CheckControlBarCtrlD1 {w x y} {
        global T S
        set id [$w find withtag current]
        set x [$w canvasx $x]
        set y [$w canvasy $y]
        if {$id != {}}  {
            set tags [$w gettags $id]
            if {[lsearch -glob $tags *C] != -1} {
                # NODE N
                set n [string trimright \
                        [lindex $tags [lsearch -glob $tags *C]] C]
                set t [string range \
                        [lindex $tags [lsearch -glob $tags T*]] 1 end]
                set leafscode [Tools::NodeNoToLe $t $n]
                set leafs [Tools::NodeLeCoToRe $t $leafscode]
                foreach l $leafs  {
                    set tagi [format "%s%s" SELECT¶ $l]
                    set id [$w find withtag $tagi]
                    if {$id != {}} {SwitchOff $w $id}
                }
            }  elseif  {[lsearch -exact $tags L] != -1} {
                # LEAF
                set l  [string trimleft \
                        [lindex $tags [lsearch -glob $tags EUL*]] EUL]
                set tagi [format "%s%s" SELECT¶ $l]
                set id [$w find withtag $tagi]
                if {$id != {}} {SwitchOff $w $id}
            } elseif {[lsearch -glob $tags SelMatrix] != -1} {
                SwitchOff $w $id
            }
        } elseif {[$w find overlapping [expr $x -10] [expr $y - 5] [expr $x+10] [expr $y+5] ] != "" } {
            set id [lindex [$w find overlapping [expr $x -10] [expr $y - 5] [expr $x+10] [expr $y+5]] 0]
            set tags [$w gettags $id]
            if {[lsearch -glob $tags SelMatrix] != -1} {
                SwitchOff $w $id
            }
        } else {
            # TREE
            if {[winfo exists $w.d3menu ] == 1} {destroy $w.d3menu}
            set m [menu $w.d3menu -tearoff 0]
            set id [$w find closest $x $y]
            set tags [$w gettags $id]
            set t [string range  [lindex $tags [lsearch -glob $tags T*]] 1 end]
            if {$t != ""} {
                LeafSelection::D3Tree $w $m $t $x $y $tags
                tk_popup $m [winfo pointerx $w] [winfo pointery $w]
            }
        }
    }
    proc SwitchOnOff {w id} {
        set fi [lindex [$w itemconfigure $id -fill] end]
        if {$fi == {}} {
            $w itemconfigure $id -fill black
        } else  {
            $w itemconfigure $id -fill {}
        }
    }
    proc SwitchOn {w id} {
        $w itemconfigure $id -fill black
    }
    proc SwitchOff {w id} {
        $w itemconfigure $id -fill {}
    }
    proc D3Tree {w m t x y tags} {
        global S B
        if {$S($t,tit) != ""} {
            $m add command -label "Tree: $S($t,tit)" -command "Selection::ShwoTree $t"
        } else  {
            $m add command -label Tree -command "Selection::ShwoTree $t"
        }
        $m add command -label "New selection column" -command "LeafSelection::CheckControlAdd $w $t"
        $m add command -label "Export selection (file)" -command "LeafSelection::ExportSelection $w $t"
        $m add command -label "Export selection (clipboard)" -command "LeafSelection::ExportSelectionClipboard $w $t"
    }
    proc CheckControlAdd {w t} {
        global S T
        set S(symboltype) 08 ;#symbol checkoff
        set S(symboldx) 3
        set S(symboldy) 3
        set col $S(col)
        set S(col) black
        LeafSelection::LillC $w $t $T($t,ue_lab)
        set S(col) $col
    }
    proc ExportSelection {w t} {
        global S
        set liste [$w find withtag SelMatrix]
        set listefeuille {}
        foreach i $liste {
            set fi [lindex [$w itemconfigure $i -fill] end]
            if {$fi != {}} {
                set tags [$w gettags $i]
                set f [lindex [split [lindex $tags [lsearch -glob $tags MA¶*]] ¶] end]
                lappend listefeuille $f
            }
        }
        # listefeuille list les feuilles dans l'ordre de l'arbre
        set listefeuille2 [lsort -dictionary $listefeuille]
        # file
        set typelist {
            {"Text File" {".txt"} }
            {"All Files" {*}}
        }
        set file [tk_getSaveFile -initialdir $S(userDIR) -defaultextension ".txt" \
                -filetypes $typelist -title "Save Leaf labels selection as a text file..."]
        if {$file != "" } {set S(userDIR) [file dirname $file]}
        if {$file != ""} {
            set fid [open $file w]
            puts $fid "### tree order"
            foreach l $listefeuille {puts $fid $l}
            puts $fid "### alphabetic order"
            foreach l $listefeuille2 {puts $fid $l}
            close $fid
        }
        
    }
    proc ExportSelectionClipboard  {w t} {
        global S
        set liste [$w find withtag SelMatrix]
        set listefeuille {}
        foreach i $liste {
            set fi [lindex [$w itemconfigure $i -fill] end]
            if {$fi != {}} {
                set tags [$w gettags $i]
                set f [lindex [split [lindex $tags [lsearch -glob $tags MA¶*]] ¶] end]
                lappend listefeuille $f
            }
        }
        # listefeuille list les feuilles dans l'ordre de l'arbre
        set listefeuille2 [lsort -dictionary $listefeuille]
        # file
        clipboard clear
        clipboard append  "### tree order \n"
        foreach e $listefeuille {
            clipboard append "$e \n"
        }
        clipboard append  "### alphabetic order \n"
        foreach e $listefeuille2 {
            clipboard append "$e \n"
        }
        
    }
    
    
    # ce LillC est different du Illustration::LillC par un tag  suplementaire SelMatrix
    proc LillC {w t leu } {
        global S ann T
        # pour l'instant une seule colonne de selection
        $w delete SelMatrix
        if {$S(illustration-tabulation) == 1} {
            set S($t,LabelMatrixBase) [expr $S($t,LabelMatrixBase) + $S(TabulationAnnot)]
        }
        set stip $S(stipple)
        set S(stipple) z.xbm
        switch -exact $S($t,type) {
            PhyNJ - ClaSla - ClaRec {
                set XMAX1 [lindex [$w bbox [list T$t && Z]] 2]
                set XMAX2 [lindex [$w bbox [list T$t && L]] 2]
                if {$XMAX1 < $XMAX2} {set XMAX $XMAX2 } {set XMAX $XMAX1}
                set x [expr $XMAX + $S($t,LabelMatrixBase)]
                # tag de colonne
                set tagC [format "%s%s%s" COL ¶ [Tools::GenId]]
                foreach l $leu {
                    # recherche y (code arrete terminale)
                    set item [$w find withtag [list [format "%s%s" EU  $l ] && T$t]]
                    if {$item != ""} {
                        set co [$w coords $item]
                        set y [lindex $co 1]
                        Illustration::drawsymbol  $w $x $y [list ILLCo¶$l SELECT¶$l T$t AnnotMatrix SelMatrix AM$t MA¶$l $tagC AMatrixCo]
                    }
                }
            }
            PhyRad - PhyCir1 - PhyCir2 - ClaRad  {
            }
            ClaCir1 - ClaCir2 - ClaCir3 {   
            }
        }
        set S(stipple) $stip
    }
    
}

################################################################################
# GO
################################################################################
switch $tcl_platform(platform) {
    "unix" {
        if  {$tcl_platform(os) == "Darwin"} {
            package require Tktable
            package require Itcl
            package require Itk
            package require Iwidgets
            package require Img
            package require http
        } else  {
            lappend auto_path [file dirname [info script]]
            lappend auto_path [file join [file dirname [info script]] +/extensions/linux]
            set env(ITCL_LIBRARY) [file join [file dirname [info script]] +/extensions/linux/itcl3.2]
            set env(ITK_LIBRARY) [file join [file dirname [info script]] +/extensions/linux/itk3.2]
            load +/extensions/linux/itcl3.2/libitcl3.2.so
            load +/extensions/linux/itk3.2/libitk3.2.so
            source +/extensions/linux/iwidgets4.0.2/iwidgets.tcl
            source +/extensions/linux/http.tcl
            set extensionsLinux {Tktable2.9/libTktable2.9.so Img1.3/libtkimg1.3.so Img1.3/libjpegtcl1.0.so Img1.3/libpngtcl1.0.so
                Img1.3/libtifftcl1.0.so Img1.3/libtkimgbmp1.3.so Img1.3/libtkimggif1.3.so Img1.3/libtkimgico1.3.so
                Img1.3/libtkimgjpeg1.3.so Img1.3/libtkimgpcx1.3.so Img1.3/libtkimgpixmap1.3.so Img1.3/libtkimgpng1.3.so
                Img1.3/libtkimgppm1.3.so Img1.3/libtkimgps1.3.so Img1.3/libtkimgsgi1.3.so Img1.3/libtkimgsun1.3.so
                Img1.3/libtkimgtga1.3.so Img1.3/libtkimgtiff1.3.so Img1.3/libtkimgwindow1.3.so Img1.3/libtkimgxbm1.3.so
                Img1.3/libtkimgxpm1.3.so Img1.3/libzlibtcl1.0.so}
            foreach e $extensionsLinux {load [file join +/extensions/linux/ $e]}
        }
    }
    "windows" {
        set extensionsWindows {itcl3.2/itcl32.dll itk3.2/itk32.dll hdc/hdc.dll gdi/gdi.dll printer/printer.dll
            wmf/wmf.dll Tktable2.8/Tktable28.dll Img1.3/tkimg13.dll Img1.3/tkimgwindow13.dll
            Img1.3/tkimgtga13.dll Img1.3/tkimgico13.dll Img1.3/tkimgpcx13.dll Img1.3/tkimgsgi13.dll Img1.3/tkimgsun13.dll
            Img1.3/tkimgxbm13.dll Img1.3/tkimgxpm13.dll Img1.3/tkimgps13.dll Img1.3/tkimgjpeg13.dll
            Img1.3/tkimgpng13.dll Img1.3/tkimgtiff13.dll Img1.3/tkimgbmp13.dll Img1.3/tkimgppm13.dll
            Img1.3/tkimggif13.dll Img1.3/tkimgpixmap13.dll}
        lappend auto_path [file dirname [info script]]
        lappend auto_path [file join [file dirname [info script]] +/extensions/windows]
        set env(ITCL_LIBRARY) [file join [file dirname [info script]] +/extensions/windows/itcl3.2]
        set env(ITK_LIBRARY) [file join [file dirname [info script]] +/extensions/windows/itk3.2]
        source +/extensions/windows/iwidgets4.0.2/iwidgets.tcl
        source +/extensions/windows/http.tcl
        foreach e $extensionsWindows {load [file join +/extensions/windows/ $e]}
    }
}
Interface::TreeDynInitialisation
proc bgerror {m} {}
if {[string first "-psn" [lindex $argv 0]] == 0} {set argv [lrange $argv 1 end]} ;# darwin

if {$argv == {}} {
    # MODE interface
    Iconographie::MakeIconographie
    wm withdraw .
    toplevel .about -relief raised -borderwidth 2 -background white
    wm overrideredirect .about 1
    after idle {
        label .about.logo -borderwidth 2  -relief groove \
                -background white -image IMGlogo
        pack .about.logo
        set x [expr ([winfo screenwidth .about] - [winfo reqwidth .about.logo]) /2]
        set y [expr ([winfo screenheight .about] - [winfo reqheight .about.logo]) /2]
        wm geometry .about "+$x+$y"
    }
    update
    Interface::TreeDynPanel
    Toolbox::BalloonhelpMake
    update
    after 1000 destroy .about
    bind .treedyn <Unmap> {if {"%W" == ".treedyn"} {Interface::unmapall}}
    bind .treedyn <Map> {if {"%W" == ".treedyn"} {Interface::mapall}}
} else {
    # MODE commande
    $asedCon alias db "TDcom::db"
    TDcom::com $argv
}
################################################################################
